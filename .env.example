# Home Security Intelligence - Environment Configuration
# Copy this file to .env and adjust values as needed.
# See docs/RUNTIME_CONFIG.md for detailed documentation.

# =============================================================================
# DATABASE
# =============================================================================
# PostgreSQL database URL (required - no SQLite support)
# Native: postgresql+asyncpg://security:your_password_here@localhost:5432/security
# Docker: postgresql+asyncpg://security:your_password_here@postgres:5432/security
DATABASE_URL=postgresql+asyncpg://security:your_password_here@localhost:5432/security

# =============================================================================
# REDIS
# =============================================================================
# Redis connection URL
# Native: redis://localhost:6379/0
# Docker: redis://redis:6379
# For TLS: rediss://redis-host:6379/0 (note double 's')
REDIS_URL=redis://localhost:6379/0

# -----------------------------------------------------------------------------
# REDIS SSL/TLS CONFIGURATION
# -----------------------------------------------------------------------------
# Enable SSL/TLS encryption for Redis connections.
# SECURITY: Enable for production environments to encrypt data in transit.
# When True, ensures all Redis traffic (cached data, session info, alerts) is encrypted.
REDIS_SSL_ENABLED=false

# SSL certificate verification mode:
#   'none'     - No verification (NOT recommended for production)
#   'optional' - Verify if certificate is provided
#   'required' - Always verify (RECOMMENDED for production)
REDIS_SSL_CERT_REQS=required

# Path to CA certificate file (PEM format) for verifying Redis server certificate.
# Required when REDIS_SSL_CERT_REQS is 'required' or 'optional'.
# REDIS_SSL_CA_CERTS=/path/to/redis-ca.crt

# Path to client certificate file (PEM format) for mutual TLS (mTLS) authentication.
# Optional - only needed if Redis server requires client certificates.
# REDIS_SSL_CERTFILE=/path/to/redis-client.crt

# Path to client private key file (PEM format) for mutual TLS (mTLS) authentication.
# Required if REDIS_SSL_CERTFILE is provided.
# REDIS_SSL_KEYFILE=/path/to/redis-client.key

# Verify that the Redis server's certificate hostname matches.
# Should be True for production. Set to False only for testing with self-signed certs.
REDIS_SSL_CHECK_HOSTNAME=true

# =============================================================================
# AI SERVICES (containerized with GPU passthrough via Podman)
# =============================================================================
# RT-DETRv2 object detection service
# WARNING: Use HTTPS in production to prevent man-in-the-middle (MITM) attacks.
#          HTTP is acceptable for local development only.
# Container name: ai-detector_1
# Default: http://localhost:8090
# Production: https://your-rtdetr-host:8090
RTDETR_URL=http://localhost:8090

# Nemotron LLM risk analysis service (via llama.cpp)
# WARNING: Use HTTPS in production to prevent man-in-the-middle (MITM) attacks.
#          HTTP is acceptable for local development only.
# Container name: ai-llm_1
# Default: http://localhost:8091
# Production: https://your-nemotron-host:8091
NEMOTRON_URL=http://localhost:8091

# =============================================================================
# CAMERA INTEGRATION
# =============================================================================
# Base directory for Foscam FTP uploads
# Cameras upload to {FOSCAM_BASE_PATH}/{camera_name}/
FOSCAM_BASE_PATH=/export/foscam

# =============================================================================
# FILE WATCHER
# =============================================================================
# Use polling observer instead of native filesystem events.
# Set to true for Docker Desktop on macOS/Windows where inotify/FSEvents
# don't propagate through volume mounts.
# Native observers (inotify/FSEvents) are more efficient but don't work
# reliably across Docker volume boundaries.
FILE_WATCHER_POLLING=false

# Polling interval in seconds when FILE_WATCHER_POLLING=true (0.1-30.0)
# Lower values = faster detection but higher CPU usage
# Higher values = lower CPU but slower detection
FILE_WATCHER_POLLING_INTERVAL=1.0

# =============================================================================
# DETECTION SETTINGS
# =============================================================================
# Minimum confidence threshold for object detections (0.0-1.0)
DETECTION_CONFIDENCE_THRESHOLD=0.5

# =============================================================================
# FAST PATH SETTINGS
# =============================================================================
# High-confidence detections bypass batching for immediate alerts
# Confidence threshold for fast path (0.0-1.0)
FAST_PATH_CONFIDENCE_THRESHOLD=0.90

# Object types eligible for fast path (JSON array)
# FAST_PATH_OBJECT_TYPES=["person"]

# =============================================================================
# BATCH PROCESSING
# =============================================================================
# Maximum time window for grouping detections into events (seconds)
BATCH_WINDOW_SECONDS=90

# Close batch after this many seconds of inactivity
BATCH_IDLE_TIMEOUT_SECONDS=30

# =============================================================================
# RETENTION
# =============================================================================
# Days to keep events and detections
RETENTION_DAYS=30

# Days to keep log entries in database
LOG_RETENTION_DAYS=7

# =============================================================================
# GPU MONITORING
# =============================================================================
# How often to poll GPU stats via pynvml (seconds, 1.0-60.0)
# Each poll reads GPU utilization, VRAM, temperature, and power usage,
# then writes to the database and broadcasts via WebSocket.
#
# Performance impact considerations:
#   1-2s   = Real-time visibility (development/debugging)
#   5s     = Balanced responsiveness and overhead (default)
#   15-30s = Lower overhead when system is under pressure
#   60s    = Minimal monitoring for trend analysis only
#
# Increase this value if:
#   - System is under heavy CPU/disk I/O pressure
#   - AI inference pipeline is saturating GPU bandwidth
#   - Database is on slow storage (HDD, network mount)
GPU_POLL_INTERVAL_SECONDS=5.0

# Minutes of GPU history to retain in memory (1-1440)
GPU_STATS_HISTORY_MINUTES=60

# =============================================================================
# FILE DEDUPLICATION
# =============================================================================
# TTL for file deduplication entries in Redis (seconds, 60-3600)
DEDUPE_TTL_SECONDS=300

# =============================================================================
# LOGGING
# =============================================================================
# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO

# Path for rotating log file
LOG_FILE_PATH=data/logs/security.log

# Maximum size of each log file in bytes (default: 10MB)
LOG_FILE_MAX_BYTES=10485760

# Number of backup log files to keep
LOG_FILE_BACKUP_COUNT=7

# Write logs to database
LOG_DB_ENABLED=true

# Minimum log level for database logging
LOG_DB_MIN_LEVEL=DEBUG

# =============================================================================
# APPLICATION
# =============================================================================
# Enable debug mode (development only)
DEBUG=false

# API server bind address
API_HOST=0.0.0.0

# API server port
API_PORT=8000

# =============================================================================
# AUTHENTICATION (disabled by default for single-user deployment)
# =============================================================================
# Enable API key authentication
API_KEY_ENABLED=false

# Valid API keys (JSON array, hashed on startup)
# API_KEYS=["your-secure-api-key-here"]

# =============================================================================
# TLS/HTTPS CONFIGURATION
# =============================================================================
# This project supports two TLS configuration approaches:
# 1. Modern mode-based (RECOMMENDED) - using TLS_MODE
# 2. Legacy flag-based (DEPRECATED) - using TLS_ENABLED
#
# The modern mode-based approach is cleaner and should be used for new deployments.
# Legacy settings are kept for backward compatibility but may be removed in future versions.

# -----------------------------------------------------------------------------
# MODERN TLS CONFIGURATION (RECOMMENDED)
# -----------------------------------------------------------------------------
# TLS mode: 'disabled' (HTTP only), 'self_signed' (auto-generate), 'provided' (use existing)
TLS_MODE=disabled

# For TLS_MODE=provided: Path to TLS certificate file (PEM format)
# TLS_CERT_PATH=/path/to/server.crt

# For TLS_MODE=provided: Path to TLS private key file (PEM format)
# TLS_KEY_PATH=/path/to/server.key

# Optional: Path to CA certificate for client verification (mutual TLS)
# TLS_CA_PATH=/path/to/ca.crt

# Require and verify client certificates (mutual TLS / mTLS)
# When enabled, clients must present a valid certificate signed by TLS_CA_PATH
TLS_VERIFY_CLIENT=false

# Minimum TLS version: 'TLSv1.2' or 'TLSv1.3'
# TLSv1.2 is the minimum recommended for production; TLSv1.3 offers better security
TLS_MIN_VERSION=TLSv1.2

# -----------------------------------------------------------------------------
# LEGACY TLS CONFIGURATION (DEPRECATED - use TLS_MODE instead)
# -----------------------------------------------------------------------------
# Enable HTTPS for the API server (use TLS_MODE=self_signed or TLS_MODE=provided instead)
TLS_ENABLED=false

# Path to TLS certificate file (use TLS_CERT_PATH instead)
# TLS_CERT_FILE=/path/to/server.crt

# Path to TLS private key file (use TLS_KEY_PATH instead)
# TLS_KEY_FILE=/path/to/server.key

# Path to CA certificate (use TLS_CA_PATH instead)
# TLS_CA_FILE=/path/to/ca.crt

# Auto-generate self-signed certificates (use TLS_MODE=self_signed instead)
TLS_AUTO_GENERATE=false

# Directory for auto-generated certificates
TLS_CERT_DIR=data/certs

# =============================================================================
# CORS
# =============================================================================
# Allowed origins (JSON array format)
# Default allows localhost on dev ports. For network access, add your server's IP:
# CORS_ORIGINS=["http://localhost:3000", "http://localhost:5173", "http://192.168.1.145:5173"]
#
# For development with access from any origin (not recommended for production):
# CORS_ORIGINS=["*"]
#
# Note: In production with nginx proxy (docker-compose.prod.yml), CORS is not
# needed because the frontend and API are served from the same origin via nginx.

# =============================================================================
# FRONTEND (VITE_* vars are embedded at build time)
# =============================================================================
# Host port to expose the production frontend container (default: 5173)
# The nginx server inside the container always listens on port 80.
# This variable maps the host port to container port 80.
# Note: This is a docker-compose variable, not a Python config setting.
# FRONTEND_PORT=5173

# Backend API URL (accessed from browser, not container)
VITE_API_BASE_URL=http://localhost:8000

# WebSocket URL (accessed from browser, not container)
VITE_WS_BASE_URL=ws://localhost:8000
