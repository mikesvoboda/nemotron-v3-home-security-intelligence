name: Deploy

on:
  push:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  # Build each image on native architecture runners
  build:
    name: Build ${{ matrix.image }} (${{ matrix.platform.arch }})
    runs-on: ${{ matrix.platform.runner }}
    permissions:
      contents: read
      packages: write

    strategy:
      fail-fast: false
      matrix:
        image:
          - name: backend
            context: .
            dockerfile: ./backend/Dockerfile
            target: prod
          - name: frontend
            context: ./frontend
            dockerfile: ./frontend/Dockerfile
            target: prod
          - name: ai-yolo26
            context: .
            dockerfile: ./ai/yolo26/Dockerfile
        platform:
          - runner: ubuntu-latest
            arch: linux/amd64
            suffix: amd64
          - runner: ubuntu-24.04-arm
            arch: linux/arm64
            suffix: arm64

    steps:
      - name: Free disk space
        if: matrix.image.name == 'backend'
        uses: jlumbroso/free-disk-space@54081f138730dfa15788a46383842cd2f914a1be # v1.3.1
        with:
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Log in to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image.name }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest

      # Build and push by digest (for later manifest merge)
      # Note: Trivy scan temporarily disabled to reduce disk usage during build
      # TODO: Re-enable scanning from registry after push (see option 3 in PR #128)
      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v5
        with:
          context: ${{ matrix.image.context }}
          file: ${{ matrix.image.dockerfile }}
          target: ${{ matrix.image.target || '' }}
          platforms: ${{ matrix.platform.arch }}
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image.name }},push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=${{ matrix.image.name }}-${{ matrix.platform.suffix }}
          cache-to: type=gha,mode=max,scope=${{ matrix.image.name }}-${{ matrix.platform.suffix }}

      # Export digest to file for artifact upload
      - name: Export digest
        run: |
          mkdir -p /tmp/digests/${{ matrix.image.name }}
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${{ matrix.image.name }}/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4
        with:
          name: digests-${{ matrix.image.name }}-${{ matrix.platform.suffix }}
          path: /tmp/digests/${{ matrix.image.name }}/*
          if-no-files-found: error
          retention-days: 1

  # Merge architecture-specific images into multi-arch manifests
  merge:
    name: Create multi-arch manifest (${{ matrix.image }})
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        image: [backend, frontend]

    steps:
      - name: Download digests
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          pattern: digests-${{ matrix.image }}-*
          path: /tmp/digests/${{ matrix.image }}
          merge-multiple: true

      - name: Log in to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest

      - name: Create manifest list and push
        working-directory: /tmp/digests/${{ matrix.image }}
        run: |
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image }}@sha256:%s ' *)

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image }}:latest

  # Smoke test deployment verification
  # Runs after images are pushed to verify containers work correctly
  smoke-test:
    name: Smoke Test Deployment
    runs-on: ubuntu-latest
    needs: merge
    timeout-minutes: 15
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Log in to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull images
        env:
          GHCR_OWNER: ${{ github.repository_owner }}
          GHCR_REPO: ${{ github.event.repository.name }}
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/backend:latest
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/frontend:latest

      - name: Start services
        env:
          GHCR_OWNER: ${{ github.repository_owner }}
          GHCR_REPO: ${{ github.event.repository.name }}
          IMAGE_TAG: latest
        run: |
          # Start services using CI docker-compose
          docker compose -f docker-compose.ci.yml up -d

          # Show container status
          docker compose -f docker-compose.ci.yml ps

      - name: Wait for services to be healthy
        run: |
          echo "Waiting for services to become healthy..."

          # Wait for backend with timeout
          timeout 120 bash -c '
            until docker compose -f docker-compose.ci.yml exec -T backend python -c "import httpx; r = httpx.get(\"http://localhost:8000/api/system/health/ready\"); exit(0 if r.status_code == 200 else 1)" 2>/dev/null; do
              echo "Waiting for backend..."
              sleep 5
            done
          ' || {
            echo "Backend health check timed out"
            docker compose -f docker-compose.ci.yml logs backend
            exit 1
          }

          echo "Backend is healthy!"

          # Wait for frontend with timeout
          timeout 60 bash -c '
            until curl -sf http://localhost:3000/ > /dev/null 2>&1; do
              echo "Waiting for frontend..."
              sleep 5
            done
          ' || {
            echo "Frontend health check timed out"
            docker compose -f docker-compose.ci.yml logs frontend
            exit 1
          }

          echo "Frontend is healthy!"

      - name: Run smoke tests
        run: |
          chmod +x ./scripts/ci-smoke-test.sh
          ./scripts/ci-smoke-test.sh \
            --backend-url http://localhost:8000 \
            --frontend-url http://localhost:3000 \
            --timeout 60 \
            --skip-websocket

      - name: Perform health check validation
        id: health-check
        run: |
          echo "Performing comprehensive health checks..."

          # Health check endpoint for critical services
          echo "Testing /api/system/health/ready..."

          # Capture both response body and HTTP status code
          RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:8000/api/system/health/ready)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "HTTP Status Code: $HTTP_CODE"
          echo "Response body: $BODY"

          # Validate HTTP status code
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Health check /api/system/health/ready failed with status $HTTP_CODE"
            echo "Response body: $BODY"
            exit 1
          fi

          HEALTH_READY="$BODY"
          READY=$(echo "$HEALTH_READY" | jq -r '.ready // false')

          if [ "$READY" != "true" ]; then
            echo "warning: System not fully ready, but checking full health..."
          fi

          # Full health check including circuit breakers
          echo "Testing /api/system/health/full..."

          # Capture both response body and HTTP status code for full health check
          RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:8000/api/system/health/full)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "HTTP Status Code: $HTTP_CODE"
          echo "Response body: $BODY"

          # Validate HTTP status code for full health check
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Health check /api/system/health/full failed with status $HTTP_CODE"
            echo "Response body: $BODY"
            exit 1
          fi

          HEALTH_FULL="$BODY"

          # Verify critical services are healthy
          POSTGRES_STATUS=$(echo "$HEALTH_FULL" | jq -r '.postgres.status // "unknown"')
          REDIS_STATUS=$(echo "$HEALTH_FULL" | jq -r '.redis.status // "unknown"')

          echo "Postgres status: $POSTGRES_STATUS"
          echo "Redis status: $REDIS_STATUS"

          if [ "$POSTGRES_STATUS" != "healthy" ] || [ "$REDIS_STATUS" != "healthy" ]; then
            echo "::error::Critical services are not healthy"
            echo "Postgres: $POSTGRES_STATUS, Redis: $REDIS_STATUS"
            exit 1
          fi

          echo "All health checks passed"
          echo "health-check-passed=true" >> $GITHUB_OUTPUT

      - name: Check deployment readiness
        if: success()
        run: |
          echo "Deployment validation successful!"
          echo ""
          echo "Summary:"
          echo "  Backend: Healthy and responding"
          echo "  Frontend: Serving content"
          echo "  Database: Connected and operational"
          echo "  Cache: Connected and operational"
          echo ""
          echo "Images are ready for production deployment"

      - name: Collect logs on failure
        if: failure()
        run: |
          echo "=== Backend Logs ==="
          docker compose -f docker-compose.ci.yml logs backend --tail=100

          echo "=== Frontend Logs ==="
          docker compose -f docker-compose.ci.yml logs frontend --tail=50

          echo "=== Postgres Logs ==="
          docker compose -f docker-compose.ci.yml logs postgres --tail=50

          echo "=== Redis Logs ==="
          docker compose -f docker-compose.ci.yml logs redis --tail=50

          echo "=== Container Status ==="
          docker compose -f docker-compose.ci.yml ps -a

          echo "=== Health Check Details ==="
          curl -s http://localhost:8000/api/system/health/full 2>/dev/null | jq . || echo "Could not retrieve full health status"

      - name: Tear down services
        if: always()
        run: |
          docker compose -f docker-compose.ci.yml down -v --remove-orphans

  # Generate SBOM and sign container images for supply chain security
  sbom-and-sign:
    name: SBOM & Sign (${{ matrix.image }})
    runs-on: ubuntu-latest
    needs: merge
    permissions:
      contents: read
      packages: write
      id-token: write # Required for cosign OIDC signing

    strategy:
      matrix:
        image: [backend, frontend]

    steps:
      - name: Log in to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v3

      - name: Generate SBOM
        uses: anchore/sbom-action@62ad5284b8ced813296287a0b63906cb364b73ee # v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image }}:latest
          format: spdx-json
          output-file: sbom-${{ matrix.image }}.spdx.json

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4
        with:
          name: sbom-${{ matrix.image }}
          path: sbom-${{ matrix.image }}.spdx.json
          retention-days: 90

      - name: Sign container image
        run: |
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image }}:latest
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image }}:${{ github.sha }}

      - name: Attach SBOM to image
        run: |
          # Attach SBOM as attestation to the container image
          cosign attest --yes --predicate sbom-${{ matrix.image }}.spdx.json \
            --type spdxjson \
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image }}:latest

  # Staging environment deployment
  # Deploys images to staging environment for pre-production validation
  # This job is optional and can be skipped for direct production deployments
  staging-deployment:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: merge
    if: success()
    permissions:
      contents: read
      packages: read
    environment:
      name: staging
      url: http://staging.example.com # Update with actual staging URL

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Deploy to staging environment
        run: |
          echo "Staging Deployment Instructions"
          echo "=================================="
          echo ""
          echo "Container images are ready for staging deployment:"
          echo ""
          echo "Backend:  ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/backend:latest"
          echo "Frontend: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/frontend:latest"
          echo ""
          echo "To deploy to staging:"
          echo ""
          echo "1. SSH into staging server"
          echo "2. Pull latest images:"
          echo ""
          echo "   docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/backend:latest"
          echo "   docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/frontend:latest"
          echo ""
          echo "3. Update docker-compose.staging.yml with IMAGE_TAG=latest"
          echo ""
          echo "4. Deploy:"
          echo ""
          echo "   docker compose -f docker-compose.staging.yml up -d"
          echo ""
          echo "5. Verify deployment:"
          echo ""
          echo "   docker compose -f docker-compose.staging.yml ps"
          echo "   curl http://localhost:8000/api/system/health/ready"
          echo ""
          echo "6. Run smoke tests:"
          echo ""
          echo "   BACKEND_URL=http://localhost:8000 pytest tests/smoke/ -m critical -v"
          echo ""
          echo "NOTE: This is a manual deployment step."
          echo "For automated staging deployment, implement a deployment webhook or API."

      - name: Verify staging deployment checklist
        run: |
          echo "Staging Deployment Checklist"
          echo "============================="
          echo ""
          echo "Before running E2E tests against staging:"
          echo "- [ ] Backend service is healthy (/api/system/health/ready returns 200)"
          echo "- [ ] Frontend is serving HTML (http status 200)"
          echo "- [ ] Database migrations have completed"
          echo "- [ ] Redis is accessible and healthy"
          echo "- [ ] All API endpoints respond without errors"
          echo "- [ ] WebSocket endpoint is accessible"
          echo "- [ ] Monitoring stack is running (if enabled)"
          echo "- [ ] No error messages in application logs"
          echo ""
          echo "Run smoke tests to verify:"
          echo "  BACKEND_URL=http://staging:8000 pytest tests/smoke/ -m critical -v"
          echo ""
          echo "Then run E2E tests:"
          echo "  FRONTEND_URL=http://staging:5173 npm test -- --project=chromium"

      - name: Document staging validation
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4
        with:
          name: staging-deployment-guide
          path: docs/DEPLOYMENT_VERIFICATION_CHECKLIST.md
          retention-days: 30

  # Post-deployment health validation and progression
  # Validates deployment success and readiness for canary/progressive rollout
  post-deployment-validation:
    name: Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: smoke-test
    if: success()
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Verify deployment readiness
        run: |
          echo "Deployment Validation Report"
          echo "=============================="
          echo ""
          echo "Images have been successfully built, validated, and pushed:"
          echo ""
          echo "Registry: ghcr.io"
          echo "Prefix: ${{ github.repository }}"
          echo "Tags: latest, ${{ github.sha }}"
          echo ""
          echo "Validated Services:"
          echo "  - Backend API: Healthy"
          echo "  - Frontend UI: Healthy"
          echo "  - PostgreSQL: Responsive"
          echo "  - Redis: Responsive"
          echo ""
          echo "For production deployment, implement one of:"
          echo ""
          echo "1. ROLLING UPDATE (Default - All-at-once)"
          echo "   - Immediate deployment to all instances"
          echo "   - Brief downtime during update"
          echo "   - Automatic rollback on failure"
          echo ""
          echo "2. BLUE-GREEN DEPLOYMENT (Zero-downtime)"
          echo "   - Deploy to green environment"
          echo "   - Run health checks in parallel"
          echo "   - Atomic traffic switch"
          echo "   - Quick rollback by switching back to blue"
          echo ""
          echo "3. CANARY DEPLOYMENT (Progressive - Recommended)"
          echo "   - Initial 10% traffic to new version"
          echo "   - Monitor error rate, latency, circuit breakers"
          echo "   - Automatic escalation: 10% -> 25% -> 50% -> 100%"
          echo "   - Automatic rollback if thresholds exceeded"
          echo ""
          echo "See docs/DEPLOYMENT.md for implementation details"

      - name: Document canary deployment readiness
        run: |
          cat > canary-readiness.txt << 'EOF'
          # Canary Deployment Readiness Checklist

          ## Pre-Deployment Requirements
          - [ ] Load balancer configured for traffic splitting
          - [ ] Monitoring system ready (Prometheus/Grafana)
          - [ ] Alert channels configured (Email, Slack, PagerDuty)
          - [ ] Thresholds defined for automatic rollback
          - [ ] Team on-call and monitoring dashboard open

          ## Canary Metrics to Monitor
          - [ ] Request error rate (target < 1.0%)
          - [ ] Response latency P99 (target < 100ms increase)
          - [ ] Circuit breaker states (target: all closed)
          - [ ] Database connection usage (target < 80%)
          - [ ] Cache hit rate (target > 90%)
          - [ ] GPU utilization (if applicable)

          ## Escalation Schedule
          - Stage 1: Deploy to 10% traffic, monitor 5 minutes
          - Stage 2: Escalate to 25%, monitor 5 minutes
          - Stage 3: Escalate to 50%, monitor 10 minutes
          - Stage 4: Escalate to 100%, maintain monitoring 1 hour

          ## Automatic Rollback Triggers
          - Error rate exceeds 2.0%
          - Latency P99 increases > 100ms
          - Circuit breaker opens (any service)
          - Database connection pool > 95%
          - Deployment validation job fails

          ## Post-Deployment
          - Monitor for 1 hour after 100% deployment
          - Verify no error spikes or degradation
          - Check logs for any warning conditions
          - Confirm all metrics returned to baseline

          EOF
          cat canary-readiness.txt

      - name: Create deployment documentation artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4
        with:
          name: deployment-readiness
          path: canary-readiness.txt
          retention-days: 30

      - name: Output deployment instructions
        run: |
          echo "âœ… Deployment Validation Complete"
          echo ""
          echo "Next Steps:"
          echo "1. Review images in GHCR: https://github.com/orgs/${{ github.repository_owner }}/packages"
          echo "2. Choose deployment strategy (see DEPLOYMENT.md)"
          echo "3. Execute deployment on production environment"
          echo "4. Monitor health dashboard during rollout"
          echo "5. Verify metrics meet SLAs"

  # Generate SLSA provenance attestations for supply chain security
  # SLSA Level 3: Provides cryptographic proof of build provenance
  slsa-provenance:
    name: SLSA Provenance (${{ matrix.image }})
    runs-on: ubuntu-latest
    needs: merge
    permissions:
      contents: read
      packages: write
      id-token: write # Required for SLSA provenance generation
      attestations: write # Required for GitHub attestation API

    strategy:
      matrix:
        image: [backend, frontend]

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Log in to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get image digest
        id: digest
        run: |
          # Get the digest of the pushed image
          DIGEST=$(docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image }}:latest --format '{{json .Manifest}}' | jq -r '.digest')
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Image digest: $DIGEST"

      - name: Generate SLSA provenance attestation
        uses: actions/attest-build-provenance@ef244123eb79f2f7a7e75d99086184180e6d0018 # v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.image }}
          subject-digest: ${{ steps.digest.outputs.digest }}
          push-to-registry: true
