#!/usr/bin/env python3
"""Generate test stubs from OpenAPI specification.

This script extracts endpoint definitions from the FastAPI app's OpenAPI spec
and generates corresponding test cases for each endpoint.

The generated tests include:
- Happy path test (successful request)
- Error case test (404, 400, 500)
- Validation test (invalid input)
- Authorization test (if applicable)

Usage:
    ./scripts/generate-api-tests.py [--output-dir backend/tests/integration]
"""

import json
import sys
from pathlib import Path
from typing import Any


def extract_openapi_spec() -> dict[str, Any] | None:
    """Extract OpenAPI spec from FastAPI app.

    Returns:
        OpenAPI spec dictionary or None if extraction fails
    """
    try:
        # Run FastAPI app and extract OpenAPI spec
        import subprocess

        result = subprocess.run(
            [
                sys.executable,
                "-c",
                """
import json
import sys
sys.path.insert(0, '.')
from backend.main import app

spec = app.openapi()
print(json.dumps(spec, indent=2))
""",
            ],
            check=False,
            capture_output=True,
            text=True,
            timeout=10,
        )

        if result.returncode == 0:
            return json.loads(result.stdout)
        else:
            print(f"Error extracting OpenAPI spec: {result.stderr}")
            return None

    except Exception as e:
        print(f"Failed to extract OpenAPI spec: {e}")
        return None


def generate_endpoint_test(path: str, method: str, operation: dict[str, Any]) -> str | None:
    """Generate test case for an endpoint.

    Args:
        path: API path (e.g., "/api/cameras")
        method: HTTP method (e.g., "get", "post")
        operation: OpenAPI operation object

    Returns:
        Generated test code or None
    """
    # Extract operation details
    operation_id = operation.get("operationId", f"{method}_{path.replace('/', '_')}")
    summary = operation.get("summary", "")
    _description = operation.get("description", "")
    _request_body = operation.get("requestBody")
    _parameters = operation.get("parameters", [])
    _responses = operation.get("responses", {})

    # Generate test name
    test_name = f"test_{operation_id}"

    # Build test code
    test_code = f'''    @pytest.mark.asyncio
    async def {test_name}(self, async_client: AsyncClient):
        """Test {method.upper()} {path}.

        Endpoint: {method.upper()} {path}
        Summary: {summary}
        """
        # TODO: Implement test
        response = await async_client.{method}(
            "{path}",
            # TODO: Add request body if needed
        )

        # TODO: Verify response
        assert response.status_code in [200, 201]  # or appropriate codes'''

    return test_code


def generate_test_class(tag: str, paths: dict[str, Any], output_dir: Path) -> str | None:
    """Generate test class for an API tag/group.

    Args:
        tag: API tag (e.g., "cameras", "detections")
        paths: OpenAPI paths object
        output_dir: Output directory for test files

    Returns:
        Test file path if generated, None otherwise
    """
    # Filter paths for this tag
    tagged_endpoints = []

    for path, methods in paths.items():
        for method, operation in methods.items():
            if method == "parameters":
                continue
            tags = operation.get("tags", [])
            if tag in tags:
                tagged_endpoints.append((path, method, operation))

    if not tagged_endpoints:
        return None

    # Generate test class
    class_name = f"Test{tag.title()}Endpoints"
    test_content = f'''"""Auto-generated tests for {tag} API endpoints.

Generated from OpenAPI specification.
These are skeleton tests - implement the actual test logic.
"""

import pytest
from httpx import AsyncClient


class {class_name}:
    """Tests for {tag} API endpoints."""
'''

    # Add test methods
    for path, method, operation in tagged_endpoints:
        test_method = generate_endpoint_test(path, method, operation)
        if test_method:
            test_content += "\n" + test_method

    # Write test file
    test_file = output_dir / f"test_{tag}_endpoints.py"
    test_file.parent.mkdir(parents=True, exist_ok=True)

    # Add file header with import statements
    full_content = (
        '''"""Auto-generated endpoint tests.

This file was generated by generate-api-tests.py from the OpenAPI specification.
Implement the test logic for each endpoint.
"""

import pytest
from httpx import AsyncClient
from unittest.mock import patch, AsyncMock


'''
        + test_content
    )

    test_file.write_text(full_content)
    return str(test_file)


def main() -> int:
    """Main entry point.

    Returns:
        0 on success, 1 on failure
    """
    import argparse

    parser = argparse.ArgumentParser(
        description="Generate API endpoint test stubs from OpenAPI spec"
    )
    parser.add_argument(
        "--output-dir",
        default="backend/tests/integration",
        help="Output directory for generated tests",
    )
    parser.add_argument(
        "--save-spec",
        action="store_true",
        help="Save extracted OpenAPI spec to openapi-extracted.json",
    )
    args = parser.parse_args()

    project_root = Path(__file__).parent.parent
    output_dir = project_root / args.output_dir

    print("Extracting OpenAPI specification from FastAPI app...")
    spec = extract_openapi_spec()

    if not spec:
        print("ERROR: Could not extract OpenAPI specification")
        print("Make sure backend.main:app is a valid FastAPI application")
        return 1

    # Save spec if requested
    if args.save_spec:
        spec_file = project_root / "openapi-extracted.json"
        spec_file.write_text(json.dumps(spec, indent=2))
        print(f"Saved OpenAPI spec to {spec_file}")

    # Extract paths
    paths = spec.get("paths", {})
    if not paths:
        print("No paths found in OpenAPI spec")
        return 0

    # Extract tags
    tags_info = spec.get("tags", [])
    tags = {tag["name"] for tag in tags_info}

    # Generate tests for each tag
    generated_files = []

    print(f"\nFound {len(tags)} API tags")
    for tag in sorted(tags):
        print(f"  Generating tests for tag: {tag}")
        test_file = generate_test_class(tag, paths, output_dir)
        if test_file:
            generated_files.append(test_file)

    if generated_files:
        print(f"\nGenerated {len(generated_files)} test files:")
        for test_file in generated_files:
            print(f"  - {test_file}")
        print("\nNext steps:")
        print("  1. Review generated tests in: " + str(output_dir))
        print("  2. Implement test logic (replace TODO comments)")
        print("  3. Run tests: uv run pytest backend/tests/integration/test_*_endpoints.py")
        return 0
    else:
        print("\nNo tests generated (no matching endpoints found)")
        return 1


if __name__ == "__main__":
    sys.exit(main())
