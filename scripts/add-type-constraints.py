#!/usr/bin/env python3
"""Add validation constraints as JSDoc comments to generated TypeScript types.

This script post-processes the TypeScript types generated by openapi-typescript
to include validation constraints (minLength, maxLength, minimum, maximum, etc.)
as JSDoc comments for better developer experience.

Usage:
    ./scripts/add-type-constraints.py              # Add constraints
    ./scripts/add-type-constraints.py --check      # Check if constraints are current

The script reads the OpenAPI spec and adds constraint comments to the generated
TypeScript file at frontend/src/types/generated/api.ts.

Example output:
    Before:
        /**
         * Name
         * @description Camera name
         */
        name: string;

    After:
        /**
         * Name
         * @description Camera name
         * @constraint minLength: 1
         * @constraint maxLength: 255
         */
        name: string;
"""

from __future__ import annotations

import argparse
import json
import os
import re
import sys
from pathlib import Path

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Set required environment variables before importing backend modules
# fmt: off
os.environ.setdefault("DATABASE_URL", "postgresql+asyncpg://user:password@localhost:5432/security")  # pragma: allowlist secret
# fmt: on
os.environ.setdefault("REDIS_URL", "redis://localhost:6379/0")

# File paths
OPENAPI_SPEC_FILE = PROJECT_ROOT / "docs" / "openapi.json"
GENERATED_TYPES_FILE = PROJECT_ROOT / "frontend" / "src" / "types" / "generated" / "api.ts"


def load_openapi_spec() -> dict[str, object]:
    """Load the OpenAPI spec from file or generate it."""
    if OPENAPI_SPEC_FILE.exists():
        spec: dict[str, object] = json.loads(OPENAPI_SPEC_FILE.read_text())
        return spec

    # Fall back to generating from app
    from backend.main import app

    return app.openapi()


def extract_constraints(schema: dict) -> list[str]:
    """Extract validation constraints from an OpenAPI schema.

    Args:
        schema: OpenAPI schema object

    Returns:
        List of constraint strings for JSDoc comments
    """
    constraints: list[str] = []

    # String constraints
    if "minLength" in schema:
        constraints.append(f"minLength: {schema['minLength']}")
    if "maxLength" in schema:
        constraints.append(f"maxLength: {schema['maxLength']}")
    if "pattern" in schema:
        constraints.append(f"pattern: {schema['pattern']}")
    if "format" in schema:
        constraints.append(f"format: {schema['format']}")

    # Number constraints
    if "minimum" in schema:
        constraints.append(f"minimum: {schema['minimum']}")
    if "maximum" in schema:
        constraints.append(f"maximum: {schema['maximum']}")
    if "exclusiveMinimum" in schema:
        constraints.append(f"exclusiveMinimum: {schema['exclusiveMinimum']}")
    if "exclusiveMaximum" in schema:
        constraints.append(f"exclusiveMaximum: {schema['exclusiveMaximum']}")
    if "multipleOf" in schema:
        constraints.append(f"multipleOf: {schema['multipleOf']}")

    # Array constraints
    if "minItems" in schema:
        constraints.append(f"minItems: {schema['minItems']}")
    if "maxItems" in schema:
        constraints.append(f"maxItems: {schema['maxItems']}")
    if schema.get("uniqueItems"):
        constraints.append("uniqueItems: true")

    return constraints


def get_schema_constraints(spec: dict) -> dict[str, dict[str, list[str]]]:
    """Extract all schema constraints from OpenAPI spec.

    Returns:
        Nested dict: schema_name -> property_name -> list of constraint strings
    """
    schemas = spec.get("components", {}).get("schemas", {})
    result: dict[str, dict[str, list[str]]] = {}

    for schema_name, schema in schemas.items():
        properties = schema.get("properties", {})
        if not properties:
            continue

        schema_constraints: dict[str, list[str]] = {}
        for prop_name, prop_schema in properties.items():
            # Handle anyOf/oneOf for nullable types
            if "anyOf" in prop_schema:
                for variant in prop_schema["anyOf"]:
                    if variant.get("type") != "null":
                        constraints = extract_constraints(variant)
                        if constraints:
                            schema_constraints[prop_name] = constraints
                        break
            else:
                constraints = extract_constraints(prop_schema)
                if constraints:
                    schema_constraints[prop_name] = constraints

        if schema_constraints:
            result[schema_name] = schema_constraints

    return result


def add_constraints_to_typescript(
    content: str, constraints: dict[str, dict[str, list[str]]]
) -> str:
    """Add constraint comments to TypeScript content.

    This function finds JSDoc comments in the generated TypeScript and
    adds @constraint annotations for validation constraints.

    Args:
        content: Original TypeScript content
        constraints: Schema -> Property -> Constraints mapping

    Returns:
        Modified TypeScript content with constraint comments
    """
    lines = content.split("\n")
    result_lines: list[str] = []
    current_schema: str | None = None
    brace_depth = 0

    # Pattern to match schema definition start
    schema_pattern = re.compile(r'^(\s+)("[^"]+"|[\w]+):\s*\{$')
    # Pattern to match JSDoc end: */
    jsdoc_end_pattern = re.compile(r"^(\s+)\*/\s*$")
    # Pattern to match property after JSDoc
    property_pattern = re.compile(r'^(\s+)("[^"]+"|[\w]+)(\??):')

    i = 0
    while i < len(lines):
        line = lines[i]

        # Track schema context by watching for schema definitions in components/schemas
        schema_match = schema_pattern.match(line)
        if schema_match:
            schema_name = schema_match.group(2).strip('"')
            if schema_name in constraints:
                current_schema = schema_name
                brace_depth = 1
            elif current_schema:
                brace_depth += 1
            result_lines.append(line)
            i += 1
            continue

        # Track brace depth to know when we exit a schema
        if current_schema:
            brace_depth += line.count("{") - line.count("}")
            if brace_depth <= 0:
                current_schema = None
                brace_depth = 0

        # Look for JSDoc comment end followed by property definition
        if current_schema and jsdoc_end_pattern.match(line):
            # Check if next line is a property definition
            if i + 1 < len(lines):
                next_line = lines[i + 1]
                prop_match = property_pattern.match(next_line)
                if prop_match:
                    prop_name = prop_match.group(2).strip('"')
                    schema_constraints = constraints.get(current_schema, {})

                    if prop_name in schema_constraints:
                        # Get the indent from the */ line
                        indent_match = jsdoc_end_pattern.match(line)
                        if indent_match:
                            indent = indent_match.group(1)
                            # Insert constraint comment before */
                            # Use same indent as the */ line minus one space for the * alignment
                            constraint_str = ", ".join(schema_constraints[prop_name])
                            result_lines.append(f"{indent}* @constraint {constraint_str}")

        result_lines.append(line)
        i += 1

    return "\n".join(result_lines)


def main() -> int:
    """Main entry point.

    Returns:
        Exit code (0 for success, 1 for failure)
    """
    parser = argparse.ArgumentParser(
        description="Add validation constraints as JSDoc comments to generated TypeScript types"
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check if constraint comments are current (for CI)",
    )
    args = parser.parse_args()

    # Check if generated types file exists
    if not GENERATED_TYPES_FILE.exists():
        print(f"ERROR: Generated types file does not exist: {GENERATED_TYPES_FILE}")
        print("Run './scripts/generate-types.sh' first")
        return 1

    # Load OpenAPI spec
    try:
        spec = load_openapi_spec()
    except Exception as e:
        print(f"ERROR: Failed to load OpenAPI spec: {e}")
        return 1

    # Extract constraints
    constraints = get_schema_constraints(spec)

    if not constraints:
        print("No validation constraints found in OpenAPI spec")
        return 0

    # Read current TypeScript content
    current_content = GENERATED_TYPES_FILE.read_text()

    # Check if constraints are already present
    if "@constraint" in current_content:
        if args.check:
            print("OK: Constraint comments are present")
            return 0
        else:
            print("Constraint comments already present, skipping")
            return 0

    # Add constraints
    new_content = add_constraints_to_typescript(current_content, constraints)

    if args.check:
        # Check mode - constraints should be added
        print("INFO: Constraint comments not present")
        print("Run './scripts/generate-types.sh' to regenerate types with constraints")
        return 1

    # Write updated content
    GENERATED_TYPES_FILE.write_text(new_content)

    # Count constraints added
    total_properties = sum(len(props) for props in constraints.values())
    print(
        f"Added constraint annotations for {total_properties} properties across {len(constraints)} schemas"
    )
    print(f"Updated: {GENERATED_TYPES_FILE}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
