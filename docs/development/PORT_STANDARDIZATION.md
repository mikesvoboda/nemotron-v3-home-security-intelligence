# Port Standardization (NEM-3148)

## Overview

Port configuration is now standardized across all environments (development and Docker). The same internal ports are used for service-to-service communication in both environments - only the hostname/network location changes.

## Principle: "Build Once, Deploy Anywhere"

This standardization ensures:

- **Consistency**: Same port numbers across all environments
- **Predictability**: No surprises when moving from dev to production
- **Simplicity**: Configuration files don't need environment-specific port rewrites
- **Reduced errors**: No accidental hardcoded port mismatches

## Standardized Ports

### Internal Service Ports (Constant - Never Change)

These ports are used for service-to-service communication and remain the same in all environments:

| Service      | Port | Purpose          | Network Location                                             |
| ------------ | ---- | ---------------- | ------------------------------------------------------------ |
| Backend API  | 8000 | FastAPI server   | Development: `localhost:8000` / Docker: `backend:8000`       |
| PostgreSQL   | 5432 | Database         | Development: `localhost:5432` / Docker: `postgres:5432`      |
| Redis        | 6379 | Cache & Queue    | Development: `localhost:6379` / Docker: `redis:6379`         |
| YOLO26       | 8090 | Object Detection | Development: `localhost:8095` / Docker: `ai-yolo26:8095`     |
| Nemotron LLM | 8091 | LLM Reasoning    | Development: `localhost:8091` / Docker: `ai-llm:8091`        |
| Florence-2   | 8092 | Vision-Language  | Development: `localhost:8092` / Docker: `ai-florence:8092`   |
| CLIP         | 8093 | Embeddings       | Development: `localhost:8093` / Docker: `ai-clip:8093`       |
| Enrichment   | 8094 | Multi-Model      | Development: `localhost:8094` / Docker: `ai-enrichment:8094` |

### External/Host Ports (Configurable)

These ports expose services to external hosts and can vary based on availability:

| Service        | Default | Purpose       | External Access                                                           |
| -------------- | ------- | ------------- | ------------------------------------------------------------------------- |
| Frontend HTTP  | 5173    | Web UI        | http://localhost:5173 (dev), configurable via docker-compose.override.yml |
| Frontend HTTPS | 8443    | Web UI (SSL)  | https://localhost:8443 (dev), configurable                                |
| Grafana        | 3002    | Dashboards    | http://localhost:3002 (dev), configurable                                 |
| Prometheus     | 9090    | Metrics       | http://localhost:9090 (dev), configurable                                 |
| Alertmanager   | 9093    | Alerts        | http://localhost:9093 (dev), configurable                                 |
| Redis Exporter | 9121    | Redis metrics | http://localhost:9121 (dev), configurable                                 |
| JSON Exporter  | 7979    | JSON metrics  | http://localhost:7979 (dev), configurable                                 |

## Environment Separation

### Development Environment

Services are accessed via `localhost` with standard ports:

```env
# Development .env  # pragma: allowlist secret
DATABASE_URL=postgresql+asyncpg://security:password@localhost:5432/security  # pragma: allowlist secret
REDIS_URL=redis://localhost:6379/0
YOLO26_URL=http://localhost:8095
NEMOTRON_URL=http://localhost:8091
FLORENCE_URL=http://localhost:8092
CLIP_URL=http://localhost:8093
ENRICHMENT_URL=http://localhost:8094
```

### Docker Compose Environment

Services are accessed via container service names with the same standard internal ports:

```yaml
# backend service environment (generated by docker-compose)  # pragma: allowlist secret
DATABASE_URL=postgresql+asyncpg://security:password@postgres:5432/security  # pragma: allowlist secret
REDIS_URL=redis://redis:6379/0
YOLO26_URL=http://ai-yolo26:8095
NEMOTRON_URL=http://ai-llm:8091
FLORENCE_URL=http://ai-florence:8092
CLIP_URL=http://ai-clip:8093
ENRICHMENT_URL=http://ai-enrichment:8094
```

Notice: **Only the hostname changes, ports remain 5432, 6379, 8090, etc.**

## Configuration Files

### backend/core/config.py

All service URLs include documentation for both environments:

```python
database_url: str = Field(
    default="",
    description="PostgreSQL database URL. Development: localhost:5432, Docker: postgres:5432",
)

redis_url: str = Field(
    default="redis://localhost:6379/0",
    description="Redis connection URL. Development: redis://localhost:6379/0, Docker: redis://redis:6379/0",
)

yolo26_url: str = Field(
    default="http://localhost:8095",
    description="YOLO26 detection service URL. Development: http://localhost:8095, Docker: http://ai-yolo26:8095",
)
```

### .env.example

The example environment file documents port standardization:

```env
# STANDARDIZED PORTS (same for development and Docker):
#   Backend API:        8000
#   PostgreSQL:         5432
#   Redis:              6379
#   YOLO26:          8090
#   Nemotron LLM:       8091
#   Florence-2:         8092
#   CLIP:               8093
#   Enrichment:         8094
#
# Environment Separation:
#   Development (localhost):     Service URLs point to localhost
#   Docker Compose (network):    Service URLs use container service names
```

### setup.py

The setup script automatically generates environment-appropriate configuration:

```python
# Service definitions with STANDARDIZED DEFAULT PORTS
SERVICES: dict[str, ServiceInfo] = {
    "backend": {"port": 8000, "category": "Core", "desc": "Backend API"},
    "postgres": {"port": 5432, "category": "Core", "desc": "PostgreSQL database"},
    "redis": {"port": 6379, "category": "Core", "desc": "Redis cache/queue"},
    "yolo26": {"port": 8090, "category": "AI", "desc": "YOLO26 object detection"},
    # ... etc
}
```

### docker-compose.prod.yml

Standard internal ports are exposed via environment variables:

```yaml
backend:
  environment:
    - DATABASE_URL=postgresql+asyncpg://user:pass@postgres:5432/db # pragma: allowlist secret
    - REDIS_URL=redis://redis:6379
    - YOLO26_URL=http://ai-yolo26:8095
    - NEMOTRON_URL=http://ai-llm:8091
    # ... uses standard ports, no custom 5433, 6380, etc
```

### docker-compose.override.yml

External ports may differ, but internal container ports remain standard:

```yaml
# Generated by setup.py - maps external ports to standard internal ports
postgres:
  ports:
    - '5433:5432' # Host 5433 -> Container 5432 (internal standard)

redis:
  ports:
    - '6380:6379' # Host 6380 -> Container 6379 (internal standard)

backend:
  ports:
    - '8000:8000' # Host 8000 -> Container 8000 (always standard)

ai-yolo26:
  ports:
    - '8095:8095' # Host 8095 -> Container 8090 (internal standard)
```

## When Ports Are Standard vs. When They Can Vary

### Always Standard (Never Change)

- **Backend API**: 8000 (internal communication between frontend/backend)
- **PostgreSQL**: 5432 (internal communication with database)
- **Redis**: 6379 (internal communication with cache)
- **AI Services**: 8090-8094 (internal communication with detectors)

These ports are embedded in configuration and service discovery.

### Can Vary Based on Availability

- **Frontend**: 5173 (development) or 8080 (docker internal), mapped to configurable external ports
- **Monitoring**: 3002, 9090, 9093, etc. (all configurable external ports)

These ports are for external access only and are safely remappable.

## Important Files Changed (NEM-3148)

### 1. backend/core/config.py

- Added environment-separation documentation to all service URL fields
- Clarified standard ports vs. hostname changes
- Database port always 5432 (not 5433 in docker)
- PostgreSQL, Redis, AI services use standard ports

### 2. .env.example

- Added comprehensive port standardization section at top
- Documented environment separation (localhost vs. service names)
- Updated all service URL examples to show both environments
- Emphasized that ports remain constant across environments

### 3. setup.py

- Updated SERVICES dictionary comments explaining standardization
- Documented internal vs. external ports
- Clarified that setup.py handles external port conflicts automatically

### 4. docker-compose.prod.yml

- Verified all internal container ports use standards (5432, 6379, 8090-8094)
- Environment variables reference standard internal ports

### 5. docker-compose.override.yml

- Generated by setup.py, maps external ports to standard internal ports
- Example: 5433 (external) → 5432 (internal standard)

## Migration Guide

If you have existing configurations using non-standard ports:

### From Older Configuration

```env
# Old (inconsistent)  # pragma: allowlist secret
DATABASE_URL=postgresql://user:pass@localhost:5432/db  # pragma: allowlist secret
# OR  # pragma: allowlist secret
DATABASE_URL=postgresql://user:pass@postgres:5433/db  # pragma: allowlist secret
```

### To Standardized Configuration

```env
# New (standardized)  # pragma: allowlist secret
DATABASE_URL=postgresql://user:pass@localhost:5432/db  # pragma: allowlist secret
# AND  # pragma: allowlist secret
DATABASE_URL=postgresql://user:pass@postgres:5432/db   # pragma: allowlist secret
```

**Key Change**: Remove custom port numbers from internal service URLs. Use `setup.sh` to generate correct configuration for your environment.

## Running setup.sh

The `setup.sh` script now automatically:

1. **Detects** your environment (development vs. Docker)
2. **Generates** correct service URLs with standard ports
3. **Checks** for external port conflicts
4. **Finds alternatives** for conflicting external ports (5433, 6380, 8095, etc.)
5. **Creates** docker-compose.override.yml with proper port mappings

```bash
# Run once to set up standardized configuration
./setup.sh
```

This ensures your configuration uses standard internal ports while automatically handling external port conflicts.

## Configuration Examples

### Development (All Services Local)

```bash
# All services on localhost with standard ports  # pragma: allowlist secret
DATABASE_URL=postgresql+asyncpg://user:pass@localhost:5432/db  # pragma: allowlist secret
REDIS_URL=redis://localhost:6379/0
YOLO26_URL=http://localhost:8095
NEMOTRON_URL=http://localhost:8091
API_HOST=0.0.0.0
API_PORT=8000
```

### Docker Compose (Service Network)

```yaml
# Backend service environment (auto-generated)  # pragma: allowlist secret
DATABASE_URL=postgresql+asyncpg://user:pass@postgres:5432/db  # pragma: allowlist secret
REDIS_URL=redis://redis:6379/0
YOLO26_URL=http://ai-yolo26:8095
NEMOTRON_URL=http://ai-llm:8091
```

### Mixed Environment (Local Services + Docker)

```env
# Custom setup for special cases  # pragma: allowlist secret
DATABASE_URL=postgresql+asyncpg://user:pass@localhost:5432/db  # pragma: allowlist secret
REDIS_URL=redis://redis.example.com:6379/0                     # Remote redis
YOLO26_URL=http://ai-yolo26:8095                             # Docker network detector
```

Note: Even in mixed environments, ports remain standard (5432, 6379, 8090).

## Troubleshooting

### Port Conflicts

If you see "Address already in use":

```bash
# 1. Run setup.sh again - it will find available ports
./setup.sh

# 2. Or check what's using the port
lsof -i :5432        # Check PostgreSQL port
lsof -i :6379        # Check Redis port
lsof -i :8000        # Check Backend port
```

### Service Can't Connect

If backend can't connect to Redis:

```bash
# Wrong: Using external port from docker-compose.override.yml
REDIS_URL=redis://localhost:6380  # ❌ This won't work!

# Right: Use internal standard port
REDIS_URL=redis://localhost:6379  # ✅ Correct for local dev
REDIS_URL=redis://redis:6379      # ✅ Correct for Docker
```

### Environment Variable Mismatch

If you see "Connection refused":

1. Check hostname matches environment (localhost for dev, service names for docker)
2. Verify port is standard (5432, 6379, 8090, not 5433, 6380, 8095)
3. Confirm DATABASE_URL_in environment variables, not just .env.example

```bash
# Debug: Check what environment variables are set
env | grep -E "DATABASE_URL|REDIS_URL|YOLO26_URL"
```

## Benefits

1. **Simplified Configuration**: No special port handling per environment
2. **Better Documentation**: Clear separation of hostname vs. port changes
3. **Fewer Bugs**: Reduces misconfigured ports causing connection failures
4. **Easier Migration**: Moving from dev to Docker/production requires only hostname changes
5. **Standard Compliance**: Uses industry-standard ports (PostgreSQL 5432, Redis 6379, etc.)
6. **Automated Setup**: `setup.sh` handles complexity automatically

## References

- [docker-compose.prod.yml](/docker-compose.prod.yml) - Production configuration
- [docker-compose.override.yml](/docker-compose.override.yml) - Development overrides (generated)
- [.env.example](/.env.example) - Environment template with port documentation
- [backend/core/config.py](/backend/core/config.py) - Configuration settings
- [setup.py](/setup.py) - Setup script with port standardization
