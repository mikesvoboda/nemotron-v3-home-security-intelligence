{
  "components": {
    "schemas": {
      "AIServiceHealthStatus": {
        "description": "Health status for an AI service.\n\nIncludes service identification, health state, circuit breaker state,\nand response time metrics.",
        "example": {
          "circuit_state": "closed",
          "display_name": "RT-DETRv2 Object Detection",
          "last_check": "2026-01-08T10:30:00Z",
          "name": "rtdetr",
          "response_time_ms": 45.2,
          "status": "healthy",
          "url": "http://ai-detector:8090"
        },
        "properties": {
          "circuit_state": {
            "$ref": "#/components/schemas/CircuitState",
            "default": "closed",
            "description": "Circuit breaker state"
          },
          "display_name": {
            "description": "Human-readable service name",
            "title": "Display Name",
            "type": "string"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if unhealthy",
            "title": "Error"
          },
          "last_check": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of last health check",
            "title": "Last Check"
          },
          "name": {
            "description": "Service identifier (e.g., 'rtdetr', 'nemotron')",
            "title": "Name",
            "type": "string"
          },
          "response_time_ms": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Health check response time in milliseconds",
            "title": "Response Time Ms"
          },
          "status": {
            "$ref": "#/components/schemas/ServiceHealthState",
            "description": "Current health state"
          },
          "url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Service URL if configured",
            "title": "Url"
          }
        },
        "required": [
          "name",
          "display_name",
          "status"
        ],
        "title": "AIServiceHealthStatus",
        "type": "object"
      },
      "ActivityBaselineEntry": {
        "description": "A single activity baseline entry for a specific hour and day combination.\n\nThis represents one cell in the 24x7 activity heatmap (168 total entries).",
        "example": {
          "avg_count": 5.2,
          "day_of_week": 0,
          "hour": 17,
          "is_peak": true,
          "sample_count": 30
        },
        "properties": {
          "avg_count": {
            "description": "Average activity count for this time slot",
            "minimum": 0.0,
            "title": "Avg Count",
            "type": "number"
          },
          "day_of_week": {
            "description": "Day of week (0=Monday, 6=Sunday)",
            "maximum": 6.0,
            "minimum": 0.0,
            "title": "Day Of Week",
            "type": "integer"
          },
          "hour": {
            "description": "Hour of day (0-23)",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Hour",
            "type": "integer"
          },
          "is_peak": {
            "default": false,
            "description": "Whether this time slot has above-average activity",
            "title": "Is Peak",
            "type": "boolean"
          },
          "sample_count": {
            "description": "Number of samples used to calculate this average",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "hour",
          "day_of_week",
          "avg_count",
          "sample_count"
        ],
        "title": "ActivityBaselineEntry",
        "type": "object"
      },
      "ActivityBaselineResponse": {
        "description": "Response for camera activity baseline endpoint.\n\nContains 168 entries (24 hours x 7 days) representing the full weekly\nactivity heatmap for a camera.",
        "example": {
          "camera_id": "front_door",
          "entries": [
            {
              "avg_count": 0.5,
              "day_of_week": 0,
              "hour": 0,
              "is_peak": false,
              "sample_count": 30
            },
            {
              "avg_count": 5.2,
              "day_of_week": 4,
              "hour": 17,
              "is_peak": true,
              "sample_count": 30
            }
          ],
          "learning_complete": true,
          "min_samples_required": 10,
          "peak_day": 4,
          "peak_hour": 17,
          "total_samples": 720
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "entries": {
            "description": "Activity baseline entries (up to 168 = 24h x 7 days)",
            "items": {
              "$ref": "#/components/schemas/ActivityBaselineEntry"
            },
            "title": "Entries",
            "type": "array"
          },
          "learning_complete": {
            "default": false,
            "description": "Whether baseline has sufficient samples for reliable anomaly detection",
            "title": "Learning Complete",
            "type": "boolean"
          },
          "min_samples_required": {
            "default": 10,
            "description": "Minimum samples required per time slot for learning completion",
            "minimum": 1.0,
            "title": "Min Samples Required",
            "type": "integer"
          },
          "peak_day": {
            "anyOf": [
              {
                "maximum": 6.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Day with highest average activity (0=Monday, 6=Sunday)",
            "title": "Peak Day"
          },
          "peak_hour": {
            "anyOf": [
              {
                "maximum": 23.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Hour with highest average activity (0-23)",
            "title": "Peak Hour"
          },
          "total_samples": {
            "description": "Total number of samples across all entries",
            "minimum": 0.0,
            "title": "Total Samples",
            "type": "integer"
          }
        },
        "required": [
          "camera_id",
          "total_samples"
        ],
        "title": "ActivityBaselineResponse",
        "type": "object"
      },
      "AlertResponse": {
        "description": "Schema for alert response.",
        "example": {
          "channels": [
            "pushover"
          ],
          "created_at": "2025-12-28T12:00:00Z",
          "dedup_key": "front_door:person:entry_zone",
          "delivered_at": "2025-12-28T12:00:30Z",
          "event_id": 123,
          "id": "550e8400-e29b-41d4-a716-446655440001",
          "metadata": {
            "camera_name": "Front Door"
          },
          "rule_id": "550e8400-e29b-41d4-a716-446655440000",
          "severity": "high",
          "status": "delivered",
          "updated_at": "2025-12-28T12:01:00Z"
        },
        "properties": {
          "channels": {
            "description": "Notification channels",
            "items": {
              "type": "string"
            },
            "title": "Channels",
            "type": "array"
          },
          "created_at": {
            "description": "Creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "dedup_key": {
            "description": "Deduplication key",
            "title": "Dedup Key",
            "type": "string"
          },
          "delivered_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Delivery timestamp",
            "title": "Delivered At"
          },
          "event_id": {
            "description": "Event ID that triggered this alert",
            "title": "Event Id",
            "type": "integer"
          },
          "id": {
            "description": "Alert UUID",
            "title": "Id",
            "type": "string"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional context",
            "title": "Metadata"
          },
          "rule_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Alert rule UUID that matched",
            "title": "Rule Id"
          },
          "severity": {
            "$ref": "#/components/schemas/AlertSeverity",
            "description": "Alert severity level"
          },
          "status": {
            "$ref": "#/components/schemas/AlertStatus",
            "description": "Alert status"
          },
          "updated_at": {
            "description": "Last update timestamp",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          }
        },
        "required": [
          "id",
          "event_id",
          "severity",
          "status",
          "created_at",
          "updated_at",
          "dedup_key"
        ],
        "title": "AlertResponse",
        "type": "object"
      },
      "AlertRuleConditions": {
        "description": "Schema for legacy alert rule conditions (backward compatibility).\n\nNew rules should use explicit fields on AlertRuleCreate/AlertRuleUpdate.\nThis schema is kept for backward compatibility with existing rules.",
        "example": {
          "camera_ids": [
            "front_door",
            "backyard"
          ],
          "object_types": [
            "person",
            "vehicle"
          ],
          "risk_threshold": 70,
          "time_ranges": [
            {
              "end": "06:00",
              "start": "22:00"
            }
          ]
        },
        "properties": {
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Specific camera IDs that trigger alerts",
            "title": "Camera Ids"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object types that trigger alerts (e.g., person, vehicle)",
            "title": "Object Types"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum risk score to trigger alert",
            "title": "Risk Threshold"
          },
          "time_ranges": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time ranges when alerts are active (start/end in HH:MM format)",
            "title": "Time Ranges"
          }
        },
        "title": "AlertRuleConditions",
        "type": "object"
      },
      "AlertRuleCreate": {
        "description": "Schema for creating an alert rule.\n\nAll conditions use AND logic - all specified conditions must match for the rule to trigger.\nLeave a condition as null/empty to not filter on that criterion.",
        "example": {
          "camera_ids": [
            "front_door",
            "backyard"
          ],
          "channels": [
            "pushover",
            "webhook"
          ],
          "cooldown_seconds": 300,
          "dedup_key_template": "{camera_id}:{rule_id}",
          "description": "High-priority alert for person detection at night",
          "enabled": true,
          "min_confidence": 0.8,
          "name": "Night Intruder Alert",
          "object_types": [
            "person"
          ],
          "risk_threshold": 70,
          "schedule": {
            "days": [
              "monday",
              "tuesday",
              "wednesday",
              "thursday",
              "friday"
            ],
            "end_time": "06:00",
            "start_time": "22:00",
            "timezone": "America/New_York"
          },
          "severity": "critical"
        },
        "properties": {
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera IDs to apply rule to (empty = all cameras)",
            "title": "Camera Ids"
          },
          "channels": {
            "description": "Notification channels for this rule",
            "items": {
              "type": "string"
            },
            "title": "Channels",
            "type": "array"
          },
          "conditions": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleConditions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Legacy conditions (use explicit fields instead)"
          },
          "cooldown_seconds": {
            "default": 300,
            "description": "Minimum seconds between duplicate alerts",
            "minimum": 0.0,
            "title": "Cooldown Seconds",
            "type": "integer"
          },
          "dedup_key_template": {
            "default": "{camera_id}:{rule_id}",
            "description": "Template for dedup key. Variables: {camera_id}, {rule_id}, {object_type}",
            "maxLength": 255,
            "title": "Dedup Key Template",
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Rule description",
            "title": "Description"
          },
          "enabled": {
            "default": true,
            "description": "Whether the rule is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "min_confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum detection confidence (0.0-1.0)",
            "title": "Min Confidence"
          },
          "name": {
            "description": "Rule name",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object types to match (e.g., ['person', 'vehicle'])",
            "title": "Object Types"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Alert when risk_score >= threshold",
            "title": "Risk Threshold"
          },
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleSchedule"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based conditions (null = always active)"
          },
          "severity": {
            "$ref": "#/components/schemas/AlertSeverity",
            "default": "medium",
            "description": "Severity level for triggered alerts"
          },
          "zone_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Zone IDs to match (empty = any zone)",
            "title": "Zone Ids"
          }
        },
        "required": [
          "name"
        ],
        "title": "AlertRuleCreate",
        "type": "object"
      },
      "AlertRuleListResponse": {
        "description": "Schema for alert rule list response with pagination.",
        "example": {
          "items": [
            {
              "channels": [
                "pushover"
              ],
              "conditions": {
                "risk_threshold": 70
              },
              "cooldown_seconds": 300,
              "created_at": "2025-12-28T12:00:00Z",
              "enabled": true,
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "name": "High Risk Alert",
              "updated_at": "2025-12-28T12:00:00Z"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of alert rules",
            "items": {
              "$ref": "#/components/schemas/AlertRuleResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "AlertRuleListResponse",
        "type": "object"
      },
      "AlertRuleResponse": {
        "description": "Schema for alert rule response.",
        "example": {
          "camera_ids": [
            "front_door",
            "backyard"
          ],
          "channels": [
            "pushover",
            "webhook"
          ],
          "cooldown_seconds": 300,
          "created_at": "2025-12-28T12:00:00Z",
          "dedup_key_template": "{camera_id}:{rule_id}",
          "description": "High-priority alert for person detection at night",
          "enabled": true,
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "min_confidence": 0.8,
          "name": "Night Intruder Alert",
          "object_types": [
            "person"
          ],
          "risk_threshold": 70,
          "schedule": {
            "days": [
              "monday",
              "tuesday",
              "wednesday",
              "thursday",
              "friday"
            ],
            "end_time": "06:00",
            "start_time": "22:00",
            "timezone": "America/New_York"
          },
          "severity": "critical",
          "updated_at": "2025-12-28T12:00:00Z"
        },
        "properties": {
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera IDs to apply to",
            "title": "Camera Ids"
          },
          "channels": {
            "description": "Notification channels",
            "items": {
              "type": "string"
            },
            "title": "Channels",
            "type": "array"
          },
          "conditions": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleConditions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Legacy conditions"
          },
          "cooldown_seconds": {
            "description": "Minimum seconds between duplicate alerts",
            "title": "Cooldown Seconds",
            "type": "integer"
          },
          "created_at": {
            "description": "Creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "dedup_key_template": {
            "description": "Template for dedup key",
            "title": "Dedup Key Template",
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Rule description",
            "title": "Description"
          },
          "enabled": {
            "description": "Whether the rule is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "id": {
            "description": "Alert rule UUID",
            "title": "Id",
            "type": "string"
          },
          "min_confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum confidence",
            "title": "Min Confidence"
          },
          "name": {
            "description": "Rule name",
            "title": "Name",
            "type": "string"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object types to match",
            "title": "Object Types"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk score threshold",
            "title": "Risk Threshold"
          },
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleSchedule"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based conditions"
          },
          "severity": {
            "$ref": "#/components/schemas/AlertSeverity",
            "description": "Severity level"
          },
          "updated_at": {
            "description": "Last update timestamp",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "zone_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Zone IDs to match",
            "title": "Zone Ids"
          }
        },
        "required": [
          "id",
          "name",
          "enabled",
          "severity",
          "dedup_key_template",
          "cooldown_seconds",
          "created_at",
          "updated_at"
        ],
        "title": "AlertRuleResponse",
        "type": "object"
      },
      "AlertRuleSchedule": {
        "description": "Schema for alert rule schedule (time-based conditions).\n\nIf start_time > end_time, the schedule spans midnight (e.g., 22:00-06:00).\nEmpty days array means all days. No schedule = always active (vacation mode).\n\nValidation:\n- Days must be valid day names (monday-sunday)\n- Times must be valid HH:MM format with hours 00-23, minutes 00-59\n- Start and end times are validated but can span midnight",
        "example": {
          "days": [
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday"
          ],
          "end_time": "06:00",
          "start_time": "22:00",
          "timezone": "America/New_York"
        },
        "properties": {
          "days": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Days of week when rule is active (empty = all days). Values: monday, tuesday, wednesday, thursday, friday, saturday, sunday",
            "title": "Days"
          },
          "end_time": {
            "anyOf": [
              {
                "pattern": "^\\d{2}:\\d{2}$",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "End time in HH:MM format (00:00-23:59)",
            "title": "End Time"
          },
          "start_time": {
            "anyOf": [
              {
                "pattern": "^\\d{2}:\\d{2}$",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Start time in HH:MM format (00:00-23:59)",
            "title": "Start Time"
          },
          "timezone": {
            "default": "UTC",
            "description": "Timezone for time evaluation",
            "title": "Timezone",
            "type": "string"
          }
        },
        "title": "AlertRuleSchedule",
        "type": "object"
      },
      "AlertRuleUpdate": {
        "description": "Schema for updating an alert rule (PATCH).\n\nOnly provided fields will be updated. Null values clear the field.",
        "example": {
          "cooldown_seconds": 600,
          "enabled": false,
          "risk_threshold": 80
        },
        "properties": {
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera IDs to apply rule to",
            "title": "Camera Ids"
          },
          "channels": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Notification channels for this rule",
            "title": "Channels"
          },
          "conditions": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleConditions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Legacy conditions"
          },
          "cooldown_seconds": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum seconds between duplicate alerts",
            "title": "Cooldown Seconds"
          },
          "dedup_key_template": {
            "anyOf": [
              {
                "maxLength": 255,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Template for dedup key",
            "title": "Dedup Key Template"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Rule description",
            "title": "Description"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether the rule is active",
            "title": "Enabled"
          },
          "min_confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum detection confidence",
            "title": "Min Confidence"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 255,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Rule name",
            "title": "Name"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object types to match",
            "title": "Object Types"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Alert when risk_score >= threshold",
            "title": "Risk Threshold"
          },
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleSchedule"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based conditions"
          },
          "severity": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertSeverity"
              },
              {
                "type": "null"
              }
            ],
            "description": "Severity level"
          },
          "zone_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Zone IDs to match",
            "title": "Zone Ids"
          }
        },
        "title": "AlertRuleUpdate",
        "type": "object"
      },
      "AlertSeverity": {
        "description": "Alert severity levels.",
        "enum": [
          "low",
          "medium",
          "high",
          "critical"
        ],
        "title": "AlertSeverity",
        "type": "string"
      },
      "AlertStatus": {
        "description": "Alert status values.",
        "enum": [
          "pending",
          "delivered",
          "acknowledged",
          "dismissed"
        ],
        "title": "AlertStatus",
        "type": "string"
      },
      "AllPromptsResponse": {
        "description": "Response containing prompts for all models.",
        "example": {
          "prompts": {
            "florence2": {
              "config": {
                "vqa_queries": [
                  "What is this?"
                ]
              },
              "model_name": "florence2",
              "updated_at": "2026-01-01T08:00:00Z",
              "version": 1
            },
            "nemotron": {
              "config": {
                "system_prompt": "...",
                "temperature": 0.7
              },
              "model_name": "nemotron",
              "updated_at": "2026-01-03T10:30:00Z",
              "version": 3
            }
          }
        },
        "properties": {
          "prompts": {
            "additionalProperties": {
              "$ref": "#/components/schemas/ModelPromptResponse"
            },
            "description": "Dictionary mapping model names to their configurations",
            "title": "Prompts",
            "type": "object"
          }
        },
        "required": [
          "prompts"
        ],
        "title": "AllPromptsResponse",
        "type": "object"
      },
      "AnomalyConfig": {
        "description": "Current anomaly detection configuration.",
        "example": {
          "decay_factor": 0.1,
          "min_samples": 10,
          "threshold_stdev": 2.0,
          "window_days": 30
        },
        "properties": {
          "decay_factor": {
            "description": "Exponential decay factor for EWMA (0 < factor <= 1)",
            "exclusiveMinimum": 0.0,
            "maximum": 1.0,
            "title": "Decay Factor",
            "type": "number"
          },
          "min_samples": {
            "description": "Minimum samples required before anomaly detection is reliable",
            "minimum": 1.0,
            "title": "Min Samples",
            "type": "integer"
          },
          "threshold_stdev": {
            "description": "Number of standard deviations from mean for anomaly detection",
            "exclusiveMinimum": 0.0,
            "title": "Threshold Stdev",
            "type": "number"
          },
          "window_days": {
            "description": "Rolling window size in days for baseline calculations",
            "minimum": 1.0,
            "title": "Window Days",
            "type": "integer"
          }
        },
        "required": [
          "threshold_stdev",
          "min_samples",
          "decay_factor",
          "window_days"
        ],
        "title": "AnomalyConfig",
        "type": "object"
      },
      "AnomalyConfigUpdate": {
        "description": "Request to update anomaly detection configuration.",
        "example": {
          "min_samples": 15,
          "threshold_stdev": 2.5
        },
        "properties": {
          "min_samples": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum samples required before anomaly detection is reliable",
            "title": "Min Samples"
          },
          "threshold_stdev": {
            "anyOf": [
              {
                "exclusiveMinimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of standard deviations from mean for anomaly detection",
            "title": "Threshold Stdev"
          }
        },
        "title": "AnomalyConfigUpdate",
        "type": "object"
      },
      "AnomalyEvent": {
        "description": "A single anomaly event detected for a camera.",
        "example": {
          "anomaly_score": 0.95,
          "detection_class": "vehicle",
          "expected_frequency": 0.1,
          "observed_frequency": 5.0,
          "reason": "Vehicle detected at 2:30 AM when rarely seen at this hour",
          "timestamp": "2026-01-03T02:30:00Z"
        },
        "properties": {
          "anomaly_score": {
            "description": "Anomaly score (0.0-1.0, higher is more anomalous)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Anomaly Score",
            "type": "number"
          },
          "detection_class": {
            "description": "Object class that triggered the anomaly",
            "title": "Detection Class",
            "type": "string"
          },
          "expected_frequency": {
            "description": "Expected frequency for this class at this time",
            "minimum": 0.0,
            "title": "Expected Frequency",
            "type": "number"
          },
          "observed_frequency": {
            "description": "Observed frequency that triggered the anomaly",
            "minimum": 0.0,
            "title": "Observed Frequency",
            "type": "number"
          },
          "reason": {
            "description": "Human-readable explanation of why this is anomalous",
            "title": "Reason",
            "type": "string"
          },
          "timestamp": {
            "description": "When the anomaly was detected",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "detection_class",
          "anomaly_score",
          "expected_frequency",
          "observed_frequency",
          "reason"
        ],
        "title": "AnomalyEvent",
        "type": "object"
      },
      "AnomalyListResponse": {
        "description": "Response schema for camera anomaly list endpoint.",
        "example": {
          "anomalies": [
            {
              "anomaly_score": 0.95,
              "detection_class": "vehicle",
              "expected_frequency": 0.1,
              "observed_frequency": 5.0,
              "reason": "Vehicle detected at 2:30 AM when rarely seen",
              "timestamp": "2026-01-03T02:30:00Z"
            }
          ],
          "camera_id": "front_door",
          "count": 1,
          "period_days": 7
        },
        "properties": {
          "anomalies": {
            "description": "List of recent anomaly events",
            "items": {
              "$ref": "#/components/schemas/AnomalyEvent"
            },
            "title": "Anomalies",
            "type": "array"
          },
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "count": {
            "description": "Total number of anomalies returned",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "period_days": {
            "description": "Number of days covered by this query",
            "minimum": 1.0,
            "title": "Period Days",
            "type": "integer"
          }
        },
        "required": [
          "camera_id",
          "count",
          "period_days"
        ],
        "title": "AnomalyListResponse",
        "type": "object"
      },
      "AuditLogListResponse": {
        "description": "Schema for paginated audit log response.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.",
        "example": {
          "items": [
            {
              "action": "acknowledge",
              "actor": "admin@example.com",
              "id": 1,
              "ip_address": "192.168.1.100",
              "resource_id": "123",
              "resource_type": "event",
              "status": "success",
              "timestamp": "2026-01-03T10:30:00Z"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjYtMDEtMDNUMTA6MzA6MDBaIn0=",
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Warning when using deprecated offset pagination",
            "title": "Deprecation Warning"
          },
          "items": {
            "description": "List of audit log entries",
            "items": {
              "$ref": "#/components/schemas/AuditLogResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "AuditLogListResponse",
        "type": "object"
      },
      "AuditLogResponse": {
        "description": "Schema for a single audit log entry.",
        "example": {
          "action": "acknowledge",
          "actor": "admin@example.com",
          "details": {
            "new_status": "acknowledged",
            "previous_status": "unacknowledged"
          },
          "id": 1,
          "ip_address": "192.168.1.100",
          "resource_id": "123",
          "resource_type": "event",
          "status": "success",
          "timestamp": "2026-01-03T10:30:00Z",
          "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0"
        },
        "properties": {
          "action": {
            "description": "The action performed (e.g., 'create', 'update', 'delete', 'acknowledge')",
            "maxLength": 50,
            "minLength": 1,
            "title": "Action",
            "type": "string"
          },
          "actor": {
            "description": "User or system that performed the action",
            "maxLength": 200,
            "minLength": 1,
            "title": "Actor",
            "type": "string"
          },
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Action-specific details (JSON-serializable)",
            "title": "Details"
          },
          "id": {
            "description": "Audit log entry ID",
            "minimum": 1.0,
            "title": "Id",
            "type": "integer"
          },
          "ip_address": {
            "anyOf": [
              {
                "maxLength": 45,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "IP address of the client (IPv4 or IPv6)",
            "title": "Ip Address"
          },
          "resource_id": {
            "anyOf": [
              {
                "maxLength": 128,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the specific resource",
            "title": "Resource Id"
          },
          "resource_type": {
            "description": "Type of resource (event, alert, rule, camera, settings)",
            "maxLength": 50,
            "minLength": 1,
            "title": "Resource Type",
            "type": "string"
          },
          "status": {
            "description": "Status of the action (success/failure)",
            "pattern": "^(success|failure)$",
            "title": "Status",
            "type": "string"
          },
          "timestamp": {
            "description": "When the action occurred (UTC)",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "user_agent": {
            "anyOf": [
              {
                "maxLength": 500,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "User agent string of the client",
            "title": "User Agent"
          }
        },
        "required": [
          "id",
          "timestamp",
          "action",
          "resource_type",
          "actor",
          "status"
        ],
        "title": "AuditLogResponse",
        "type": "object"
      },
      "AuditLogStats": {
        "description": "Schema for audit log statistics.",
        "example": {
          "by_action": {
            "acknowledge": 50,
            "create": 30,
            "delete": 25,
            "update": 45
          },
          "by_resource_type": {
            "alert": 40,
            "camera": 20,
            "event": 80,
            "settings": 10
          },
          "by_status": {
            "failure": 5,
            "success": 145
          },
          "logs_today": 150,
          "recent_actors": [
            "admin@example.com",
            "system",
            "scheduler"
          ],
          "total_logs": 5000
        },
        "properties": {
          "by_action": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Counts by action type",
            "title": "By Action",
            "type": "object"
          },
          "by_resource_type": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Counts by resource type",
            "title": "By Resource Type",
            "type": "object"
          },
          "by_status": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Counts by status",
            "title": "By Status",
            "type": "object"
          },
          "logs_today": {
            "description": "Number of logs today",
            "minimum": 0.0,
            "title": "Logs Today",
            "type": "integer"
          },
          "recent_actors": {
            "description": "Recently active actors",
            "items": {
              "type": "string"
            },
            "title": "Recent Actors",
            "type": "array"
          },
          "total_logs": {
            "description": "Total number of audit logs",
            "minimum": 0.0,
            "title": "Total Logs",
            "type": "integer"
          }
        },
        "required": [
          "total_logs",
          "logs_today",
          "by_action",
          "by_resource_type",
          "by_status",
          "recent_actors"
        ],
        "title": "AuditLogStats",
        "type": "object"
      },
      "AuditStatsResponse": {
        "description": "Aggregate audit statistics.",
        "example": {
          "audited_events": 1100,
          "audits_by_day": [
            {
              "count": 45,
              "date": "2026-01-01"
            },
            {
              "count": 52,
              "date": "2026-01-02"
            },
            {
              "count": 38,
              "date": "2026-01-03"
            }
          ],
          "avg_consistency_rate": 0.92,
          "avg_enrichment_utilization": 0.78,
          "avg_quality_score": 4.1,
          "fully_evaluated_events": 950,
          "model_contribution_rates": {
            "clothing": 0.72,
            "florence": 0.85,
            "rtdetr": 0.98,
            "weather": 0.95
          },
          "total_events": 1250
        },
        "properties": {
          "audited_events": {
            "title": "Audited Events",
            "type": "integer"
          },
          "audits_by_day": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "title": "Audits By Day",
            "type": "array"
          },
          "avg_consistency_rate": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Consistency Rate"
          },
          "avg_enrichment_utilization": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Enrichment Utilization"
          },
          "avg_quality_score": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Quality Score"
          },
          "fully_evaluated_events": {
            "title": "Fully Evaluated Events",
            "type": "integer"
          },
          "model_contribution_rates": {
            "additionalProperties": {
              "type": "number"
            },
            "title": "Model Contribution Rates",
            "type": "object"
          },
          "total_events": {
            "title": "Total Events",
            "type": "integer"
          }
        },
        "required": [
          "total_events",
          "audited_events",
          "fully_evaluated_events",
          "avg_quality_score",
          "avg_consistency_rate",
          "avg_enrichment_utilization",
          "model_contribution_rates",
          "audits_by_day"
        ],
        "title": "AuditStatsResponse",
        "type": "object"
      },
      "BaselineSummaryResponse": {
        "description": "Response schema for camera baseline summary endpoint.\n\nProvides comprehensive baseline data for a camera including:\n- Hourly activity patterns (0-23 hours)\n- Daily patterns (by day of week)\n- Object-specific baselines\n- Current deviation from baseline",
        "example": {
          "baseline_established": "2026-01-01T00:00:00Z",
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "current_deviation": {
            "contributing_factors": [
              "person_count_elevated"
            ],
            "interpretation": "slightly_above_normal",
            "score": 1.8
          },
          "daily_patterns": {
            "monday": {
              "avg_detections": 45,
              "peak_hour": 17,
              "total_samples": 24
            }
          },
          "data_points": 720,
          "hourly_patterns": {
            "0": {
              "avg_detections": 0.5,
              "sample_count": 30,
              "std_dev": 0.3
            },
            "17": {
              "avg_detections": 5.2,
              "sample_count": 30,
              "std_dev": 1.1
            }
          },
          "object_baselines": {
            "person": {
              "avg_hourly": 2.3,
              "peak_hour": 17,
              "total_detections": 550
            }
          }
        },
        "properties": {
          "baseline_established": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When baseline data collection started (null if no data)",
            "title": "Baseline Established"
          },
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "description": "Human-readable camera name",
            "title": "Camera Name",
            "type": "string"
          },
          "current_deviation": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CurrentDeviation"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current deviation from baseline (null if insufficient data)"
          },
          "daily_patterns": {
            "additionalProperties": {
              "$ref": "#/components/schemas/DailyPattern"
            },
            "description": "Activity patterns by day of week (monday-sunday)",
            "title": "Daily Patterns",
            "type": "object"
          },
          "data_points": {
            "description": "Total number of data points in baseline",
            "minimum": 0.0,
            "title": "Data Points",
            "type": "integer"
          },
          "hourly_patterns": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HourlyPattern"
            },
            "description": "Activity patterns by hour (0-23)",
            "title": "Hourly Patterns",
            "type": "object"
          },
          "object_baselines": {
            "additionalProperties": {
              "$ref": "#/components/schemas/ObjectBaseline"
            },
            "description": "Baseline statistics by object type",
            "title": "Object Baselines",
            "type": "object"
          }
        },
        "required": [
          "camera_id",
          "camera_name",
          "data_points"
        ],
        "title": "BaselineSummaryResponse",
        "type": "object"
      },
      "BatchAggregatorStatusResponse": {
        "description": "Status information for the BatchAggregator service.",
        "example": {
          "active_batches": 2,
          "batch_window_seconds": 90,
          "batches": [
            {
              "age_seconds": 45.5,
              "batch_id": "abc123",
              "camera_id": "front_door",
              "detection_count": 5,
              "last_activity_seconds": 10.2,
              "started_at": 1735500000.0
            }
          ],
          "idle_timeout_seconds": 30
        },
        "properties": {
          "active_batches": {
            "description": "Number of active batches being aggregated",
            "minimum": 0.0,
            "title": "Active Batches",
            "type": "integer"
          },
          "batch_window_seconds": {
            "description": "Configured batch window timeout in seconds",
            "minimum": 1.0,
            "title": "Batch Window Seconds",
            "type": "integer"
          },
          "batches": {
            "description": "Details of active batches",
            "items": {
              "$ref": "#/components/schemas/BatchInfoResponse"
            },
            "title": "Batches",
            "type": "array"
          },
          "idle_timeout_seconds": {
            "description": "Configured idle timeout in seconds",
            "minimum": 1.0,
            "title": "Idle Timeout Seconds",
            "type": "integer"
          }
        },
        "required": [
          "active_batches",
          "batch_window_seconds",
          "idle_timeout_seconds"
        ],
        "title": "BatchAggregatorStatusResponse",
        "type": "object"
      },
      "BatchAuditRequest": {
        "description": "Request for batch audit processing.",
        "example": {
          "force_reevaluate": false,
          "limit": 100,
          "min_risk_score": 50
        },
        "properties": {
          "force_reevaluate": {
            "default": false,
            "title": "Force Reevaluate",
            "type": "boolean"
          },
          "limit": {
            "default": 100,
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "type": "integer"
          },
          "min_risk_score": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Risk Score"
          }
        },
        "title": "BatchAuditRequest",
        "type": "object"
      },
      "BatchAuditResponse": {
        "description": "Response for batch audit request.",
        "example": {
          "message": "Queued 75 events for audit processing",
          "queued_count": 75
        },
        "properties": {
          "message": {
            "title": "Message",
            "type": "string"
          },
          "queued_count": {
            "title": "Queued Count",
            "type": "integer"
          }
        },
        "required": [
          "queued_count",
          "message"
        ],
        "title": "BatchAuditResponse",
        "type": "object"
      },
      "BatchInfoResponse": {
        "description": "Information about an active batch.",
        "properties": {
          "age_seconds": {
            "description": "Time since batch started in seconds",
            "minimum": 0.0,
            "title": "Age Seconds",
            "type": "number"
          },
          "batch_id": {
            "description": "Unique batch identifier",
            "title": "Batch Id",
            "type": "string"
          },
          "camera_id": {
            "description": "Camera ID this batch belongs to",
            "title": "Camera Id",
            "type": "string"
          },
          "detection_count": {
            "description": "Number of detections in this batch",
            "minimum": 0.0,
            "title": "Detection Count",
            "type": "integer"
          },
          "last_activity_seconds": {
            "description": "Time since last activity in seconds",
            "minimum": 0.0,
            "title": "Last Activity Seconds",
            "type": "number"
          },
          "started_at": {
            "description": "Batch start time (Unix timestamp)",
            "title": "Started At",
            "type": "number"
          }
        },
        "required": [
          "batch_id",
          "camera_id",
          "detection_count",
          "started_at",
          "age_seconds",
          "last_activity_seconds"
        ],
        "title": "BatchInfoResponse",
        "type": "object"
      },
      "BulkItemResult": {
        "description": "Result for a single item in a bulk operation.\n\nAttributes:\n    index: Zero-based index of the item in the request array\n    status: Operation status (success, failed, skipped)\n    id: ID of the created/updated resource (for successful operations)\n    error: Error message (for failed operations)",
        "properties": {
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message for failed operations",
            "title": "Error"
          },
          "id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the created/updated resource",
            "title": "Id"
          },
          "index": {
            "description": "Zero-based index of the item in the request",
            "minimum": 0.0,
            "title": "Index",
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/BulkOperationStatus",
            "description": "Operation status"
          }
        },
        "required": [
          "index",
          "status"
        ],
        "title": "BulkItemResult",
        "type": "object"
      },
      "BulkOperationResponse": {
        "description": "Base response for bulk operations with partial success support.\n\nUses HTTP 207 Multi-Status when some operations succeed and others fail.\n\nAttributes:\n    total: Total number of items in the request\n    succeeded: Number of successful operations\n    failed: Number of failed operations\n    skipped: Number of skipped operations\n    results: Per-item results with status and error details",
        "properties": {
          "failed": {
            "description": "Number of failed operations",
            "minimum": 0.0,
            "title": "Failed",
            "type": "integer"
          },
          "results": {
            "description": "Per-item results",
            "items": {
              "$ref": "#/components/schemas/BulkItemResult"
            },
            "title": "Results",
            "type": "array"
          },
          "skipped": {
            "default": 0,
            "description": "Number of skipped operations",
            "minimum": 0.0,
            "title": "Skipped",
            "type": "integer"
          },
          "succeeded": {
            "description": "Number of successful operations",
            "minimum": 0.0,
            "title": "Succeeded",
            "type": "integer"
          },
          "total": {
            "description": "Total number of items in the request",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "succeeded",
          "failed"
        ],
        "title": "BulkOperationResponse",
        "type": "object"
      },
      "BulkOperationStatus": {
        "description": "Status of individual items in a bulk operation.",
        "enum": [
          "success",
          "failed",
          "skipped"
        ],
        "title": "BulkOperationStatus",
        "type": "string"
      },
      "CameraCreate": {
        "description": "Schema for creating a new camera.",
        "example": {
          "folder_path": "/export/foscam/front_door",
          "name": "Front Door Camera",
          "status": "online"
        },
        "properties": {
          "folder_path": {
            "description": "File system path for camera uploads",
            "maxLength": 500,
            "minLength": 1,
            "title": "Folder Path",
            "type": "string"
          },
          "name": {
            "description": "Camera name",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/CameraStatus",
            "default": "online",
            "description": "Camera status (online, offline, error, unknown)"
          }
        },
        "required": [
          "name",
          "folder_path"
        ],
        "title": "CameraCreate",
        "type": "object"
      },
      "CameraListResponse": {
        "description": "Schema for camera list response.\n\nNEM-2075: Standardized pagination envelope with items + pagination structure.",
        "example": {
          "items": [
            {
              "created_at": "2025-12-23T10:00:00Z",
              "folder_path": "/export/foscam/front_door",
              "id": "front_door",
              "last_seen_at": "2025-12-23T12:00:00Z",
              "name": "Front Door Camera",
              "status": "online"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of cameras",
            "items": {
              "$ref": "#/components/schemas/CameraResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "CameraListResponse",
        "type": "object"
      },
      "CameraNotificationSettingResponse": {
        "description": "Schema for camera notification setting response.",
        "example": {
          "camera_id": "front_door",
          "enabled": true,
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "risk_threshold": 50
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "enabled": {
            "description": "Whether notifications are enabled for this camera",
            "title": "Enabled",
            "type": "boolean"
          },
          "id": {
            "description": "Setting UUID",
            "title": "Id",
            "type": "string"
          },
          "risk_threshold": {
            "description": "Minimum risk score to trigger notifications (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Risk Threshold",
            "type": "integer"
          }
        },
        "required": [
          "id",
          "camera_id",
          "enabled",
          "risk_threshold"
        ],
        "title": "CameraNotificationSettingResponse",
        "type": "object"
      },
      "CameraNotificationSettingUpdate": {
        "description": "Schema for updating camera notification setting.",
        "example": {
          "enabled": false,
          "risk_threshold": 70
        },
        "properties": {
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether notifications are enabled for this camera",
            "title": "Enabled"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum risk score to trigger notifications (0-100)",
            "title": "Risk Threshold"
          }
        },
        "title": "CameraNotificationSettingUpdate",
        "type": "object"
      },
      "CameraNotificationSettingsListResponse": {
        "description": "Schema for camera notification settings list response with pagination.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "enabled": true,
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "risk_threshold": 50
            },
            {
              "camera_id": "back_yard",
              "enabled": false,
              "id": "550e8400-e29b-41d4-a716-446655440001",
              "risk_threshold": 70
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 2
          }
        },
        "properties": {
          "items": {
            "description": "List of camera notification settings",
            "items": {
              "$ref": "#/components/schemas/CameraNotificationSettingResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "CameraNotificationSettingsListResponse",
        "type": "object"
      },
      "CameraPathValidationResponse": {
        "description": "Schema for camera path validation response.\n\nNEM-2063: Response model for the /api/cameras/validation/paths endpoint.\nValidates all camera folder paths against the configured base path.",
        "example": {
          "base_path": "/export/foscam",
          "invalid_cameras": [
            {
              "folder_path": "/export/foscam/garage",
              "id": "garage",
              "issues": [
                "directory does not exist"
              ],
              "name": "Garage Camera",
              "status": "offline"
            }
          ],
          "invalid_count": 2,
          "total_cameras": 6,
          "valid_cameras": [
            {
              "folder_path": "/export/foscam/front_door",
              "id": "front_door",
              "name": "Front Door Camera",
              "status": "online"
            }
          ],
          "valid_count": 4
        },
        "properties": {
          "base_path": {
            "description": "Configured base path for camera folders",
            "title": "Base Path",
            "type": "string"
          },
          "invalid_cameras": {
            "description": "Cameras with validation issues",
            "items": {
              "$ref": "#/components/schemas/CameraValidationInfo"
            },
            "title": "Invalid Cameras",
            "type": "array"
          },
          "invalid_count": {
            "description": "Number of cameras with invalid paths",
            "title": "Invalid Count",
            "type": "integer"
          },
          "total_cameras": {
            "description": "Total number of cameras validated",
            "title": "Total Cameras",
            "type": "integer"
          },
          "valid_cameras": {
            "description": "Cameras with valid paths",
            "items": {
              "$ref": "#/components/schemas/CameraValidationInfo"
            },
            "title": "Valid Cameras",
            "type": "array"
          },
          "valid_count": {
            "description": "Number of cameras with valid paths",
            "title": "Valid Count",
            "type": "integer"
          }
        },
        "required": [
          "base_path",
          "total_cameras",
          "valid_count",
          "invalid_count",
          "valid_cameras",
          "invalid_cameras"
        ],
        "title": "CameraPathValidationResponse",
        "type": "object"
      },
      "CameraResponse": {
        "description": "Schema for camera response.",
        "example": {
          "created_at": "2025-12-23T10:00:00Z",
          "folder_path": "/export/foscam/front_door",
          "id": "front_door",
          "last_seen_at": "2025-12-23T12:00:00Z",
          "name": "Front Door Camera",
          "status": "online"
        },
        "properties": {
          "created_at": {
            "description": "Timestamp when camera was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "folder_path": {
            "description": "File system path for camera uploads",
            "title": "Folder Path",
            "type": "string"
          },
          "id": {
            "description": "Normalized camera ID derived from folder name (e.g., 'front_door')",
            "title": "Id",
            "type": "string"
          },
          "last_seen_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Last time camera was active",
            "title": "Last Seen At"
          },
          "name": {
            "description": "Camera name",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/CameraStatus",
            "description": "Camera status (online, offline, error, unknown)"
          }
        },
        "required": [
          "id",
          "name",
          "folder_path",
          "status",
          "created_at"
        ],
        "title": "CameraResponse",
        "type": "object"
      },
      "CameraStatus": {
        "description": "Camera status values.\n\nIndicates the operational state of a camera:\n- ONLINE: Camera is active and receiving images\n- OFFLINE: Camera is not currently active (e.g., disconnected)\n- ERROR: Camera is experiencing an error condition\n- UNKNOWN: Camera status cannot be determined",
        "enum": [
          "online",
          "offline",
          "error",
          "unknown"
        ],
        "title": "CameraStatus",
        "type": "string"
      },
      "CameraUpdate": {
        "description": "Schema for updating an existing camera.",
        "example": {
          "name": "Front Door Camera - Updated",
          "status": "offline"
        },
        "properties": {
          "folder_path": {
            "anyOf": [
              {
                "maxLength": 500,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "File system path for camera uploads",
            "title": "Folder Path"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 255,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera name",
            "title": "Name"
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CameraStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera status (online, offline, error, unknown)"
          }
        },
        "title": "CameraUpdate",
        "type": "object"
      },
      "CameraUptimeDataPoint": {
        "description": "Schema for a single camera uptime data point.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "detection_count": 150,
          "uptime_percentage": 98.5
        },
        "properties": {
          "camera_id": {
            "description": "Normalized camera ID (e.g., 'front_door')",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "description": "Camera name",
            "title": "Camera Name",
            "type": "string"
          },
          "detection_count": {
            "description": "Total detections in date range",
            "minimum": 0.0,
            "title": "Detection Count",
            "type": "integer"
          },
          "uptime_percentage": {
            "description": "Uptime percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Uptime Percentage",
            "type": "number"
          }
        },
        "required": [
          "camera_id",
          "camera_name",
          "uptime_percentage",
          "detection_count"
        ],
        "title": "CameraUptimeDataPoint",
        "type": "object"
      },
      "CameraUptimeResponse": {
        "description": "Schema for camera uptime percentage per camera.",
        "example": {
          "cameras": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_count": 150,
              "uptime_percentage": 98.5
            },
            {
              "camera_id": "back_door",
              "camera_name": "Back Door",
              "detection_count": 120,
              "uptime_percentage": 95.2
            }
          ],
          "end_date": "2025-01-07",
          "start_date": "2025-01-01"
        },
        "properties": {
          "cameras": {
            "description": "Uptime data per camera",
            "items": {
              "$ref": "#/components/schemas/CameraUptimeDataPoint"
            },
            "title": "Cameras",
            "type": "array"
          },
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          }
        },
        "required": [
          "cameras",
          "start_date",
          "end_date"
        ],
        "title": "CameraUptimeResponse",
        "type": "object"
      },
      "CameraValidationInfo": {
        "description": "Schema for individual camera validation result.\n\nNEM-2063: Response model for camera path validation details.",
        "example": {
          "folder_path": "/export/foscam/front_door",
          "id": "front_door",
          "issues": [
            "directory does not exist"
          ],
          "name": "Front Door Camera",
          "resolved_path": "/export/foscam/front_door",
          "status": "online"
        },
        "properties": {
          "folder_path": {
            "description": "Configured folder path",
            "title": "Folder Path",
            "type": "string"
          },
          "id": {
            "description": "Camera ID",
            "title": "Id",
            "type": "string"
          },
          "issues": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of validation issues (only for invalid cameras)",
            "title": "Issues"
          },
          "name": {
            "description": "Camera name",
            "title": "Name",
            "type": "string"
          },
          "resolved_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Resolved absolute path (included if path is outside base_path)",
            "title": "Resolved Path"
          },
          "status": {
            "$ref": "#/components/schemas/CameraStatus",
            "description": "Camera status"
          }
        },
        "required": [
          "id",
          "name",
          "folder_path",
          "status"
        ],
        "title": "CameraValidationInfo",
        "type": "object"
      },
      "CategorySummary": {
        "description": "Summary of services in a category.\n\nProvides a quick overview of service health within a category\nfor dashboard displays.",
        "example": {
          "healthy": 3,
          "total": 5,
          "unhealthy": 2
        },
        "properties": {
          "healthy": {
            "description": "Number of healthy (running) services",
            "minimum": 0.0,
            "title": "Healthy",
            "type": "integer"
          },
          "total": {
            "description": "Total number of services in this category",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          },
          "unhealthy": {
            "description": "Number of unhealthy/stopped/disabled services",
            "minimum": 0.0,
            "title": "Unhealthy",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "healthy",
          "unhealthy"
        ],
        "title": "CategorySummary",
        "type": "object"
      },
      "CircuitBreakerConfigResponse": {
        "description": "Configuration for a circuit breaker.",
        "properties": {
          "failure_threshold": {
            "description": "Number of failures before opening circuit",
            "minimum": 1.0,
            "title": "Failure Threshold",
            "type": "integer"
          },
          "half_open_max_calls": {
            "description": "Maximum calls allowed in half-open state",
            "minimum": 1.0,
            "title": "Half Open Max Calls",
            "type": "integer"
          },
          "recovery_timeout": {
            "description": "Seconds to wait before transitioning to half-open",
            "minimum": 0.0,
            "title": "Recovery Timeout",
            "type": "number"
          },
          "success_threshold": {
            "description": "Successes needed in half-open to close circuit",
            "minimum": 1.0,
            "title": "Success Threshold",
            "type": "integer"
          }
        },
        "required": [
          "failure_threshold",
          "recovery_timeout",
          "half_open_max_calls",
          "success_threshold"
        ],
        "title": "CircuitBreakerConfigResponse",
        "type": "object"
      },
      "CircuitBreakerResetResponse": {
        "description": "Response for circuit breaker reset operation.",
        "properties": {
          "message": {
            "description": "Human-readable result message",
            "title": "Message",
            "type": "string"
          },
          "name": {
            "description": "Name of the circuit breaker that was reset",
            "title": "Name",
            "type": "string"
          },
          "new_state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "State after reset (should be closed)"
          },
          "previous_state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "State before reset"
          }
        },
        "required": [
          "name",
          "previous_state",
          "new_state",
          "message"
        ],
        "title": "CircuitBreakerResetResponse",
        "type": "object"
      },
      "CircuitBreakerStateEnum": {
        "description": "Circuit breaker states.",
        "enum": [
          "closed",
          "open",
          "half_open",
          "unavailable"
        ],
        "title": "CircuitBreakerStateEnum",
        "type": "string"
      },
      "CircuitBreakerStatusResponse": {
        "description": "Status of a single circuit breaker.",
        "example": {
          "config": {
            "failure_threshold": 5,
            "half_open_max_calls": 3,
            "recovery_timeout": 30.0,
            "success_threshold": 2
          },
          "failure_count": 0,
          "name": "ai_service",
          "rejected_calls": 0,
          "state": "closed",
          "success_count": 0,
          "total_calls": 150
        },
        "properties": {
          "config": {
            "$ref": "#/components/schemas/CircuitBreakerConfigResponse",
            "description": "Circuit breaker configuration"
          },
          "failure_count": {
            "description": "Current consecutive failure count",
            "minimum": 0.0,
            "title": "Failure Count",
            "type": "integer"
          },
          "last_failure_time": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Monotonic time of last failure (seconds)",
            "title": "Last Failure Time"
          },
          "name": {
            "description": "Circuit breaker name",
            "title": "Name",
            "type": "string"
          },
          "opened_at": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Monotonic time when circuit opened (seconds)",
            "title": "Opened At"
          },
          "rejected_calls": {
            "description": "Calls rejected due to open circuit",
            "minimum": 0.0,
            "title": "Rejected Calls",
            "type": "integer"
          },
          "state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "Current circuit state: closed (normal), open (failing), half_open (testing)"
          },
          "success_count": {
            "description": "Current consecutive success count (relevant in half-open)",
            "minimum": 0.0,
            "title": "Success Count",
            "type": "integer"
          },
          "total_calls": {
            "description": "Total calls attempted through this circuit",
            "minimum": 0.0,
            "title": "Total Calls",
            "type": "integer"
          }
        },
        "required": [
          "name",
          "state",
          "failure_count",
          "success_count",
          "total_calls",
          "rejected_calls",
          "config"
        ],
        "title": "CircuitBreakerStatusResponse",
        "type": "object"
      },
      "CircuitBreakerSummary": {
        "description": "Summary of all circuit breakers in the system.\n\nProvides counts by state and individual breaker states for monitoring.",
        "example": {
          "breakers": {
            "clip": "closed",
            "enrichment": "closed",
            "florence": "open",
            "nemotron": "closed",
            "rtdetr": "closed"
          },
          "closed": 4,
          "half_open": 0,
          "open": 1,
          "total": 5
        },
        "properties": {
          "breakers": {
            "additionalProperties": {
              "$ref": "#/components/schemas/CircuitState"
            },
            "description": "Individual circuit breaker states keyed by service name",
            "title": "Breakers",
            "type": "object"
          },
          "closed": {
            "description": "Number of breakers in closed state",
            "title": "Closed",
            "type": "integer"
          },
          "half_open": {
            "description": "Number of breakers in half-open state",
            "title": "Half Open",
            "type": "integer"
          },
          "open": {
            "description": "Number of breakers in open state",
            "title": "Open",
            "type": "integer"
          },
          "total": {
            "description": "Total number of circuit breakers",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "closed",
          "open",
          "half_open",
          "breakers"
        ],
        "title": "CircuitBreakerSummary",
        "type": "object"
      },
      "CircuitBreakersResponse": {
        "description": "Response schema for circuit breakers status endpoint.",
        "example": {
          "circuit_breakers": {
            "rtdetr": {
              "config": {
                "failure_threshold": 5,
                "half_open_max_calls": 3,
                "recovery_timeout": 30.0,
                "success_threshold": 2
              },
              "failure_count": 0,
              "name": "rtdetr",
              "rejected_calls": 0,
              "state": "closed",
              "success_count": 0,
              "total_calls": 100
            }
          },
          "open_count": 0,
          "timestamp": "2025-12-30T10:30:00Z",
          "total_count": 2
        },
        "properties": {
          "circuit_breakers": {
            "additionalProperties": {
              "$ref": "#/components/schemas/CircuitBreakerStatusResponse"
            },
            "description": "Status of all circuit breakers keyed by name",
            "title": "Circuit Breakers",
            "type": "object"
          },
          "open_count": {
            "description": "Number of circuit breakers currently open",
            "minimum": 0.0,
            "title": "Open Count",
            "type": "integer"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "total_count": {
            "description": "Total number of circuit breakers",
            "minimum": 0.0,
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "circuit_breakers",
          "total_count",
          "open_count",
          "timestamp"
        ],
        "title": "CircuitBreakersResponse",
        "type": "object"
      },
      "CircuitState": {
        "description": "Circuit breaker state for a service.\n\nStates:\n- closed: Normal operation, requests pass through\n- open: Service failing, requests fail immediately\n- half_open: Testing recovery, limited requests allowed",
        "enum": [
          "closed",
          "open",
          "half_open"
        ],
        "title": "CircuitState",
        "type": "string"
      },
      "ClassBaselineEntry": {
        "description": "Baseline entry for a specific object class at a specific hour.",
        "example": {
          "frequency": 3.5,
          "hour": 17,
          "object_class": "person",
          "sample_count": 45
        },
        "properties": {
          "frequency": {
            "description": "Frequency of this class at this hour",
            "minimum": 0.0,
            "title": "Frequency",
            "type": "number"
          },
          "hour": {
            "description": "Hour of day (0-23)",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Hour",
            "type": "integer"
          },
          "object_class": {
            "description": "Object class (e.g., person, vehicle, animal)",
            "title": "Object Class",
            "type": "string"
          },
          "sample_count": {
            "description": "Number of samples for this class/hour combination",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "object_class",
          "hour",
          "frequency",
          "sample_count"
        ],
        "title": "ClassBaselineEntry",
        "type": "object"
      },
      "ClassBaselineResponse": {
        "description": "Response for camera class frequency baseline endpoint.",
        "example": {
          "camera_id": "front_door",
          "entries": [
            {
              "frequency": 3.5,
              "hour": 17,
              "object_class": "person",
              "sample_count": 45
            },
            {
              "frequency": 2.1,
              "hour": 8,
              "object_class": "vehicle",
              "sample_count": 30
            }
          ],
          "most_common_class": "person",
          "total_samples": 150,
          "unique_classes": [
            "person",
            "vehicle",
            "animal"
          ]
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "entries": {
            "description": "Class baseline entries grouped by class and hour",
            "items": {
              "$ref": "#/components/schemas/ClassBaselineEntry"
            },
            "title": "Entries",
            "type": "array"
          },
          "most_common_class": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Most frequently detected object class",
            "title": "Most Common Class"
          },
          "total_samples": {
            "description": "Total number of samples across all entries",
            "minimum": 0.0,
            "title": "Total Samples",
            "type": "integer"
          },
          "unique_classes": {
            "description": "List of unique object classes detected for this camera",
            "items": {
              "type": "string"
            },
            "title": "Unique Classes",
            "type": "array"
          }
        },
        "required": [
          "camera_id",
          "total_samples"
        ],
        "title": "ClassBaselineResponse",
        "type": "object"
      },
      "CleanupResponse": {
        "description": "Response schema for data cleanup endpoint.\n\nReturns statistics about the cleanup operation including counts of\ndeleted records and files. When dry_run is True, the counts represent\nwhat would be deleted without actually deleting.",
        "example": {
          "detections_deleted": 89,
          "dry_run": false,
          "events_deleted": 15,
          "gpu_stats_deleted": 2880,
          "images_deleted": 0,
          "logs_deleted": 150,
          "retention_days": 30,
          "space_reclaimed": 524288000,
          "thumbnails_deleted": 89,
          "timestamp": "2025-12-27T10:30:00Z"
        },
        "properties": {
          "detections_deleted": {
            "description": "Number of detections deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Detections Deleted",
            "type": "integer"
          },
          "dry_run": {
            "default": false,
            "description": "Whether this was a dry run (no actual deletion performed)",
            "title": "Dry Run",
            "type": "boolean"
          },
          "events_deleted": {
            "description": "Number of events deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Events Deleted",
            "type": "integer"
          },
          "gpu_stats_deleted": {
            "description": "Number of GPU stat records deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Gpu Stats Deleted",
            "type": "integer"
          },
          "images_deleted": {
            "description": "Number of original image files deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Images Deleted",
            "type": "integer"
          },
          "logs_deleted": {
            "description": "Number of log records deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Logs Deleted",
            "type": "integer"
          },
          "retention_days": {
            "description": "Retention period used for cleanup",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Retention Days",
            "type": "integer"
          },
          "space_reclaimed": {
            "description": "Estimated disk space freed in bytes (or would be freed in dry run)",
            "minimum": 0.0,
            "title": "Space Reclaimed",
            "type": "integer"
          },
          "thumbnails_deleted": {
            "description": "Number of thumbnail files deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Thumbnails Deleted",
            "type": "integer"
          },
          "timestamp": {
            "description": "Timestamp of cleanup operation",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "events_deleted",
          "detections_deleted",
          "gpu_stats_deleted",
          "logs_deleted",
          "thumbnails_deleted",
          "images_deleted",
          "space_reclaimed",
          "retention_days",
          "timestamp"
        ],
        "title": "CleanupResponse",
        "type": "object"
      },
      "CleanupStatusResponse": {
        "description": "Response schema for cleanup service status endpoint.",
        "example": {
          "cleanup_time": "03:00",
          "delete_images": false,
          "next_cleanup": "2025-12-31T03:00:00Z",
          "retention_days": 30,
          "running": true,
          "timestamp": "2025-12-30T10:30:00Z"
        },
        "properties": {
          "cleanup_time": {
            "description": "Scheduled daily cleanup time in HH:MM format",
            "title": "Cleanup Time",
            "type": "string"
          },
          "delete_images": {
            "description": "Whether original images are deleted during cleanup",
            "title": "Delete Images",
            "type": "boolean"
          },
          "next_cleanup": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ISO timestamp of next scheduled cleanup (null if not running)",
            "title": "Next Cleanup"
          },
          "retention_days": {
            "description": "Current retention period in days",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Retention Days",
            "type": "integer"
          },
          "running": {
            "description": "Whether the cleanup service is currently running",
            "title": "Running",
            "type": "boolean"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "running",
          "retention_days",
          "cleanup_time",
          "delete_images",
          "timestamp"
        ],
        "title": "CleanupStatusResponse",
        "type": "object"
      },
      "ClearDataRequest": {
        "description": "Request schema for clearing data - requires confirmation.",
        "properties": {
          "confirm": {
            "description": "Must be exactly 'DELETE_ALL_DATA' to confirm deletion",
            "title": "Confirm",
            "type": "string"
          }
        },
        "required": [
          "confirm"
        ],
        "title": "ClearDataRequest",
        "type": "object"
      },
      "ClearDataResponse": {
        "description": "Response schema for clear data endpoint.",
        "properties": {
          "cameras_cleared": {
            "title": "Cameras Cleared",
            "type": "integer"
          },
          "detections_cleared": {
            "title": "Detections Cleared",
            "type": "integer"
          },
          "events_cleared": {
            "title": "Events Cleared",
            "type": "integer"
          }
        },
        "required": [
          "cameras_cleared",
          "events_cleared",
          "detections_cleared"
        ],
        "title": "ClearDataResponse",
        "type": "object"
      },
      "ClipGenerateRequest": {
        "description": "Schema for clip generation request (POST /api/events/{event_id}/clip/generate).\n\nOffset validation (NEM-1355):\n- start_offset_seconds: -30 to 3600 seconds\n- end_offset_seconds: -30 to 3600 seconds\n- end_offset_seconds must be >= start_offset_seconds",
        "example": {
          "end_offset_seconds": 30,
          "force": false,
          "start_offset_seconds": -15
        },
        "properties": {
          "end_offset_seconds": {
            "default": 30,
            "description": "Seconds relative to event start to end clip (range: -30 to 3600, must be >= start_offset_seconds)",
            "maximum": 3600.0,
            "minimum": -30.0,
            "title": "End Offset Seconds",
            "type": "integer"
          },
          "force": {
            "default": false,
            "description": "Force regeneration even if clip already exists",
            "title": "Force",
            "type": "boolean"
          },
          "start_offset_seconds": {
            "default": -15,
            "description": "Seconds relative to event start to begin clip (negative = before event, range: -30 to 3600)",
            "maximum": 3600.0,
            "minimum": -30.0,
            "title": "Start Offset Seconds",
            "type": "integer"
          }
        },
        "title": "ClipGenerateRequest",
        "type": "object"
      },
      "ClipGenerateResponse": {
        "description": "Schema for clip generation response.",
        "example": {
          "clip_url": "/api/media/clips/123_clip.mp4",
          "event_id": 123,
          "generated_at": "2026-01-03T10:30:00Z",
          "message": "Clip generated successfully",
          "status": "completed"
        },
        "properties": {
          "clip_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to access the clip (if completed)",
            "title": "Clip Url"
          },
          "event_id": {
            "description": "Event ID",
            "title": "Event Id",
            "type": "integer"
          },
          "generated_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when the clip was generated",
            "title": "Generated At"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status message or error details",
            "title": "Message"
          },
          "status": {
            "$ref": "#/components/schemas/ClipStatus",
            "description": "Status of clip generation"
          }
        },
        "required": [
          "event_id",
          "status"
        ],
        "title": "ClipGenerateResponse",
        "type": "object"
      },
      "ClipInfoResponse": {
        "description": "Schema for clip info response (GET /api/events/{event_id}/clip).",
        "example": {
          "clip_available": true,
          "clip_url": "/api/media/clips/123_clip.mp4",
          "duration_seconds": 30,
          "event_id": 123,
          "file_size_bytes": 5242880,
          "generated_at": "2026-01-03T10:30:00Z"
        },
        "properties": {
          "clip_available": {
            "description": "Whether a clip is available for this event",
            "title": "Clip Available",
            "type": "boolean"
          },
          "clip_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to access the clip (if available)",
            "title": "Clip Url"
          },
          "duration_seconds": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Duration of the clip in seconds",
            "title": "Duration Seconds"
          },
          "event_id": {
            "description": "Event ID",
            "title": "Event Id",
            "type": "integer"
          },
          "file_size_bytes": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "File size of the clip in bytes",
            "title": "File Size Bytes"
          },
          "generated_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when the clip was generated",
            "title": "Generated At"
          }
        },
        "required": [
          "event_id",
          "clip_available"
        ],
        "title": "ClipInfoResponse",
        "type": "object"
      },
      "ClipStatus": {
        "description": "Status of clip generation.",
        "enum": [
          "pending",
          "completed",
          "failed"
        ],
        "title": "ClipStatus",
        "type": "string"
      },
      "ClothingEnrichment": {
        "description": "Clothing classification and segmentation results.",
        "example": {
          "has_bag": true,
          "has_face_covered": false,
          "is_service_uniform": false,
          "is_suspicious": false,
          "lower": "blue jeans",
          "upper": "red t-shirt"
        },
        "properties": {
          "clothing_items": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of detected clothing items",
            "title": "Clothing Items"
          },
          "has_bag": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether person is carrying a bag",
            "title": "Has Bag"
          },
          "has_face_covered": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether face is covered (hat/sunglasses/mask)",
            "title": "Has Face Covered"
          },
          "is_service_uniform": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether wearing service uniform",
            "title": "Is Service Uniform"
          },
          "is_suspicious": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether clothing is flagged as suspicious",
            "title": "Is Suspicious"
          },
          "lower": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Lower body clothing description",
            "title": "Lower"
          },
          "upper": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Upper body clothing description",
            "title": "Upper"
          }
        },
        "title": "ClothingEnrichment",
        "type": "object"
      },
      "ConfigResponse": {
        "description": "Response schema for configuration endpoint.\n\nOnly includes public, non-sensitive configuration values.",
        "example": {
          "app_name": "Home Security Intelligence",
          "batch_idle_timeout_seconds": 30,
          "batch_window_seconds": 90,
          "detection_confidence_threshold": 0.5,
          "grafana_url": "http://localhost:3002",
          "retention_days": 30,
          "version": "0.1.0"
        },
        "properties": {
          "app_name": {
            "description": "Application name",
            "title": "App Name",
            "type": "string"
          },
          "batch_idle_timeout_seconds": {
            "description": "Idle timeout before processing incomplete batch",
            "minimum": 1.0,
            "title": "Batch Idle Timeout Seconds",
            "type": "integer"
          },
          "batch_window_seconds": {
            "description": "Time window for batch processing detections",
            "minimum": 1.0,
            "title": "Batch Window Seconds",
            "type": "integer"
          },
          "detection_confidence_threshold": {
            "description": "Minimum confidence threshold for detections (0.0-1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Detection Confidence Threshold",
            "type": "number"
          },
          "grafana_url": {
            "description": "Grafana dashboard URL for frontend link",
            "title": "Grafana Url",
            "type": "string"
          },
          "retention_days": {
            "description": "Number of days to retain events and detections",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Retention Days",
            "type": "integer"
          },
          "version": {
            "description": "Application version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "app_name",
          "version",
          "retention_days",
          "batch_window_seconds",
          "batch_idle_timeout_seconds",
          "detection_confidence_threshold",
          "grafana_url"
        ],
        "title": "ConfigResponse",
        "type": "object"
      },
      "ConfigUpdateRequest": {
        "description": "Request schema for PATCH /api/system/config.\n\nOnly supports a subset of processing-related settings.",
        "properties": {
          "batch_idle_timeout_seconds": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Idle timeout before processing incomplete batch",
            "title": "Batch Idle Timeout Seconds"
          },
          "batch_window_seconds": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time window for batch processing detections",
            "title": "Batch Window Seconds"
          },
          "detection_confidence_threshold": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum confidence threshold for detections (0.0-1.0)",
            "title": "Detection Confidence Threshold"
          },
          "retention_days": {
            "anyOf": [
              {
                "maximum": 365.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of days to retain events and detections",
            "title": "Retention Days"
          }
        },
        "title": "ConfigUpdateRequest",
        "type": "object"
      },
      "ContainerServiceStatus": {
        "description": "Current status of a managed container service.\n\nStatus values:\n- RUNNING: Container is up and passing health checks\n- STARTING: Container is starting, not yet healthy\n- UNHEALTHY: Running but failing health checks\n- STOPPED: Container is not running\n- DISABLED: Exceeded failure limit, requires manual reset\n- NOT_FOUND: Container doesn't exist yet",
        "enum": [
          "running",
          "starting",
          "unhealthy",
          "stopped",
          "disabled",
          "not_found"
        ],
        "title": "ContainerServiceStatus",
        "type": "string"
      },
      "CurrentDeviation": {
        "description": "Current activity deviation from established baseline.",
        "example": {
          "contributing_factors": [
            "person_count_elevated",
            "unusual_hour"
          ],
          "interpretation": "slightly_above_normal",
          "score": 1.8
        },
        "properties": {
          "contributing_factors": {
            "description": "Factors contributing to current deviation",
            "items": {
              "type": "string"
            },
            "title": "Contributing Factors",
            "type": "array"
          },
          "interpretation": {
            "$ref": "#/components/schemas/DeviationInterpretation",
            "description": "Human-readable interpretation of the deviation"
          },
          "score": {
            "description": "Deviation score (standard deviations from mean, can be negative)",
            "title": "Score",
            "type": "number"
          }
        },
        "required": [
          "score",
          "interpretation"
        ],
        "title": "CurrentDeviation",
        "type": "object"
      },
      "CustomTestPromptRequest": {
        "description": "Request to test a custom prompt against an existing event.\n\nThis is used for A/B testing in the Prompt Playground - testing a\nmodified prompt without persisting results to the database.",
        "example": {
          "custom_prompt": "You are a home security AI with enhanced context...",
          "event_id": 12345,
          "max_tokens": 2048,
          "model": "nemotron",
          "temperature": 0.7
        },
        "properties": {
          "custom_prompt": {
            "description": "Custom prompt text to test",
            "minLength": 1,
            "title": "Custom Prompt",
            "type": "string"
          },
          "event_id": {
            "description": "Event ID to test the prompt against",
            "minimum": 1.0,
            "title": "Event Id",
            "type": "integer"
          },
          "max_tokens": {
            "default": 2048,
            "description": "Maximum tokens in response",
            "maximum": 8192.0,
            "minimum": 100.0,
            "title": "Max Tokens",
            "type": "integer"
          },
          "model": {
            "default": "nemotron",
            "description": "Model name to use for testing",
            "title": "Model",
            "type": "string"
          },
          "temperature": {
            "default": 0.7,
            "description": "LLM temperature setting",
            "maximum": 2.0,
            "minimum": 0.0,
            "title": "Temperature",
            "type": "number"
          }
        },
        "required": [
          "event_id",
          "custom_prompt"
        ],
        "title": "CustomTestPromptRequest",
        "type": "object"
      },
      "CustomTestPromptResponse": {
        "description": "Response from testing a custom prompt against an event.\n\nResults are NOT persisted - this is for A/B testing only.",
        "example": {
          "entities": [
            {
              "confidence": 0.95,
              "type": "person"
            }
          ],
          "flags": [],
          "processing_time_ms": 1250,
          "reasoning": "The detected person matches the expected delivery pattern based on time and approach direction.",
          "recommended_action": "No action required",
          "risk_level": "low",
          "risk_score": 45,
          "summary": "Delivery person detected at front door during expected hours",
          "tokens_used": 512
        },
        "properties": {
          "entities": {
            "description": "Detected entities in the analysis",
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "title": "Entities",
            "type": "array"
          },
          "flags": {
            "description": "Risk flags identified in the analysis",
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "title": "Flags",
            "type": "array"
          },
          "processing_time_ms": {
            "description": "Time taken for inference in milliseconds",
            "minimum": 0.0,
            "title": "Processing Time Ms",
            "type": "integer"
          },
          "reasoning": {
            "description": "LLM reasoning for the risk assessment",
            "title": "Reasoning",
            "type": "string"
          },
          "recommended_action": {
            "default": "",
            "description": "Recommended action based on risk analysis",
            "title": "Recommended Action",
            "type": "string"
          },
          "risk_level": {
            "description": "Risk level: low, medium, high, or critical",
            "title": "Risk Level",
            "type": "string"
          },
          "risk_score": {
            "description": "Computed risk score (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Risk Score",
            "type": "integer"
          },
          "summary": {
            "description": "Brief summary of the event analysis",
            "title": "Summary",
            "type": "string"
          },
          "tokens_used": {
            "description": "Number of tokens used in inference",
            "minimum": 0.0,
            "title": "Tokens Used",
            "type": "integer"
          }
        },
        "required": [
          "risk_score",
          "risk_level",
          "reasoning",
          "summary",
          "processing_time_ms",
          "tokens_used"
        ],
        "title": "CustomTestPromptResponse",
        "type": "object"
      },
      "DLQClearResponse": {
        "description": "Response schema for clearing a DLQ.",
        "example": {
          "message": "Cleared 5 jobs from dlq:detection_queue",
          "queue_name": "dlq:detection_queue",
          "success": true
        },
        "properties": {
          "message": {
            "description": "Status message",
            "title": "Message",
            "type": "string"
          },
          "queue_name": {
            "description": "Name of the cleared queue",
            "title": "Queue Name",
            "type": "string"
          },
          "success": {
            "description": "Whether the clear operation succeeded",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success",
          "message",
          "queue_name"
        ],
        "title": "DLQClearResponse",
        "type": "object"
      },
      "DLQJobResponse": {
        "description": "Response schema for a single job in the dead-letter queue.\n\nIncludes enriched error context (NEM-1474) for faster debugging:\n- error_type: Exception class name for categorization\n- stack_trace: Truncated stack trace for debugging\n- http_status: HTTP status code (for network errors)\n- response_body: Truncated AI service response (for debugging)\n- retry_delays: Delays applied between retry attempts\n- context: System state snapshot at failure time",
        "example": {
          "attempt_count": 3,
          "context": {
            "analysis_queue_depth": 25,
            "detection_queue_depth": 150,
            "dlq_circuit_breaker_state": "closed"
          },
          "error": "Connection refused: detector service unavailable",
          "error_type": "ConnectionRefusedError",
          "first_failed_at": "2025-12-23T10:30:05.000000",
          "last_failed_at": "2025-12-23T10:30:15.000000",
          "original_job": {
            "camera_id": "front_door",
            "file_path": "/export/foscam/front_door/image_001.jpg",
            "timestamp": "2025-12-23T10:30:00.000000"
          },
          "queue_name": "detection_queue",
          "retry_delays": [
            1.0,
            2.0
          ],
          "stack_trace": "Traceback (most recent call last):\n  ..."
        },
        "properties": {
          "attempt_count": {
            "description": "Number of processing attempts made",
            "minimum": 1.0,
            "title": "Attempt Count",
            "type": "integer"
          },
          "context": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "System state snapshot at failure time (queue depths, circuit breaker states)",
            "title": "Context"
          },
          "error": {
            "description": "Error message from the last failure attempt",
            "title": "Error",
            "type": "string"
          },
          "error_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Exception class name (e.g., 'ConnectionRefusedError')",
            "title": "Error Type"
          },
          "first_failed_at": {
            "description": "ISO timestamp of the first failure",
            "title": "First Failed At",
            "type": "string"
          },
          "http_status": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "HTTP status code if the error was from a network request",
            "title": "Http Status"
          },
          "last_failed_at": {
            "description": "ISO timestamp of the last failure",
            "title": "Last Failed At",
            "type": "string"
          },
          "original_job": {
            "additionalProperties": true,
            "description": "Original job payload that failed",
            "title": "Original Job",
            "type": "object"
          },
          "queue_name": {
            "description": "Name of the original queue where the job came from",
            "title": "Queue Name",
            "type": "string"
          },
          "response_body": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Truncated response body (max 2KB) from AI service",
            "title": "Response Body"
          },
          "retry_delays": {
            "anyOf": [
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Delays (in seconds) applied between retry attempts",
            "title": "Retry Delays"
          },
          "stack_trace": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Truncated stack trace (max 4KB) for debugging",
            "title": "Stack Trace"
          }
        },
        "required": [
          "original_job",
          "error",
          "attempt_count",
          "first_failed_at",
          "last_failed_at",
          "queue_name"
        ],
        "title": "DLQJobResponse",
        "type": "object"
      },
      "DLQJobsResponse": {
        "description": "Response schema for listing jobs in a DLQ.\n\nUses standard pagination envelope format (NEM-2178):\n- items: List of DLQ jobs (renamed from 'jobs')\n- pagination: Standard pagination metadata\n- queue_name: Name of the dead-letter queue",
        "example": {
          "items": [
            {
              "attempt_count": 3,
              "error": "Connection refused",
              "first_failed_at": "2025-12-23T10:30:05.000000",
              "last_failed_at": "2025-12-23T10:30:15.000000",
              "original_job": {
                "camera_id": "front_door",
                "file_path": "/export/foscam/front_door/image_001.jpg",
                "timestamp": "2025-12-23T10:30:00.000000"
              },
              "queue_name": "detection_queue"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 100,
            "offset": 0,
            "total": 1
          },
          "queue_name": "dlq:detection_queue"
        },
        "properties": {
          "items": {
            "description": "List of jobs in the queue",
            "items": {
              "$ref": "#/components/schemas/DLQJobResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          },
          "queue_name": {
            "description": "Name of the dead-letter queue",
            "title": "Queue Name",
            "type": "string"
          }
        },
        "required": [
          "queue_name",
          "items",
          "pagination"
        ],
        "title": "DLQJobsResponse",
        "type": "object"
      },
      "DLQName": {
        "description": "Available dead-letter queue names.",
        "enum": [
          "dlq:detection_queue",
          "dlq:analysis_queue"
        ],
        "title": "DLQName",
        "type": "string"
      },
      "DLQRequeueResponse": {
        "description": "Response schema for requeuing a job from DLQ.",
        "example": {
          "job": {
            "camera_id": "front_door",
            "file_path": "/export/foscam/front_door/image_001.jpg",
            "timestamp": "2025-12-23T10:30:00.000000"
          },
          "message": "Job requeued from dlq:detection_queue to detection_queue",
          "success": true
        },
        "properties": {
          "job": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "The requeued job data (if successful)",
            "title": "Job"
          },
          "message": {
            "description": "Status message",
            "title": "Message",
            "type": "string"
          },
          "success": {
            "description": "Whether the requeue operation succeeded",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success",
          "message"
        ],
        "title": "DLQRequeueResponse",
        "type": "object"
      },
      "DLQStatsResponse": {
        "description": "Response schema for DLQ statistics.",
        "example": {
          "analysis_queue_count": 1,
          "detection_queue_count": 2,
          "total_count": 3
        },
        "properties": {
          "analysis_queue_count": {
            "description": "Number of jobs in the analysis DLQ",
            "minimum": 0.0,
            "title": "Analysis Queue Count",
            "type": "integer"
          },
          "detection_queue_count": {
            "description": "Number of jobs in the detection DLQ",
            "minimum": 0.0,
            "title": "Detection Queue Count",
            "type": "integer"
          },
          "total_count": {
            "description": "Total number of jobs across all DLQs",
            "minimum": 0.0,
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "detection_queue_count",
          "analysis_queue_count",
          "total_count"
        ],
        "title": "DLQStatsResponse",
        "type": "object"
      },
      "DailyPattern": {
        "description": "Activity pattern for a specific day of the week.",
        "example": {
          "avg_detections": 45.0,
          "peak_hour": 17,
          "total_samples": 168
        },
        "properties": {
          "avg_detections": {
            "description": "Average number of detections for this day",
            "minimum": 0.0,
            "title": "Avg Detections",
            "type": "number"
          },
          "peak_hour": {
            "description": "Hour with most activity (0-23)",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Peak Hour",
            "type": "integer"
          },
          "total_samples": {
            "description": "Total samples for this day",
            "minimum": 0.0,
            "title": "Total Samples",
            "type": "integer"
          }
        },
        "required": [
          "avg_detections",
          "peak_hour",
          "total_samples"
        ],
        "title": "DailyPattern",
        "type": "object"
      },
      "DebugCircuitBreakersResponse": {
        "description": "Response for circuit breaker states.",
        "properties": {
          "circuit_breakers": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "description": "All circuit breaker states keyed by name",
            "title": "Circuit Breakers",
            "type": "object"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "circuit_breakers",
          "timestamp"
        ],
        "title": "DebugCircuitBreakersResponse",
        "type": "object"
      },
      "DebugConfigResponse": {
        "description": "Response for configuration inspection.",
        "properties": {
          "config": {
            "additionalProperties": true,
            "description": "Current configuration with sensitive values redacted",
            "title": "Config",
            "type": "object"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "config",
          "timestamp"
        ],
        "title": "DebugConfigResponse",
        "type": "object"
      },
      "DebugWebSocketBroadcasterStatus": {
        "description": "Status of a WebSocket broadcaster.",
        "properties": {
          "channel_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Redis channel being listened to",
            "title": "Channel Name"
          },
          "circuit_state": {
            "description": "Circuit breaker state (CLOSED, OPEN, HALF_OPEN)",
            "title": "Circuit State",
            "type": "string"
          },
          "connection_count": {
            "description": "Number of active connections",
            "title": "Connection Count",
            "type": "integer"
          },
          "is_degraded": {
            "description": "Whether the broadcaster is in degraded mode",
            "title": "Is Degraded",
            "type": "boolean"
          },
          "is_listening": {
            "description": "Whether the broadcaster is listening for events",
            "title": "Is Listening",
            "type": "boolean"
          }
        },
        "required": [
          "connection_count",
          "is_listening",
          "is_degraded",
          "circuit_state"
        ],
        "title": "DebugWebSocketBroadcasterStatus",
        "type": "object"
      },
      "DegradationModeEnum": {
        "description": "System degradation modes.",
        "enum": [
          "normal",
          "degraded",
          "minimal",
          "offline"
        ],
        "title": "DegradationModeEnum",
        "type": "string"
      },
      "DegradationStatusResponse": {
        "description": "Status information for the DegradationManager service.",
        "example": {
          "available_features": [
            "detection",
            "analysis",
            "events",
            "media"
          ],
          "fallback_queues": {},
          "is_degraded": false,
          "memory_queue_size": 0,
          "mode": "normal",
          "redis_healthy": true,
          "services": [
            {
              "consecutive_failures": 0,
              "last_check": 1735500000.0,
              "name": "rtdetr",
              "status": "healthy"
            }
          ]
        },
        "properties": {
          "available_features": {
            "description": "Features available in current degradation mode",
            "items": {
              "type": "string"
            },
            "title": "Available Features",
            "type": "array"
          },
          "fallback_queues": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of items in disk-based fallback queues by name",
            "title": "Fallback Queues",
            "type": "object"
          },
          "is_degraded": {
            "description": "Whether system is in any degraded state",
            "title": "Is Degraded",
            "type": "boolean"
          },
          "memory_queue_size": {
            "description": "Number of jobs in in-memory fallback queue",
            "minimum": 0.0,
            "title": "Memory Queue Size",
            "type": "integer"
          },
          "mode": {
            "$ref": "#/components/schemas/DegradationModeEnum",
            "description": "Current degradation mode"
          },
          "redis_healthy": {
            "description": "Whether Redis is healthy",
            "title": "Redis Healthy",
            "type": "boolean"
          },
          "services": {
            "description": "Health status of registered services",
            "items": {
              "$ref": "#/components/schemas/ServiceHealthStatusResponse"
            },
            "title": "Services",
            "type": "array"
          }
        },
        "required": [
          "mode",
          "is_degraded",
          "redis_healthy",
          "memory_queue_size"
        ],
        "title": "DegradationStatusResponse",
        "type": "object"
      },
      "DeletedCamerasListResponse": {
        "description": "Schema for listing soft-deleted cameras (trash view).\n\nNEM-1955: Provides a trash view of soft-deleted cameras that can be restored.\nCameras are ordered by deleted_at descending (most recently deleted first).\nNEM-2075: Standardized pagination envelope with items + pagination structure.",
        "example": {
          "items": [
            {
              "created_at": "2025-12-23T10:00:00Z",
              "folder_path": "/export/foscam/front_door",
              "id": "front_door",
              "last_seen_at": "2025-12-23T12:00:00Z",
              "name": "Front Door Camera",
              "status": "offline"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of soft-deleted cameras",
            "items": {
              "$ref": "#/components/schemas/CameraResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "DeletedCamerasListResponse",
        "type": "object"
      },
      "DeletedEventsListResponse": {
        "description": "Schema for listing soft-deleted events (trash view).\n\nNEM-1955: Provides a trash view of soft-deleted events that can be restored.\nEvents are ordered by deleted_at descending (most recently deleted first).\nNEM-2075: Standardized pagination envelope with items + pagination structure.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "detection_count": 5,
              "detection_ids": [
                1,
                2,
                3,
                4,
                5
              ],
              "ended_at": "2025-12-23T12:02:30Z",
              "id": 1,
              "reasoning": "Analysis details",
              "reviewed": false,
              "risk_level": "medium",
              "risk_score": 75,
              "started_at": "2025-12-23T12:00:00Z",
              "summary": "Person detected near front entrance",
              "thumbnail_url": "/api/media/detections/1"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of soft-deleted events",
            "items": {
              "$ref": "#/components/schemas/EventResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "DeletedEventsListResponse",
        "type": "object"
      },
      "DepthEnrichment": {
        "description": "Depth estimation results (placeholder for future Depth Anything V2).",
        "example": {
          "confidence": 0.78,
          "estimated_distance_m": 4.2
        },
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimation confidence",
            "title": "Confidence"
          },
          "estimated_distance_m": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimated distance in meters",
            "title": "Estimated Distance M"
          }
        },
        "title": "DepthEnrichment",
        "type": "object"
      },
      "DetectionBulkCreateItem": {
        "description": "Schema for a single detection in a bulk create request.\n\nAttributes:\n    camera_id: Camera ID that captured this detection\n    object_type: Type of detected object (person, vehicle, etc.)\n    confidence: Detection confidence score (0.0-1.0)\n    detected_at: Detection timestamp\n    file_path: Path to the detection image\n    bbox_x: Bounding box X coordinate\n    bbox_y: Bounding box Y coordinate\n    bbox_width: Bounding box width\n    bbox_height: Bounding box height\n    enrichment_data: Optional enrichment pipeline results",
        "properties": {
          "bbox_height": {
            "description": "Bounding box height",
            "exclusiveMinimum": 0.0,
            "title": "Bbox Height",
            "type": "integer"
          },
          "bbox_width": {
            "description": "Bounding box width",
            "exclusiveMinimum": 0.0,
            "title": "Bbox Width",
            "type": "integer"
          },
          "bbox_x": {
            "description": "Bounding box X coordinate",
            "minimum": 0.0,
            "title": "Bbox X",
            "type": "integer"
          },
          "bbox_y": {
            "description": "Bounding box Y coordinate",
            "minimum": 0.0,
            "title": "Bbox Y",
            "type": "integer"
          },
          "camera_id": {
            "description": "Camera ID",
            "maxLength": 255,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_-]+$",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence": {
            "description": "Confidence score (0.0-1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Confidence",
            "type": "number"
          },
          "detected_at": {
            "description": "Detection timestamp",
            "format": "date-time",
            "title": "Detected At",
            "type": "string"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enrichment pipeline results",
            "title": "Enrichment Data"
          },
          "file_path": {
            "description": "Image file path",
            "maxLength": 1000,
            "minLength": 1,
            "title": "File Path",
            "type": "string"
          },
          "object_type": {
            "description": "Object type (person, vehicle, etc.)",
            "maxLength": 100,
            "minLength": 1,
            "title": "Object Type",
            "type": "string"
          }
        },
        "required": [
          "camera_id",
          "object_type",
          "confidence",
          "detected_at",
          "file_path",
          "bbox_x",
          "bbox_y",
          "bbox_width",
          "bbox_height"
        ],
        "title": "DetectionBulkCreateItem",
        "type": "object"
      },
      "DetectionBulkCreateRequest": {
        "description": "Request schema for bulk detection creation.\n\nAttributes:\n    detections: List of detections to create (max 100 per request)",
        "properties": {
          "detections": {
            "description": "Detections to create (max 100)",
            "items": {
              "$ref": "#/components/schemas/DetectionBulkCreateItem"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Detections",
            "type": "array"
          }
        },
        "required": [
          "detections"
        ],
        "title": "DetectionBulkCreateRequest",
        "type": "object"
      },
      "DetectionBulkCreateResponse": {
        "description": "Response schema for bulk detection creation.\n\nExtends BulkOperationResponse with created detection IDs.",
        "properties": {
          "failed": {
            "description": "Number of failed operations",
            "minimum": 0.0,
            "title": "Failed",
            "type": "integer"
          },
          "results": {
            "description": "Per-item results",
            "items": {
              "$ref": "#/components/schemas/BulkItemResult"
            },
            "title": "Results",
            "type": "array"
          },
          "skipped": {
            "default": 0,
            "description": "Number of skipped operations",
            "minimum": 0.0,
            "title": "Skipped",
            "type": "integer"
          },
          "succeeded": {
            "description": "Number of successful operations",
            "minimum": 0.0,
            "title": "Succeeded",
            "type": "integer"
          },
          "total": {
            "description": "Total number of items in the request",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "succeeded",
          "failed"
        ],
        "title": "DetectionBulkCreateResponse",
        "type": "object"
      },
      "DetectionBulkDeleteRequest": {
        "description": "Request schema for bulk detection deletion.\n\nNote: Detection deletion is always hard delete as detections\nare raw data and soft-delete is not supported.\n\nAttributes:\n    detection_ids: List of detection IDs to delete (max 100 per request)",
        "properties": {
          "detection_ids": {
            "description": "Detection IDs to delete (max 100)",
            "items": {
              "type": "integer"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Detection Ids",
            "type": "array"
          }
        },
        "required": [
          "detection_ids"
        ],
        "title": "DetectionBulkDeleteRequest",
        "type": "object"
      },
      "DetectionBulkUpdateItem": {
        "description": "Schema for a single detection update in a bulk update request.\n\nAttributes:\n    id: Detection ID to update\n    object_type: Updated object type\n    confidence: Updated confidence score\n    enrichment_data: Updated enrichment data",
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Confidence score",
            "title": "Confidence"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enrichment pipeline results",
            "title": "Enrichment Data"
          },
          "id": {
            "description": "Detection ID to update",
            "exclusiveMinimum": 0.0,
            "title": "Id",
            "type": "integer"
          },
          "object_type": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object type",
            "title": "Object Type"
          }
        },
        "required": [
          "id"
        ],
        "title": "DetectionBulkUpdateItem",
        "type": "object"
      },
      "DetectionBulkUpdateRequest": {
        "description": "Request schema for bulk detection updates.\n\nAttributes:\n    detections: List of detection updates (max 100 per request)",
        "properties": {
          "detections": {
            "description": "Detection updates (max 100)",
            "items": {
              "$ref": "#/components/schemas/DetectionBulkUpdateItem"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Detections",
            "type": "array"
          }
        },
        "required": [
          "detections"
        ],
        "title": "DetectionBulkUpdateRequest",
        "type": "object"
      },
      "DetectionLabelCount": {
        "description": "Schema for a label with count.",
        "properties": {
          "count": {
            "title": "Count",
            "type": "integer"
          },
          "label": {
            "title": "Label",
            "type": "string"
          }
        },
        "required": [
          "label",
          "count"
        ],
        "title": "DetectionLabelCount",
        "type": "object"
      },
      "DetectionLabelsResponse": {
        "description": "Schema for detection labels response.",
        "properties": {
          "labels": {
            "items": {
              "$ref": "#/components/schemas/DetectionLabelCount"
            },
            "title": "Labels",
            "type": "array"
          }
        },
        "required": [
          "labels"
        ],
        "title": "DetectionLabelsResponse",
        "type": "object"
      },
      "DetectionListResponse": {
        "description": "Schema for detection list response with standardized pagination envelope.\n\nUses the standard pagination envelope: {\"items\": [...], \"pagination\": {...}}\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).",
        "example": {
          "items": [
            {
              "bbox_height": 400,
              "bbox_width": 200,
              "bbox_x": 100,
              "bbox_y": 150,
              "camera_id": "front_door",
              "confidence": 0.95,
              "detected_at": "2025-12-23T12:00:00Z",
              "file_path": "/export/foscam/front_door/20251223_120000.jpg",
              "file_type": "image/jpeg",
              "id": 1,
              "object_type": "person",
              "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=",
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Warning message when using deprecated offset pagination",
            "title": "Deprecation Warning"
          },
          "items": {
            "description": "List of detections",
            "items": {
              "$ref": "#/components/schemas/DetectionResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "DetectionListResponse",
        "type": "object"
      },
      "DetectionResponse": {
        "description": "Schema for detection response.",
        "example": {
          "bbox_height": 400,
          "bbox_width": 200,
          "bbox_x": 100,
          "bbox_y": 150,
          "camera_id": "front_door",
          "confidence": 0.95,
          "detected_at": "2025-12-23T12:00:00Z",
          "enrichment_data": {
            "errors": [],
            "person": {
              "action": "walking",
              "carrying": [
                "backpack"
              ],
              "clothing_description": "dark jacket",
              "is_suspicious": false
            },
            "vehicle": {
              "has_damage": false,
              "is_commercial": false,
              "vehicle_color": "blue",
              "vehicle_type": "sedan"
            },
            "weather": "sunny"
          },
          "file_path": "/export/foscam/front_door/20251223_120000.jpg",
          "file_type": "image/jpeg",
          "id": 1,
          "media_type": "image",
          "object_type": "person",
          "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
        },
        "properties": {
          "bbox_height": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box height",
            "title": "Bbox Height"
          },
          "bbox_width": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box width",
            "title": "Bbox Width"
          },
          "bbox_x": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box X coordinate",
            "title": "Bbox X"
          },
          "bbox_y": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box Y coordinate",
            "title": "Bbox Y"
          },
          "camera_id": {
            "description": "Normalized camera ID (e.g., 'front_door')",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detection confidence score (0-1)",
            "title": "Confidence"
          },
          "detected_at": {
            "description": "Timestamp when detection was made",
            "format": "date-time",
            "title": "Detected At",
            "type": "string"
          },
          "duration": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video duration in seconds (video only)",
            "title": "Duration"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "AI enrichment data including vehicle classification, pet identification, person attributes, license plates, weather, and image quality scores",
            "title": "Enrichment Data"
          },
          "file_path": {
            "description": "Path to source image or video file",
            "title": "File Path",
            "type": "string"
          },
          "file_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "MIME type of source file",
            "title": "File Type"
          },
          "id": {
            "description": "Detection ID",
            "title": "Id",
            "type": "integer"
          },
          "media_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "default": "image",
            "description": "Media type: 'image' or 'video'",
            "title": "Media Type"
          },
          "object_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Type of detected object (person, car, etc.)",
            "title": "Object Type"
          },
          "thumbnail_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to thumbnail image with bbox overlay",
            "title": "Thumbnail Path"
          },
          "video_codec": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video codec (e.g., h264, hevc)",
            "title": "Video Codec"
          },
          "video_height": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video resolution height",
            "title": "Video Height"
          },
          "video_width": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video resolution width",
            "title": "Video Width"
          }
        },
        "required": [
          "id",
          "camera_id",
          "file_path",
          "detected_at"
        ],
        "title": "DetectionResponse",
        "type": "object"
      },
      "DetectionSearchResponse": {
        "description": "Schema for detection search response.",
        "properties": {
          "limit": {
            "title": "Limit",
            "type": "integer"
          },
          "offset": {
            "title": "Offset",
            "type": "integer"
          },
          "results": {
            "description": "Search results",
            "items": {
              "$ref": "#/components/schemas/DetectionSearchResult"
            },
            "title": "Results",
            "type": "array"
          },
          "total_count": {
            "description": "Total matching detections",
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "results",
          "total_count",
          "limit",
          "offset"
        ],
        "title": "DetectionSearchResponse",
        "type": "object"
      },
      "DetectionSearchResult": {
        "description": "Schema for a single detection search result.",
        "properties": {
          "bbox_height": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox Height"
          },
          "bbox_width": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox Width"
          },
          "bbox_x": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox X"
          },
          "bbox_y": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox Y"
          },
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detection confidence score",
            "title": "Confidence"
          },
          "detected_at": {
            "description": "Detection timestamp",
            "format": "date-time",
            "title": "Detected At",
            "type": "string"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enrichment Data"
          },
          "file_path": {
            "description": "Path to source file",
            "title": "File Path",
            "type": "string"
          },
          "id": {
            "description": "Detection ID",
            "title": "Id",
            "type": "integer"
          },
          "labels": {
            "description": "Searchable labels",
            "items": {
              "type": "string"
            },
            "title": "Labels",
            "type": "array"
          },
          "object_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detected object type",
            "title": "Object Type"
          },
          "relevance_score": {
            "default": 0.0,
            "description": "Search relevance score",
            "title": "Relevance Score",
            "type": "number"
          },
          "thumbnail_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to thumbnail",
            "title": "Thumbnail Path"
          }
        },
        "required": [
          "id",
          "camera_id",
          "detected_at",
          "file_path"
        ],
        "title": "DetectionSearchResult",
        "type": "object"
      },
      "DetectionStatsResponse": {
        "description": "Schema for detection statistics response.\n\nReturns aggregate statistics about detections including counts by object class.\nUsed by the AI Performance page to display detection class distribution.",
        "example": {
          "average_confidence": 0.87,
          "detections_by_class": {
            "bicycle": 1,
            "car": 20,
            "person": 23,
            "truck": 6
          },
          "total_detections": 107
        },
        "properties": {
          "average_confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Average confidence score across all detections",
            "title": "Average Confidence"
          },
          "detections_by_class": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Detection counts grouped by object class (e.g., person, car, truck)",
            "title": "Detections By Class",
            "type": "object"
          },
          "total_detections": {
            "description": "Total number of detections",
            "title": "Total Detections",
            "type": "integer"
          }
        },
        "required": [
          "total_detections",
          "detections_by_class"
        ],
        "title": "DetectionStatsResponse",
        "type": "object"
      },
      "DetectionTrendDataPoint": {
        "description": "Schema for a single detection trend data point.",
        "example": {
          "count": 25,
          "date": "2025-01-07"
        },
        "properties": {
          "count": {
            "description": "Number of detections on this date",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "date": {
            "description": "Date of the data point",
            "format": "date",
            "title": "Date",
            "type": "string"
          }
        },
        "required": [
          "date",
          "count"
        ],
        "title": "DetectionTrendDataPoint",
        "type": "object"
      },
      "DetectionTrendsResponse": {
        "description": "Schema for detection trends aggregated by day.",
        "example": {
          "data_points": [
            {
              "count": 20,
              "date": "2025-01-01"
            },
            {
              "count": 25,
              "date": "2025-01-02"
            },
            {
              "count": 18,
              "date": "2025-01-03"
            }
          ],
          "end_date": "2025-01-03",
          "start_date": "2025-01-01",
          "total_detections": 63
        },
        "properties": {
          "data_points": {
            "description": "Detection counts aggregated by day",
            "items": {
              "$ref": "#/components/schemas/DetectionTrendDataPoint"
            },
            "title": "Data Points",
            "type": "array"
          },
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          },
          "total_detections": {
            "description": "Total detections in date range",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          }
        },
        "required": [
          "data_points",
          "total_detections",
          "start_date",
          "end_date"
        ],
        "title": "DetectionTrendsResponse",
        "type": "object"
      },
      "DeviationInterpretation": {
        "description": "Interpretation of current deviation from baseline.",
        "enum": [
          "far_below_normal",
          "below_normal",
          "normal",
          "slightly_above_normal",
          "above_normal",
          "far_above_normal"
        ],
        "title": "DeviationInterpretation",
        "type": "string"
      },
      "EnrichmentResponse": {
        "description": "Structured enrichment data for a single detection.\n\nContains results from all vision models run during the enrichment pipeline.",
        "example": {
          "clothing": {
            "lower": "blue jeans",
            "upper": "red t-shirt"
          },
          "detection_id": 12345,
          "enriched_at": "2026-01-03T10:30:00Z",
          "errors": [],
          "face": {
            "confidence": 0.88,
            "count": 1,
            "detected": true
          },
          "image_quality": {
            "is_blurry": false,
            "score": 0.85
          },
          "license_plate": {
            "confidence": 0.92,
            "detected": true,
            "text": "ABC-1234"
          },
          "processing_time_ms": 125.5,
          "vehicle": {
            "color": "silver",
            "confidence": 0.91,
            "type": "sedan"
          },
          "violence": {
            "detected": false,
            "score": 0.12
          },
          "weather": {
            "condition": "clear",
            "confidence": 0.95
          }
        },
        "properties": {
          "clothing": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ClothingEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Clothing analysis results",
            "title": "Clothing"
          },
          "depth": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DepthEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Depth estimation results",
            "title": "Depth"
          },
          "detection_id": {
            "description": "Detection ID",
            "title": "Detection Id",
            "type": "integer"
          },
          "enriched_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when enrichment was performed",
            "title": "Enriched At"
          },
          "errors": {
            "description": "Errors encountered during enrichment",
            "items": {
              "type": "string"
            },
            "title": "Errors",
            "type": "array"
          },
          "face": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FaceEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "description": "Face detection results",
            "title": "Face"
          },
          "image_quality": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ImageQualityEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Image quality assessment",
            "title": "Image Quality"
          },
          "license_plate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LicensePlateEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "description": "License plate detection results",
            "title": "License Plate"
          },
          "pet": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PetEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Pet classification results",
            "title": "Pet"
          },
          "pose": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PoseEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Pose estimation results",
            "title": "Pose"
          },
          "processing_time_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enrichment processing time in milliseconds",
            "title": "Processing Time Ms"
          },
          "vehicle": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VehicleEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Vehicle classification results",
            "title": "Vehicle"
          },
          "violence": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ViolenceEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "description": "Violence detection results",
            "title": "Violence"
          },
          "weather": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WeatherEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Weather classification results",
            "title": "Weather"
          }
        },
        "required": [
          "detection_id"
        ],
        "title": "EnrichmentResponse",
        "type": "object"
      },
      "EnrichmentStatusEnum": {
        "description": "Status of enrichment pipeline execution for an event.\n\nValues:\n    full: All enrichment models succeeded\n    partial: Some models succeeded, some failed\n    failed: All models failed (no enrichment data)\n    skipped: Enrichment was not attempted",
        "enum": [
          "full",
          "partial",
          "failed",
          "skipped"
        ],
        "title": "EnrichmentStatusEnum",
        "type": "string"
      },
      "EnrichmentStatusResponse": {
        "description": "Schema for enrichment status in event responses (NEM-1672).\n\nProvides visibility into which enrichment models succeeded/failed\nfor a given event, instead of silently degrading.",
        "example": {
          "errors": {
            "clothing": "Model not loaded"
          },
          "failed_models": [
            "clothing"
          ],
          "status": "partial",
          "success_rate": 0.75,
          "successful_models": [
            "violence",
            "weather",
            "face"
          ]
        },
        "properties": {
          "errors": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Model name to error message mapping",
            "title": "Errors",
            "type": "object"
          },
          "failed_models": {
            "description": "List of enrichment models that failed",
            "items": {
              "type": "string"
            },
            "title": "Failed Models",
            "type": "array"
          },
          "status": {
            "$ref": "#/components/schemas/EnrichmentStatusEnum",
            "description": "Overall enrichment status (full, partial, failed, skipped)"
          },
          "success_rate": {
            "description": "Success rate (0.0 to 1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Success Rate",
            "type": "number"
          },
          "successful_models": {
            "description": "List of enrichment models that succeeded",
            "items": {
              "type": "string"
            },
            "title": "Successful Models",
            "type": "array"
          }
        },
        "required": [
          "status",
          "success_rate"
        ],
        "title": "EnrichmentStatusResponse",
        "type": "object"
      },
      "EntityAppearance": {
        "description": "Schema for a single entity appearance at a specific time and camera.\n\nRepresents one sighting of an entity, including the detection it came from\nand additional attributes extracted from the image.",
        "example": {
          "attributes": {
            "carrying": "backpack",
            "clothing": "blue jacket"
          },
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "detection_id": "det_abc123",
          "similarity_score": 0.92,
          "thumbnail_url": "/api/detections/123/image",
          "timestamp": "2025-12-23T14:30:00Z"
        },
        "properties": {
          "attributes": {
            "additionalProperties": true,
            "description": "Additional attributes extracted from the detection (clothing, carrying, etc.)",
            "title": "Attributes",
            "type": "object"
          },
          "camera_id": {
            "description": "Camera ID where entity was seen",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable camera name",
            "title": "Camera Name"
          },
          "detection_id": {
            "description": "Detection ID from original detection",
            "title": "Detection Id",
            "type": "string"
          },
          "similarity_score": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Similarity score to the entity's reference embedding",
            "title": "Similarity Score"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to thumbnail image of this appearance",
            "title": "Thumbnail Url"
          },
          "timestamp": {
            "description": "When the entity was detected",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "detection_id",
          "camera_id",
          "timestamp"
        ],
        "title": "EntityAppearance",
        "type": "object"
      },
      "EntityDetail": {
        "description": "Schema for detailed entity information including appearance history.\n\nExtends EntitySummary with the full list of appearances.",
        "example": {
          "appearance_count": 3,
          "appearances": [
            {
              "attributes": {
                "clothing": "blue jacket"
              },
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_id": "det_001",
              "similarity_score": 1.0,
              "thumbnail_url": "/api/detections/1/image",
              "timestamp": "2025-12-23T10:00:00Z"
            },
            {
              "attributes": {
                "carrying": "bag",
                "clothing": "blue jacket"
              },
              "camera_id": "backyard",
              "camera_name": "Backyard",
              "detection_id": "det_002",
              "similarity_score": 0.94,
              "thumbnail_url": "/api/detections/2/image",
              "timestamp": "2025-12-23T12:15:00Z"
            }
          ],
          "cameras_seen": [
            "front_door",
            "backyard"
          ],
          "entity_type": "person",
          "first_seen": "2025-12-23T10:00:00Z",
          "id": "entity_abc123",
          "last_seen": "2025-12-23T14:30:00Z",
          "thumbnail_url": "/api/detections/123/image"
        },
        "properties": {
          "appearance_count": {
            "description": "Total number of appearances",
            "minimum": 0.0,
            "title": "Appearance Count",
            "type": "integer"
          },
          "appearances": {
            "description": "List of all appearances for this entity",
            "items": {
              "$ref": "#/components/schemas/EntityAppearance"
            },
            "title": "Appearances",
            "type": "array"
          },
          "cameras_seen": {
            "description": "List of camera IDs where entity was detected",
            "items": {
              "type": "string"
            },
            "title": "Cameras Seen",
            "type": "array"
          },
          "entity_type": {
            "description": "Type of entity: 'person' or 'vehicle'",
            "title": "Entity Type",
            "type": "string"
          },
          "first_seen": {
            "description": "Timestamp of first appearance",
            "format": "date-time",
            "title": "First Seen",
            "type": "string"
          },
          "id": {
            "description": "Unique entity identifier",
            "title": "Id",
            "type": "string"
          },
          "last_seen": {
            "description": "Timestamp of most recent appearance",
            "format": "date-time",
            "title": "Last Seen",
            "type": "string"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to the most recent thumbnail image",
            "title": "Thumbnail Url"
          }
        },
        "required": [
          "id",
          "entity_type",
          "first_seen",
          "last_seen",
          "appearance_count"
        ],
        "title": "EntityDetail",
        "type": "object"
      },
      "EntityHistoryResponse": {
        "description": "Schema for entity appearance history response.",
        "example": {
          "appearances": [
            {
              "attributes": {},
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_id": "det_001",
              "similarity_score": 1.0,
              "thumbnail_url": "/api/detections/1/image",
              "timestamp": "2025-12-23T10:00:00Z"
            }
          ],
          "count": 1,
          "entity_id": "entity_abc123",
          "entity_type": "person"
        },
        "properties": {
          "appearances": {
            "description": "List of appearances in chronological order",
            "items": {
              "$ref": "#/components/schemas/EntityAppearance"
            },
            "title": "Appearances",
            "type": "array"
          },
          "count": {
            "description": "Total number of appearances",
            "title": "Count",
            "type": "integer"
          },
          "entity_id": {
            "description": "Entity identifier",
            "title": "Entity Id",
            "type": "string"
          },
          "entity_type": {
            "description": "Type of entity",
            "title": "Entity Type",
            "type": "string"
          }
        },
        "required": [
          "entity_id",
          "entity_type",
          "appearances",
          "count"
        ],
        "title": "EntityHistoryResponse",
        "type": "object"
      },
      "EntityListResponse": {
        "description": "Schema for paginated entity list response (NEM-2075 pagination envelope).\n\nUses standardized pagination envelope with 'items' and 'pagination' fields.",
        "example": {
          "items": [
            {
              "appearance_count": 5,
              "cameras_seen": [
                "front_door",
                "backyard"
              ],
              "entity_type": "person",
              "first_seen": "2025-12-23T10:00:00Z",
              "id": "entity_abc123",
              "last_seen": "2025-12-23T14:30:00Z",
              "thumbnail_url": "/api/detections/123/image"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of tracked entities",
            "items": {
              "$ref": "#/components/schemas/EntitySummary"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "EntityListResponse",
        "type": "object"
      },
      "EntityMatchItem": {
        "description": "Schema for a single entity match result.\n\nRepresents a matching entity found through re-identification,\nincluding similarity score and time gap.",
        "example": {
          "attributes": {
            "clothing": "blue jacket"
          },
          "camera_id": "backyard",
          "camera_name": "Backyard",
          "entity_id": "det_abc123",
          "entity_type": "person",
          "similarity_score": 0.92,
          "thumbnail_url": "/api/detections/123/image",
          "time_gap_seconds": 3600.0,
          "timestamp": "2025-12-23T10:00:00Z"
        },
        "properties": {
          "attributes": {
            "additionalProperties": true,
            "description": "Additional attributes extracted from the detection",
            "title": "Attributes",
            "type": "object"
          },
          "camera_id": {
            "description": "Camera ID where entity was seen",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable camera name",
            "title": "Camera Name"
          },
          "entity_id": {
            "description": "Detection ID of the matched entity",
            "title": "Entity Id",
            "type": "string"
          },
          "entity_type": {
            "description": "Type of entity: 'person' or 'vehicle'",
            "title": "Entity Type",
            "type": "string"
          },
          "similarity_score": {
            "description": "Cosine similarity score (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Similarity Score",
            "type": "number"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to thumbnail image",
            "title": "Thumbnail Url"
          },
          "time_gap_seconds": {
            "description": "Time gap in seconds between query and match",
            "title": "Time Gap Seconds",
            "type": "number"
          },
          "timestamp": {
            "description": "When the entity was detected",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "entity_id",
          "entity_type",
          "camera_id",
          "timestamp",
          "similarity_score",
          "time_gap_seconds"
        ],
        "title": "EntityMatchItem",
        "type": "object"
      },
      "EntityMatchResponse": {
        "description": "Schema for entity match query response.\n\nReturns entities matching a specific detection's embedding,\nused for showing re-ID matches in the EventDetailModal.",
        "example": {
          "entity_type": "person",
          "matches": [
            {
              "attributes": {
                "clothing": "blue jacket"
              },
              "camera_id": "backyard",
              "camera_name": "Backyard",
              "entity_id": "det_002",
              "entity_type": "person",
              "similarity_score": 0.92,
              "thumbnail_url": "/api/detections/2/image",
              "time_gap_seconds": 3600.0,
              "timestamp": "2025-12-23T09:00:00Z"
            }
          ],
          "query_detection_id": "det_001",
          "threshold": 0.85,
          "total_matches": 1
        },
        "properties": {
          "entity_type": {
            "description": "Type of entity searched",
            "title": "Entity Type",
            "type": "string"
          },
          "matches": {
            "description": "List of matching entities sorted by similarity",
            "items": {
              "$ref": "#/components/schemas/EntityMatchItem"
            },
            "title": "Matches",
            "type": "array"
          },
          "query_detection_id": {
            "description": "Detection ID used for the query",
            "title": "Query Detection Id",
            "type": "string"
          },
          "threshold": {
            "description": "Similarity threshold used for matching",
            "title": "Threshold",
            "type": "number"
          },
          "total_matches": {
            "description": "Total number of matches found",
            "title": "Total Matches",
            "type": "integer"
          }
        },
        "required": [
          "query_detection_id",
          "entity_type",
          "total_matches",
          "threshold"
        ],
        "title": "EntityMatchResponse",
        "type": "object"
      },
      "EntitySummary": {
        "description": "Schema for entity summary in list responses.\n\nProvides an overview of a tracked entity without the full appearance history.",
        "example": {
          "appearance_count": 5,
          "cameras_seen": [
            "front_door",
            "backyard",
            "driveway"
          ],
          "entity_type": "person",
          "first_seen": "2025-12-23T10:00:00Z",
          "id": "entity_abc123",
          "last_seen": "2025-12-23T14:30:00Z",
          "thumbnail_url": "/api/detections/123/image"
        },
        "properties": {
          "appearance_count": {
            "description": "Total number of appearances",
            "minimum": 0.0,
            "title": "Appearance Count",
            "type": "integer"
          },
          "cameras_seen": {
            "description": "List of camera IDs where entity was detected",
            "items": {
              "type": "string"
            },
            "title": "Cameras Seen",
            "type": "array"
          },
          "entity_type": {
            "description": "Type of entity: 'person' or 'vehicle'",
            "title": "Entity Type",
            "type": "string"
          },
          "first_seen": {
            "description": "Timestamp of first appearance",
            "format": "date-time",
            "title": "First Seen",
            "type": "string"
          },
          "id": {
            "description": "Unique entity identifier",
            "title": "Id",
            "type": "string"
          },
          "last_seen": {
            "description": "Timestamp of most recent appearance",
            "format": "date-time",
            "title": "Last Seen",
            "type": "string"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to the most recent thumbnail image",
            "title": "Thumbnail Url"
          }
        },
        "required": [
          "id",
          "entity_type",
          "first_seen",
          "last_seen",
          "appearance_count"
        ],
        "title": "EntitySummary",
        "type": "object"
      },
      "EntityTypeEnum": {
        "description": "Valid entity types for filtering.",
        "enum": [
          "person",
          "vehicle"
        ],
        "title": "EntityTypeEnum",
        "type": "string"
      },
      "EventAuditResponse": {
        "description": "Full audit response for a single event.",
        "example": {
          "audited_at": "2026-01-03T10:30:00Z",
          "consistency_diff": 3,
          "consistency_risk_score": 62,
          "contributions": {
            "baseline": false,
            "clip": false,
            "clothing": true,
            "cross_camera": false,
            "florence": true,
            "image_quality": true,
            "pet": false,
            "rtdetr": true,
            "vehicle": false,
            "violence": false,
            "weather": true,
            "zones": true
          },
          "enrichment_utilization": 0.85,
          "event_id": 12345,
          "id": 456,
          "improvements": {
            "confusing_sections": [],
            "format_suggestions": [],
            "missing_context": [
              "Time since last motion event"
            ],
            "model_gaps": [],
            "unused_data": []
          },
          "is_fully_evaluated": true,
          "prompt_length": 2048,
          "prompt_token_estimate": 512,
          "scores": {
            "consistency": 4.0,
            "context_usage": 4.2,
            "overall": 4.1,
            "reasoning_coherence": 4.5,
            "risk_justification": 3.8
          },
          "self_eval_critique": "More historical context would improve analysis."
        },
        "properties": {
          "audited_at": {
            "format": "date-time",
            "title": "Audited At",
            "type": "string"
          },
          "consistency_diff": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Consistency Diff"
          },
          "consistency_risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Consistency Risk Score"
          },
          "contributions": {
            "$ref": "#/components/schemas/ModelContributions"
          },
          "enrichment_utilization": {
            "title": "Enrichment Utilization",
            "type": "number"
          },
          "event_id": {
            "title": "Event Id",
            "type": "integer"
          },
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "improvements": {
            "$ref": "#/components/schemas/PromptImprovements"
          },
          "is_fully_evaluated": {
            "title": "Is Fully Evaluated",
            "type": "boolean"
          },
          "prompt_length": {
            "title": "Prompt Length",
            "type": "integer"
          },
          "prompt_token_estimate": {
            "title": "Prompt Token Estimate",
            "type": "integer"
          },
          "scores": {
            "$ref": "#/components/schemas/QualityScores"
          },
          "self_eval_critique": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Self Eval Critique"
          }
        },
        "required": [
          "id",
          "event_id",
          "audited_at",
          "is_fully_evaluated",
          "contributions",
          "prompt_length",
          "prompt_token_estimate",
          "enrichment_utilization",
          "scores",
          "improvements"
        ],
        "title": "EventAuditResponse",
        "type": "object"
      },
      "EventBulkCreateItem": {
        "description": "Schema for a single event in a bulk create request.\n\nAttributes:\n    batch_id: Batch ID that generated this event (tracks detection grouping)\n    camera_id: Camera ID that generated this event\n    started_at: Event start timestamp\n    ended_at: Optional event end timestamp\n    risk_score: Risk score from 0-100\n    risk_level: Risk level (low, medium, high, critical)\n    summary: Brief event summary\n    reasoning: Detailed reasoning from LLM analysis\n    detection_ids: List of detection IDs associated with this event",
        "properties": {
          "batch_id": {
            "description": "Batch ID that generated this event",
            "maxLength": 255,
            "minLength": 1,
            "title": "Batch Id",
            "type": "string"
          },
          "camera_id": {
            "description": "Camera ID",
            "maxLength": 255,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_-]+$",
            "title": "Camera Id",
            "type": "string"
          },
          "detection_ids": {
            "description": "Associated detection IDs",
            "items": {
              "type": "integer"
            },
            "title": "Detection Ids",
            "type": "array"
          },
          "ended_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event end timestamp",
            "title": "Ended At"
          },
          "reasoning": {
            "anyOf": [
              {
                "maxLength": 5000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM reasoning",
            "title": "Reasoning"
          },
          "risk_level": {
            "description": "Risk level",
            "pattern": "^(low|medium|high|critical)$",
            "title": "Risk Level",
            "type": "string"
          },
          "risk_score": {
            "description": "Risk score (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Risk Score",
            "type": "integer"
          },
          "started_at": {
            "description": "Event start timestamp",
            "format": "date-time",
            "title": "Started At",
            "type": "string"
          },
          "summary": {
            "description": "Event summary",
            "maxLength": 1000,
            "minLength": 1,
            "title": "Summary",
            "type": "string"
          }
        },
        "required": [
          "batch_id",
          "camera_id",
          "started_at",
          "risk_score",
          "risk_level",
          "summary"
        ],
        "title": "EventBulkCreateItem",
        "type": "object"
      },
      "EventBulkCreateRequest": {
        "description": "Request schema for bulk event creation.\n\nAttributes:\n    events: List of events to create (max 100 per request)",
        "properties": {
          "events": {
            "description": "Events to create (max 100)",
            "items": {
              "$ref": "#/components/schemas/EventBulkCreateItem"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Events",
            "type": "array"
          }
        },
        "required": [
          "events"
        ],
        "title": "EventBulkCreateRequest",
        "type": "object"
      },
      "EventBulkCreateResponse": {
        "description": "Response schema for bulk event creation.\n\nExtends BulkOperationResponse with created event IDs.",
        "properties": {
          "failed": {
            "description": "Number of failed operations",
            "minimum": 0.0,
            "title": "Failed",
            "type": "integer"
          },
          "results": {
            "description": "Per-item results",
            "items": {
              "$ref": "#/components/schemas/BulkItemResult"
            },
            "title": "Results",
            "type": "array"
          },
          "skipped": {
            "default": 0,
            "description": "Number of skipped operations",
            "minimum": 0.0,
            "title": "Skipped",
            "type": "integer"
          },
          "succeeded": {
            "description": "Number of successful operations",
            "minimum": 0.0,
            "title": "Succeeded",
            "type": "integer"
          },
          "total": {
            "description": "Total number of items in the request",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "succeeded",
          "failed"
        ],
        "title": "EventBulkCreateResponse",
        "type": "object"
      },
      "EventBulkDeleteRequest": {
        "description": "Request schema for bulk event deletion.\n\nAttributes:\n    event_ids: List of event IDs to delete (max 100 per request)\n    soft_delete: If true, mark as deleted instead of removing",
        "properties": {
          "event_ids": {
            "description": "Event IDs to delete (max 100)",
            "items": {
              "type": "integer"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Event Ids",
            "type": "array"
          },
          "soft_delete": {
            "default": true,
            "description": "Soft delete (default) vs hard delete",
            "title": "Soft Delete",
            "type": "boolean"
          }
        },
        "required": [
          "event_ids"
        ],
        "title": "EventBulkDeleteRequest",
        "type": "object"
      },
      "EventBulkUpdateItem": {
        "description": "Schema for a single event update in a bulk update request.\n\nAttributes:\n    id: Event ID to update\n    reviewed: Mark event as reviewed/dismissed\n    notes: Optional notes for the event",
        "properties": {
          "id": {
            "description": "Event ID to update",
            "exclusiveMinimum": 0.0,
            "title": "Id",
            "type": "integer"
          },
          "notes": {
            "anyOf": [
              {
                "maxLength": 2000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Notes",
            "title": "Notes"
          },
          "reviewed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Mark as reviewed",
            "title": "Reviewed"
          }
        },
        "required": [
          "id"
        ],
        "title": "EventBulkUpdateItem",
        "type": "object"
      },
      "EventBulkUpdateRequest": {
        "description": "Request schema for bulk event updates.\n\nAttributes:\n    events: List of event updates (max 100 per request)",
        "properties": {
          "events": {
            "description": "Event updates (max 100)",
            "items": {
              "$ref": "#/components/schemas/EventBulkUpdateItem"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Events",
            "type": "array"
          }
        },
        "required": [
          "events"
        ],
        "title": "EventBulkUpdateRequest",
        "type": "object"
      },
      "EventEnrichmentsResponse": {
        "description": "Enrichment data for all detections in an event with pagination support.",
        "example": {
          "count": 2,
          "enrichments": [
            {
              "detection_id": 1,
              "enriched_at": "2026-01-03T10:30:00Z",
              "face": {
                "count": 0,
                "detected": false
              },
              "license_plate": {
                "detected": true,
                "text": "ABC-1234"
              },
              "violence": {
                "detected": false,
                "score": 0.0
              }
            },
            {
              "detection_id": 2,
              "enriched_at": "2026-01-03T10:30:05Z",
              "face": {
                "count": 1,
                "detected": true
              },
              "license_plate": {
                "detected": false
              },
              "violence": {
                "detected": false,
                "score": 0.0
              }
            }
          ],
          "event_id": 100,
          "has_more": false,
          "limit": 50,
          "offset": 0,
          "total": 10
        },
        "properties": {
          "count": {
            "description": "Number of enrichments in this response (page size)",
            "title": "Count",
            "type": "integer"
          },
          "enrichments": {
            "description": "Enrichment data per detection",
            "items": {
              "$ref": "#/components/schemas/EnrichmentResponse"
            },
            "title": "Enrichments",
            "type": "array"
          },
          "event_id": {
            "description": "Event ID",
            "title": "Event Id",
            "type": "integer"
          },
          "has_more": {
            "description": "Whether there are more results available",
            "title": "Has More",
            "type": "boolean"
          },
          "limit": {
            "description": "Maximum number of results requested",
            "title": "Limit",
            "type": "integer"
          },
          "offset": {
            "description": "Number of results skipped",
            "title": "Offset",
            "type": "integer"
          },
          "total": {
            "description": "Total number of detections with enrichment data for this event",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "event_id",
          "enrichments",
          "count",
          "total",
          "limit",
          "offset",
          "has_more"
        ],
        "title": "EventEnrichmentsResponse",
        "type": "object"
      },
      "EventFeedbackCreate": {
        "description": "Schema for creating event feedback.\n\nUsed when submitting user feedback about an event's classification.",
        "example": {
          "event_id": 123,
          "feedback_type": "false_positive",
          "notes": "This was my neighbor's car, not a threat."
        },
        "properties": {
          "event_id": {
            "description": "ID of the event this feedback is for",
            "exclusiveMinimum": 0.0,
            "title": "Event Id",
            "type": "integer"
          },
          "feedback_type": {
            "$ref": "#/components/schemas/FeedbackType",
            "description": "Type of feedback (false_positive, missed_detection, wrong_severity, correct)"
          },
          "notes": {
            "anyOf": [
              {
                "maxLength": 1000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional notes explaining the feedback",
            "title": "Notes"
          }
        },
        "required": [
          "event_id",
          "feedback_type"
        ],
        "title": "EventFeedbackCreate",
        "type": "object"
      },
      "EventFeedbackResponse": {
        "description": "Schema for event feedback response.\n\nReturned when retrieving feedback for an event.",
        "example": {
          "created_at": "2025-01-01T12:00:00Z",
          "event_id": 123,
          "feedback_type": "false_positive",
          "id": 1,
          "notes": "This was my neighbor's car, not a threat."
        },
        "properties": {
          "created_at": {
            "description": "When feedback was submitted",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "event_id": {
            "description": "Event ID this feedback belongs to",
            "title": "Event Id",
            "type": "integer"
          },
          "feedback_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ],
            "description": "Type of feedback provided",
            "title": "Feedback Type"
          },
          "id": {
            "description": "Feedback record ID",
            "title": "Id",
            "type": "integer"
          },
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional notes from user",
            "title": "Notes"
          }
        },
        "required": [
          "id",
          "event_id",
          "feedback_type",
          "created_at"
        ],
        "title": "EventFeedbackResponse",
        "type": "object"
      },
      "EventListResponse": {
        "description": "Schema for event list response with pagination.\n\nNEM-2075: Standardized pagination envelope with items + pagination structure.\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nUse cursor-based pagination for better performance with large datasets.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "detection_count": 5,
              "detection_ids": [
                1,
                2,
                3,
                4,
                5
              ],
              "ended_at": "2025-12-23T12:02:30Z",
              "id": 1,
              "reasoning": "Person approaching entrance during daytime",
              "reviewed": false,
              "risk_level": "medium",
              "risk_score": 75,
              "started_at": "2025-12-23T12:00:00Z",
              "summary": "Person detected near front entrance",
              "thumbnail_url": "/api/media/detections/1"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=",
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Warning message when using deprecated offset pagination",
            "title": "Deprecation Warning"
          },
          "items": {
            "description": "List of events",
            "items": {
              "$ref": "#/components/schemas/EventResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "EventListResponse",
        "type": "object"
      },
      "EventRegistryResponse": {
        "description": "Response containing the complete WebSocket event registry.",
        "example": {
          "channels": [
            "detections",
            "events",
            "alerts",
            "cameras",
            "jobs",
            "system"
          ],
          "deprecated_count": 3,
          "event_types": [],
          "total_count": 25
        },
        "properties": {
          "channels": {
            "description": "List of all available WebSocket channels",
            "items": {
              "type": "string"
            },
            "title": "Channels",
            "type": "array"
          },
          "deprecated_count": {
            "description": "Number of deprecated event types",
            "title": "Deprecated Count",
            "type": "integer"
          },
          "event_types": {
            "description": "List of all available event types",
            "items": {
              "$ref": "#/components/schemas/EventTypeInfo"
            },
            "title": "Event Types",
            "type": "array"
          },
          "total_count": {
            "description": "Total number of event types",
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "event_types",
          "channels",
          "total_count",
          "deprecated_count"
        ],
        "title": "EventRegistryResponse",
        "type": "object"
      },
      "EventResponse": {
        "description": "Schema for event response.",
        "example": {
          "camera_id": "front_door",
          "detection_count": 5,
          "detection_ids": [
            1,
            2,
            3,
            4,
            5
          ],
          "ended_at": "2025-12-23T12:02:30Z",
          "enrichment_status": {
            "errors": {},
            "failed_models": [],
            "status": "full",
            "success_rate": 1.0,
            "successful_models": [
              "violence",
              "weather",
              "face",
              "clothing"
            ]
          },
          "id": 1,
          "llm_prompt": "<|im_start|>system\nYou are a home security risk analyzer...",
          "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
          "reviewed": false,
          "risk_level": "medium",
          "risk_score": 75,
          "started_at": "2025-12-23T12:00:00Z",
          "summary": "Person detected near front entrance",
          "thumbnail_url": "/api/media/detections/1"
        },
        "properties": {
          "camera_id": {
            "description": "Normalized camera ID (e.g., 'front_door')",
            "title": "Camera Id",
            "type": "string"
          },
          "detection_count": {
            "default": 0,
            "description": "Number of detections in this event",
            "title": "Detection Count",
            "type": "integer"
          },
          "detection_ids": {
            "description": "List of detection IDs associated with this event",
            "items": {
              "type": "integer"
            },
            "title": "Detection Ids",
            "type": "array"
          },
          "ended_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event end timestamp",
            "title": "Ended At"
          },
          "enrichment_status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enrichment pipeline status (NEM-1672) - shows which models succeeded/failed"
          },
          "id": {
            "description": "Event ID",
            "title": "Id",
            "type": "integer"
          },
          "llm_prompt": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Full prompt sent to Nemotron LLM (for debugging/improvement)",
            "title": "Llm Prompt"
          },
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "User notes for the event",
            "title": "Notes"
          },
          "reasoning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM reasoning for risk score",
            "title": "Reasoning"
          },
          "reviewed": {
            "default": false,
            "description": "Whether event has been reviewed",
            "title": "Reviewed",
            "type": "boolean"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk level (low, medium, high, critical)",
            "title": "Risk Level"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk score (0-100)",
            "title": "Risk Score"
          },
          "started_at": {
            "description": "Event start timestamp",
            "format": "date-time",
            "title": "Started At",
            "type": "string"
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM-generated event summary",
            "title": "Summary"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to thumbnail image (first detection's media)",
            "title": "Thumbnail Url"
          }
        },
        "required": [
          "id",
          "camera_id",
          "started_at"
        ],
        "title": "EventResponse",
        "type": "object"
      },
      "EventStatsResponse": {
        "description": "Schema for aggregated event statistics.",
        "example": {
          "events_by_camera": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "event_count": 30
            },
            {
              "camera_id": "back_door",
              "camera_name": "Back Door",
              "event_count": 14
            }
          ],
          "events_by_risk_level": {
            "critical": 2,
            "high": 5,
            "low": 25,
            "medium": 12
          },
          "total_events": 44
        },
        "properties": {
          "events_by_camera": {
            "description": "Events grouped by camera",
            "items": {
              "$ref": "#/components/schemas/EventsByCamera"
            },
            "title": "Events By Camera",
            "type": "array"
          },
          "events_by_risk_level": {
            "$ref": "#/components/schemas/EventsByRiskLevel",
            "description": "Events grouped by risk level"
          },
          "total_events": {
            "description": "Total number of events",
            "title": "Total Events",
            "type": "integer"
          }
        },
        "required": [
          "total_events",
          "events_by_risk_level",
          "events_by_camera"
        ],
        "title": "EventStatsResponse",
        "type": "object"
      },
      "EventTypeInfo": {
        "description": "Information about a single WebSocket event type.",
        "example": {
          "channel": "detections",
          "deprecated": false,
          "description": "New detection from AI pipeline",
          "example": {
            "confidence": 0.95,
            "detection_id": "123",
            "label": "person"
          },
          "payload_schema": {
            "confidence": {
              "type": "number"
            },
            "detection_id": {
              "format": "uuid",
              "type": "string"
            },
            "label": {
              "type": "string"
            }
          },
          "type": "detection.new"
        },
        "properties": {
          "channel": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "WebSocket channel this event is broadcast on",
            "title": "Channel"
          },
          "deprecated": {
            "default": false,
            "description": "Whether this event type is deprecated",
            "title": "Deprecated",
            "type": "boolean"
          },
          "description": {
            "description": "Human-readable description",
            "title": "Description",
            "type": "string"
          },
          "example": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Example payload",
            "title": "Example"
          },
          "payload_schema": {
            "additionalProperties": true,
            "description": "JSON Schema for the event payload",
            "title": "Payload Schema",
            "type": "object"
          },
          "replacement": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Replacement event type if deprecated",
            "title": "Replacement"
          },
          "type": {
            "description": "Event type identifier",
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "type",
          "description",
          "payload_schema"
        ],
        "title": "EventTypeInfo",
        "type": "object"
      },
      "EventUpdate": {
        "description": "Schema for updating an event (PATCH).",
        "example": {
          "notes": "Verified - delivery person",
          "reviewed": true
        },
        "properties": {
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "User notes for the event",
            "title": "Notes"
          },
          "reviewed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Mark event as reviewed or not reviewed",
            "title": "Reviewed"
          }
        },
        "title": "EventUpdate",
        "type": "object"
      },
      "EventsByCamera": {
        "description": "Schema for events count by camera.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "event_count": 15
        },
        "properties": {
          "camera_id": {
            "description": "Normalized camera ID (e.g., 'front_door')",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "description": "Camera name",
            "title": "Camera Name",
            "type": "string"
          },
          "event_count": {
            "description": "Number of events for this camera",
            "title": "Event Count",
            "type": "integer"
          }
        },
        "required": [
          "camera_id",
          "camera_name",
          "event_count"
        ],
        "title": "EventsByCamera",
        "type": "object"
      },
      "EventsByRiskLevel": {
        "description": "Schema for events count by risk level.",
        "example": {
          "critical": 2,
          "high": 5,
          "low": 25,
          "medium": 12
        },
        "properties": {
          "critical": {
            "default": 0,
            "description": "Number of critical risk events",
            "title": "Critical",
            "type": "integer"
          },
          "high": {
            "default": 0,
            "description": "Number of high risk events",
            "title": "High",
            "type": "integer"
          },
          "low": {
            "default": 0,
            "description": "Number of low risk events",
            "title": "Low",
            "type": "integer"
          },
          "medium": {
            "default": 0,
            "description": "Number of medium risk events",
            "title": "Medium",
            "type": "integer"
          }
        },
        "title": "EventsByRiskLevel",
        "type": "object"
      },
      "ExportFormat": {
        "description": "Supported export formats.",
        "enum": [
          "csv",
          "json",
          "zip"
        ],
        "title": "ExportFormat",
        "type": "string"
      },
      "ExportJobRequest": {
        "description": "Request to start an export job.",
        "example": {
          "end_date": "2024-01-15T23:59:59Z",
          "format": "csv",
          "risk_level": "high",
          "start_date": "2024-01-01T00:00:00Z"
        },
        "properties": {
          "camera_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by camera ID",
            "title": "Camera Id"
          },
          "end_date": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by end date (ISO format)",
            "title": "End Date"
          },
          "format": {
            "$ref": "#/components/schemas/ExportFormat",
            "default": "csv",
            "description": "Export format"
          },
          "reviewed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by reviewed status",
            "title": "Reviewed"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by risk level (low, medium, high, critical)",
            "title": "Risk Level"
          },
          "start_date": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by start date (ISO format)",
            "title": "Start Date"
          }
        },
        "title": "ExportJobRequest",
        "type": "object"
      },
      "ExportJobStartResponse": {
        "description": "Response when starting an export job.",
        "example": {
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "message": "Export job created. Use GET /api/jobs/{job_id} to track progress.",
          "status": "pending"
        },
        "properties": {
          "job_id": {
            "description": "Job ID for tracking progress",
            "title": "Job Id",
            "type": "string"
          },
          "message": {
            "description": "Status message",
            "title": "Message",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatusEnum",
            "default": "pending",
            "description": "Initial job status"
          }
        },
        "required": [
          "job_id",
          "message"
        ],
        "title": "ExportJobStartResponse",
        "type": "object"
      },
      "FaceEnrichment": {
        "description": "Face detection results.",
        "example": {
          "confidence": 0.88,
          "count": 1,
          "detected": true
        },
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Highest face confidence",
            "title": "Confidence"
          },
          "count": {
            "default": 0,
            "description": "Number of faces detected",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "detected": {
            "default": false,
            "description": "Whether faces were detected",
            "title": "Detected",
            "type": "boolean"
          }
        },
        "title": "FaceEnrichment",
        "type": "object"
      },
      "FeedbackStatsResponse": {
        "description": "Schema for aggregate feedback statistics.\n\nReturns counts of feedback by type and by camera to help\ncalibrate the AI model's risk assessment.",
        "example": {
          "by_camera": {
            "back_yard": 30,
            "front_door": 50,
            "garage": 20
          },
          "by_type": {
            "correct": 10,
            "false_positive": 40,
            "missed_detection": 30,
            "wrong_severity": 20
          },
          "total_feedback": 100
        },
        "properties": {
          "by_camera": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of feedback entries grouped by camera ID",
            "title": "By Camera",
            "type": "object"
          },
          "by_type": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of feedback entries grouped by feedback type",
            "title": "By Type",
            "type": "object"
          },
          "total_feedback": {
            "description": "Total number of feedback entries",
            "minimum": 0.0,
            "title": "Total Feedback",
            "type": "integer"
          }
        },
        "required": [
          "total_feedback",
          "by_type",
          "by_camera"
        ],
        "title": "FeedbackStatsResponse",
        "type": "object"
      },
      "FeedbackType": {
        "description": "Types of feedback users can provide on events.\n\nValues:\n    FALSE_POSITIVE: Event was incorrectly flagged as concerning\n    MISSED_DETECTION: System failed to detect a concerning event\n    WRONG_SEVERITY: Event was flagged but with wrong severity level\n    CORRECT: Event was correctly classified and scored",
        "enum": [
          "false_positive",
          "missed_detection",
          "wrong_severity",
          "correct"
        ],
        "title": "FeedbackType",
        "type": "string"
      },
      "FileWatcherStatusResponse": {
        "description": "Status information for the FileWatcher service.",
        "example": {
          "camera_root": "/export/foscam",
          "observer_type": "native",
          "pending_tasks": 3,
          "running": true
        },
        "properties": {
          "camera_root": {
            "description": "Root directory being watched for camera uploads",
            "title": "Camera Root",
            "type": "string"
          },
          "observer_type": {
            "description": "Type of filesystem observer (native or polling)",
            "title": "Observer Type",
            "type": "string"
          },
          "pending_tasks": {
            "description": "Number of files pending processing (debouncing)",
            "minimum": 0.0,
            "title": "Pending Tasks",
            "type": "integer"
          },
          "running": {
            "description": "Whether the file watcher is currently running",
            "title": "Running",
            "type": "boolean"
          }
        },
        "required": [
          "running",
          "camera_root",
          "pending_tasks",
          "observer_type"
        ],
        "title": "FileWatcherStatusResponse",
        "type": "object"
      },
      "FrontendLogCreate": {
        "description": "Schema for frontend log submission.",
        "example": {
          "component": "RiskGauge",
          "extra": {
            "last_error": "Connection refused",
            "reconnect_attempts": 3
          },
          "level": "ERROR",
          "message": "WebSocket connection lost",
          "url": "https://localhost:5173/dashboard",
          "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0"
        },
        "properties": {
          "component": {
            "description": "Frontend component name (e.g., 'RiskGauge', 'CameraGrid')",
            "maxLength": 50,
            "minLength": 1,
            "title": "Component",
            "type": "string"
          },
          "extra": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional context (JSON-serializable)",
            "title": "Extra"
          },
          "level": {
            "description": "Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
            "pattern": "^(DEBUG|INFO|WARNING|ERROR|CRITICAL)$",
            "title": "Level",
            "type": "string"
          },
          "message": {
            "description": "Log message content",
            "maxLength": 2000,
            "minLength": 1,
            "title": "Message",
            "type": "string"
          },
          "url": {
            "anyOf": [
              {
                "maxLength": 2000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Page URL where log occurred",
            "title": "Url"
          },
          "user_agent": {
            "anyOf": [
              {
                "maxLength": 500,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Browser user agent string",
            "title": "User Agent"
          }
        },
        "required": [
          "level",
          "component",
          "message"
        ],
        "title": "FrontendLogCreate",
        "type": "object"
      },
      "FullHealthResponse": {
        "description": "Comprehensive health check response for GET /api/system/health/full.\n\nAggregates health status from all services:\n- Infrastructure (postgres, redis)\n- AI services (rtdetr, nemotron, florence, clip, enrichment)\n- Circuit breakers\n- Background workers\n\nHTTP Status Codes:\n- 200: System is healthy or degraded (can still serve traffic)\n- 503: Critical services are unhealthy (should not receive traffic)",
        "example": {
          "ai_services": [
            {
              "circuit_state": "closed",
              "display_name": "RT-DETRv2 Object Detection",
              "last_check": "2026-01-08T10:30:00Z",
              "name": "rtdetr",
              "response_time_ms": 45.2,
              "status": "healthy",
              "url": "http://ai-detector:8090"
            }
          ],
          "circuit_breakers": {
            "breakers": {
              "nemotron": "closed",
              "rtdetr": "closed"
            },
            "closed": 5,
            "half_open": 0,
            "open": 0,
            "total": 5
          },
          "message": "All systems operational",
          "postgres": {
            "message": "Database operational",
            "name": "postgres",
            "status": "healthy"
          },
          "ready": true,
          "redis": {
            "details": {
              "redis_version": "7.4.0"
            },
            "message": "Redis connected",
            "name": "redis",
            "status": "healthy"
          },
          "status": "healthy",
          "timestamp": "2026-01-08T10:30:00Z",
          "version": "0.1.0",
          "workers": [
            {
              "critical": true,
              "name": "file_watcher",
              "running": true
            }
          ]
        },
        "properties": {
          "ai_services": {
            "description": "Health status of all AI services",
            "items": {
              "$ref": "#/components/schemas/AIServiceHealthStatus"
            },
            "title": "Ai Services",
            "type": "array"
          },
          "circuit_breakers": {
            "$ref": "#/components/schemas/CircuitBreakerSummary",
            "description": "Circuit breaker summary"
          },
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "postgres": {
            "$ref": "#/components/schemas/InfrastructureHealthStatus",
            "description": "PostgreSQL health status"
          },
          "ready": {
            "description": "Whether system is ready to receive traffic",
            "title": "Ready",
            "type": "boolean"
          },
          "redis": {
            "$ref": "#/components/schemas/InfrastructureHealthStatus",
            "description": "Redis health status"
          },
          "status": {
            "$ref": "#/components/schemas/ServiceHealthState",
            "description": "Overall system health status"
          },
          "timestamp": {
            "description": "Response timestamp",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "version": {
            "description": "Application version",
            "title": "Version",
            "type": "string"
          },
          "workers": {
            "description": "Background worker statuses",
            "items": {
              "$ref": "#/components/schemas/WorkerHealthStatus"
            },
            "title": "Workers",
            "type": "array"
          }
        },
        "required": [
          "status",
          "ready",
          "message",
          "postgres",
          "redis",
          "ai_services",
          "circuit_breakers",
          "workers",
          "timestamp",
          "version"
        ],
        "title": "FullHealthResponse",
        "type": "object"
      },
      "GPUStatsHistoryResponse": {
        "description": "Response schema for GPU stats history endpoint.\n\nUses standard pagination envelope format (NEM-2178):\n- items: GPU stats samples (renamed from 'samples')\n- pagination: Standard pagination metadata",
        "example": {
          "items": [
            {
              "gpu_name": "NVIDIA RTX A5500",
              "inference_fps": 30.5,
              "memory_total": 24000,
              "memory_used": 12000,
              "power_usage": 150.0,
              "recorded_at": "2025-12-27T10:30:00Z",
              "temperature": 65.0,
              "utilization": 75.5
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 300,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "GPU stats samples (chronological order)",
            "items": {
              "$ref": "#/components/schemas/GPUStatsSample"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "GPUStatsHistoryResponse",
        "type": "object"
      },
      "GPUStatsResponse": {
        "description": "Response schema for GPU statistics endpoint.",
        "example": {
          "gpu_name": "NVIDIA RTX A5500",
          "inference_fps": 30.5,
          "memory_total": 24000,
          "memory_used": 12000,
          "power_usage": 150.0,
          "temperature": 65.0,
          "utilization": 75.5
        },
        "properties": {
          "gpu_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU device name (e.g., 'NVIDIA RTX A5500')",
            "title": "Gpu Name"
          },
          "inference_fps": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Inference frames per second",
            "title": "Inference Fps"
          },
          "memory_total": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total GPU memory in MB",
            "title": "Memory Total"
          },
          "memory_used": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU memory used in MB",
            "title": "Memory Used"
          },
          "power_usage": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU power usage in watts",
            "title": "Power Usage"
          },
          "temperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU temperature in Celsius",
            "title": "Temperature"
          },
          "utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU utilization percentage (0-100)",
            "title": "Utilization"
          }
        },
        "title": "GPUStatsResponse",
        "type": "object"
      },
      "GPUStatsSample": {
        "description": "Single time-series sample of GPU statistics.",
        "properties": {
          "gpu_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU device name",
            "title": "Gpu Name"
          },
          "inference_fps": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Inference frames per second",
            "title": "Inference Fps"
          },
          "memory_total": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total GPU memory in MB",
            "title": "Memory Total"
          },
          "memory_used": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU memory used in MB",
            "title": "Memory Used"
          },
          "power_usage": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU power usage in watts",
            "title": "Power Usage"
          },
          "recorded_at": {
            "description": "When the GPU sample was recorded (UTC)",
            "format": "date-time",
            "title": "Recorded At",
            "type": "string"
          },
          "temperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU temperature in Celsius",
            "title": "Temperature"
          },
          "utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU utilization percentage (0-100)",
            "title": "Utilization"
          }
        },
        "required": [
          "recorded_at"
        ],
        "title": "GPUStatsSample",
        "type": "object"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "title": "Detail",
            "type": "array"
          }
        },
        "title": "HTTPValidationError",
        "type": "object"
      },
      "HealthCheckServiceStatus": {
        "description": "Status information for a service component in health checks.\n\nNote: Renamed from ServiceStatus to avoid name collision with\nbackend.api.schemas.services.ServiceStatus (orchestrator enum).",
        "properties": {
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional service-specific details (may contain nested objects)",
            "title": "Details"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional status message or error details",
            "title": "Message"
          },
          "status": {
            "description": "Service status: healthy, unhealthy, or not_initialized",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "status"
        ],
        "title": "HealthCheckServiceStatus",
        "type": "object"
      },
      "HealthEventResponse": {
        "description": "Schema for a health event in the failure history.\n\nRepresents a single health-related event such as a failure, recovery, or restart.",
        "example": {
          "event_type": "failure",
          "message": "Health check failed: connection refused",
          "service": "redis",
          "timestamp": "2025-12-23T10:30:00Z"
        },
        "properties": {
          "event_type": {
            "description": "Type of event: 'failure', 'recovery', or 'restart'",
            "title": "Event Type",
            "type": "string"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional descriptive message about the event",
            "title": "Message"
          },
          "service": {
            "description": "Name of the service this event relates to",
            "title": "Service",
            "type": "string"
          },
          "timestamp": {
            "description": "When the event occurred (UTC)",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "service",
          "event_type"
        ],
        "title": "HealthEventResponse",
        "type": "object"
      },
      "HealthResponse": {
        "description": "Response schema for health check endpoint.",
        "example": {
          "recent_events": [
            {
              "event_type": "recovery",
              "message": "Service recovered",
              "service": "redis",
              "timestamp": "2025-12-23T10:25:00Z"
            },
            {
              "event_type": "failure",
              "message": "Health check failed",
              "service": "redis",
              "timestamp": "2025-12-23T10:20:00Z"
            }
          ],
          "services": {
            "ai": {
              "message": "AI services operational",
              "status": "healthy"
            },
            "database": {
              "message": "Database operational",
              "status": "healthy"
            },
            "redis": {
              "details": {
                "redis_version": "7.0.0"
              },
              "message": "Redis connected",
              "status": "healthy"
            }
          },
          "status": "healthy",
          "timestamp": "2025-12-23T10:30:00"
        },
        "properties": {
          "recent_events": {
            "description": "Recent health events for debugging intermittent issues",
            "items": {
              "$ref": "#/components/schemas/HealthEventResponse"
            },
            "title": "Recent Events",
            "type": "array"
          },
          "services": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HealthCheckServiceStatus"
            },
            "description": "Status of individual services (database, redis, ai)",
            "title": "Services",
            "type": "object"
          },
          "status": {
            "description": "Overall system status: healthy, degraded, or unhealthy",
            "title": "Status",
            "type": "string"
          },
          "timestamp": {
            "description": "Timestamp of health check",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "status",
          "services",
          "timestamp"
        ],
        "title": "HealthResponse",
        "type": "object"
      },
      "HourlyPattern": {
        "description": "Activity pattern for a specific hour.",
        "example": {
          "avg_detections": 2.5,
          "sample_count": 30,
          "std_dev": 0.8
        },
        "properties": {
          "avg_detections": {
            "description": "Average number of detections during this hour",
            "minimum": 0.0,
            "title": "Avg Detections",
            "type": "number"
          },
          "sample_count": {
            "description": "Number of samples used for this calculation",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          },
          "std_dev": {
            "description": "Standard deviation of detection count",
            "minimum": 0.0,
            "title": "Std Dev",
            "type": "number"
          }
        },
        "required": [
          "avg_detections",
          "std_dev",
          "sample_count"
        ],
        "title": "HourlyPattern",
        "type": "object"
      },
      "ImageQualityEnrichment": {
        "description": "Image quality assessment results.",
        "example": {
          "is_blurry": false,
          "is_low_quality": false,
          "quality_issues": [],
          "score": 0.85
        },
        "properties": {
          "is_blurry": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether image is blurry",
            "title": "Is Blurry"
          },
          "is_low_quality": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether image has low quality",
            "title": "Is Low Quality"
          },
          "quality_change_detected": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether sudden quality change was detected",
            "title": "Quality Change Detected"
          },
          "quality_issues": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of detected quality issues",
            "title": "Quality Issues"
          },
          "score": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Quality score (0-100)",
            "title": "Score"
          }
        },
        "title": "ImageQualityEnrichment",
        "type": "object"
      },
      "InfrastructureHealthStatus": {
        "description": "Health status for infrastructure services (postgres, redis).\n\nProvides detailed status including connection info and any error details.",
        "example": {
          "message": "Database operational",
          "name": "postgres",
          "status": "healthy"
        },
        "properties": {
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional details (e.g., redis version)",
            "title": "Details"
          },
          "message": {
            "description": "Status message or error description",
            "title": "Message",
            "type": "string"
          },
          "name": {
            "description": "Service name (e.g., 'postgres', 'redis')",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ServiceHealthState",
            "description": "Current health state"
          }
        },
        "required": [
          "name",
          "status",
          "message"
        ],
        "title": "InfrastructureHealthStatus",
        "type": "object"
      },
      "JobCancelResponse": {
        "description": "Response model for job cancellation request.",
        "example": {
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "message": "Job cancellation requested",
          "status": "failed"
        },
        "properties": {
          "job_id": {
            "description": "Job ID that was cancelled",
            "title": "Job Id",
            "type": "string"
          },
          "message": {
            "description": "Cancellation status message",
            "title": "Message",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatusEnum",
            "description": "New job status after cancellation"
          }
        },
        "required": [
          "job_id",
          "status",
          "message"
        ],
        "title": "JobCancelResponse",
        "type": "object"
      },
      "JobListResponse": {
        "description": "Response model for listing jobs.",
        "example": {
          "jobs": [
            {
              "created_at": "2024-01-15T10:30:00Z",
              "job_id": "550e8400-e29b-41d4-a716-446655440000",
              "job_type": "export",
              "message": "Exporting events: 450/1000",
              "progress": 45,
              "started_at": "2024-01-15T10:30:01Z",
              "status": "running"
            }
          ],
          "total": 1
        },
        "properties": {
          "jobs": {
            "description": "List of jobs",
            "items": {
              "$ref": "#/components/schemas/JobResponse"
            },
            "title": "Jobs",
            "type": "array"
          },
          "total": {
            "description": "Total number of jobs matching filter",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "jobs",
          "total"
        ],
        "title": "JobListResponse",
        "type": "object"
      },
      "JobResponse": {
        "description": "Response model for job status.",
        "example": {
          "created_at": "2024-01-15T10:30:00Z",
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "job_type": "export",
          "message": "Exporting events: 450/1000",
          "progress": 45,
          "started_at": "2024-01-15T10:30:01Z",
          "status": "running"
        },
        "properties": {
          "completed_at": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ISO 8601 timestamp when job finished",
            "title": "Completed At"
          },
          "created_at": {
            "description": "ISO 8601 timestamp when job was created",
            "title": "Created At",
            "type": "string"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message (if failed)",
            "title": "Error"
          },
          "job_id": {
            "description": "Unique job identifier",
            "title": "Job Id",
            "type": "string"
          },
          "job_type": {
            "description": "Type of job (e.g., 'export')",
            "title": "Job Type",
            "type": "string"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable status message",
            "title": "Message"
          },
          "progress": {
            "description": "Progress percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Progress",
            "type": "integer"
          },
          "result": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "description": "Job result data (if completed)",
            "title": "Result"
          },
          "started_at": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ISO 8601 timestamp when job started",
            "title": "Started At"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatusEnum",
            "description": "Current job status"
          }
        },
        "required": [
          "job_id",
          "job_type",
          "status",
          "progress",
          "created_at"
        ],
        "title": "JobResponse",
        "type": "object"
      },
      "JobStatusEnum": {
        "description": "Status of a background job.",
        "enum": [
          "pending",
          "running",
          "completed",
          "failed"
        ],
        "title": "JobStatusEnum",
        "type": "string"
      },
      "JobTypeInfo": {
        "description": "Information about a job type.",
        "example": {
          "description": "Export events to CSV, JSON, or ZIP format",
          "name": "export"
        },
        "properties": {
          "description": {
            "description": "Human-readable description of the job type",
            "title": "Description",
            "type": "string"
          },
          "name": {
            "description": "Job type name (e.g., 'export', 'cleanup')",
            "title": "Name",
            "type": "string"
          }
        },
        "required": [
          "name",
          "description"
        ],
        "title": "JobTypeInfo",
        "type": "object"
      },
      "JobTypesResponse": {
        "description": "Response model for listing job types.",
        "example": {
          "job_types": [
            {
              "description": "Export events to CSV, JSON, or ZIP format",
              "name": "export"
            },
            {
              "description": "Clean up old data and temporary files",
              "name": "cleanup"
            }
          ]
        },
        "properties": {
          "job_types": {
            "description": "List of available job types",
            "items": {
              "$ref": "#/components/schemas/JobTypeInfo"
            },
            "title": "Job Types",
            "type": "array"
          }
        },
        "required": [
          "job_types"
        ],
        "title": "JobTypesResponse",
        "type": "object"
      },
      "LatencyHistorySnapshot": {
        "description": "Single time-bucket snapshot of pipeline latency metrics.",
        "properties": {
          "stages": {
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LatencyHistoryStageStats"
                },
                {
                  "type": "null"
                }
              ]
            },
            "description": "Latency stats for each pipeline stage (None if no samples)",
            "title": "Stages",
            "type": "object"
          },
          "timestamp": {
            "description": "Bucket start time (ISO format)",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "stages"
        ],
        "title": "LatencyHistorySnapshot",
        "type": "object"
      },
      "LatencyHistoryStageStats": {
        "description": "Latency statistics for a single stage in a history snapshot.",
        "properties": {
          "avg_ms": {
            "description": "Average latency in milliseconds",
            "title": "Avg Ms",
            "type": "number"
          },
          "p50_ms": {
            "description": "50th percentile (median) latency",
            "title": "P50 Ms",
            "type": "number"
          },
          "p95_ms": {
            "description": "95th percentile latency",
            "title": "P95 Ms",
            "type": "number"
          },
          "p99_ms": {
            "description": "99th percentile latency",
            "title": "P99 Ms",
            "type": "number"
          },
          "sample_count": {
            "description": "Number of samples in this bucket",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "avg_ms",
          "p50_ms",
          "p95_ms",
          "p99_ms",
          "sample_count"
        ],
        "title": "LatencyHistoryStageStats",
        "type": "object"
      },
      "LeaderboardResponse": {
        "description": "Model leaderboard response.",
        "example": {
          "entries": [
            {
              "contribution_rate": 0.98,
              "event_count": 1200,
              "model_name": "rtdetr",
              "quality_correlation": 0.85
            },
            {
              "contribution_rate": 0.85,
              "event_count": 1050,
              "model_name": "florence",
              "quality_correlation": 0.72
            }
          ],
          "period_days": 30
        },
        "properties": {
          "entries": {
            "items": {
              "$ref": "#/components/schemas/ModelLeaderboardEntry"
            },
            "title": "Entries",
            "type": "array"
          },
          "period_days": {
            "title": "Period Days",
            "type": "integer"
          }
        },
        "required": [
          "entries",
          "period_days"
        ],
        "title": "LeaderboardResponse",
        "type": "object"
      },
      "LicensePlateEnrichment": {
        "description": "License plate detection and OCR results.",
        "example": {
          "bbox": [
            100.0,
            200.0,
            300.0,
            250.0
          ],
          "confidence": 0.92,
          "detected": true,
          "ocr_confidence": 0.88,
          "text": "ABC-1234"
        },
        "properties": {
          "bbox": {
            "anyOf": [
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box [x1, y1, x2, y2]",
            "title": "Bbox"
          },
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detection confidence",
            "title": "Confidence"
          },
          "detected": {
            "default": false,
            "description": "Whether a license plate was detected",
            "title": "Detected",
            "type": "boolean"
          },
          "ocr_confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "OCR confidence",
            "title": "Ocr Confidence"
          },
          "text": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "OCR-extracted plate text",
            "title": "Text"
          }
        },
        "title": "LicensePlateEnrichment",
        "type": "object"
      },
      "LogEntry": {
        "description": "Schema for a single log entry.",
        "example": {
          "camera_id": "front_door",
          "component": "backend.services.detector",
          "detection_id": 456,
          "duration_ms": 150,
          "event_id": 123,
          "extra": {
            "confidence_avg": 0.87,
            "detections_count": 3
          },
          "id": 1,
          "level": "INFO",
          "message": "Detection completed for front_door camera",
          "request_id": "req-550e8400-e29b-41d4",
          "source": "backend",
          "timestamp": "2026-01-03T10:30:00Z"
        },
        "properties": {
          "camera_id": {
            "anyOf": [
              {
                "maxLength": 64,
                "pattern": "^[a-zA-Z0-9_-]+$",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Associated camera ID (alphanumeric, underscore, hyphen only)",
            "title": "Camera Id"
          },
          "component": {
            "description": "Component/module name (e.g., 'backend.services.detector')",
            "maxLength": 200,
            "minLength": 1,
            "title": "Component",
            "type": "string"
          },
          "detection_id": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Associated detection ID",
            "title": "Detection Id"
          },
          "duration_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Operation duration in milliseconds",
            "title": "Duration Ms"
          },
          "event_id": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Associated event ID",
            "title": "Event Id"
          },
          "extra": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional structured data (JSON-serializable)",
            "title": "Extra"
          },
          "id": {
            "description": "Log entry ID",
            "minimum": 1.0,
            "title": "Id",
            "type": "integer"
          },
          "level": {
            "description": "Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
            "pattern": "^(DEBUG|INFO|WARNING|ERROR|CRITICAL)$",
            "title": "Level",
            "type": "string"
          },
          "message": {
            "description": "Log message content",
            "maxLength": 5000,
            "minLength": 1,
            "title": "Message",
            "type": "string"
          },
          "request_id": {
            "anyOf": [
              {
                "maxLength": 128,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Request correlation ID for tracing",
            "title": "Request Id"
          },
          "source": {
            "default": "backend",
            "description": "Log source (backend, frontend)",
            "pattern": "^(backend|frontend)$",
            "title": "Source",
            "type": "string"
          },
          "timestamp": {
            "description": "Log timestamp (UTC)",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "id",
          "timestamp",
          "level",
          "component",
          "message"
        ],
        "title": "LogEntry",
        "type": "object"
      },
      "LogLevelRequest": {
        "description": "Request to change log level.",
        "properties": {
          "level": {
            "description": "New log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
            "title": "Level",
            "type": "string"
          }
        },
        "required": [
          "level"
        ],
        "title": "LogLevelRequest",
        "type": "object"
      },
      "LogLevelResponse": {
        "description": "Response for log level operations.",
        "properties": {
          "level": {
            "description": "Current log level",
            "title": "Level",
            "type": "string"
          },
          "previous_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Previous log level (on change)",
            "title": "Previous Level"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "level",
          "timestamp"
        ],
        "title": "LogLevelResponse",
        "type": "object"
      },
      "LogStats": {
        "description": "Schema for log statistics (dashboard).",
        "example": {
          "by_component": {
            "backend.api.routes": 300,
            "backend.services.analyzer": 400,
            "backend.services.detector": 800
          },
          "by_level": {
            "CRITICAL": 0,
            "DEBUG": 500,
            "ERROR": 12,
            "INFO": 900,
            "WARNING": 45
          },
          "errors_today": 12,
          "top_component": "backend.services.detector",
          "total_today": 1500,
          "warnings_today": 45
        },
        "properties": {
          "by_component": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Counts by component",
            "title": "By Component",
            "type": "object"
          },
          "by_level": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Counts by level",
            "title": "By Level",
            "type": "object"
          },
          "errors_today": {
            "description": "Error count today",
            "minimum": 0.0,
            "title": "Errors Today",
            "type": "integer"
          },
          "top_component": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Most active component",
            "title": "Top Component"
          },
          "total_today": {
            "description": "Total logs today",
            "minimum": 0.0,
            "title": "Total Today",
            "type": "integer"
          },
          "warnings_today": {
            "description": "Warning count today",
            "minimum": 0.0,
            "title": "Warnings Today",
            "type": "integer"
          }
        },
        "required": [
          "total_today",
          "errors_today",
          "warnings_today",
          "by_component",
          "by_level"
        ],
        "title": "LogStats",
        "type": "object"
      },
      "LogsResponse": {
        "description": "Schema for paginated logs response (NEM-2075 pagination envelope).\n\nUses standardized pagination envelope with 'items' and 'pagination' fields.\nSupports both cursor-based pagination (recommended) and offset pagination.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "component": "backend.services.detector",
              "detection_id": 456,
              "duration_ms": 150,
              "event_id": 123,
              "id": 1,
              "level": "INFO",
              "message": "Detection completed",
              "source": "backend",
              "timestamp": "2026-01-03T10:30:00Z"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjYtMDEtMDNUMTA6MzA6MDBaIn0=",
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of log entries",
            "items": {
              "$ref": "#/components/schemas/LogEntry"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "LogsResponse",
        "type": "object"
      },
      "MediaErrorResponse": {
        "description": "Error response for media access failures.",
        "example": {
          "error": "File not found",
          "path": "/export/foscam/front_door/image_001.jpg"
        },
        "properties": {
          "error": {
            "description": "Error message describing what went wrong",
            "maxLength": 500,
            "minLength": 1,
            "title": "Error",
            "type": "string"
          },
          "path": {
            "description": "The path that was attempted to be accessed",
            "maxLength": 4096,
            "minLength": 0,
            "title": "Path",
            "type": "string"
          }
        },
        "required": [
          "error",
          "path"
        ],
        "title": "MediaErrorResponse",
        "type": "object"
      },
      "ModelContributions": {
        "description": "Model contribution flags.",
        "example": {
          "baseline": false,
          "clip": false,
          "clothing": true,
          "cross_camera": false,
          "florence": true,
          "image_quality": true,
          "pet": false,
          "rtdetr": true,
          "vehicle": false,
          "violence": false,
          "weather": true,
          "zones": true
        },
        "properties": {
          "baseline": {
            "default": false,
            "description": "Baseline comparison",
            "title": "Baseline",
            "type": "boolean"
          },
          "clip": {
            "default": false,
            "description": "CLIP embeddings",
            "title": "Clip",
            "type": "boolean"
          },
          "clothing": {
            "default": false,
            "description": "Clothing analysis",
            "title": "Clothing",
            "type": "boolean"
          },
          "cross_camera": {
            "default": false,
            "description": "Cross-camera correlation",
            "title": "Cross Camera",
            "type": "boolean"
          },
          "florence": {
            "default": false,
            "description": "Florence-2 vision attributes",
            "title": "Florence",
            "type": "boolean"
          },
          "image_quality": {
            "default": false,
            "description": "Image quality assessment",
            "title": "Image Quality",
            "type": "boolean"
          },
          "pet": {
            "default": false,
            "description": "Pet classification",
            "title": "Pet",
            "type": "boolean"
          },
          "rtdetr": {
            "default": false,
            "description": "RT-DETR object detection",
            "title": "Rtdetr",
            "type": "boolean"
          },
          "vehicle": {
            "default": false,
            "description": "Vehicle classification",
            "title": "Vehicle",
            "type": "boolean"
          },
          "violence": {
            "default": false,
            "description": "Violence detection",
            "title": "Violence",
            "type": "boolean"
          },
          "weather": {
            "default": false,
            "description": "Weather classification",
            "title": "Weather",
            "type": "boolean"
          },
          "zones": {
            "default": false,
            "description": "Zone analysis",
            "title": "Zones",
            "type": "boolean"
          }
        },
        "title": "ModelContributions",
        "type": "object"
      },
      "ModelLatencyHistoryResponse": {
        "description": "Response schema for Model Zoo latency history endpoint.\n\nReturns time-series latency data for a specific Model Zoo model.\nUsed to populate the dropdown-controlled latency chart.",
        "example": {
          "bucket_seconds": 60,
          "display_name": "YOLO11 License Plate",
          "has_data": true,
          "model_name": "yolo11-license-plate",
          "snapshots": [
            {
              "stats": {
                "avg_ms": 45.0,
                "p50_ms": 42.0,
                "p95_ms": 68.0,
                "sample_count": 15
              },
              "timestamp": "2026-01-04T10:00:00+00:00"
            }
          ],
          "timestamp": "2026-01-04T10:30:00Z",
          "window_minutes": 60
        },
        "properties": {
          "bucket_seconds": {
            "description": "Bucket size for aggregation",
            "minimum": 1.0,
            "title": "Bucket Seconds",
            "type": "integer"
          },
          "display_name": {
            "description": "Human-readable display name",
            "title": "Display Name",
            "type": "string"
          },
          "has_data": {
            "description": "Whether any latency data exists for this model",
            "title": "Has Data",
            "type": "boolean"
          },
          "model_name": {
            "description": "Name of the model this data is for",
            "title": "Model Name",
            "type": "string"
          },
          "snapshots": {
            "description": "Chronologically ordered latency snapshots",
            "items": {
              "$ref": "#/components/schemas/ModelLatencyHistorySnapshot"
            },
            "title": "Snapshots",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp when history was retrieved",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "window_minutes": {
            "description": "Time window covered by the history",
            "minimum": 1.0,
            "title": "Window Minutes",
            "type": "integer"
          }
        },
        "required": [
          "model_name",
          "display_name",
          "snapshots",
          "window_minutes",
          "bucket_seconds",
          "has_data",
          "timestamp"
        ],
        "title": "ModelLatencyHistoryResponse",
        "type": "object"
      },
      "ModelLatencyHistorySnapshot": {
        "description": "Single time-bucket snapshot of Model Zoo model latency.",
        "properties": {
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModelLatencyStageStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency statistics for this time bucket (None if no data)"
          },
          "timestamp": {
            "description": "Bucket start time (ISO format)",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp"
        ],
        "title": "ModelLatencyHistorySnapshot",
        "type": "object"
      },
      "ModelLatencyStageStats": {
        "description": "Latency statistics for a Model Zoo model at a point in time.",
        "properties": {
          "avg_ms": {
            "description": "Average latency in milliseconds",
            "minimum": 0.0,
            "title": "Avg Ms",
            "type": "number"
          },
          "p50_ms": {
            "description": "50th percentile (median) latency in milliseconds",
            "minimum": 0.0,
            "title": "P50 Ms",
            "type": "number"
          },
          "p95_ms": {
            "description": "95th percentile latency in milliseconds",
            "minimum": 0.0,
            "title": "P95 Ms",
            "type": "number"
          },
          "sample_count": {
            "description": "Number of samples in this time bucket",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "avg_ms",
          "p50_ms",
          "p95_ms",
          "sample_count"
        ],
        "title": "ModelLatencyStageStats",
        "type": "object"
      },
      "ModelLeaderboardEntry": {
        "description": "Single entry in model leaderboard.",
        "example": {
          "contribution_rate": 0.85,
          "event_count": 1050,
          "model_name": "florence",
          "quality_correlation": 0.72
        },
        "properties": {
          "contribution_rate": {
            "title": "Contribution Rate",
            "type": "number"
          },
          "event_count": {
            "title": "Event Count",
            "type": "integer"
          },
          "model_name": {
            "title": "Model Name",
            "type": "string"
          },
          "quality_correlation": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quality Correlation"
          }
        },
        "required": [
          "model_name",
          "contribution_rate",
          "quality_correlation",
          "event_count"
        ],
        "title": "ModelLeaderboardEntry",
        "type": "object"
      },
      "ModelPromptResponse": {
        "description": "Response for a single model's prompt configuration.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "You are a home security AI...",
            "temperature": 0.7
          },
          "model_name": "nemotron",
          "updated_at": "2026-01-03T10:30:00Z",
          "version": 3
        },
        "properties": {
          "config": {
            "additionalProperties": true,
            "description": "Current configuration for this model",
            "title": "Config",
            "type": "object"
          },
          "model_name": {
            "description": "Name of the AI model",
            "title": "Model Name",
            "type": "string"
          },
          "updated_at": {
            "description": "When last updated",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "version": {
            "description": "Current version number",
            "minimum": 1.0,
            "title": "Version",
            "type": "integer"
          }
        },
        "required": [
          "model_name",
          "config",
          "version",
          "updated_at"
        ],
        "title": "ModelPromptResponse",
        "type": "object"
      },
      "ModelRegistryResponse": {
        "description": "Response schema for model registry endpoint.\n\nReturns comprehensive information about all models in the Model Zoo\nincluding VRAM budget, current usage, and individual model statuses.",
        "example": {
          "loading_strategy": "sequential",
          "max_concurrent_models": 1,
          "models": [],
          "vram_available_mb": 1350,
          "vram_budget_mb": 1650,
          "vram_used_mb": 300
        },
        "properties": {
          "loading_strategy": {
            "default": "sequential",
            "description": "Model loading strategy (sequential = one at a time)",
            "title": "Loading Strategy",
            "type": "string"
          },
          "max_concurrent_models": {
            "default": 1,
            "description": "Maximum number of models that can be loaded concurrently",
            "minimum": 1.0,
            "title": "Max Concurrent Models",
            "type": "integer"
          },
          "models": {
            "description": "List of all models in the registry with their status",
            "items": {
              "$ref": "#/components/schemas/ModelStatusResponse"
            },
            "title": "Models",
            "type": "array"
          },
          "vram_available_mb": {
            "description": "Available VRAM for loading additional models",
            "minimum": 0.0,
            "title": "Vram Available Mb",
            "type": "integer"
          },
          "vram_budget_mb": {
            "description": "Total VRAM budget available for Model Zoo models (excludes Nemotron and RT-DETRv2)",
            "minimum": 0.0,
            "title": "Vram Budget Mb",
            "type": "integer"
          },
          "vram_used_mb": {
            "description": "Currently used VRAM by loaded models",
            "minimum": 0.0,
            "title": "Vram Used Mb",
            "type": "integer"
          }
        },
        "required": [
          "vram_budget_mb",
          "vram_used_mb",
          "vram_available_mb",
          "models"
        ],
        "title": "ModelRegistryResponse",
        "type": "object"
      },
      "ModelStatusEnum": {
        "description": "Model loading status.",
        "enum": [
          "loaded",
          "unloaded",
          "disabled",
          "loading",
          "error"
        ],
        "title": "ModelStatusEnum",
        "type": "string"
      },
      "ModelStatusResponse": {
        "description": "Status information for a single model in the Model Zoo.\n\nProvides detailed information about a model including:\n- Identity: name, display_name, category\n- Configuration: vram_mb, enabled, available, path\n- Runtime status: status, load_count",
        "example": {
          "available": false,
          "category": "detection",
          "display_name": "YOLO11 License Plate",
          "enabled": true,
          "load_count": 0,
          "name": "yolo11-license-plate",
          "path": "/models/model-zoo/yolo11-license-plate/license-plate-finetune-v1n.pt",
          "status": "unloaded",
          "vram_mb": 300
        },
        "properties": {
          "available": {
            "description": "Whether the model has been successfully loaded at least once",
            "title": "Available",
            "type": "boolean"
          },
          "category": {
            "description": "Model category (detection, recognition, ocr, embedding, etc.)",
            "title": "Category",
            "type": "string"
          },
          "display_name": {
            "description": "Human-readable display name for the model",
            "title": "Display Name",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the model is enabled for use",
            "title": "Enabled",
            "type": "boolean"
          },
          "load_count": {
            "default": 0,
            "description": "Current reference count for loaded model (0 if not loaded)",
            "minimum": 0.0,
            "title": "Load Count",
            "type": "integer"
          },
          "name": {
            "description": "Unique identifier for the model (e.g., 'yolo11-license-plate')",
            "title": "Name",
            "type": "string"
          },
          "path": {
            "description": "HuggingFace repo path or local file path for the model",
            "title": "Path",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ModelStatusEnum",
            "description": "Current loading status: loaded, unloaded, disabled, loading, error"
          },
          "vram_mb": {
            "description": "Estimated VRAM usage in megabytes when loaded",
            "minimum": 0.0,
            "title": "Vram Mb",
            "type": "integer"
          }
        },
        "required": [
          "name",
          "display_name",
          "vram_mb",
          "status",
          "category",
          "enabled",
          "available",
          "path"
        ],
        "title": "ModelStatusResponse",
        "type": "object"
      },
      "ModelZooStatusItem": {
        "description": "Status information for a single Model Zoo model.\n\nUsed in the compact status card display for Model Zoo models.",
        "properties": {
          "category": {
            "description": "Model category (detection, classification, segmentation, etc.)",
            "title": "Category",
            "type": "string"
          },
          "display_name": {
            "description": "Human-readable display name",
            "title": "Display Name",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the model is enabled for use",
            "title": "Enabled",
            "type": "boolean"
          },
          "last_used_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of last model usage (null if never used)",
            "title": "Last Used At"
          },
          "name": {
            "description": "Model identifier (e.g., 'yolo11-license-plate')",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ModelStatusEnum",
            "description": "Current status: loaded (green), unloaded (gray), disabled (yellow)"
          },
          "vram_mb": {
            "description": "VRAM usage in megabytes when loaded",
            "minimum": 0.0,
            "title": "Vram Mb",
            "type": "integer"
          }
        },
        "required": [
          "name",
          "display_name",
          "category",
          "status",
          "vram_mb",
          "enabled"
        ],
        "title": "ModelZooStatusItem",
        "type": "object"
      },
      "ModelZooStatusResponse": {
        "description": "Response schema for Model Zoo status endpoint.\n\nReturns status information for all 18 Model Zoo models organized by category.\nUsed to populate the compact status cards in the UI.",
        "example": {
          "disabled_count": 3,
          "loaded_count": 0,
          "models": [
            {
              "category": "detection",
              "display_name": "YOLO11 License Plate",
              "enabled": true,
              "name": "yolo11-license-plate",
              "status": "unloaded",
              "vram_mb": 300
            }
          ],
          "timestamp": "2026-01-04T10:30:00Z",
          "total_models": 18,
          "vram_budget_mb": 1650,
          "vram_used_mb": 0
        },
        "properties": {
          "disabled_count": {
            "description": "Number of disabled models",
            "minimum": 0.0,
            "title": "Disabled Count",
            "type": "integer"
          },
          "loaded_count": {
            "description": "Number of currently loaded models",
            "minimum": 0.0,
            "title": "Loaded Count",
            "type": "integer"
          },
          "models": {
            "description": "List of all Model Zoo models with their current status",
            "items": {
              "$ref": "#/components/schemas/ModelZooStatusItem"
            },
            "title": "Models",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "total_models": {
            "description": "Total number of models in the registry",
            "minimum": 0.0,
            "title": "Total Models",
            "type": "integer"
          },
          "vram_budget_mb": {
            "description": "Total VRAM budget for Model Zoo",
            "minimum": 0.0,
            "title": "Vram Budget Mb",
            "type": "integer"
          },
          "vram_used_mb": {
            "description": "Currently used VRAM",
            "minimum": 0.0,
            "title": "Vram Used Mb",
            "type": "integer"
          }
        },
        "required": [
          "models",
          "total_models",
          "loaded_count",
          "disabled_count",
          "vram_budget_mb",
          "vram_used_mb",
          "timestamp"
        ],
        "title": "ModelZooStatusResponse",
        "type": "object"
      },
      "NotificationChannel": {
        "description": "Notification channel types.",
        "enum": [
          "email",
          "webhook",
          "push"
        ],
        "title": "NotificationChannel",
        "type": "string"
      },
      "NotificationConfigResponse": {
        "description": "Schema for notification configuration status.",
        "example": {
          "available_channels": [
            "email",
            "webhook"
          ],
          "default_email_recipients": [
            "user@example.com"
          ],
          "default_webhook_url": "https://example.com/webhook",
          "email_configured": true,
          "notification_enabled": true,
          "push_configured": false,
          "smtp_from_address": "alerts@example.com",
          "smtp_host": "smtp.example.com",
          "smtp_port": 587,
          "smtp_use_tls": true,
          "webhook_configured": true,
          "webhook_timeout_seconds": 30
        },
        "properties": {
          "available_channels": {
            "description": "List of channels that are properly configured",
            "items": {
              "$ref": "#/components/schemas/NotificationChannel"
            },
            "title": "Available Channels",
            "type": "array"
          },
          "default_email_recipients": {
            "description": "Default email recipients",
            "items": {
              "type": "string"
            },
            "title": "Default Email Recipients",
            "type": "array"
          },
          "default_webhook_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Default webhook URL",
            "title": "Default Webhook Url"
          },
          "email_configured": {
            "description": "Whether email (SMTP) is configured",
            "title": "Email Configured",
            "type": "boolean"
          },
          "notification_enabled": {
            "description": "Whether notifications are enabled",
            "title": "Notification Enabled",
            "type": "boolean"
          },
          "push_configured": {
            "description": "Whether push notifications are configured",
            "title": "Push Configured",
            "type": "boolean"
          },
          "smtp_from_address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configured sender email",
            "title": "Smtp From Address"
          },
          "smtp_host": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configured SMTP host (if any)",
            "title": "Smtp Host"
          },
          "smtp_port": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configured SMTP port",
            "title": "Smtp Port"
          },
          "smtp_use_tls": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether TLS is enabled for SMTP",
            "title": "Smtp Use Tls"
          },
          "webhook_configured": {
            "description": "Whether webhook is configured",
            "title": "Webhook Configured",
            "type": "boolean"
          },
          "webhook_timeout_seconds": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Webhook request timeout",
            "title": "Webhook Timeout Seconds"
          }
        },
        "required": [
          "notification_enabled",
          "email_configured",
          "webhook_configured",
          "push_configured",
          "available_channels"
        ],
        "title": "NotificationConfigResponse",
        "type": "object"
      },
      "NotificationPreferencesResponse": {
        "description": "Schema for notification preferences response.",
        "example": {
          "enabled": true,
          "id": 1,
          "risk_filters": [
            "critical",
            "high",
            "medium"
          ],
          "sound": "default"
        },
        "properties": {
          "enabled": {
            "description": "Whether notifications are globally enabled",
            "title": "Enabled",
            "type": "boolean"
          },
          "id": {
            "default": 1,
            "description": "Preferences ID (always 1, singleton)",
            "title": "Id",
            "type": "integer"
          },
          "risk_filters": {
            "description": "Risk levels that trigger notifications (critical, high, medium, low)",
            "items": {
              "type": "string"
            },
            "title": "Risk Filters",
            "type": "array"
          },
          "sound": {
            "description": "Notification sound (none, default, alert, chime, urgent)",
            "title": "Sound",
            "type": "string"
          }
        },
        "required": [
          "enabled",
          "sound",
          "risk_filters"
        ],
        "title": "NotificationPreferencesResponse",
        "type": "object"
      },
      "NotificationPreferencesUpdate": {
        "description": "Schema for updating notification preferences.",
        "example": {
          "enabled": true,
          "risk_filters": [
            "critical",
            "high"
          ],
          "sound": "alert"
        },
        "properties": {
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether notifications are globally enabled",
            "title": "Enabled"
          },
          "risk_filters": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk levels that trigger notifications (critical, high, medium, low)",
            "title": "Risk Filters"
          },
          "sound": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Notification sound (none, default, alert, chime, urgent)",
            "title": "Sound"
          }
        },
        "title": "NotificationPreferencesUpdate",
        "type": "object"
      },
      "ObjectBaseline": {
        "description": "Baseline statistics for a specific object class.",
        "example": {
          "avg_hourly": 2.3,
          "peak_hour": 17,
          "total_detections": 550
        },
        "properties": {
          "avg_hourly": {
            "description": "Average hourly detection count for this object type",
            "minimum": 0.0,
            "title": "Avg Hourly",
            "type": "number"
          },
          "peak_hour": {
            "description": "Hour with most detections of this type (0-23)",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Peak Hour",
            "type": "integer"
          },
          "total_detections": {
            "description": "Total detections of this type in the baseline period",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          }
        },
        "required": [
          "avg_hourly",
          "peak_hour",
          "total_detections"
        ],
        "title": "ObjectBaseline",
        "type": "object"
      },
      "ObjectDistributionDataPoint": {
        "description": "Schema for a single object distribution data point.",
        "example": {
          "count": 120,
          "object_type": "person",
          "percentage": 45.5
        },
        "properties": {
          "count": {
            "description": "Number of detections for this object type",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "object_type": {
            "description": "Detected object type (e.g., 'person', 'car')",
            "title": "Object Type",
            "type": "string"
          },
          "percentage": {
            "description": "Percentage of total detections (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Percentage",
            "type": "number"
          }
        },
        "required": [
          "object_type",
          "count",
          "percentage"
        ],
        "title": "ObjectDistributionDataPoint",
        "type": "object"
      },
      "ObjectDistributionResponse": {
        "description": "Schema for detection counts by object type.",
        "example": {
          "end_date": "2025-01-07",
          "object_types": [
            {
              "count": 120,
              "object_type": "person",
              "percentage": 45.5
            },
            {
              "count": 80,
              "object_type": "car",
              "percentage": 30.3
            },
            {
              "count": 64,
              "object_type": "dog",
              "percentage": 24.2
            }
          ],
          "start_date": "2025-01-01",
          "total_detections": 264
        },
        "properties": {
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "object_types": {
            "description": "Detection counts by object type",
            "items": {
              "$ref": "#/components/schemas/ObjectDistributionDataPoint"
            },
            "title": "Object Types",
            "type": "array"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          },
          "total_detections": {
            "description": "Total detections in date range",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          }
        },
        "required": [
          "object_types",
          "total_detections",
          "start_date",
          "end_date"
        ],
        "title": "ObjectDistributionResponse",
        "type": "object"
      },
      "PaginationInfo": {
        "description": "Pagination metadata for list responses (NEM-2075).",
        "properties": {
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current cursor position",
            "title": "Cursor"
          },
          "has_more": {
            "default": false,
            "description": "Whether more results are available",
            "title": "Has More",
            "type": "boolean"
          },
          "limit": {
            "description": "Page size (1-1000)",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "type": "integer"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Cursor for next page",
            "title": "Next Cursor"
          },
          "offset": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Page offset (0-based, for offset pagination)",
            "title": "Offset"
          },
          "total": {
            "description": "Total count matching filters",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "limit"
        ],
        "title": "PaginationInfo",
        "type": "object"
      },
      "PaginationMeta": {
        "description": "Pagination metadata for list responses.\n\nContains information about the current page and total results.\nSupports both offset-based and cursor-based pagination.",
        "example": {
          "has_more": true,
          "limit": 50,
          "next_cursor": "eyJpZCI6IDUwfQ",
          "offset": 0,
          "total": 150
        },
        "properties": {
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current cursor position (cursor-based pagination)",
            "title": "Cursor"
          },
          "has_more": {
            "description": "Whether more items are available beyond this page",
            "title": "Has More",
            "type": "boolean"
          },
          "limit": {
            "description": "Maximum number of items returned per page",
            "maximum": 10000.0,
            "minimum": 1.0,
            "title": "Limit",
            "type": "integer"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Cursor for the next page of results",
            "title": "Next Cursor"
          },
          "offset": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of items skipped (offset-based pagination)",
            "title": "Offset"
          },
          "total": {
            "description": "Total number of items matching the query",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "limit",
          "has_more"
        ],
        "title": "PaginationMeta",
        "type": "object"
      },
      "PetEnrichment": {
        "description": "Pet classification results for false positive reduction.",
        "example": {
          "confidence": 0.94,
          "detected": true,
          "is_household_pet": true,
          "type": "dog"
        },
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Classification confidence",
            "title": "Confidence"
          },
          "detected": {
            "default": false,
            "description": "Whether a pet was detected",
            "title": "Detected",
            "type": "boolean"
          },
          "is_household_pet": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether classified as household pet",
            "title": "Is Household Pet"
          },
          "type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Pet type (cat, dog)",
            "title": "Type"
          }
        },
        "title": "PetEnrichment",
        "type": "object"
      },
      "PipelineLatencies": {
        "description": "Latency statistics for all pipeline stages.\n\nPipeline stages:\n- watch: File watcher detecting new images (file event -> queue)\n- detect: RT-DETRv2 object detection (image -> detections)\n- batch: Batch aggregation window (detections -> batch)\n- analyze: Nemotron LLM risk analysis (batch -> event)",
        "example": {
          "analyze": {
            "avg_ms": 5000.0,
            "max_ms": 15000.0,
            "min_ms": 2000.0,
            "p50_ms": 4500.0,
            "p95_ms": 12000.0,
            "p99_ms": 14000.0,
            "sample_count": 100
          },
          "batch": {
            "avg_ms": 30000.0,
            "max_ms": 90000.0,
            "min_ms": 5000.0,
            "p50_ms": 25000.0,
            "p95_ms": 80000.0,
            "p99_ms": 88000.0,
            "sample_count": 100
          },
          "detect": {
            "avg_ms": 200.0,
            "max_ms": 800.0,
            "min_ms": 100.0,
            "p50_ms": 180.0,
            "p95_ms": 600.0,
            "p99_ms": 750.0,
            "sample_count": 500
          },
          "watch": {
            "avg_ms": 10.0,
            "max_ms": 50.0,
            "min_ms": 5.0,
            "p50_ms": 8.0,
            "p95_ms": 40.0,
            "p99_ms": 48.0,
            "sample_count": 500
          }
        },
        "properties": {
          "analyze": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM analysis stage latency (Nemotron inference)"
          },
          "batch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Batch aggregation window time"
          },
          "detect": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object detection stage latency (RT-DETRv2 inference)"
          },
          "watch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "File watcher stage latency (file event to queue)"
          }
        },
        "title": "PipelineLatencies",
        "type": "object"
      },
      "PipelineLatencyHistoryResponse": {
        "description": "Response schema for pipeline latency history endpoint.\n\nProvides time-series latency data for charting and trend analysis.\nEach snapshot contains aggregated metrics for a time bucket.",
        "example": {
          "bucket_seconds": 60,
          "snapshots": [
            {
              "stages": {
                "watch_to_detect": {
                  "avg_ms": 50.0,
                  "p50_ms": 45.0,
                  "p95_ms": 120.0,
                  "p99_ms": 150.0,
                  "sample_count": 15
                }
              },
              "timestamp": "2025-12-28T10:00:00+00:00"
            }
          ],
          "timestamp": "2025-12-28T10:30:00Z",
          "window_minutes": 60
        },
        "properties": {
          "bucket_seconds": {
            "description": "Bucket size for aggregation",
            "minimum": 1.0,
            "title": "Bucket Seconds",
            "type": "integer"
          },
          "snapshots": {
            "description": "Chronologically ordered latency snapshots",
            "items": {
              "$ref": "#/components/schemas/LatencyHistorySnapshot"
            },
            "title": "Snapshots",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp when history was retrieved",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "window_minutes": {
            "description": "Time window covered by the history",
            "minimum": 1.0,
            "title": "Window Minutes",
            "type": "integer"
          }
        },
        "required": [
          "snapshots",
          "window_minutes",
          "bucket_seconds",
          "timestamp"
        ],
        "title": "PipelineLatencyHistoryResponse",
        "type": "object"
      },
      "PipelineLatencyResponse": {
        "description": "Response schema for pipeline latency endpoint.\n\nProvides latency metrics for each stage transition in the AI pipeline:\n- watch_to_detect: Time from file watcher detecting image to RT-DETR processing start\n- detect_to_batch: Time from detection completion to batch aggregation\n- batch_to_analyze: Time from batch completion to Nemotron analysis start\n- total_pipeline: Total end-to-end processing time",
        "example": {
          "batch_to_analyze": {
            "avg_ms": 5000.0,
            "max_ms": 15000.0,
            "min_ms": 2000.0,
            "p50_ms": 4500.0,
            "p95_ms": 12000.0,
            "p99_ms": 14000.0,
            "sample_count": 100
          },
          "detect_to_batch": {
            "avg_ms": 100.0,
            "max_ms": 500.0,
            "min_ms": 20.0,
            "p50_ms": 80.0,
            "p95_ms": 400.0,
            "p99_ms": 480.0,
            "sample_count": 500
          },
          "timestamp": "2025-12-28T10:30:00Z",
          "total_pipeline": {
            "avg_ms": 35000.0,
            "max_ms": 120000.0,
            "min_ms": 10000.0,
            "p50_ms": 30000.0,
            "p95_ms": 100000.0,
            "p99_ms": 110000.0,
            "sample_count": 100
          },
          "watch_to_detect": {
            "avg_ms": 50.0,
            "max_ms": 200.0,
            "min_ms": 10.0,
            "p50_ms": 40.0,
            "p95_ms": 150.0,
            "p99_ms": 180.0,
            "sample_count": 500
          },
          "window_minutes": 60
        },
        "properties": {
          "batch_to_analyze": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency from batch to Nemotron analysis"
          },
          "detect_to_batch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency from detection to batch aggregation"
          },
          "timestamp": {
            "description": "Timestamp of latency snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "total_pipeline": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total end-to-end pipeline latency"
          },
          "watch_to_detect": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency from file detection to RT-DETR processing"
          },
          "window_minutes": {
            "description": "Time window used for calculating statistics",
            "minimum": 1.0,
            "title": "Window Minutes",
            "type": "integer"
          }
        },
        "required": [
          "window_minutes",
          "timestamp"
        ],
        "title": "PipelineLatencyResponse",
        "type": "object"
      },
      "PipelineStageLatency": {
        "description": "Latency statistics for a single pipeline transition stage.\n\nTracks time between pipeline stages:\n- watch_to_detect: File detection to RT-DETR processing\n- detect_to_batch: Detection to batch aggregation\n- batch_to_analyze: Batch to Nemotron analysis\n- total_pipeline: End-to-end latency",
        "example": {
          "avg_ms": 150.5,
          "max_ms": 500.0,
          "min_ms": 50.0,
          "p50_ms": 120.0,
          "p95_ms": 400.0,
          "p99_ms": 480.0,
          "sample_count": 100
        },
        "properties": {
          "avg_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Average latency in milliseconds",
            "title": "Avg Ms"
          },
          "max_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum latency in milliseconds",
            "title": "Max Ms"
          },
          "min_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum latency in milliseconds",
            "title": "Min Ms"
          },
          "p50_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "50th percentile (median) latency in milliseconds",
            "title": "P50 Ms"
          },
          "p95_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "95th percentile latency in milliseconds",
            "title": "P95 Ms"
          },
          "p99_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "99th percentile latency in milliseconds",
            "title": "P99 Ms"
          },
          "sample_count": {
            "description": "Number of samples used to calculate statistics",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "sample_count"
        ],
        "title": "PipelineStageLatency",
        "type": "object"
      },
      "PipelineStateResponse": {
        "description": "Response for pipeline state inspection.",
        "properties": {
          "correlation_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Correlation ID from request",
            "title": "Correlation Id"
          },
          "queue_depths": {
            "$ref": "#/components/schemas/QueueDepths",
            "description": "Current queue depths"
          },
          "recent_errors": {
            "description": "Recent errors (last 10)",
            "items": {
              "$ref": "#/components/schemas/RecentError"
            },
            "title": "Recent Errors",
            "type": "array"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          },
          "workers": {
            "$ref": "#/components/schemas/PipelineWorkersStatus",
            "description": "Worker status"
          }
        },
        "required": [
          "queue_depths",
          "workers",
          "timestamp"
        ],
        "title": "PipelineStateResponse",
        "type": "object"
      },
      "PipelineStatusResponse": {
        "description": "Combined status of all pipeline operations.\n\nProvides visibility into:\n- FileWatcher: Monitoring camera directories for new uploads\n- BatchAggregator: Grouping detections into time-based batches\n- DegradationManager: Graceful degradation and service health",
        "example": {
          "batch_aggregator": {
            "active_batches": 1,
            "batch_window_seconds": 90,
            "batches": [],
            "idle_timeout_seconds": 30
          },
          "degradation": {
            "available_features": [
              "detection",
              "analysis",
              "events",
              "media"
            ],
            "fallback_queues": {},
            "is_degraded": false,
            "memory_queue_size": 0,
            "mode": "normal",
            "redis_healthy": true,
            "services": []
          },
          "file_watcher": {
            "camera_root": "/export/foscam",
            "observer_type": "native",
            "pending_tasks": 0,
            "running": true
          },
          "timestamp": "2025-12-30T10:30:00Z"
        },
        "properties": {
          "batch_aggregator": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BatchAggregatorStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "BatchAggregator service status (null if not running)"
          },
          "degradation": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DegradationStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "DegradationManager service status (null if not initialized)"
          },
          "file_watcher": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FileWatcherStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "FileWatcher service status (null if not running)"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp"
        ],
        "title": "PipelineStatusResponse",
        "type": "object"
      },
      "PipelineWorkerStatus": {
        "description": "Status of a pipeline worker.",
        "properties": {
          "error_count": {
            "default": 0,
            "description": "Number of recent errors",
            "title": "Error Count",
            "type": "integer"
          },
          "last_activity": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ISO timestamp of last activity",
            "title": "Last Activity"
          },
          "name": {
            "description": "Worker name",
            "title": "Name",
            "type": "string"
          },
          "running": {
            "description": "Whether worker is currently running",
            "title": "Running",
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "running"
        ],
        "title": "PipelineWorkerStatus",
        "type": "object"
      },
      "PipelineWorkersStatus": {
        "description": "Status of all pipeline workers.",
        "properties": {
          "analyzer": {
            "$ref": "#/components/schemas/PipelineWorkerStatus",
            "description": "Analyzer worker status"
          },
          "detector": {
            "$ref": "#/components/schemas/PipelineWorkerStatus",
            "description": "Detector worker status"
          },
          "file_watcher": {
            "$ref": "#/components/schemas/PipelineWorkerStatus",
            "description": "File watcher status"
          }
        },
        "required": [
          "file_watcher",
          "detector",
          "analyzer"
        ],
        "title": "PipelineWorkersStatus",
        "type": "object"
      },
      "PoseEnrichment": {
        "description": "Pose estimation results (placeholder for future ViTPose integration).",
        "example": {
          "action": "walking",
          "confidence": 0.82,
          "keypoints": [
            [
              100,
              150,
              0.9
            ],
            [
              120,
              160,
              0.85
            ]
          ]
        },
        "properties": {
          "action": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Recognized action (walking, running, etc.)",
            "title": "Action"
          },
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Action confidence",
            "title": "Confidence"
          },
          "keypoints": {
            "anyOf": [
              {
                "items": {
                  "items": {
                    "type": "number"
                  },
                  "type": "array"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Body keypoints [[x, y, conf], ...]",
            "title": "Keypoints"
          }
        },
        "title": "PoseEnrichment",
        "type": "object"
      },
      "ProfileStartResponse": {
        "description": "Response for starting profiling.",
        "properties": {
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "started_at": {
            "description": "ISO timestamp when profiling started",
            "title": "Started At",
            "type": "string"
          },
          "status": {
            "description": "Profiling status ('started' or 'already_running')",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "status",
          "started_at",
          "message"
        ],
        "title": "ProfileStartResponse",
        "type": "object"
      },
      "ProfileStatsResponse": {
        "description": "Response for profiling statistics.",
        "properties": {
          "is_profiling": {
            "description": "Whether profiling is currently active",
            "title": "Is Profiling",
            "type": "boolean"
          },
          "last_profile_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to last saved profile",
            "title": "Last Profile Path"
          },
          "stats_text": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable profiling statistics",
            "title": "Stats Text"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "is_profiling",
          "timestamp"
        ],
        "title": "ProfileStatsResponse",
        "type": "object"
      },
      "ProfileStopResponse": {
        "description": "Response for stopping profiling.",
        "properties": {
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "profile_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to saved profile file",
            "title": "Profile Path"
          },
          "status": {
            "description": "Profiling status ('stopped' or 'not_running')",
            "title": "Status",
            "type": "string"
          },
          "stopped_at": {
            "description": "ISO timestamp when profiling stopped",
            "title": "Stopped At",
            "type": "string"
          }
        },
        "required": [
          "status",
          "stopped_at",
          "message"
        ],
        "title": "ProfileStopResponse",
        "type": "object"
      },
      "PromptConfigRequest": {
        "description": "Request to update a model's prompt configuration (database-backed).\n\nUsed by the Prompt Playground \"Save\" functionality to persist\nprompt configurations to the database.",
        "example": {
          "maxTokens": 2048,
          "systemPrompt": "You are a home security AI assistant...",
          "temperature": 0.7
        },
        "properties": {
          "maxTokens": {
            "default": 2048,
            "description": "Maximum tokens in response (100-8192)",
            "maximum": 8192.0,
            "minimum": 100.0,
            "title": "Maxtokens",
            "type": "integer"
          },
          "systemPrompt": {
            "description": "Full system prompt text for the model",
            "minLength": 1,
            "title": "Systemprompt",
            "type": "string"
          },
          "temperature": {
            "default": 0.7,
            "description": "LLM temperature setting (0-2)",
            "maximum": 2.0,
            "minimum": 0.0,
            "title": "Temperature",
            "type": "number"
          }
        },
        "required": [
          "systemPrompt"
        ],
        "title": "PromptConfigRequest",
        "type": "object"
      },
      "PromptConfigResponse": {
        "description": "Response containing a model's prompt configuration (database-backed).\n\nReturned when retrieving or updating prompt configurations.",
        "example": {
          "maxTokens": 2048,
          "model": "nemotron",
          "systemPrompt": "You are a home security AI assistant...",
          "temperature": 0.7,
          "updatedAt": "2026-01-03T10:30:00Z",
          "version": 3
        },
        "properties": {
          "maxTokens": {
            "description": "Maximum tokens in response (100-8192)",
            "title": "Maxtokens",
            "type": "integer"
          },
          "model": {
            "description": "Model name",
            "title": "Model",
            "type": "string"
          },
          "systemPrompt": {
            "description": "Full system prompt text for the model",
            "title": "Systemprompt",
            "type": "string"
          },
          "temperature": {
            "description": "LLM temperature setting (0-2)",
            "title": "Temperature",
            "type": "number"
          },
          "updatedAt": {
            "description": "When the configuration was last updated",
            "format": "date-time",
            "title": "Updatedat",
            "type": "string"
          },
          "version": {
            "description": "Configuration version number",
            "minimum": 1.0,
            "title": "Version",
            "type": "integer"
          }
        },
        "required": [
          "model",
          "systemPrompt",
          "temperature",
          "maxTokens",
          "version",
          "updatedAt"
        ],
        "title": "PromptConfigResponse",
        "type": "object"
      },
      "PromptExportResponse": {
        "description": "Response containing all prompt configurations for export.",
        "example": {
          "exported_at": "2026-01-03T10:30:00Z",
          "prompts": {
            "florence2": {
              "vqa_queries": [
                "What is this person wearing?"
              ]
            },
            "nemotron": {
              "max_tokens": 2048,
              "system_prompt": "You are a home security AI...",
              "temperature": 0.7
            }
          },
          "version": "1.0"
        },
        "properties": {
          "exported_at": {
            "description": "When the export was created",
            "format": "date-time",
            "title": "Exported At",
            "type": "string"
          },
          "prompts": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "description": "All model configurations keyed by model name",
            "title": "Prompts",
            "type": "object"
          },
          "version": {
            "default": "1.0",
            "description": "Export format version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "exported_at",
          "prompts"
        ],
        "title": "PromptExportResponse",
        "type": "object"
      },
      "PromptHistoryEntry": {
        "description": "A single entry in prompt version history.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "Previous version of prompt...",
            "temperature": 0.7
          },
          "created_at": "2026-01-02T14:00:00Z",
          "created_by": "admin",
          "description": "Initial prompt configuration",
          "version": 2
        },
        "properties": {
          "config": {
            "additionalProperties": true,
            "description": "Configuration at this version",
            "title": "Config",
            "type": "object"
          },
          "created_at": {
            "description": "When this version was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "created_by": {
            "default": "system",
            "description": "Who created this version",
            "title": "Created By",
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Description of changes",
            "title": "Description"
          },
          "version": {
            "description": "Version number",
            "minimum": 1.0,
            "title": "Version",
            "type": "integer"
          }
        },
        "required": [
          "version",
          "config",
          "created_at"
        ],
        "title": "PromptHistoryEntry",
        "type": "object"
      },
      "PromptHistoryResponse": {
        "description": "Response containing version history for a model's prompts.",
        "example": {
          "model_name": "nemotron",
          "total_versions": 3,
          "versions": [
            {
              "config": {
                "system_prompt": "...",
                "temperature": 0.8
              },
              "created_at": "2026-01-03T10:30:00Z",
              "created_by": "admin",
              "description": "Added weather context",
              "version": 3
            },
            {
              "config": {
                "system_prompt": "...",
                "temperature": 0.7
              },
              "created_at": "2026-01-02T14:00:00Z",
              "created_by": "system",
              "description": "Initial configuration",
              "version": 2
            }
          ]
        },
        "properties": {
          "model_name": {
            "title": "Model Name",
            "type": "string"
          },
          "total_versions": {
            "title": "Total Versions",
            "type": "integer"
          },
          "versions": {
            "items": {
              "$ref": "#/components/schemas/PromptHistoryEntry"
            },
            "title": "Versions",
            "type": "array"
          }
        },
        "required": [
          "model_name",
          "versions",
          "total_versions"
        ],
        "title": "PromptHistoryResponse",
        "type": "object"
      },
      "PromptImportRequest": {
        "description": "Request to import prompt configurations.",
        "example": {
          "overwrite": true,
          "prompts": {
            "nemotron": {
              "max_tokens": 2048,
              "system_prompt": "Imported system prompt...",
              "temperature": 0.7
            }
          }
        },
        "properties": {
          "overwrite": {
            "default": false,
            "description": "Whether to overwrite existing configurations",
            "title": "Overwrite",
            "type": "boolean"
          },
          "prompts": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "description": "Model configurations to import, keyed by model name",
            "title": "Prompts",
            "type": "object"
          }
        },
        "required": [
          "prompts"
        ],
        "title": "PromptImportRequest",
        "type": "object"
      },
      "PromptImportResponse": {
        "description": "Response after importing prompt configurations.",
        "example": {
          "errors": [],
          "imported_count": 3,
          "message": "Successfully imported 3 prompt configurations",
          "skipped_count": 1
        },
        "properties": {
          "errors": {
            "description": "Any errors encountered",
            "items": {
              "type": "string"
            },
            "title": "Errors",
            "type": "array"
          },
          "imported_count": {
            "description": "Number of models imported",
            "minimum": 0.0,
            "title": "Imported Count",
            "type": "integer"
          },
          "message": {
            "title": "Message",
            "type": "string"
          },
          "skipped_count": {
            "description": "Number of models skipped",
            "minimum": 0.0,
            "title": "Skipped Count",
            "type": "integer"
          }
        },
        "required": [
          "imported_count",
          "skipped_count",
          "message"
        ],
        "title": "PromptImportResponse",
        "type": "object"
      },
      "PromptImprovements": {
        "description": "Prompt improvement suggestions from self-evaluation.",
        "example": {
          "confusing_sections": [
            "Zone overlap handling unclear"
          ],
          "format_suggestions": [
            "Add structured detection summary"
          ],
          "missing_context": [
            "Time since last motion event",
            "Weather conditions"
          ],
          "model_gaps": [
            "Pet detection model not active"
          ],
          "unused_data": [
            "Vehicle color data not utilized"
          ]
        },
        "properties": {
          "confusing_sections": {
            "items": {
              "type": "string"
            },
            "title": "Confusing Sections",
            "type": "array"
          },
          "format_suggestions": {
            "items": {
              "type": "string"
            },
            "title": "Format Suggestions",
            "type": "array"
          },
          "missing_context": {
            "items": {
              "type": "string"
            },
            "title": "Missing Context",
            "type": "array"
          },
          "model_gaps": {
            "items": {
              "type": "string"
            },
            "title": "Model Gaps",
            "type": "array"
          },
          "unused_data": {
            "items": {
              "type": "string"
            },
            "title": "Unused Data",
            "type": "array"
          }
        },
        "title": "PromptImprovements",
        "type": "object"
      },
      "PromptRestoreRequest": {
        "description": "Request to restore a specific version of a prompt.",
        "example": {
          "description": "Restoring to version 2 due to regression in analysis quality"
        },
        "properties": {
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional description for the restore action",
            "title": "Description"
          }
        },
        "title": "PromptRestoreRequest",
        "type": "object"
      },
      "PromptRestoreResponse": {
        "description": "Response after restoring a prompt version.",
        "example": {
          "message": "Successfully restored version 2 as new version 4",
          "model_name": "nemotron",
          "new_version": 4,
          "restored_version": 2
        },
        "properties": {
          "message": {
            "title": "Message",
            "type": "string"
          },
          "model_name": {
            "title": "Model Name",
            "type": "string"
          },
          "new_version": {
            "title": "New Version",
            "type": "integer"
          },
          "restored_version": {
            "title": "Restored Version",
            "type": "integer"
          }
        },
        "required": [
          "model_name",
          "restored_version",
          "new_version",
          "message"
        ],
        "title": "PromptRestoreResponse",
        "type": "object"
      },
      "PromptTestRequest": {
        "description": "Request to test a modified prompt against an event.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "Modified prompt for testing...",
            "temperature": 0.7
          },
          "event_id": 12345,
          "model": "nemotron"
        },
        "properties": {
          "config": {
            "additionalProperties": true,
            "description": "Modified configuration to test",
            "title": "Config",
            "type": "object"
          },
          "event_id": {
            "description": "Event ID to test against",
            "minimum": 1.0,
            "title": "Event Id",
            "type": "integer"
          },
          "model": {
            "description": "Model name to test (nemotron, florence2, etc.)",
            "title": "Model",
            "type": "string"
          }
        },
        "required": [
          "model",
          "config",
          "event_id"
        ],
        "title": "PromptTestRequest",
        "type": "object"
      },
      "PromptTestResponse": {
        "description": "Response from testing a modified prompt.",
        "example": {
          "after": {
            "risk_level": "low",
            "score": 45,
            "summary": "Regular visitor detected - matches known delivery pattern"
          },
          "before": {
            "risk_level": "medium",
            "score": 65,
            "summary": "Person detected at front door during evening hours"
          },
          "improved": true,
          "inference_time_ms": 1250
        },
        "properties": {
          "after": {
            "$ref": "#/components/schemas/PromptTestResultAfter",
            "description": "Results from modified prompt"
          },
          "before": {
            "$ref": "#/components/schemas/PromptTestResultBefore",
            "description": "Results from original prompt"
          },
          "improved": {
            "description": "Whether the modification improved results",
            "title": "Improved",
            "type": "boolean"
          },
          "inference_time_ms": {
            "description": "Time taken for inference in ms",
            "minimum": 0.0,
            "title": "Inference Time Ms",
            "type": "integer"
          }
        },
        "required": [
          "before",
          "after",
          "improved",
          "inference_time_ms"
        ],
        "title": "PromptTestResponse",
        "type": "object"
      },
      "PromptTestResultAfter": {
        "description": "Result from the modified prompt.",
        "example": {
          "risk_level": "low",
          "score": 45,
          "summary": "Regular visitor detected - matches known delivery pattern"
        },
        "properties": {
          "risk_level": {
            "description": "Risk level (low, medium, high, critical)",
            "title": "Risk Level",
            "type": "string"
          },
          "score": {
            "description": "Risk score from modified prompt",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Score",
            "type": "integer"
          },
          "summary": {
            "description": "Summary from modified analysis",
            "title": "Summary",
            "type": "string"
          }
        },
        "required": [
          "score",
          "risk_level",
          "summary"
        ],
        "title": "PromptTestResultAfter",
        "type": "object"
      },
      "PromptTestResultBefore": {
        "description": "Result from the original (current) prompt.",
        "example": {
          "risk_level": "medium",
          "score": 65,
          "summary": "Person detected at front door during evening hours"
        },
        "properties": {
          "risk_level": {
            "description": "Risk level (low, medium, high, critical)",
            "title": "Risk Level",
            "type": "string"
          },
          "score": {
            "description": "Risk score from original prompt",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Score",
            "type": "integer"
          },
          "summary": {
            "description": "Summary from original analysis",
            "title": "Summary",
            "type": "string"
          }
        },
        "required": [
          "score",
          "risk_level",
          "summary"
        ],
        "title": "PromptTestResultBefore",
        "type": "object"
      },
      "PromptUpdateRequest": {
        "description": "Request to update a model's prompt configuration.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "Updated system prompt with new context...",
            "temperature": 0.8
          },
          "description": "Added weather context to improve analysis"
        },
        "properties": {
          "config": {
            "additionalProperties": true,
            "description": "New configuration for the model",
            "title": "Config",
            "type": "object"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Description of the changes",
            "title": "Description"
          }
        },
        "required": [
          "config"
        ],
        "title": "PromptUpdateRequest",
        "type": "object"
      },
      "PromptUpdateResponse": {
        "description": "Response after updating a model's prompt.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "Updated system prompt...",
            "temperature": 0.8
          },
          "message": "Prompt configuration updated successfully",
          "model_name": "nemotron",
          "version": 4
        },
        "properties": {
          "config": {
            "additionalProperties": true,
            "title": "Config",
            "type": "object"
          },
          "message": {
            "title": "Message",
            "type": "string"
          },
          "model_name": {
            "title": "Model Name",
            "type": "string"
          },
          "version": {
            "title": "Version",
            "type": "integer"
          }
        },
        "required": [
          "model_name",
          "version",
          "message",
          "config"
        ],
        "title": "PromptUpdateResponse",
        "type": "object"
      },
      "QualityScores": {
        "description": "Self-evaluation quality scores (1-5 scale).",
        "example": {
          "consistency": 4.0,
          "context_usage": 4.2,
          "overall": 4.1,
          "reasoning_coherence": 4.5,
          "risk_justification": 3.8
        },
        "properties": {
          "consistency": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Consistency"
          },
          "context_usage": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Context Usage"
          },
          "overall": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Overall"
          },
          "reasoning_coherence": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reasoning Coherence"
          },
          "risk_justification": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Justification"
          }
        },
        "title": "QualityScores",
        "type": "object"
      },
      "QueueDepths": {
        "description": "Queue depth information for pipeline queues.",
        "example": {
          "analysis_queue": 2,
          "detection_queue": 5
        },
        "properties": {
          "analysis_queue": {
            "description": "Number of batches in analysis queue waiting for Nemotron LLM analysis",
            "minimum": 0.0,
            "title": "Analysis Queue",
            "type": "integer"
          },
          "detection_queue": {
            "description": "Number of items in detection queue waiting for RT-DETRv2 processing",
            "minimum": 0.0,
            "title": "Detection Queue",
            "type": "integer"
          }
        },
        "required": [
          "detection_queue",
          "analysis_queue"
        ],
        "title": "QueueDepths",
        "type": "object"
      },
      "QuietHoursPeriodCreate": {
        "description": "Schema for creating a quiet hours period.",
        "example": {
          "days": [
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday"
          ],
          "end_time": "06:00:00",
          "label": "Night Time",
          "start_time": "22:00:00"
        },
        "properties": {
          "days": {
            "description": "Days of week when period is active",
            "items": {
              "type": "string"
            },
            "title": "Days",
            "type": "array"
          },
          "end_time": {
            "description": "End time (HH:MM:SS)",
            "format": "time",
            "title": "End Time",
            "type": "string"
          },
          "label": {
            "description": "Period label",
            "maxLength": 255,
            "minLength": 1,
            "title": "Label",
            "type": "string"
          },
          "start_time": {
            "description": "Start time (HH:MM:SS)",
            "format": "time",
            "title": "Start Time",
            "type": "string"
          }
        },
        "required": [
          "label",
          "start_time",
          "end_time"
        ],
        "title": "QuietHoursPeriodCreate",
        "type": "object"
      },
      "QuietHoursPeriodResponse": {
        "description": "Schema for quiet hours period response.",
        "example": {
          "days": [
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday"
          ],
          "end_time": "06:00:00",
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "label": "Night Time",
          "start_time": "22:00:00"
        },
        "properties": {
          "days": {
            "description": "Days of week when period is active",
            "items": {
              "type": "string"
            },
            "title": "Days",
            "type": "array"
          },
          "end_time": {
            "description": "End time",
            "format": "time",
            "title": "End Time",
            "type": "string"
          },
          "id": {
            "description": "Period UUID",
            "title": "Id",
            "type": "string"
          },
          "label": {
            "description": "Period label",
            "title": "Label",
            "type": "string"
          },
          "start_time": {
            "description": "Start time",
            "format": "time",
            "title": "Start Time",
            "type": "string"
          }
        },
        "required": [
          "id",
          "label",
          "start_time",
          "end_time",
          "days"
        ],
        "title": "QuietHoursPeriodResponse",
        "type": "object"
      },
      "QuietHoursPeriodsListResponse": {
        "description": "Schema for quiet hours periods list response with pagination.",
        "example": {
          "items": [
            {
              "days": [
                "monday",
                "tuesday",
                "wednesday",
                "thursday",
                "friday"
              ],
              "end_time": "06:00:00",
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "label": "Night Time",
              "start_time": "22:00:00"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of quiet hours periods",
            "items": {
              "$ref": "#/components/schemas/QuietHoursPeriodResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "QuietHoursPeriodsListResponse",
        "type": "object"
      },
      "RUMBatchRequest": {
        "description": "Batch request for multiple Core Web Vitals metrics.\n\nThe frontend batches metrics to reduce API calls. Each batch may contain\nmetrics from different pages or navigation events.\n\nAttributes:\n    metrics: List of Core Web Vital metrics to ingest\n    session_id: Optional session identifier for correlating metrics\n    user_agent: Optional user agent string for device/browser analysis",
        "example": {
          "metrics": [
            {
              "delta": 2500.0,
              "id": "v1-1234567890123-1234567890123",
              "name": "LCP",
              "rating": "good",
              "value": 2500.0
            },
            {
              "delta": 0.02,
              "id": "v1-1234567890123-1234567890124",
              "name": "CLS",
              "rating": "good",
              "value": 0.05
            }
          ],
          "session_id": "sess-12345"
        },
        "properties": {
          "metrics": {
            "description": "List of metrics to ingest (non-empty)",
            "items": {
              "$ref": "#/components/schemas/WebVitalMetric"
            },
            "minItems": 1,
            "title": "Metrics",
            "type": "array"
          },
          "session_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional session identifier",
            "title": "Session Id"
          },
          "user_agent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional user agent string",
            "title": "User Agent"
          }
        },
        "required": [
          "metrics"
        ],
        "title": "RUMBatchRequest",
        "type": "object"
      },
      "RUMIngestResponse": {
        "description": "Response from the RUM metrics ingestion endpoint.\n\nAttributes:\n    success: Whether the ingestion was successful\n    metrics_count: Number of metrics successfully ingested\n    message: Human-readable status message\n    errors: List of any errors encountered during ingestion",
        "example": {
          "errors": [],
          "message": "Successfully ingested 5 metrics",
          "metrics_count": 5,
          "success": true
        },
        "properties": {
          "errors": {
            "description": "List of any errors encountered",
            "items": {
              "type": "string"
            },
            "title": "Errors",
            "type": "array"
          },
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "metrics_count": {
            "description": "Number of metrics successfully ingested",
            "minimum": 0.0,
            "title": "Metrics Count",
            "type": "integer"
          },
          "success": {
            "description": "Whether ingestion was successful",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success",
          "metrics_count",
          "message"
        ],
        "title": "RUMIngestResponse",
        "type": "object"
      },
      "ReadinessResponse": {
        "description": "Response schema for readiness probe endpoint.\n\nReadiness probes indicate whether the application is ready to receive\ntraffic and process requests. This checks all dependencies:\n- Database connectivity\n- Redis connectivity\n- AI services availability\n- Background worker status",
        "example": {
          "ready": true,
          "services": {
            "ai": {
              "message": "AI services operational",
              "status": "healthy"
            },
            "database": {
              "message": "Database operational",
              "status": "healthy"
            },
            "redis": {
              "details": {
                "redis_version": "7.0.0"
              },
              "message": "Redis connected",
              "status": "healthy"
            }
          },
          "status": "ready",
          "timestamp": "2025-12-23T10:30:00",
          "workers": [
            {
              "name": "gpu_monitor",
              "running": true
            },
            {
              "name": "cleanup_service",
              "running": true
            }
          ]
        },
        "properties": {
          "ai_warmth_status": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Warmth status of AI models (NEM-1670). Keys are model names (e.g., 'rtdetr', 'nemotron'), values are states: 'cold', 'warming', 'warm'",
            "title": "Ai Warmth Status"
          },
          "ready": {
            "description": "Overall readiness status: True if system can process requests",
            "title": "Ready",
            "type": "boolean"
          },
          "services": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HealthCheckServiceStatus"
            },
            "description": "Status of infrastructure services (database, redis, ai)",
            "title": "Services",
            "type": "object"
          },
          "status": {
            "description": "Status string: 'ready', 'degraded', or 'not_ready'",
            "title": "Status",
            "type": "string"
          },
          "timestamp": {
            "description": "Timestamp of readiness check",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "workers": {
            "description": "Status of background workers",
            "items": {
              "$ref": "#/components/schemas/WorkerStatus"
            },
            "title": "Workers",
            "type": "array"
          }
        },
        "required": [
          "ready",
          "status",
          "services",
          "timestamp"
        ],
        "title": "ReadinessResponse",
        "type": "object"
      },
      "RecentError": {
        "description": "Recent error information.",
        "properties": {
          "component": {
            "description": "Component that generated error",
            "title": "Component",
            "type": "string"
          },
          "error_type": {
            "description": "Type of error",
            "title": "Error Type",
            "type": "string"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message",
            "title": "Message"
          },
          "timestamp": {
            "description": "ISO timestamp of error",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "error_type",
          "component"
        ],
        "title": "RecentError",
        "type": "object"
      },
      "RecommendationItem": {
        "description": "Single recommendation item.",
        "example": {
          "category": "missing_context",
          "frequency": 25,
          "priority": "high",
          "suggestion": "Add time since last motion event to prompt"
        },
        "properties": {
          "category": {
            "title": "Category",
            "type": "string"
          },
          "frequency": {
            "title": "Frequency",
            "type": "integer"
          },
          "priority": {
            "title": "Priority",
            "type": "string"
          },
          "suggestion": {
            "title": "Suggestion",
            "type": "string"
          }
        },
        "required": [
          "category",
          "suggestion",
          "frequency",
          "priority"
        ],
        "title": "RecommendationItem",
        "type": "object"
      },
      "RecommendationsResponse": {
        "description": "Aggregated recommendations response.",
        "example": {
          "recommendations": [
            {
              "category": "missing_context",
              "frequency": 25,
              "priority": "high",
              "suggestion": "Add time since last motion event"
            },
            {
              "category": "model_gaps",
              "frequency": 12,
              "priority": "medium",
              "suggestion": "Enable pet detection model"
            }
          ],
          "total_events_analyzed": 500
        },
        "properties": {
          "recommendations": {
            "items": {
              "$ref": "#/components/schemas/RecommendationItem"
            },
            "title": "Recommendations",
            "type": "array"
          },
          "total_events_analyzed": {
            "title": "Total Events Analyzed",
            "type": "integer"
          }
        },
        "required": [
          "recommendations",
          "total_events_analyzed"
        ],
        "title": "RecommendationsResponse",
        "type": "object"
      },
      "RecordingResponse": {
        "description": "Response for a single recording.",
        "properties": {
          "body_truncated": {
            "default": false,
            "description": "Whether body was truncated",
            "title": "Body Truncated",
            "type": "boolean"
          },
          "duration_ms": {
            "description": "Request duration in milliseconds",
            "title": "Duration Ms",
            "type": "number"
          },
          "method": {
            "description": "HTTP method",
            "title": "Method",
            "type": "string"
          },
          "path": {
            "description": "Request path",
            "title": "Path",
            "type": "string"
          },
          "recording_id": {
            "description": "Unique recording ID",
            "title": "Recording Id",
            "type": "string"
          },
          "status_code": {
            "description": "HTTP response status code",
            "title": "Status Code",
            "type": "integer"
          },
          "timestamp": {
            "description": "ISO timestamp when recorded",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "recording_id",
          "timestamp",
          "method",
          "path",
          "status_code",
          "duration_ms"
        ],
        "title": "RecordingResponse",
        "type": "object"
      },
      "RecordingsListResponse": {
        "description": "Response for listing recordings.",
        "properties": {
          "recordings": {
            "description": "List of recordings",
            "items": {
              "$ref": "#/components/schemas/RecordingResponse"
            },
            "title": "Recordings",
            "type": "array"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          },
          "total": {
            "description": "Total number of recordings",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "recordings",
          "total",
          "timestamp"
        ],
        "title": "RecordingsListResponse",
        "type": "object"
      },
      "RedisInfoResponse": {
        "description": "Response for Redis connection stats.",
        "properties": {
          "info": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Redis INFO command output",
            "title": "Info"
          },
          "pubsub": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Pub/sub channel information",
            "title": "Pubsub"
          },
          "status": {
            "description": "Redis connection status (connected, unavailable)",
            "title": "Status",
            "type": "string"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "status",
          "timestamp"
        ],
        "title": "RedisInfoResponse",
        "type": "object"
      },
      "ReplayResponse": {
        "description": "Response for request replay.",
        "properties": {
          "original_status_code": {
            "description": "Original response status code",
            "title": "Original Status Code",
            "type": "integer"
          },
          "recording_id": {
            "description": "ID of the replayed recording",
            "title": "Recording Id",
            "type": "string"
          },
          "replay_metadata": {
            "additionalProperties": true,
            "description": "Metadata about the replay",
            "title": "Replay Metadata",
            "type": "object"
          },
          "replay_response": {
            "description": "Response from replayed request",
            "title": "Replay Response"
          },
          "replay_status_code": {
            "description": "Replay response status code",
            "title": "Replay Status Code",
            "type": "integer"
          },
          "timestamp": {
            "description": "ISO timestamp of replay",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "recording_id",
          "original_status_code",
          "replay_status_code",
          "replay_response",
          "replay_metadata",
          "timestamp"
        ],
        "title": "ReplayResponse",
        "type": "object"
      },
      "RiskHistoryDataPoint": {
        "description": "Schema for a single risk history data point.",
        "example": {
          "critical": 1,
          "date": "2025-01-07",
          "high": 2,
          "low": 10,
          "medium": 5
        },
        "properties": {
          "critical": {
            "default": 0,
            "description": "Count of critical risk events",
            "minimum": 0.0,
            "title": "Critical",
            "type": "integer"
          },
          "date": {
            "description": "Date of the data point",
            "format": "date",
            "title": "Date",
            "type": "string"
          },
          "high": {
            "default": 0,
            "description": "Count of high risk events",
            "minimum": 0.0,
            "title": "High",
            "type": "integer"
          },
          "low": {
            "default": 0,
            "description": "Count of low risk events",
            "minimum": 0.0,
            "title": "Low",
            "type": "integer"
          },
          "medium": {
            "default": 0,
            "description": "Count of medium risk events",
            "minimum": 0.0,
            "title": "Medium",
            "type": "integer"
          }
        },
        "required": [
          "date"
        ],
        "title": "RiskHistoryDataPoint",
        "type": "object"
      },
      "RiskHistoryResponse": {
        "description": "Schema for risk score distribution over time.",
        "example": {
          "data_points": [
            {
              "critical": 1,
              "date": "2025-01-01",
              "high": 2,
              "low": 10,
              "medium": 5
            },
            {
              "critical": 0,
              "date": "2025-01-02",
              "high": 3,
              "low": 12,
              "medium": 4
            }
          ],
          "end_date": "2025-01-02",
          "start_date": "2025-01-01"
        },
        "properties": {
          "data_points": {
            "description": "Risk level counts aggregated by day",
            "items": {
              "$ref": "#/components/schemas/RiskHistoryDataPoint"
            },
            "title": "Data Points",
            "type": "array"
          },
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          }
        },
        "required": [
          "data_points",
          "start_date",
          "end_date"
        ],
        "title": "RiskHistoryResponse",
        "type": "object"
      },
      "RuleTestEventResult": {
        "description": "Schema for a single event's test result.",
        "example": {
          "camera_id": "front_door",
          "event_id": 123,
          "matched_conditions": [
            "risk_score >= 70",
            "object_type in ['person']"
          ],
          "matches": true,
          "object_types": [
            "person"
          ],
          "risk_score": 75,
          "started_at": "2025-12-28T22:15:00Z"
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "event_id": {
            "description": "Event ID",
            "title": "Event Id",
            "type": "integer"
          },
          "matched_conditions": {
            "description": "List of conditions that matched",
            "items": {
              "type": "string"
            },
            "title": "Matched Conditions",
            "type": "array"
          },
          "matches": {
            "description": "Whether the rule matched this event",
            "title": "Matches",
            "type": "boolean"
          },
          "object_types": {
            "description": "Detected object types",
            "items": {
              "type": "string"
            },
            "title": "Object Types",
            "type": "array"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event risk score",
            "title": "Risk Score"
          },
          "started_at": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event start timestamp",
            "title": "Started At"
          }
        },
        "required": [
          "event_id",
          "camera_id",
          "matches"
        ],
        "title": "RuleTestEventResult",
        "type": "object"
      },
      "RuleTestRequest": {
        "description": "Schema for testing a rule against historical events.",
        "example": {
          "event_ids": [
            1,
            2,
            3,
            4,
            5
          ],
          "test_time": "2025-12-28T22:30:00Z"
        },
        "properties": {
          "event_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "integer"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Specific event IDs to test against. If not provided, tests against recent events.",
            "title": "Event Ids"
          },
          "limit": {
            "default": 10,
            "description": "Maximum number of recent events to test (if event_ids not provided)",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "type": "integer"
          },
          "test_time": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Override current time for schedule testing (ISO format)",
            "title": "Test Time"
          }
        },
        "title": "RuleTestRequest",
        "type": "object"
      },
      "RuleTestResponse": {
        "description": "Schema for rule test response.",
        "example": {
          "events_matched": 3,
          "events_tested": 10,
          "match_rate": 0.3,
          "results": [
            {
              "camera_id": "front_door",
              "event_id": 123,
              "matched_conditions": [
                "risk_score >= 70",
                "object_type in ['person']"
              ],
              "matches": true,
              "object_types": [
                "person"
              ],
              "risk_score": 75,
              "started_at": "2025-12-28T22:15:00Z"
            }
          ],
          "rule_id": "550e8400-e29b-41d4-a716-446655440000",
          "rule_name": "Night Intruder Alert"
        },
        "properties": {
          "events_matched": {
            "description": "Number of events that matched the rule",
            "title": "Events Matched",
            "type": "integer"
          },
          "events_tested": {
            "description": "Number of events tested",
            "title": "Events Tested",
            "type": "integer"
          },
          "match_rate": {
            "description": "Proportion of events that matched (0.0-1.0)",
            "title": "Match Rate",
            "type": "number"
          },
          "results": {
            "description": "Per-event test results",
            "items": {
              "$ref": "#/components/schemas/RuleTestEventResult"
            },
            "title": "Results",
            "type": "array"
          },
          "rule_id": {
            "description": "Rule ID that was tested",
            "title": "Rule Id",
            "type": "string"
          },
          "rule_name": {
            "description": "Rule name",
            "title": "Rule Name",
            "type": "string"
          }
        },
        "required": [
          "rule_id",
          "rule_name",
          "events_tested",
          "events_matched",
          "match_rate",
          "results"
        ],
        "title": "RuleTestResponse",
        "type": "object"
      },
      "SceneChangeAcknowledgeResponse": {
        "description": "Response schema for acknowledging a scene change.\n\nConfirms that a scene change has been acknowledged.",
        "example": {
          "acknowledged": true,
          "acknowledged_at": "2026-01-03T11:00:00Z",
          "id": 1
        },
        "properties": {
          "acknowledged": {
            "default": true,
            "description": "Acknowledgement status (always True)",
            "title": "Acknowledged",
            "type": "boolean"
          },
          "acknowledged_at": {
            "description": "When the change was acknowledged",
            "format": "date-time",
            "title": "Acknowledged At",
            "type": "string"
          },
          "id": {
            "description": "Scene change ID",
            "title": "Id",
            "type": "integer"
          }
        },
        "required": [
          "id",
          "acknowledged_at"
        ],
        "title": "SceneChangeAcknowledgeResponse",
        "type": "object"
      },
      "SceneChangeListResponse": {
        "description": "Response schema for listing scene changes.\n\nReturns a list of scene changes for a camera with cursor-based pagination.",
        "example": {
          "camera_id": "front_door",
          "has_more": true,
          "next_cursor": "2026-01-03T09:30:00Z",
          "scene_changes": [
            {
              "acknowledged": false,
              "change_type": "view_blocked",
              "detected_at": "2026-01-03T10:30:00Z",
              "id": 1,
              "similarity_score": 0.23
            }
          ],
          "total_changes": 1
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "has_more": {
            "default": false,
            "description": "Whether there are more results available",
            "title": "Has More",
            "type": "boolean"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Cursor for fetching the next page (ISO 8601 timestamp)",
            "title": "Next Cursor"
          },
          "scene_changes": {
            "description": "List of scene changes",
            "items": {
              "$ref": "#/components/schemas/SceneChangeResponse"
            },
            "title": "Scene Changes",
            "type": "array"
          },
          "total_changes": {
            "default": 0,
            "description": "Number of scene changes returned",
            "minimum": 0.0,
            "title": "Total Changes",
            "type": "integer"
          }
        },
        "required": [
          "camera_id"
        ],
        "title": "SceneChangeListResponse",
        "type": "object"
      },
      "SceneChangeResponse": {
        "description": "Response schema for a single scene change.\n\nRepresents a detected camera view change that may indicate\ntampering, angle changes, or blocked views.",
        "example": {
          "acknowledged": false,
          "change_type": "view_blocked",
          "detected_at": "2026-01-03T10:30:00Z",
          "file_path": "/export/foscam/front_door/image.jpg",
          "id": 1,
          "similarity_score": 0.23
        },
        "properties": {
          "acknowledged": {
            "default": false,
            "description": "Whether the change has been acknowledged",
            "title": "Acknowledged",
            "type": "boolean"
          },
          "acknowledged_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the change was acknowledged",
            "title": "Acknowledged At"
          },
          "change_type": {
            "description": "Type of change: view_blocked, angle_changed, view_tampered, unknown",
            "title": "Change Type",
            "type": "string"
          },
          "detected_at": {
            "description": "When the scene change was detected",
            "format": "date-time",
            "title": "Detected At",
            "type": "string"
          },
          "file_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to the image that triggered detection",
            "title": "File Path"
          },
          "id": {
            "description": "Unique scene change ID",
            "title": "Id",
            "type": "integer"
          },
          "similarity_score": {
            "description": "SSIM similarity score (0-1, lower means more different)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Similarity Score",
            "type": "number"
          }
        },
        "required": [
          "id",
          "detected_at",
          "change_type",
          "similarity_score"
        ],
        "title": "SceneChangeResponse",
        "type": "object"
      },
      "SearchResponse": {
        "description": "Schema for search response with pagination.",
        "example": {
          "limit": 50,
          "offset": 0,
          "results": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_count": 5,
              "detection_ids": [
                1,
                2,
                3,
                4,
                5
              ],
              "ended_at": "2025-12-23T12:02:30Z",
              "id": 1,
              "object_types": "person, vehicle",
              "reasoning": "Unknown individual approaching entrance during nighttime",
              "relevance_score": 0.85,
              "reviewed": false,
              "risk_level": "medium",
              "risk_score": 75,
              "started_at": "2025-12-23T12:00:00Z",
              "summary": "Suspicious person detected near front entrance"
            }
          ],
          "total_count": 42
        },
        "properties": {
          "limit": {
            "description": "Maximum number of results returned",
            "title": "Limit",
            "type": "integer"
          },
          "offset": {
            "description": "Number of results skipped",
            "title": "Offset",
            "type": "integer"
          },
          "results": {
            "description": "List of search results",
            "items": {
              "$ref": "#/components/schemas/SearchResult"
            },
            "title": "Results",
            "type": "array"
          },
          "total_count": {
            "description": "Total number of matching events",
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "results",
          "total_count",
          "limit",
          "offset"
        ],
        "title": "SearchResponse",
        "type": "object"
      },
      "SearchResult": {
        "description": "Schema for a single search result.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "detection_count": 5,
          "detection_ids": [
            1,
            2,
            3,
            4,
            5
          ],
          "ended_at": "2025-12-23T12:02:30Z",
          "id": 1,
          "object_types": "person, vehicle",
          "reasoning": "Unknown individual approaching entrance during nighttime hours",
          "relevance_score": 0.85,
          "reviewed": false,
          "risk_level": "medium",
          "risk_score": 75,
          "started_at": "2025-12-23T12:00:00Z",
          "summary": "Suspicious person detected near front entrance"
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera display name",
            "title": "Camera Name"
          },
          "detection_count": {
            "default": 0,
            "description": "Number of detections in this event",
            "title": "Detection Count",
            "type": "integer"
          },
          "detection_ids": {
            "description": "List of detection IDs associated with this event",
            "items": {
              "type": "integer"
            },
            "title": "Detection Ids",
            "type": "array"
          },
          "ended_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event end timestamp",
            "title": "Ended At"
          },
          "id": {
            "description": "Event ID",
            "title": "Id",
            "type": "integer"
          },
          "object_types": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Comma-separated detected object types",
            "title": "Object Types"
          },
          "reasoning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM reasoning for risk score",
            "title": "Reasoning"
          },
          "relevance_score": {
            "default": 0.0,
            "description": "Full-text search relevance score (higher is more relevant)",
            "title": "Relevance Score",
            "type": "number"
          },
          "reviewed": {
            "default": false,
            "description": "Whether event has been reviewed",
            "title": "Reviewed",
            "type": "boolean"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk level (low, medium, high, critical)",
            "title": "Risk Level"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk score (0-100)",
            "title": "Risk Score"
          },
          "started_at": {
            "description": "Event start timestamp",
            "format": "date-time",
            "title": "Started At",
            "type": "string"
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM-generated event summary",
            "title": "Summary"
          }
        },
        "required": [
          "id",
          "camera_id",
          "started_at"
        ],
        "title": "SearchResult",
        "type": "object"
      },
      "SeedCamerasRequest": {
        "description": "Request schema for seeding cameras.",
        "properties": {
          "clear_existing": {
            "default": false,
            "description": "Remove existing cameras first",
            "title": "Clear Existing",
            "type": "boolean"
          },
          "count": {
            "default": 6,
            "description": "Number of cameras to create (1-6)",
            "maximum": 6.0,
            "minimum": 1.0,
            "title": "Count",
            "type": "integer"
          },
          "create_folders": {
            "default": false,
            "description": "Create camera folders on filesystem",
            "title": "Create Folders",
            "type": "boolean"
          }
        },
        "title": "SeedCamerasRequest",
        "type": "object"
      },
      "SeedCamerasResponse": {
        "description": "Response schema for seed cameras endpoint.",
        "properties": {
          "cameras": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "title": "Cameras",
            "type": "array"
          },
          "cleared": {
            "title": "Cleared",
            "type": "integer"
          },
          "created": {
            "title": "Created",
            "type": "integer"
          }
        },
        "required": [
          "created",
          "cleared",
          "cameras"
        ],
        "title": "SeedCamerasResponse",
        "type": "object"
      },
      "SeedEventsRequest": {
        "description": "Request schema for seeding events.",
        "properties": {
          "clear_existing": {
            "default": false,
            "description": "Remove existing events and detections",
            "title": "Clear Existing",
            "type": "boolean"
          },
          "count": {
            "default": 15,
            "description": "Number of events to create (1-100)",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Count",
            "type": "integer"
          }
        },
        "title": "SeedEventsRequest",
        "type": "object"
      },
      "SeedEventsResponse": {
        "description": "Response schema for seed events endpoint.",
        "properties": {
          "detections_cleared": {
            "title": "Detections Cleared",
            "type": "integer"
          },
          "detections_created": {
            "title": "Detections Created",
            "type": "integer"
          },
          "events_cleared": {
            "title": "Events Cleared",
            "type": "integer"
          },
          "events_created": {
            "title": "Events Created",
            "type": "integer"
          }
        },
        "required": [
          "events_created",
          "detections_created",
          "events_cleared",
          "detections_cleared"
        ],
        "title": "SeedEventsResponse",
        "type": "object"
      },
      "ServiceActionResponse": {
        "description": "Response for service action endpoints (restart, enable, disable, start).\n\nReturned after POST /api/system/services/{name}/restart, enable, disable, or start.",
        "example": {
          "message": "Service restarted successfully",
          "service": {
            "category": "ai",
            "container_id": "abc123...",
            "display_name": "RT-DETRv2",
            "enabled": true,
            "failure_count": 0,
            "image": "ghcr.io/.../rtdetr:latest",
            "last_restart_at": "2026-01-05T15:50:00Z",
            "name": "ai-detector",
            "port": 8090,
            "restart_count": 3,
            "status": "starting"
          },
          "success": true
        },
        "properties": {
          "message": {
            "description": "Human-readable result message",
            "title": "Message",
            "type": "string"
          },
          "service": {
            "$ref": "#/components/schemas/ServiceInfo",
            "description": "Updated service information after the action"
          },
          "success": {
            "description": "Whether the action completed successfully",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success",
          "message",
          "service"
        ],
        "title": "ServiceActionResponse",
        "type": "object"
      },
      "ServiceCategory": {
        "description": "Service category for classification and restart policy.\n\nCategories determine restart behavior and priority:\n- INFRASTRUCTURE: Critical services (PostgreSQL, Redis) with aggressive restart\n- AI: AI/ML services with standard backoff\n- MONITORING: Optional monitoring services with lenient restart",
        "enum": [
          "infrastructure",
          "ai",
          "monitoring"
        ],
        "title": "ServiceCategory",
        "type": "string"
      },
      "ServiceHealthState": {
        "description": "Health state for a service in the full health check.\n\nStates:\n- healthy: Service is fully operational\n- unhealthy: Service is down or experiencing critical issues\n- degraded: Service is partially operational\n- unknown: Service status cannot be determined",
        "enum": [
          "healthy",
          "unhealthy",
          "degraded",
          "unknown"
        ],
        "title": "ServiceHealthState",
        "type": "string"
      },
      "ServiceHealthStatusResponse": {
        "description": "Health status of a registered service.",
        "properties": {
          "consecutive_failures": {
            "description": "Count of consecutive health check failures",
            "minimum": 0.0,
            "title": "Consecutive Failures",
            "type": "integer"
          },
          "error_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Last error message if unhealthy",
            "title": "Error Message"
          },
          "last_check": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Monotonic time of last health check",
            "title": "Last Check"
          },
          "name": {
            "description": "Service name",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "description": "Health status (healthy, unhealthy, unknown)",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "name",
          "status",
          "consecutive_failures"
        ],
        "title": "ServiceHealthStatusResponse",
        "type": "object"
      },
      "ServiceInfo": {
        "description": "Information about a single managed service.\n\nContains identity, configuration, and runtime status for a container\nmanaged by the orchestrator.",
        "example": {
          "category": "ai",
          "container_id": "abc123def456",
          "display_name": "RT-DETRv2",
          "enabled": true,
          "failure_count": 0,
          "image": "ghcr.io/.../rtdetr:latest",
          "last_restart_at": "2026-01-05T10:30:00Z",
          "name": "ai-detector",
          "port": 8090,
          "restart_count": 2,
          "status": "running",
          "uptime_seconds": 3600
        },
        "properties": {
          "category": {
            "$ref": "#/components/schemas/ServiceCategory",
            "description": "Service category: infrastructure, ai, or monitoring"
          },
          "container_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Docker container ID (short form)",
            "title": "Container Id"
          },
          "display_name": {
            "description": "Human-readable display name (e.g., 'RT-DETRv2', 'PostgreSQL')",
            "title": "Display Name",
            "type": "string"
          },
          "enabled": {
            "default": true,
            "description": "Whether auto-restart is enabled for this service",
            "title": "Enabled",
            "type": "boolean"
          },
          "failure_count": {
            "default": 0,
            "description": "Consecutive health check failure count",
            "minimum": 0.0,
            "title": "Failure Count",
            "type": "integer"
          },
          "image": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Container image (e.g., 'postgres:16-alpine', 'ghcr.io/.../rtdetr:latest')",
            "title": "Image"
          },
          "last_restart_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of last restart (null if never restarted)",
            "title": "Last Restart At"
          },
          "name": {
            "description": "Service identifier (e.g., 'ai-detector', 'postgres', 'grafana')",
            "title": "Name",
            "type": "string"
          },
          "port": {
            "description": "Primary service port",
            "maximum": 65535.0,
            "minimum": 1.0,
            "title": "Port",
            "type": "integer"
          },
          "restart_count": {
            "default": 0,
            "description": "Total restarts since backend boot",
            "minimum": 0.0,
            "title": "Restart Count",
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/ContainerServiceStatus",
            "description": "Current service status: running, starting, unhealthy, stopped, disabled, not_found"
          },
          "uptime_seconds": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Seconds since container started (null if not running)",
            "title": "Uptime Seconds"
          }
        },
        "required": [
          "name",
          "display_name",
          "category",
          "status",
          "port"
        ],
        "title": "ServiceInfo",
        "type": "object"
      },
      "ServicesResponse": {
        "description": "Response for GET /api/system/services.\n\nReturns a list of all managed services with their current status\nand category-level summaries.",
        "example": {
          "by_category": {
            "ai": {
              "healthy": 3,
              "total": 5,
              "unhealthy": 2
            },
            "infrastructure": {
              "healthy": 2,
              "total": 2,
              "unhealthy": 0
            },
            "monitoring": {
              "healthy": 4,
              "total": 4,
              "unhealthy": 0
            }
          },
          "services": [
            {
              "category": "infrastructure",
              "container_id": "def456...",
              "display_name": "PostgreSQL",
              "enabled": true,
              "failure_count": 0,
              "image": "postgres:16-alpine",
              "name": "postgres",
              "port": 5432,
              "restart_count": 0,
              "status": "running",
              "uptime_seconds": 86400
            },
            {
              "category": "ai",
              "container_id": "abc123...",
              "display_name": "RT-DETRv2",
              "enabled": true,
              "failure_count": 0,
              "image": "ghcr.io/.../rtdetr:latest",
              "last_restart_at": "2026-01-05T10:30:00Z",
              "name": "ai-detector",
              "port": 8090,
              "restart_count": 2,
              "status": "running",
              "uptime_seconds": 3600
            }
          ],
          "timestamp": "2026-01-05T15:45:00Z"
        },
        "properties": {
          "by_category": {
            "additionalProperties": {
              "$ref": "#/components/schemas/CategorySummary"
            },
            "description": "Health summary by category (infrastructure, ai, monitoring)",
            "title": "By Category",
            "type": "object"
          },
          "services": {
            "description": "List of all managed services with current status",
            "items": {
              "$ref": "#/components/schemas/ServiceInfo"
            },
            "title": "Services",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "services",
          "by_category",
          "timestamp"
        ],
        "title": "ServicesResponse",
        "type": "object"
      },
      "SeverityDefinitionResponse": {
        "description": "Definition of a single severity level.",
        "example": {
          "color": "#f97316",
          "description": "Concerning activity, review soon",
          "label": "High",
          "max_score": 84,
          "min_score": 60,
          "priority": 1,
          "severity": "high"
        },
        "properties": {
          "color": {
            "description": "Hex color code for UI display (e.g., '#22c55e')",
            "pattern": "^#[0-9a-fA-F]{6}$",
            "title": "Color",
            "type": "string"
          },
          "description": {
            "description": "Description of when this severity applies",
            "title": "Description",
            "type": "string"
          },
          "label": {
            "description": "Human-readable label for the severity level",
            "title": "Label",
            "type": "string"
          },
          "max_score": {
            "description": "Maximum risk score for this severity (inclusive)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Max Score",
            "type": "integer"
          },
          "min_score": {
            "description": "Minimum risk score for this severity (inclusive)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Min Score",
            "type": "integer"
          },
          "priority": {
            "description": "Sort priority (0 = highest priority, 3 = lowest)",
            "maximum": 3.0,
            "minimum": 0.0,
            "title": "Priority",
            "type": "integer"
          },
          "severity": {
            "$ref": "#/components/schemas/SeverityEnum",
            "description": "The severity level identifier"
          }
        },
        "required": [
          "severity",
          "label",
          "description",
          "color",
          "priority",
          "min_score",
          "max_score"
        ],
        "title": "SeverityDefinitionResponse",
        "type": "object"
      },
      "SeverityEnum": {
        "description": "Severity levels for API responses.",
        "enum": [
          "low",
          "medium",
          "high",
          "critical"
        ],
        "title": "SeverityEnum",
        "type": "string"
      },
      "SeverityMetadataResponse": {
        "description": "Response schema for severity metadata endpoint.\n\nProvides complete information about severity levels including:\n- All severity definitions with thresholds and colors\n- Current threshold configuration\n- Useful for frontend to display severity information consistently",
        "example": {
          "definitions": [
            {
              "color": "#22c55e",
              "description": "Routine activity, no concern",
              "label": "Low",
              "max_score": 29,
              "min_score": 0,
              "priority": 3,
              "severity": "low"
            },
            {
              "color": "#eab308",
              "description": "Notable activity, worth reviewing",
              "label": "Medium",
              "max_score": 59,
              "min_score": 30,
              "priority": 2,
              "severity": "medium"
            },
            {
              "color": "#f97316",
              "description": "Concerning activity, review soon",
              "label": "High",
              "max_score": 84,
              "min_score": 60,
              "priority": 1,
              "severity": "high"
            },
            {
              "color": "#ef4444",
              "description": "Immediate attention required",
              "label": "Critical",
              "max_score": 100,
              "min_score": 85,
              "priority": 0,
              "severity": "critical"
            }
          ],
          "thresholds": {
            "high_max": 84,
            "low_max": 29,
            "medium_max": 59
          }
        },
        "properties": {
          "definitions": {
            "description": "List of all severity level definitions",
            "items": {
              "$ref": "#/components/schemas/SeverityDefinitionResponse"
            },
            "title": "Definitions",
            "type": "array"
          },
          "thresholds": {
            "$ref": "#/components/schemas/SeverityThresholds",
            "description": "Current severity threshold configuration"
          }
        },
        "required": [
          "definitions",
          "thresholds"
        ],
        "title": "SeverityMetadataResponse",
        "type": "object"
      },
      "SeverityThresholds": {
        "description": "Current severity threshold configuration.",
        "example": {
          "high_max": 84,
          "low_max": 29,
          "medium_max": 59
        },
        "properties": {
          "high_max": {
            "description": "Maximum risk score for HIGH severity (medium_max+1 to this value = HIGH)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "High Max",
            "type": "integer"
          },
          "low_max": {
            "description": "Maximum risk score for LOW severity (0 to this value = LOW)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Low Max",
            "type": "integer"
          },
          "medium_max": {
            "description": "Maximum risk score for MEDIUM severity (low_max+1 to this value = MEDIUM)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Medium Max",
            "type": "integer"
          }
        },
        "required": [
          "low_max",
          "medium_max",
          "high_max"
        ],
        "title": "SeverityThresholds",
        "type": "object"
      },
      "SeverityThresholdsUpdateRequest": {
        "description": "Request schema for updating severity thresholds.\n\nThe thresholds must form contiguous ranges from 0-100:\n- LOW: 0 to low_max (inclusive)\n- MEDIUM: low_max+1 to medium_max (inclusive)\n- HIGH: medium_max+1 to high_max (inclusive)\n- CRITICAL: high_max+1 to 100 (inclusive)\n\nValidation rules:\n- 0 < low_max < medium_max < high_max < 100\n- This ensures all ranges are valid and cover 0-100 without gaps or overlaps",
        "example": {
          "high_max": 84,
          "low_max": 29,
          "medium_max": 59
        },
        "properties": {
          "high_max": {
            "description": "Maximum risk score for HIGH severity (3-99)",
            "maximum": 99.0,
            "minimum": 3.0,
            "title": "High Max",
            "type": "integer"
          },
          "low_max": {
            "description": "Maximum risk score for LOW severity (1-98)",
            "maximum": 98.0,
            "minimum": 1.0,
            "title": "Low Max",
            "type": "integer"
          },
          "medium_max": {
            "description": "Maximum risk score for MEDIUM severity (2-99)",
            "maximum": 99.0,
            "minimum": 2.0,
            "title": "Medium Max",
            "type": "integer"
          }
        },
        "required": [
          "low_max",
          "medium_max",
          "high_max"
        ],
        "title": "SeverityThresholdsUpdateRequest",
        "type": "object"
      },
      "StageLatency": {
        "description": "Latency statistics for a single pipeline stage.",
        "example": {
          "avg_ms": 150.5,
          "max_ms": 500.0,
          "min_ms": 50.0,
          "p50_ms": 120.0,
          "p95_ms": 400.0,
          "p99_ms": 480.0,
          "sample_count": 100
        },
        "properties": {
          "avg_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Average latency in milliseconds",
            "title": "Avg Ms"
          },
          "max_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum latency in milliseconds",
            "title": "Max Ms"
          },
          "min_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum latency in milliseconds",
            "title": "Min Ms"
          },
          "p50_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "50th percentile (median) latency in milliseconds",
            "title": "P50 Ms"
          },
          "p95_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "95th percentile latency in milliseconds",
            "title": "P95 Ms"
          },
          "p99_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "99th percentile latency in milliseconds",
            "title": "P99 Ms"
          },
          "sample_count": {
            "description": "Number of samples used to calculate statistics",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "sample_count"
        ],
        "title": "StageLatency",
        "type": "object"
      },
      "StorageCategoryStats": {
        "description": "Storage statistics for a single category.",
        "properties": {
          "file_count": {
            "description": "Number of files in this category",
            "minimum": 0.0,
            "title": "File Count",
            "type": "integer"
          },
          "size_bytes": {
            "description": "Total size in bytes for this category",
            "minimum": 0.0,
            "title": "Size Bytes",
            "type": "integer"
          }
        },
        "required": [
          "file_count",
          "size_bytes"
        ],
        "title": "StorageCategoryStats",
        "type": "object"
      },
      "StorageStatsResponse": {
        "description": "Response schema for storage statistics endpoint.\n\nProvides detailed storage usage information including:\n- Disk usage for the storage volume\n- Breakdown by data category (thumbnails, images, clips)\n- Database record counts",
        "example": {
          "clips": {
            "file_count": 50,
            "size_bytes": 500000000
          },
          "detections_count": 892,
          "disk_free_bytes": 429496729600,
          "disk_total_bytes": 536870912000,
          "disk_usage_percent": 20.0,
          "disk_used_bytes": 107374182400,
          "events_count": 156,
          "gpu_stats_count": 2880,
          "images": {
            "file_count": 10000,
            "size_bytes": 5000000000
          },
          "logs_count": 5000,
          "thumbnails": {
            "file_count": 1500,
            "size_bytes": 75000000
          },
          "timestamp": "2025-12-30T10:30:00Z"
        },
        "properties": {
          "clips": {
            "$ref": "#/components/schemas/StorageCategoryStats",
            "description": "Storage used by event video clips"
          },
          "detections_count": {
            "description": "Total number of detections in database",
            "minimum": 0.0,
            "title": "Detections Count",
            "type": "integer"
          },
          "disk_free_bytes": {
            "description": "Free disk space in bytes",
            "minimum": 0.0,
            "title": "Disk Free Bytes",
            "type": "integer"
          },
          "disk_total_bytes": {
            "description": "Total disk space available in bytes",
            "minimum": 0.0,
            "title": "Disk Total Bytes",
            "type": "integer"
          },
          "disk_usage_percent": {
            "description": "Disk usage percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Disk Usage Percent",
            "type": "number"
          },
          "disk_used_bytes": {
            "description": "Total disk space used in bytes",
            "minimum": 0.0,
            "title": "Disk Used Bytes",
            "type": "integer"
          },
          "events_count": {
            "description": "Total number of events in database",
            "minimum": 0.0,
            "title": "Events Count",
            "type": "integer"
          },
          "gpu_stats_count": {
            "description": "Total number of GPU stats records in database",
            "minimum": 0.0,
            "title": "Gpu Stats Count",
            "type": "integer"
          },
          "images": {
            "$ref": "#/components/schemas/StorageCategoryStats",
            "description": "Storage used by original camera images"
          },
          "logs_count": {
            "description": "Total number of log entries in database",
            "minimum": 0.0,
            "title": "Logs Count",
            "type": "integer"
          },
          "thumbnails": {
            "$ref": "#/components/schemas/StorageCategoryStats",
            "description": "Storage used by detection thumbnails"
          },
          "timestamp": {
            "description": "Timestamp of storage stats snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "disk_used_bytes",
          "disk_total_bytes",
          "disk_free_bytes",
          "disk_usage_percent",
          "thumbnails",
          "images",
          "clips",
          "events_count",
          "detections_count",
          "gpu_stats_count",
          "logs_count",
          "timestamp"
        ],
        "title": "StorageStatsResponse",
        "type": "object"
      },
      "SystemStatsResponse": {
        "description": "Response schema for system statistics endpoint.",
        "example": {
          "total_cameras": 4,
          "total_detections": 892,
          "total_events": 156,
          "uptime_seconds": 86400.5
        },
        "properties": {
          "total_cameras": {
            "description": "Total number of cameras in the system",
            "minimum": 0.0,
            "title": "Total Cameras",
            "type": "integer"
          },
          "total_detections": {
            "description": "Total number of detections recorded",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          },
          "total_events": {
            "description": "Total number of events recorded",
            "minimum": 0.0,
            "title": "Total Events",
            "type": "integer"
          },
          "uptime_seconds": {
            "description": "Application uptime in seconds",
            "minimum": 0.0,
            "title": "Uptime Seconds",
            "type": "number"
          }
        },
        "required": [
          "total_cameras",
          "total_events",
          "total_detections",
          "uptime_seconds"
        ],
        "title": "SystemStatsResponse",
        "type": "object"
      },
      "TelemetryResponse": {
        "description": "Response schema for pipeline telemetry endpoint.\n\nProvides real-time visibility into:\n- Queue depths: How many items are waiting in detection/analysis queues\n- Stage latencies: How long each pipeline stage is taking\n\nThis helps operators:\n- Identify pipeline bottlenecks\n- Detect backlog situations\n- Monitor processing performance\n- Debug pipeline stalls",
        "example": {
          "latencies": {
            "detect": {
              "avg_ms": 200.0,
              "max_ms": 800.0,
              "min_ms": 100.0,
              "p50_ms": 180.0,
              "p95_ms": 600.0,
              "p99_ms": 750.0,
              "sample_count": 500
            },
            "watch": {
              "avg_ms": 10.0,
              "max_ms": 50.0,
              "min_ms": 5.0,
              "p50_ms": 8.0,
              "p95_ms": 40.0,
              "p99_ms": 48.0,
              "sample_count": 500
            }
          },
          "queues": {
            "analysis_queue": 2,
            "detection_queue": 5
          },
          "timestamp": "2025-12-27T10:30:00Z"
        },
        "properties": {
          "latencies": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineLatencies"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency statistics for each pipeline stage"
          },
          "queues": {
            "$ref": "#/components/schemas/QueueDepths",
            "description": "Current queue depths for detection and analysis queues"
          },
          "timestamp": {
            "description": "Timestamp of telemetry snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "queues",
          "timestamp"
        ],
        "title": "TelemetryResponse",
        "type": "object"
      },
      "TestNotificationResponse": {
        "description": "Schema for test notification result.",
        "example": {
          "channel": "email",
          "message": "Test email sent successfully to test@example.com",
          "success": true
        },
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "Channel that was tested"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if test failed",
            "title": "Error"
          },
          "message": {
            "description": "Human-readable result message",
            "title": "Message",
            "type": "string"
          },
          "success": {
            "description": "Whether the test was successful",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "channel",
          "success",
          "message"
        ],
        "title": "TestNotificationResponse",
        "type": "object"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "title": "Location",
            "type": "array"
          },
          "msg": {
            "title": "Message",
            "type": "string"
          },
          "type": {
            "title": "Error Type",
            "type": "string"
          }
        },
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError",
        "type": "object"
      },
      "VehicleEnrichment": {
        "description": "Vehicle classification results.",
        "example": {
          "color": "silver",
          "confidence": 0.91,
          "is_commercial": false,
          "type": "sedan"
        },
        "properties": {
          "color": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Vehicle color (if detected)",
            "title": "Color"
          },
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Classification confidence",
            "title": "Confidence"
          },
          "damage_detected": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether vehicle damage was detected",
            "title": "Damage Detected"
          },
          "damage_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Types of damage detected",
            "title": "Damage Types"
          },
          "is_commercial": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether vehicle is commercial/delivery",
            "title": "Is Commercial"
          },
          "type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Vehicle type (sedan, suv, truck, etc.)",
            "title": "Type"
          }
        },
        "title": "VehicleEnrichment",
        "type": "object"
      },
      "ViolenceEnrichment": {
        "description": "Violence detection results.",
        "example": {
          "confidence": 0.88,
          "detected": false,
          "score": 0.12
        },
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model confidence",
            "title": "Confidence"
          },
          "detected": {
            "default": false,
            "description": "Whether violence was detected",
            "title": "Detected",
            "type": "boolean"
          },
          "score": {
            "default": 0.0,
            "description": "Violence probability score",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Score",
            "type": "number"
          }
        },
        "title": "ViolenceEnrichment",
        "type": "object"
      },
      "WeatherEnrichment": {
        "description": "Weather classification results.",
        "example": {
          "condition": "clear",
          "confidence": 0.95
        },
        "properties": {
          "condition": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Weather condition (clear, rain, fog, etc.)",
            "title": "Condition"
          },
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Classification confidence",
            "title": "Confidence"
          }
        },
        "title": "WeatherEnrichment",
        "type": "object"
      },
      "WebSocketBroadcasterStatus": {
        "description": "Status of a WebSocket broadcaster's circuit breaker.",
        "properties": {
          "failure_count": {
            "description": "Current consecutive failure count",
            "minimum": 0.0,
            "title": "Failure Count",
            "type": "integer"
          },
          "is_degraded": {
            "description": "Whether the broadcaster is in degraded mode",
            "title": "Is Degraded",
            "type": "boolean"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional status message or error details",
            "title": "Message"
          },
          "state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "Current circuit state: closed (normal), open (failing), half_open (testing), unavailable (not initialized)"
          }
        },
        "required": [
          "state",
          "failure_count",
          "is_degraded"
        ],
        "title": "WebSocketBroadcasterStatus",
        "type": "object"
      },
      "WebSocketConnectionsResponse": {
        "description": "Response for WebSocket connection states.",
        "properties": {
          "event_broadcaster": {
            "$ref": "#/components/schemas/DebugWebSocketBroadcasterStatus",
            "description": "Event broadcaster status"
          },
          "system_broadcaster": {
            "$ref": "#/components/schemas/DebugWebSocketBroadcasterStatus",
            "description": "System broadcaster status"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "event_broadcaster",
          "system_broadcaster",
          "timestamp"
        ],
        "title": "WebSocketConnectionsResponse",
        "type": "object"
      },
      "WebSocketHealthResponse": {
        "description": "Response schema for WebSocket health endpoint.",
        "example": {
          "event_broadcaster": {
            "failure_count": 0,
            "is_degraded": false,
            "state": "closed"
          },
          "system_broadcaster": {
            "failure_count": 0,
            "is_degraded": false,
            "state": "closed"
          },
          "timestamp": "2025-12-30T10:30:00Z"
        },
        "properties": {
          "event_broadcaster": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebSocketBroadcasterStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status of the event broadcaster circuit breaker"
          },
          "system_broadcaster": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebSocketBroadcasterStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status of the system broadcaster circuit breaker"
          },
          "timestamp": {
            "description": "Timestamp of health check",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp"
        ],
        "title": "WebSocketHealthResponse",
        "type": "object"
      },
      "WebVitalMetric": {
        "description": "A single Core Web Vital metric measurement from the frontend.\n\nThis schema matches the structure returned by the web-vitals library's\nonLCP, onFID, onINP, onCLS, onTTFB, and onFCP functions.\n\nAttributes:\n    name: The Core Web Vital metric name (LCP, FID, INP, CLS, TTFB, FCP)\n    value: The metric value (milliseconds for most, dimensionless for CLS)\n    rating: Performance rating based on thresholds (good, needs-improvement, poor)\n    delta: The delta since the last report (for CLS this accumulates)\n    id: Unique identifier for this metric instance\n    navigationType: The type of navigation (navigate, reload, back_forward, prerender)\n    path: The page path where the metric was measured",
        "example": {
          "delta": 2500.0,
          "id": "v1-1234567890123-1234567890123",
          "name": "LCP",
          "navigationType": "navigate",
          "path": "/dashboard",
          "rating": "good",
          "value": 2500.0
        },
        "properties": {
          "delta": {
            "description": "Delta since last report",
            "title": "Delta",
            "type": "number"
          },
          "id": {
            "description": "Unique metric identifier from web-vitals",
            "title": "Id",
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/WebVitalName",
            "description": "Core Web Vital metric name"
          },
          "navigationType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Navigation type (navigate, reload, back_forward, prerender)",
            "title": "Navigationtype"
          },
          "path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Page path where metric was measured",
            "title": "Path"
          },
          "rating": {
            "description": "Performance rating",
            "enum": [
              "good",
              "needs-improvement",
              "poor"
            ],
            "title": "Rating",
            "type": "string"
          },
          "value": {
            "description": "Metric value (ms for most, dimensionless for CLS)",
            "title": "Value",
            "type": "number"
          }
        },
        "required": [
          "name",
          "value",
          "rating",
          "delta",
          "id"
        ],
        "title": "WebVitalMetric",
        "type": "object"
      },
      "WebVitalName": {
        "description": "Supported Core Web Vitals metric names.\n\nThese correspond to the metrics collected by the web-vitals library.",
        "enum": [
          "LCP",
          "FID",
          "INP",
          "CLS",
          "TTFB",
          "FCP"
        ],
        "title": "WebVitalName",
        "type": "string"
      },
      "WebhookTestNotificationRequest": {
        "description": "Schema for testing notification configuration.",
        "example": {
          "channel": "email",
          "email_recipients": [
            "test@example.com"
          ]
        },
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "Channel to test"
          },
          "email_recipients": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Email recipients for email test",
            "title": "Email Recipients"
          },
          "webhook_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Webhook URL for webhook test. Must be HTTPS and not point to private IPs.",
            "title": "Webhook Url"
          }
        },
        "required": [
          "channel"
        ],
        "title": "WebhookTestNotificationRequest",
        "type": "object"
      },
      "WorkerHealthStatus": {
        "description": "Health status for a background worker.\n\nWorkers are background processes that perform periodic or event-driven tasks.",
        "example": {
          "critical": true,
          "name": "file_watcher",
          "running": true
        },
        "properties": {
          "critical": {
            "description": "Whether this worker is critical for system operation",
            "title": "Critical",
            "type": "boolean"
          },
          "name": {
            "description": "Worker name (e.g., 'file_watcher')",
            "title": "Name",
            "type": "string"
          },
          "running": {
            "description": "Whether the worker is currently running",
            "title": "Running",
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "running",
          "critical"
        ],
        "title": "WorkerHealthStatus",
        "type": "object"
      },
      "WorkerStatus": {
        "description": "Status information for a background worker/service.",
        "properties": {
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional status message or error details",
            "title": "Message"
          },
          "name": {
            "description": "Worker/service name",
            "title": "Name",
            "type": "string"
          },
          "running": {
            "description": "Whether the worker is currently running",
            "title": "Running",
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "running"
        ],
        "title": "WorkerStatus",
        "type": "object"
      },
      "ZoneCreate": {
        "description": "Schema for creating a new zone.",
        "example": {
          "color": "#3B82F6",
          "coordinates": [
            [
              0.1,
              0.2
            ],
            [
              0.3,
              0.2
            ],
            [
              0.3,
              0.8
            ],
            [
              0.1,
              0.8
            ]
          ],
          "enabled": true,
          "name": "Front Door",
          "priority": 1,
          "shape": "rectangle",
          "zone_type": "entry_point"
        },
        "properties": {
          "color": {
            "default": "#3B82F6",
            "description": "Hex color for UI display",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "title": "Color",
            "type": "string"
          },
          "coordinates": {
            "description": "Array of normalized [x, y] points (0-1 range)",
            "items": {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            "minItems": 3,
            "title": "Coordinates",
            "type": "array"
          },
          "enabled": {
            "default": true,
            "description": "Whether zone is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "name": {
            "description": "Zone name",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "priority": {
            "default": 0,
            "description": "Priority for overlapping zones (higher = more important)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Priority",
            "type": "integer"
          },
          "shape": {
            "$ref": "#/components/schemas/ZoneShape",
            "default": "rectangle",
            "description": "Shape of the zone"
          },
          "zone_type": {
            "$ref": "#/components/schemas/ZoneType",
            "default": "other",
            "description": "Type of zone"
          }
        },
        "required": [
          "name",
          "coordinates"
        ],
        "title": "ZoneCreate",
        "type": "object"
      },
      "ZoneListResponse": {
        "description": "Schema for zone list response.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "color": "#3B82F6",
              "coordinates": [
                [
                  0.1,
                  0.2
                ],
                [
                  0.3,
                  0.2
                ],
                [
                  0.3,
                  0.8
                ],
                [
                  0.1,
                  0.8
                ]
              ],
              "created_at": "2025-12-23T10:00:00Z",
              "enabled": true,
              "id": "123e4567-e89b-12d3-a456-426614174000",
              "name": "Front Door",
              "priority": 1,
              "shape": "rectangle",
              "updated_at": "2025-12-23T12:00:00Z",
              "zone_type": "entry_point"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of zones",
            "items": {
              "$ref": "#/components/schemas/ZoneResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "ZoneListResponse",
        "type": "object"
      },
      "ZoneResponse": {
        "description": "Schema for zone response.",
        "example": {
          "camera_id": "front_door",
          "color": "#3B82F6",
          "coordinates": [
            [
              0.1,
              0.2
            ],
            [
              0.3,
              0.2
            ],
            [
              0.3,
              0.8
            ],
            [
              0.1,
              0.8
            ]
          ],
          "created_at": "2025-12-23T10:00:00Z",
          "enabled": true,
          "id": "123e4567-e89b-12d3-a456-426614174000",
          "name": "Front Door",
          "priority": 1,
          "shape": "rectangle",
          "updated_at": "2025-12-23T12:00:00Z",
          "zone_type": "entry_point"
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID this zone belongs to",
            "title": "Camera Id",
            "type": "string"
          },
          "color": {
            "description": "Hex color for UI display",
            "title": "Color",
            "type": "string"
          },
          "coordinates": {
            "description": "Array of normalized [x, y] points (0-1 range)",
            "items": {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            "title": "Coordinates",
            "type": "array"
          },
          "created_at": {
            "description": "Timestamp when zone was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "enabled": {
            "description": "Whether zone is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "id": {
            "description": "Zone UUID",
            "title": "Id",
            "type": "string"
          },
          "name": {
            "description": "Zone name",
            "title": "Name",
            "type": "string"
          },
          "priority": {
            "description": "Priority for overlapping zones",
            "title": "Priority",
            "type": "integer"
          },
          "shape": {
            "$ref": "#/components/schemas/ZoneShape",
            "description": "Shape of the zone"
          },
          "updated_at": {
            "description": "Timestamp when zone was last updated",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "zone_type": {
            "$ref": "#/components/schemas/ZoneType",
            "description": "Type of zone"
          }
        },
        "required": [
          "id",
          "camera_id",
          "name",
          "zone_type",
          "coordinates",
          "shape",
          "color",
          "enabled",
          "priority",
          "created_at",
          "updated_at"
        ],
        "title": "ZoneResponse",
        "type": "object"
      },
      "ZoneShape": {
        "description": "Shape of the zone polygon.",
        "enum": [
          "rectangle",
          "polygon"
        ],
        "title": "ZoneShape",
        "type": "string"
      },
      "ZoneType": {
        "description": "Type of zone for semantic categorization.",
        "enum": [
          "entry_point",
          "driveway",
          "sidewalk",
          "yard",
          "other"
        ],
        "title": "ZoneType",
        "type": "string"
      },
      "ZoneUpdate": {
        "description": "Schema for updating an existing zone.",
        "example": {
          "enabled": false,
          "name": "Front Door - Updated"
        },
        "properties": {
          "color": {
            "anyOf": [
              {
                "pattern": "^#[0-9A-Fa-f]{6}$",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Hex color for UI display",
            "title": "Color"
          },
          "coordinates": {
            "anyOf": [
              {
                "items": {
                  "items": {
                    "type": "number"
                  },
                  "type": "array"
                },
                "minItems": 3,
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Array of normalized [x, y] points (0-1 range)",
            "title": "Coordinates"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether zone is active",
            "title": "Enabled"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 255,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Zone name",
            "title": "Name"
          },
          "priority": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Priority for overlapping zones (higher = more important)",
            "title": "Priority"
          },
          "shape": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ZoneShape"
              },
              {
                "type": "null"
              }
            ],
            "description": "Shape of the zone"
          },
          "zone_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ZoneType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Type of zone"
          }
        },
        "title": "ZoneUpdate",
        "type": "object"
      }
    }
  },
  "info": {
    "description": "AI-powered home security monitoring system",
    "title": "Home Security Intelligence API",
    "version": "0.1.0"
  },
  "openapi": "3.1.0",
  "paths": {
    "/": {
      "get": {
        "description": "Health check endpoint.",
        "operationId": "root__get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Root  Get",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Root"
      }
    },
    "/api/admin/seed/cameras": {
      "post": {
        "description": "Seed test cameras into the database.\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\n\nArgs:\n    request: Seed configuration (count, clear_existing, create_folders)\n    db: Database session\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of seeded cameras",
        "operationId": "seed_cameras_api_admin_seed_cameras_post",
        "parameters": [
          {
            "in": "header",
            "name": "x-admin-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Admin-Api-Key"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedCamerasRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedCamerasResponse"
                }
              }
            },
            "description": "Cameras created successfully"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Seed Cameras",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/admin/seed/clear": {
      "delete": {
        "description": "Clear all seeded data (cameras, events, detections).\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\nRequires JSON body confirmation to prevent accidental data deletion:\n{\"confirm\": \"DELETE_ALL_DATA\"}\n\nArgs:\n    body: Request body with confirmation string\n    request: FastAPI request for audit logging\n    db: Database session\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of cleared data counts\n\nRaises:\n    HTTPException: 400 if confirmation string is incorrect",
        "operationId": "clear_seeded_data_api_admin_seed_clear_delete",
        "parameters": [
          {
            "in": "header",
            "name": "x-admin-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Admin-Api-Key"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClearDataRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClearDataResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Confirmation required"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Clear Seeded Data",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/admin/seed/events": {
      "post": {
        "description": "Seed mock events and detections into the database.\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\nRequires cameras to exist first.\n\nArgs:\n    request: Seed configuration (count, clear_existing)\n    db: Database session\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of seeded events and detections",
        "operationId": "seed_events_api_admin_seed_events_post",
        "parameters": [
          {
            "in": "header",
            "name": "x-admin-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Admin-Api-Key"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedEventsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedEventsResponse"
                }
              }
            },
            "description": "Events and detections created successfully"
          },
          "400": {
            "description": "Bad request - No cameras found"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Seed Events",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/ai-audit/batch": {
      "post": {
        "description": "Trigger batch audit processing for multiple events.\n\nQueues events for audit processing based on the provided criteria.\nEvents are processed asynchronously.\n\nArgs:\n    request: Batch audit request with filtering criteria\n    db: Database session\n\nReturns:\n    BatchAuditResponse with number of queued events",
        "operationId": "trigger_batch_audit_api_ai_audit_batch_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchAuditRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchAuditResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Trigger Batch Audit",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/events/{event_id}": {
      "get": {
        "description": "Get audit information for a specific event.\n\nRetrieves the AI pipeline audit record for the given event, including\nmodel contributions, quality scores, and prompt improvement suggestions.\n\nArgs:\n    event_id: The ID of the event to get audit for\n    db: Database session\n\nReturns:\n    EventAuditResponse containing full audit details\n\nRaises:\n    HTTPException: 404 if event or audit not found",
        "operationId": "get_event_audit_api_ai_audit_events__event_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventAuditResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Event or audit not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Event Audit",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/events/{event_id}/evaluate": {
      "post": {
        "description": "Trigger full evaluation for a specific event's audit.\n\nRuns the complete self-evaluation pipeline (self-critique, rubric scoring,\nconsistency check, prompt improvement) for the given event.\n\nArgs:\n    event_id: The ID of the event to evaluate\n    request: HTTP request for audit logging\n    force: If True, re-evaluate even if already evaluated\n    db: Database session\n\nReturns:\n    EventAuditResponse with updated evaluation results\n\nRaises:\n    HTTPException: 404 if event or audit not found",
        "operationId": "evaluate_event_api_ai_audit_events__event_id__evaluate_post",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Force re-evaluation even if already evaluated",
            "in": "query",
            "name": "force",
            "required": false,
            "schema": {
              "default": false,
              "description": "Force re-evaluation even if already evaluated",
              "title": "Force",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventAuditResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Event or audit not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Evaluate Event",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/leaderboard": {
      "get": {
        "description": "Get model leaderboard ranked by contribution rate.\n\nReturns a ranked list of AI models by their contribution rate,\nalong with quality correlation data.\n\nArgs:\n    days: Number of days to include (1-90, default 7)\n    db: Database session\n\nReturns:\n    LeaderboardResponse with ranked model entries",
        "operationId": "get_model_leaderboard_api_ai_audit_leaderboard_get",
        "parameters": [
          {
            "description": "Number of days to include",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "default": 7,
              "description": "Number of days to include",
              "maximum": 90,
              "minimum": 1,
              "title": "Days",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Model Leaderboard",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/prompt-config/{model}": {
      "get": {
        "description": "Get current prompt configuration for a model (database-backed).\n\nRetrieves the prompt configuration from the database for the specified model.\nReturns 404 if no configuration exists for the model.\n\nArgs:\n    model: Model name (nemotron, florence-2, yolo-world, x-clip, fashion-clip)\n    db: Database session\n\nReturns:\n    PromptConfigResponse with current configuration\n\nRaises:\n    HTTPException: 404 if model not found or no configuration exists",
        "operationId": "get_prompt_config_api_ai_audit_prompt_config__model__get",
        "parameters": [
          {
            "in": "path",
            "name": "model",
            "required": true,
            "schema": {
              "title": "Model",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Prompt Config",
        "tags": [
          "ai-audit"
        ]
      },
      "put": {
        "description": "Update prompt configuration for a model (database-backed).\n\nCreates or updates the prompt configuration in the database.\nIf updating an existing config, increments the version number.\n\nArgs:\n    model: Model name (nemotron, florence-2, yolo-world, x-clip, fashion-clip)\n    request: New configuration with system_prompt, temperature, max_tokens\n    db: Database session\n\nReturns:\n    PromptConfigResponse with updated configuration\n\nRaises:\n    HTTPException: 404 if model not found, 400 if configuration invalid",
        "operationId": "update_prompt_config_api_ai_audit_prompt_config__model__put",
        "parameters": [
          {
            "in": "path",
            "name": "model",
            "required": true,
            "schema": {
              "title": "Model",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptConfigRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Prompt Config",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/prompts": {
      "get": {
        "description": "Get current prompt configurations for all AI models.\n\nReturns configurations for nemotron, florence2, yolo_world, xclip,\nand fashion_clip models with their current versions.\n\nReturns:\n    AllPromptsResponse containing all model configurations",
        "operationId": "get_all_prompts_api_ai_audit_prompts_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AllPromptsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get All Prompts",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/prompts/export": {
      "get": {
        "description": "Export all AI model configurations as JSON.\n\nReturns all current configurations in a format suitable for\nbackup or transfer to another instance.\n\nReturns:\n    PromptExportResponse with all configurations",
        "operationId": "export_prompts_api_ai_audit_prompts_export_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptExportResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Export Prompts",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/prompts/history": {
      "get": {
        "description": "Get version history for all AI models.\n\nReturns the most recent versions for each supported model.\n\nArgs:\n    limit: Maximum number of versions to return per model (1-100, default 10)\n\nReturns:\n    Dict mapping model names to their version histories",
        "operationId": "get_all_prompts_history_api_ai_audit_prompts_history_get",
        "parameters": [
          {
            "description": "Max versions per model",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 10,
              "description": "Max versions per model",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "$ref": "#/components/schemas/PromptHistoryResponse"
                  },
                  "title": "Response Get All Prompts History Api Ai Audit Prompts History Get",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get All Prompts History",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/prompts/history/{model}": {
      "get": {
        "description": "Get version history for a specific AI model.\n\nReturns all versions of the model's configuration, newest first,\nwith pagination support.\n\nArgs:\n    model: Model name to get history for\n    limit: Maximum versions to return (1-100, default 50)\n    offset: Number of versions to skip (default 0)\n\nReturns:\n    PromptHistoryResponse with version list\n\nRaises:\n    HTTPException: 404 if model not found",
        "operationId": "get_model_history_api_ai_audit_prompts_history__model__get",
        "parameters": [
          {
            "in": "path",
            "name": "model",
            "required": true,
            "schema": {
              "title": "Model",
              "type": "string"
            }
          },
          {
            "description": "Max versions to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Max versions to return",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of versions to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of versions to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Model not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Model History",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/prompts/history/{version}": {
      "post": {
        "description": "Restore a specific version of a model's prompt configuration.\n\nCreates a new version with the configuration from the specified version.\nThe restore action is recorded in the version history.\n\nArgs:\n    version: Version number to restore\n    model: Model name to restore version for\n    request: Optional restore request with description\n\nReturns:\n    PromptRestoreResponse with restore details\n\nRaises:\n    HTTPException: 404 if model or version not found",
        "operationId": "restore_prompt_version_api_ai_audit_prompts_history__version__post",
        "parameters": [
          {
            "in": "path",
            "name": "version",
            "required": true,
            "schema": {
              "title": "Version",
              "type": "integer"
            }
          },
          {
            "description": "Model name to restore version for",
            "in": "query",
            "name": "model",
            "required": true,
            "schema": {
              "description": "Model name to restore version for",
              "title": "Model",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/PromptRestoreRequest"
                  },
                  {
                    "type": "null"
                  }
                ],
                "title": "Request"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptRestoreResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Model or version not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Restore Prompt Version",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/prompts/import": {
      "post": {
        "description": "Import AI model configurations from JSON.\n\nImports configurations for multiple models at once. By default,\nexisting configurations are not overwritten unless overwrite=true.\n\nArgs:\n    request: Import request with configurations and overwrite flag\n\nReturns:\n    PromptImportResponse with import results\n\nRaises:\n    HTTPException: 400 if no prompts provided for import",
        "operationId": "import_prompts_api_ai_audit_prompts_import_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptImportRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptImportResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - No prompts provided"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Import Prompts",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/prompts/test": {
      "post": {
        "description": "Test a modified prompt configuration against a specific event.\n\nRuns inference with both the current and modified configurations,\nreturning a comparison of the results to help evaluate changes.\n\nNote: This currently returns mock results. In production, it would\ncall the actual AI services with the modified configuration.\n\nArgs:\n    request: Test request with model name, config, and event ID\n    db: Database session\n\nReturns:\n    PromptTestResponse with before/after comparison\n\nRaises:\n    HTTPException: 404 if model or event not found, 400 if config invalid",
        "operationId": "test_prompt_api_ai_audit_prompts_test_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptTestRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptTestResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid configuration"
          },
          "404": {
            "description": "Model or event not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Test Prompt",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/prompts/{model}": {
      "get": {
        "description": "Get current prompt configuration for a specific AI model.\n\nArgs:\n    model: Model name (nemotron, florence2, yolo_world, xclip, fashion_clip)\n\nReturns:\n    ModelPromptResponse with current configuration\n\nRaises:\n    HTTPException: 404 if model not found",
        "operationId": "get_model_prompt_api_ai_audit_prompts__model__get",
        "parameters": [
          {
            "in": "path",
            "name": "model",
            "required": true,
            "schema": {
              "title": "Model",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelPromptResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Model not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Model Prompt",
        "tags": [
          "ai-audit"
        ]
      },
      "put": {
        "description": "Update prompt configuration for a specific AI model.\n\nCreates a new version of the configuration with the provided changes.\nThe previous version is preserved in history.\n\nArgs:\n    model: Model name to update\n    request: New configuration and optional description\n\nReturns:\n    PromptUpdateResponse with new version info\n\nRaises:\n    HTTPException: 404 if model not found, 400 if configuration invalid",
        "operationId": "update_model_prompt_api_ai_audit_prompts__model__put",
        "parameters": [
          {
            "in": "path",
            "name": "model",
            "required": true,
            "schema": {
              "title": "Model",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptUpdateResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid configuration"
          },
          "404": {
            "description": "Model not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Model Prompt",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/recommendations": {
      "get": {
        "description": "Get aggregated prompt improvement recommendations.\n\nAnalyzes all audits to produce actionable recommendations for\nimproving the AI pipeline prompt templates.\n\nArgs:\n    days: Number of days to analyze (1-90, default 7)\n    db: Database session\n\nReturns:\n    RecommendationsResponse with prioritized recommendations",
        "operationId": "get_recommendations_api_ai_audit_recommendations_get",
        "parameters": [
          {
            "description": "Number of days to include",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "default": 7,
              "description": "Number of days to include",
              "maximum": 90,
              "minimum": 1,
              "title": "Days",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecommendationsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Recommendations",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/stats": {
      "get": {
        "description": "Get aggregate AI audit statistics.\n\nReturns aggregate statistics including total events, quality scores,\nmodel contribution rates, and audit trends over the specified period.\n\nArgs:\n    days: Number of days to include in statistics (1-90, default 7)\n    camera_id: Optional camera ID to filter stats\n    db: Database session\n\nReturns:\n    AuditStatsResponse with aggregate statistics",
        "operationId": "get_audit_stats_api_ai_audit_stats_get",
        "parameters": [
          {
            "description": "Number of days to include",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "default": 7,
              "description": "Number of days to include",
              "maximum": 90,
              "minimum": 1,
              "title": "Days",
              "type": "integer"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Audit Stats",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/test-prompt": {
      "post": {
        "description": "Test a custom prompt against an existing event for A/B testing.\n\nThis endpoint allows testing a custom prompt without persisting results.\nIt's designed for the Prompt Playground A/B testing feature where users\ncan experiment with different prompts and compare results.\n\nThe endpoint:\n1. Fetches the event with its detections\n2. Builds context from the event data\n3. Calls the AI model with the custom prompt (or mocks if service unavailable)\n4. Returns results WITHOUT saving to database\n\nArgs:\n    request: Test request containing event_id, custom_prompt, and optional\n             parameters (temperature, max_tokens, model)\n    db: Database session\n\nReturns:\n    CustomTestPromptResponse with risk analysis results\n\nRaises:\n    HTTPException: 404 if event not found\n    HTTPException: 400 if prompt is invalid (empty or too long)\n    HTTPException: 503 if AI service is unavailable\n    HTTPException: 408 if request times out (>60s)",
        "operationId": "test_custom_prompt_api_ai_audit_test_prompt_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CustomTestPromptRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CustomTestPromptResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid or too long prompt"
          },
          "404": {
            "description": "Event not found"
          },
          "408": {
            "description": "Request timeout"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "AI service unavailable"
          }
        },
        "summary": "Test Custom Prompt",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/alerts/rules": {
      "get": {
        "description": "List all alert rules with optional filtering and pagination.\n\nArgs:\n    enabled: Filter by enabled status\n    severity: Filter by severity level (low, medium, high, critical)\n    limit: Maximum number of results to return\n    offset: Number of results to skip for pagination\n    db: Database session\n\nReturns:\n    AlertRuleListResponse with rules and pagination info",
        "operationId": "list_rules_api_alerts_rules_get",
        "parameters": [
          {
            "description": "Filter by enabled status",
            "in": "query",
            "name": "enabled",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by enabled status",
              "title": "Enabled"
            }
          },
          {
            "description": "Filter by severity level",
            "in": "query",
            "name": "severity",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by severity level",
              "title": "Severity"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Rules",
        "tags": [
          "alert-rules"
        ]
      },
      "post": {
        "description": "Create a new alert rule.\n\nArgs:\n    rule_data: Rule creation data\n    db: Database session\n    cache: Cache service for cache invalidation (NEM-1952)\n\nReturns:\n    Created AlertRule",
        "operationId": "create_rule_api_alerts_rules_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AlertRuleCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Create Rule",
        "tags": [
          "alert-rules"
        ]
      }
    },
    "/api/alerts/rules/{rule_id}": {
      "delete": {
        "description": "Delete an alert rule.\n\nArgs:\n    rule_id: Rule UUID\n    db: Database session\n    cache: Cache service for cache invalidation (NEM-1952)\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "delete_rule_api_alerts_rules__rule_id__delete",
        "parameters": [
          {
            "in": "path",
            "name": "rule_id",
            "required": true,
            "schema": {
              "title": "Rule Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert rule not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Delete Rule",
        "tags": [
          "alert-rules"
        ]
      },
      "get": {
        "description": "Get a specific alert rule by ID.\n\nArgs:\n    rule_id: Rule UUID\n    db: Database session\n\nReturns:\n    AlertRule\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "get_rule_api_alerts_rules__rule_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "rule_id",
            "required": true,
            "schema": {
              "title": "Rule Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert rule not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Rule",
        "tags": [
          "alert-rules"
        ]
      },
      "put": {
        "description": "Update an existing alert rule.\n\nArgs:\n    rule_id: Rule UUID\n    rule_data: Rule update data\n    db: Database session\n    cache: Cache service for cache invalidation (NEM-1952)\n\nReturns:\n    Updated AlertRule\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "update_rule_api_alerts_rules__rule_id__put",
        "parameters": [
          {
            "in": "path",
            "name": "rule_id",
            "required": true,
            "schema": {
              "title": "Rule Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AlertRuleUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Rule",
        "tags": [
          "alert-rules"
        ]
      }
    },
    "/api/alerts/rules/{rule_id}/test": {
      "post": {
        "description": "Test a rule against historical events.\n\nThis endpoint allows testing rule configuration without actually\ncreating alerts. Useful for validating rules before enabling them.\n\nArgs:\n    rule_id: Rule UUID\n    test_data: Test configuration (event IDs, time override)\n    db: Database session\n    engine: AlertRuleEngine injected via Depends()\n\nReturns:\n    RuleTestResponse with per-event match results\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "test_rule_api_alerts_rules__rule_id__test_post",
        "parameters": [
          {
            "in": "path",
            "name": "rule_id",
            "required": true,
            "schema": {
              "title": "Rule Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RuleTestRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RuleTestResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert rule not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Test Rule",
        "tags": [
          "alert-rules"
        ]
      }
    },
    "/api/alerts/{alert_id}/acknowledge": {
      "post": {
        "description": "Acknowledge an alert.\n\nMarks an alert as acknowledged and broadcasts the state change via WebSocket.\nOnly alerts with status PENDING or DELIVERED can be acknowledged.\n\nArgs:\n    alert_id: Alert UUID\n    db: Database session\n\nReturns:\n    Updated AlertResponse\n\nRaises:\n    HTTPException: 404 if alert not found, 409 if alert cannot be acknowledged",
        "operationId": "acknowledge_alert_api_alerts__alert_id__acknowledge_post",
        "parameters": [
          {
            "in": "path",
            "name": "alert_id",
            "required": true,
            "schema": {
              "title": "Alert Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert not found"
          },
          "409": {
            "description": "Alert cannot be acknowledged (wrong status)"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Acknowledge Alert",
        "tags": [
          "alerts"
        ]
      }
    },
    "/api/alerts/{alert_id}/dismiss": {
      "post": {
        "description": "Dismiss an alert.\n\nMarks an alert as dismissed and broadcasts the state change via WebSocket.\nOnly alerts with status PENDING, DELIVERED, or ACKNOWLEDGED can be dismissed.\n\nArgs:\n    alert_id: Alert UUID\n    db: Database session\n\nReturns:\n    Updated AlertResponse\n\nRaises:\n    HTTPException: 404 if alert not found, 409 if alert cannot be dismissed",
        "operationId": "dismiss_alert_api_alerts__alert_id__dismiss_post",
        "parameters": [
          {
            "in": "path",
            "name": "alert_id",
            "required": true,
            "schema": {
              "title": "Alert Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert not found"
          },
          "409": {
            "description": "Alert cannot be dismissed (wrong status)"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Dismiss Alert",
        "tags": [
          "alerts"
        ]
      }
    },
    "/api/analytics/camera-uptime": {
      "get": {
        "description": "Get uptime percentage per camera.\n\nReturns uptime percentage and detection count for each camera.\nUptime is calculated based on the number of days with at least one detection\ndivided by the total days in the date range.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    db: Database session\n\nReturns:\n    CameraUptimeResponse with per-camera uptime data\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "get_camera_uptime_api_analytics_camera_uptime_get",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraUptimeResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Camera Uptime",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/analytics/detection-trends": {
      "get": {
        "description": "Get detection counts aggregated by day.\n\nReturns daily detection counts for the specified date range.\nCreates one data point per day even if there are no detections.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    db: Database session\n\nReturns:\n    DetectionTrendsResponse with daily detection counts\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "get_detection_trends_api_analytics_detection_trends_get",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionTrendsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Detection Trends",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/analytics/object-distribution": {
      "get": {
        "description": "Get detection counts by object type.\n\nReturns detection counts grouped by object type with percentages.\nOnly includes detections with non-null object_type.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    db: Database session\n\nReturns:\n    ObjectDistributionResponse with object type counts and percentages\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "get_object_distribution_api_analytics_object_distribution_get",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectDistributionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Object Distribution",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/analytics/risk-history": {
      "get": {
        "description": "Get risk score distribution over time.\n\nReturns daily counts of events grouped by risk level (low, medium, high, critical).\nCreates one data point per day even if there are no events.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    db: Database session\n\nReturns:\n    RiskHistoryResponse with daily risk level counts\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "get_risk_history_api_analytics_risk_history_get",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RiskHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Risk History",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/audit": {
      "get": {
        "description": "List audit logs with optional filtering and cursor-based pagination.\n\nThis endpoint is intended for admin use to review security-sensitive operations.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\nArgs:\n    action: Optional action type to filter by\n    resource_type: Optional resource type to filter by\n    resource_id: Optional specific resource ID to filter by\n    actor: Optional actor to filter by\n    status_filter: Optional status to filter by (success/failure)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    limit: Maximum number of results to return (1-1000, default 100)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    db: Database session\n\nReturns:\n    AuditLogListResponse containing filtered logs and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid",
        "operationId": "list_audit_logs_api_audit_get",
        "parameters": [
          {
            "description": "Filter by action type",
            "in": "query",
            "name": "action",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by action type",
              "title": "Action"
            }
          },
          {
            "description": "Filter by resource type",
            "in": "query",
            "name": "resource_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by resource type",
              "title": "Resource Type"
            }
          },
          {
            "description": "Filter by resource ID",
            "in": "query",
            "name": "resource_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by resource ID",
              "title": "Resource Id"
            }
          },
          {
            "description": "Filter by actor",
            "in": "query",
            "name": "actor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by actor",
              "title": "Actor"
            }
          },
          {
            "description": "Filter by status (success/failure)",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by status (success/failure)",
              "title": "Status"
            }
          },
          {
            "description": "Filter from date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter from date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter to date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter to date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Page size",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 100,
              "description": "Page size",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip (deprecated, use cursor)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor from previous response",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditLogListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid date range or cursor"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Audit Logs",
        "tags": [
          "audit"
        ]
      }
    },
    "/api/audit/stats": {
      "get": {
        "description": "Get audit log statistics for dashboard.\n\nReturns aggregated statistics about audit logs including:\n- Total log count\n- Logs today\n- Breakdown by action type\n- Breakdown by resource type\n- Breakdown by status\n- Recently active actors\n\nThis endpoint is optimized to use a single aggregation query for counts\n(total, today, by_action, by_resource_type, by_status) plus one query\nfor recent actors, reducing database round-trips from 6 to 2.\n\nArgs:\n    db: Database session\n\nReturns:\n    AuditLogStats with aggregated statistics",
        "operationId": "get_audit_stats_api_audit_stats_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditLogStats"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid date range"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Audit Stats",
        "tags": [
          "audit"
        ]
      }
    },
    "/api/audit/{audit_id}": {
      "get": {
        "description": "Get a specific audit log entry by ID.\n\nArgs:\n    audit_id: Audit log ID\n    db: Database session\n\nReturns:\n    AuditLog record\n\nRaises:\n    HTTPException: 404 if audit log not found",
        "operationId": "get_audit_log_api_audit__audit_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "audit_id",
            "required": true,
            "schema": {
              "title": "Audit Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditLogResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Audit log not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Audit Log",
        "tags": [
          "audit"
        ]
      }
    },
    "/api/cameras": {
      "get": {
        "description": "List all cameras with optional status filter.\n\nUses Redis cache with cache-aside pattern to improve performance\nand generate cache hit metrics.\n\nSparse Fieldsets (NEM-1434):\nUse the `fields` parameter to request only specific fields in the response,\nreducing payload size. Example: ?fields=id,name,status\n\nArgs:\n    status_filter: Optional status to filter cameras by (online, offline, error)\n    fields: Comma-separated list of fields to include (sparse fieldsets)\n    db: Database session\n    cache: Cache service injected via FastAPI DI\n\nReturns:\n    CameraListResponse containing list of cameras and total count\n\nRaises:\n    HTTPException: 400 if invalid fields are requested",
        "operationId": "list_cameras_api_cameras_get",
        "parameters": [
          {
            "description": "Filter by camera status",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera status",
              "title": "Status"
            }
          },
          {
            "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, name, folder_path, status, created_at, last_seen_at",
            "in": "query",
            "name": "fields",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, name, folder_path, status, created_at, last_seen_at",
              "title": "Fields"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Cameras",
        "tags": [
          "cameras"
        ]
      },
      "post": {
        "description": "Create a new camera.\n\nArgs:\n    camera_data: Camera creation data\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    Created camera object with generated ID\n\nRaises:\n    HTTPException: 409 if camera with same name or folder_path already exists",
        "operationId": "create_camera_api_cameras_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Camera",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/deleted": {
      "get": {
        "description": "List all soft-deleted cameras for trash view.\n\nReturns cameras that have been soft-deleted (deleted_at is not null),\nordered by deleted_at descending (most recently deleted first).\n\nThis endpoint enables a \"trash\" view where users can see deleted cameras\nand optionally restore them.\n\nArgs:\n    db: Database session\n\nReturns:\n    DeletedCamerasListResponse containing list of deleted cameras and count",
        "operationId": "list_deleted_cameras_api_cameras_deleted_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeletedCamerasListResponse"
                }
              }
            },
            "description": "List of soft-deleted cameras"
          }
        },
        "summary": "List all soft-deleted cameras",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/validation/paths": {
      "get": {
        "description": "Validate all camera folder paths against the configured base path.\n\nThis endpoint checks each camera's folder_path to determine:\n1. Whether the path is under the configured FOSCAM_BASE_PATH\n2. Whether the directory exists on disk\n3. Whether the directory contains any images\n\nUse this to diagnose cameras that show \"No snapshot available\" errors.\n\nReturns:\n    CameraPathValidationResponse with validation results for all cameras",
        "operationId": "validate_camera_paths_api_cameras_validation_paths_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraPathValidationResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Validate Camera Paths",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}": {
      "delete": {
        "description": "Delete a camera.\n\nThis operation cascades to all related detections and events.\n\nArgs:\n    camera_id: Normalized camera ID (e.g., \"front_door\", \"backyard\")\n    request: FastAPI request for audit logging\n    db: Database session\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "delete_camera_api_cameras__camera_id__delete",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Camera",
        "tags": [
          "cameras"
        ]
      },
      "get": {
        "description": "Get a specific camera by ID.\n\nArgs:\n    camera_id: Normalized camera ID (e.g., \"front_door\", \"backyard\")\n    db: Database session\n\nReturns:\n    Camera object\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_api_cameras__camera_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera",
        "tags": [
          "cameras"
        ]
      },
      "patch": {
        "description": "Update an existing camera.\n\nArgs:\n    camera_id: Normalized camera ID (e.g., \"front_door\", \"backyard\")\n    camera_data: Camera update data (all fields optional)\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    Updated camera object\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "update_camera_api_cameras__camera_id__patch",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Camera",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/baseline": {
      "get": {
        "description": "Get baseline activity data for a camera.\n\nReturns comprehensive baseline statistics including:\n- Hourly activity patterns (0-23 hours)\n- Daily patterns (by day of week)\n- Object-specific baselines\n- Current deviation from baseline\n\nArgs:\n    camera_id: ID of the camera\n    db: Database session\n    baseline_service: BaselineService injected via Depends()\n\nReturns:\n    BaselineSummaryResponse with all baseline data\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_baseline_api_cameras__camera_id__baseline_get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BaselineSummaryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Baseline",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/baseline/activity": {
      "get": {
        "description": "Get raw activity baseline data for a camera.\n\nReturns up to 168 entries (24 hours x 7 days) representing the full\nweekly activity heatmap. Each entry contains the average count and\nsample count for that hour/day combination.\n\nArgs:\n    camera_id: ID of the camera\n    db: Database session\n    baseline_service: BaselineService injected via Depends()\n\nReturns:\n    ActivityBaselineResponse with entries for the heatmap\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_activity_baseline_api_cameras__camera_id__baseline_activity_get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActivityBaselineResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Activity Baseline",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/baseline/anomalies": {
      "get": {
        "description": "Get recent anomaly events for a camera.\n\nReturns a list of anomaly events detected within the specified time period.\nAnomalies are detections that significantly deviate from the established\nbaseline activity patterns.\n\nArgs:\n    camera_id: ID of the camera\n    days: Number of days to look back (default: 7, max: 90)\n    db: Database session\n    baseline_service: BaselineService injected via Depends()\n\nReturns:\n    AnomalyListResponse with list of anomaly events\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_baseline_anomalies_api_cameras__camera_id__baseline_anomalies_get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Number of days to look back",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "default": 7,
              "description": "Number of days to look back",
              "maximum": 90,
              "minimum": 1,
              "title": "Days",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnomalyListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Baseline Anomalies",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/baseline/classes": {
      "get": {
        "description": "Get class frequency baseline data for a camera.\n\nReturns baseline entries grouped by object class and hour, showing\nthe frequency of each object type at different times of day.\n\nArgs:\n    camera_id: ID of the camera\n    db: Database session\n    baseline_service: BaselineService injected via Depends()\n\nReturns:\n    ClassBaselineResponse with entries for each class/hour combination\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_class_baseline_api_cameras__camera_id__baseline_classes_get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClassBaselineResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Class Baseline",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/restore": {
      "post": {
        "description": "Restore a soft-deleted camera.\n\nClears the deleted_at timestamp on a soft-deleted camera, making it\nvisible again in normal queries.\n\nArgs:\n    camera_id: ID of the camera to restore\n    db: Database session\n    cache: Cache service for invalidation\n\nReturns:\n    CameraResponse with the restored camera data\n\nRaises:\n    HTTPException: 404 if camera not found\n    HTTPException: 400 if camera is not deleted (nothing to restore)",
        "operationId": "restore_camera_api_cameras__camera_id__restore_post",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            },
            "description": "Camera restored successfully"
          },
          "400": {
            "description": "Camera is not deleted"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Restore a soft-deleted camera",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/scene-changes": {
      "get": {
        "description": "Get scene changes for a camera with cursor-based pagination.\n\nReturns a list of detected scene changes that may indicate camera\ntampering, angle changes, or blocked views. Uses cursor-based pagination\nfor efficient navigation through large datasets.\n\nArgs:\n    camera_id: ID of the camera\n    acknowledged: Filter by acknowledgement status (None = all)\n    limit: Maximum number of results (default: 50, max: 100)\n    cursor: Cursor for pagination (detected_at timestamp from previous response)\n    db: Database session\n\nReturns:\n    SceneChangeListResponse with list of scene changes and pagination info\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_scene_changes_api_cameras__camera_id__scene_changes_get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Filter by acknowledgement status",
            "in": "query",
            "name": "acknowledged",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by acknowledgement status",
              "title": "Acknowledged"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Cursor for pagination (detected_at timestamp)",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Cursor for pagination (detected_at timestamp)",
              "title": "Cursor"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneChangeListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Scene Changes",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/scene-changes/{scene_change_id}/acknowledge": {
      "post": {
        "description": "Acknowledge a scene change alert.\n\nMarks a scene change as acknowledged to indicate it has been reviewed.\n\nArgs:\n    camera_id: ID of the camera\n    scene_change_id: ID of the scene change to acknowledge\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    SceneChangeAcknowledgeResponse confirming acknowledgement\n\nRaises:\n    HTTPException: 404 if camera or scene change not found",
        "operationId": "acknowledge_scene_change_api_cameras__camera_id__scene_changes__scene_change_id__acknowledge_post",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "scene_change_id",
            "required": true,
            "schema": {
              "title": "Scene Change Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneChangeAcknowledgeResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Acknowledge Scene Change",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/snapshot": {
      "get": {
        "description": "Return the latest image for a camera (best-effort snapshot).\n\nThis endpoint is exempt from API key authentication because:\n1. It serves static image content accessed directly by browsers via <img> tags\n2. It has its own security controls (path traversal protection, file type allowlist)\n3. It has rate limiting to prevent abuse\n\nThis endpoint uses the camera's configured `folder_path` and returns the most recently\nmodified image file under that directory.",
        "operationId": "get_camera_snapshot_api_cameras__camera_id__snapshot_get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Snapshot served successfully"
          },
          "404": {
            "description": "Camera or snapshot not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Get Camera Snapshot",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/zones": {
      "get": {
        "description": "List all zones for a camera with optional filtering.\n\nArgs:\n    camera_id: ID of the camera\n    enabled: Optional filter for enabled/disabled zones\n    db: Database session\n\nReturns:\n    ZoneListResponse containing list of zones and total count",
        "operationId": "list_zones_api_cameras__camera_id__zones_get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Filter by enabled status",
            "in": "query",
            "name": "enabled",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by enabled status",
              "title": "Enabled"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Zones",
        "tags": [
          "zones"
        ]
      },
      "post": {
        "description": "Create a new zone for a camera.\n\nArgs:\n    camera_id: ID of the camera\n    zone_data: Zone creation data\n    db: Database session\n\nReturns:\n    Created zone object with generated ID",
        "operationId": "create_zone_api_cameras__camera_id__zones_post",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZoneCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Zone",
        "tags": [
          "zones"
        ]
      }
    },
    "/api/cameras/{camera_id}/zones/{zone_id}": {
      "delete": {
        "description": "Delete a zone.\n\nArgs:\n    camera_id: ID of the camera\n    zone_id: ID of the zone to delete\n    db: Database session\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "delete_zone_api_cameras__camera_id__zones__zone_id__delete",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Zone",
        "tags": [
          "zones"
        ]
      },
      "get": {
        "description": "Get a specific zone by ID.\n\nArgs:\n    camera_id: ID of the camera\n    zone_id: ID of the zone\n    db: Database session\n\nReturns:\n    Zone object\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "get_zone_api_cameras__camera_id__zones__zone_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Zone",
        "tags": [
          "zones"
        ]
      },
      "put": {
        "description": "Update an existing zone.\n\nArgs:\n    camera_id: ID of the camera\n    zone_id: ID of the zone to update\n    zone_data: Zone update data (all fields optional)\n    db: Database session\n\nReturns:\n    Updated zone object\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "update_zone_api_cameras__camera_id__zones__zone_id__put",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZoneUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Zone",
        "tags": [
          "zones"
        ]
      }
    },
    "/api/debug/circuit-breakers": {
      "get": {
        "description": "Get all circuit breaker states.\n\nReturns the current state and metrics for all registered circuit breakers,\nincluding failure counts, success counts, and configuration.\n\nNEM-1642: Debug endpoint for circuit breaker diagnostics",
        "operationId": "get_circuit_breakers_api_debug_circuit_breakers_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebugCircuitBreakersResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Circuit Breakers",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/config": {
      "get": {
        "description": "Get current configuration with sensitive values redacted.\n\nReturns all configuration settings with passwords, API keys, and other\nsensitive values replaced with [REDACTED]. URLs containing passwords\nwill have only the password portion redacted, preserving the structure.\n\nNEM-1642: Debug endpoint for configuration inspection",
        "operationId": "get_config_api_debug_config_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebugConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Config",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/log-level": {
      "get": {
        "description": "Get current log level.\n\nNEM-1471: Log level inspection endpoint",
        "operationId": "get_log_level_api_debug_log_level_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogLevelResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Log Level",
        "tags": [
          "debug"
        ]
      },
      "post": {
        "description": "Set log level at runtime for debugging.\n\nAllows changing the log level without restarting the application.\nUseful for temporarily enabling DEBUG logging to investigate issues.\n\nNEM-1471: Log level runtime override\n\nArgs:\n    request: Log level request with new level\n\nReturns:\n    Current and previous log level\n\nRaises:\n    HTTPException: If the log level is invalid",
        "operationId": "set_log_level_api_debug_log_level_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LogLevelRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogLevelResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid log level"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Set Log Level",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/pipeline-state": {
      "get": {
        "description": "Get current state of the AI processing pipeline.\n\nReturns queue depths, worker status, and recent errors for debugging\npipeline issues and monitoring system health.\n\nNEM-1470: Debug endpoint for pipeline state inspection",
        "operationId": "get_pipeline_state_api_debug_pipeline_state_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineStateResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Pipeline State",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/profile/start": {
      "post": {
        "description": "Start performance profiling.\n\nBegins collecting profiling data for performance analysis.\nProfile data is saved to disk when stop is called.\n\nNEM-1644: Debug endpoint for performance profiling\n\nReturns:\n    Profiling start status",
        "operationId": "start_profiling_api_debug_profile_start_post",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProfileStartResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Start Profiling",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/profile/stats": {
      "get": {
        "description": "Get current profiling statistics.\n\nReturns the current profiling state and statistics from the last\ncompleted profiling session.\n\nNEM-1644: Debug endpoint for performance profiling\n\nReturns:\n    Profiling status and statistics",
        "operationId": "get_profile_stats_api_debug_profile_stats_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProfileStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Profile Stats",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/profile/stop": {
      "post": {
        "description": "Stop performance profiling and save results.\n\nStops the profiler and saves the profile data to a .prof file.\nThe file can be analyzed with snakeviz or py-spy.\n\nNEM-1644: Debug endpoint for performance profiling\n\nReturns:\n    Profiling stop status with path to saved profile",
        "operationId": "stop_profiling_api_debug_profile_stop_post",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProfileStopResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Stop Profiling",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/recordings": {
      "get": {
        "description": "List available request recordings.\n\nReturns a list of recorded requests, sorted by timestamp (newest first).\nUse the recording_id to replay a specific request.\n\nNEM-1646: Request recording and replay for debugging\n\nArgs:\n    limit: Maximum number of recordings to return (default: 50)\n\nReturns:\n    List of recordings with metadata",
        "operationId": "list_recordings_api_debug_recordings_get",
        "parameters": [
          {
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecordingsListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Recordings",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/recordings/{recording_id}": {
      "delete": {
        "description": "Delete a specific recording.\n\nNEM-1646: Request recording management\n\nArgs:\n    recording_id: ID of the recording to delete\n\nReturns:\n    Confirmation message\n\nRaises:\n    HTTPException: 404 if recording not found",
        "operationId": "delete_recording_api_debug_recordings__recording_id__delete",
        "parameters": [
          {
            "in": "path",
            "name": "recording_id",
            "required": true,
            "schema": {
              "title": "Recording Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Delete Recording Api Debug Recordings  Recording Id  Delete",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Recording",
        "tags": [
          "debug"
        ]
      },
      "get": {
        "description": "Get details of a specific recording.\n\nReturns the full recording data including headers, body, and response.\n\nNEM-1646: Request recording and replay for debugging\n\nArgs:\n    recording_id: ID of the recording to retrieve\n\nReturns:\n    Full recording data\n\nRaises:\n    HTTPException: 404 if recording not found",
        "operationId": "get_recording_api_debug_recordings__recording_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "recording_id",
            "required": true,
            "schema": {
              "title": "Recording Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": true,
                  "title": "Response Get Recording Api Debug Recordings  Recording Id  Get",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Recording",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/redis/info": {
      "get": {
        "description": "Get Redis connection stats and pub/sub channel information.\n\nReturns Redis server info, memory usage, connection stats, and\nactive pub/sub channels with their subscriber counts.\n\nNEM-1642: Debug endpoint for Redis diagnostics",
        "operationId": "get_redis_info_api_debug_redis_info_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RedisInfoResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Redis Info",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/replay/{recording_id}": {
      "post": {
        "description": "Replay a recorded request for debugging.\n\nReconstructs the original request from the recording and executes it\nagainst the current application. This is useful for:\n- Reproducing production issues locally\n- Testing fixes for error scenarios\n- Debugging intermittent failures\n\nSECURITY: This endpoint is only available when debug=True and requires\nthe request to pass through the debug mode gate.\n\nNEM-1646: Request recording and replay for debugging\n\nArgs:\n    recording_id: ID of the recording to replay\n\nReturns:\n    Replay response with original and new status codes\n\nRaises:\n    HTTPException: 404 if recording not found",
        "operationId": "replay_request_api_debug_replay__recording_id__post",
        "parameters": [
          {
            "in": "path",
            "name": "recording_id",
            "required": true,
            "schema": {
              "title": "Recording Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReplayResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Replay Request",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/websocket/connections": {
      "get": {
        "description": "Get active WebSocket connection states.\n\nReturns connection counts and health status for both the event broadcaster\n(security event stream) and system broadcaster (system status stream).\n\nNEM-1642: Debug endpoint for WebSocket diagnostics",
        "operationId": "get_websocket_connections_api_debug_websocket_connections_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketConnectionsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Websocket Connections",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/detections": {
      "get": {
        "description": "List detections with optional filtering and cursor-based pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\nSparse Fieldsets (NEM-1434):\nUse the `fields` parameter to request only specific fields in the response,\nreducing payload size. Example: ?fields=id,camera_id,object_type,confidence\n\nArgs:\n    camera_id: Optional camera ID to filter by\n    object_type: Optional object type to filter by (person, car, etc.)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    min_confidence: Optional minimum confidence score (0-1)\n    limit: Maximum number of results to return (1-100, default 50)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    fields: Comma-separated list of fields to include (sparse fieldsets)\n    db: Database session\n\nReturns:\n    DetectionListResponse containing filtered detections and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid\n    HTTPException: 400 if invalid fields are requested",
        "operationId": "list_detections_api_detections_get",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by object type",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by object type",
              "title": "Object Type"
            }
          },
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Minimum confidence score",
            "in": "query",
            "name": "min_confidence",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Minimum confidence score",
              "title": "Min Confidence"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip (deprecated, use cursor)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor from previous response",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            }
          },
          {
            "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, file_path, file_type, detected_at, object_type, confidence, bbox_x, bbox_y, bbox_width, bbox_height, thumbnail_path, media_type, duration, video_codec, video_width, video_height, enrichment_data",
            "in": "query",
            "name": "fields",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, file_path, file_type, detected_at, object_type, confidence, bbox_x, bbox_y, bbox_width, bbox_height, thumbnail_path, media_type, duration, video_codec, video_width, video_height, enrichment_data",
              "title": "Fields"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Detections",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/bulk": {
      "delete": {
        "description": "Delete multiple detections in a single request.\n\nSupports partial success - some deletions may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nNote: Detection deletion is always hard delete as detections are raw data\nand soft-delete is not supported.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk delete request with up to 100 detection IDs\n    db: Database session\n    cache: Cache service for invalidation (NEM-1951)\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "bulk_delete_detections_api_detections_bulk_delete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetectionBulkDeleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Bulk delete detections",
        "tags": [
          "detections"
        ]
      },
      "patch": {
        "description": "Update multiple detections in a single request.\n\nSupports partial success - some updates may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk update request with up to 100 detection updates\n    db: Database session\n    cache: Cache service for invalidation (NEM-1951)\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "bulk_update_detections_api_detections_bulk_patch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetectionBulkUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Bulk update detections",
        "tags": [
          "detections"
        ]
      },
      "post": {
        "description": "Create multiple detections in a single request.\n\nSupports partial success - some detections may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk create request with up to 100 detections\n    db: Database session\n    cache: Cache service for invalidation (NEM-1951)\n\nReturns:\n    DetectionBulkCreateResponse with per-item results",
        "operationId": "bulk_create_detections_api_detections_bulk_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetectionBulkCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionBulkCreateResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Bulk create detections",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/labels": {
      "get": {
        "description": "Get all unique detection labels with counts.",
        "operationId": "list_detection_labels_api_detections_labels_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionLabelsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List Detection Labels",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/search": {
      "get": {
        "description": "Search detections using full-text search.",
        "operationId": "search_detections_api_detections_search_get",
        "parameters": [
          {
            "in": "query",
            "name": "q",
            "required": true,
            "schema": {
              "minLength": 1,
              "title": "Q",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "labels",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Labels"
            }
          },
          {
            "in": "query",
            "name": "min_confidence",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Min Confidence"
            }
          },
          {
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Camera Id"
            }
          },
          {
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Start Date"
            }
          },
          {
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "End Date"
            }
          },
          {
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionSearchResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Search Detections",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/stats": {
      "get": {
        "description": "Get aggregate detection statistics including class distribution.\n\nReturns:\n- Total detection count\n- Detection counts grouped by object class (person, car, truck, etc.)\n- Average confidence score across all detections\n\nUsed by the AI Performance page to display detection class distribution charts.\n\nOptimized to use a single query with window functions instead of 3 separate queries\n(NEM-1321). The query combines:\n- Per-class counts via GROUP BY\n- Total count via SUM(COUNT(*)) OVER() window function\n- Per-class avg confidence, then combined using weighted average formula\n\nArgs:\n    db: Database session\n\nReturns:\n    DetectionStatsResponse with aggregate detection statistics",
        "operationId": "get_detection_stats_api_detections_stats_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Detection Stats",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}": {
      "get": {
        "description": "Get a specific detection by ID.\n\nArgs:\n    detection_id: Detection ID\n    db: Database session\n\nReturns:\n    Detection object\n\nRaises:\n    HTTPException: 404 if detection not found",
        "operationId": "get_detection_api_detections__detection_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Detection",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/enrichment": {
      "get": {
        "description": "Get structured enrichment data for a detection.\n\nReturns results from the 18+ vision models run during the enrichment pipeline:\n- License plate detection and OCR\n- Face detection\n- Vehicle classification and damage detection\n- Clothing analysis (FashionCLIP and SegFormer)\n- Violence detection\n- Image quality assessment\n- Pet classification\n\nArgs:\n    detection_id: Detection ID\n    db: Database session\n\nReturns:\n    EnrichmentResponse with structured vision model results\n\nRaises:\n    HTTPException: 404 if detection not found",
        "operationId": "get_detection_enrichment_api_detections__detection_id__enrichment_get",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EnrichmentResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Detection Enrichment",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/image": {
      "get": {
        "description": "Get detection image with bounding box overlay, or full-size original.\n\nThis endpoint is exempt from API key authentication because:\n1. It serves static image content accessed directly by browsers via <img> tags\n2. Detection IDs are not predictable (integer IDs require prior knowledge)\n3. It has rate limiting to prevent abuse\n\nBy default, returns the thumbnail image with bounding box drawn around the\ndetected object. If thumbnail doesn't exist, generates it on the fly from\nthe source image.\n\nWhen full=true is passed, returns the original source image without any\nbounding box overlay. This is used for the full-size image lightbox viewer.\n\nArgs:\n    detection_id: Detection ID\n    full: If true, return the original full-size image instead of thumbnail\n    db: Database session\n    thumbnail_generator: ThumbnailGenerator injected via Depends()\n\nReturns:\n    JPEG image (thumbnail with bounding box, or full-size original)\n\nRaises:\n    HTTPException: 404 if detection not found or image file doesn't exist\n    HTTPException: 500 if image generation fails",
        "operationId": "get_detection_image_api_detections__detection_id__image_get",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          },
          {
            "description": "Return full-size original image instead of thumbnail",
            "in": "query",
            "name": "full",
            "required": false,
            "schema": {
              "default": false,
              "description": "Return full-size original image instead of thumbnail",
              "title": "Full",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Image served successfully"
          },
          "404": {
            "description": "Detection or image not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Failed to generate thumbnail"
          }
        },
        "summary": "Get Detection Image",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/thumbnail": {
      "get": {
        "description": "Serve the cropped thumbnail image with bounding box overlay.",
        "operationId": "get_detection_thumbnail_api_detections__detection_id__thumbnail_get",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "image/jpeg": {},
              "image/png": {}
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Detection or thumbnail not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Failed to generate thumbnail"
          }
        },
        "summary": "Get detection thumbnail",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/video": {
      "get": {
        "description": "Stream detection video with HTTP Range request support.\n\nThis endpoint is exempt from API key authentication because:\n1. It serves video content accessed directly by browsers via <video> tags\n2. Detection IDs are not predictable (integer IDs require prior knowledge)\n3. It has rate limiting to prevent abuse\n\nSupports partial content requests for video seeking and efficient playback.\nReturns 206 Partial Content for range requests, 200 OK for full content.\n\nArgs:\n    detection_id: Detection ID\n    range_header: HTTP Range header for partial content requests\n    db: Database session\n\nReturns:\n    StreamingResponse with video content\n\nRaises:\n    HTTPException: 404 if detection not found or not a video\n    HTTPException: 416 if range is not satisfiable",
        "operationId": "stream_detection_video_api_detections__detection_id__video_get",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          },
          {
            "in": "header",
            "name": "Range",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Range"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Full video content"
          },
          "206": {
            "description": "Partial video content (range request)"
          },
          "400": {
            "description": "Detection is not a video"
          },
          "404": {
            "description": "Detection or video file not found"
          },
          "416": {
            "description": "Range not satisfiable"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Stream Detection Video",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/video/thumbnail": {
      "get": {
        "description": "Get thumbnail frame from a video detection.\n\nThis endpoint is exempt from API key authentication because:\n1. It serves static image content accessed directly by browsers via <img> tags\n2. Detection IDs are not predictable (integer IDs require prior knowledge)\n3. It has rate limiting to prevent abuse\n\nExtracts and returns a thumbnail frame from the video. If thumbnail\ndoesn't exist, generates it on the fly using ffmpeg.\n\nArgs:\n    detection_id: Detection ID\n    db: Database session\n    video_processor: VideoProcessor injected via Depends()\n\nReturns:\n    JPEG thumbnail image\n\nRaises:\n    HTTPException: 404 if detection not found or not a video\n    HTTPException: 500 if thumbnail generation fails",
        "operationId": "get_video_thumbnail_api_detections__detection_id__video_thumbnail_get",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Thumbnail served successfully"
          },
          "400": {
            "description": "Detection is not a video"
          },
          "404": {
            "description": "Detection or video not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Failed to generate thumbnail"
          }
        },
        "summary": "Get Video Thumbnail",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/dlq/jobs/{queue_name}": {
      "get": {
        "description": "List jobs in a specific dead-letter queue with enriched error context.\n\nReturns jobs in the specified DLQ without removing them.\nUse pagination parameters to control the result set.\n\nEach job includes enriched error context (NEM-1474):\n- error_type: Exception class name for categorization\n- stack_trace: Truncated stack trace for debugging\n- http_status: HTTP status code (for network errors)\n- response_body: Truncated AI service response\n- retry_delays: Delays applied between retry attempts\n- context: System state snapshot at failure time\n\nArgs:\n    queue_name: Name of the DLQ (detection or analysis)\n    start: Start index for pagination\n    limit: Maximum number of jobs to return\n    redis: Redis client\n\nReturns:\n    DLQJobsResponse with list of jobs including error context (NEM-2178 pagination envelope)",
        "operationId": "get_dlq_jobs_api_dlq_jobs__queue_name__get",
        "parameters": [
          {
            "in": "path",
            "name": "queue_name",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "description": "Start index (0-based)",
            "in": "query",
            "name": "start",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Start index (0-based)",
              "minimum": 0,
              "title": "Start",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of jobs to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 100,
              "description": "Maximum number of jobs to return",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQJobsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Dlq Jobs",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/dlq/requeue-all/{queue_name}": {
      "post": {
        "description": "Requeue all jobs from a DLQ back to their original processing queue.\n\nRemoves all jobs from the specified DLQ and adds them back to the\noriginal processing queue for retry. Limited to settings.max_requeue_iterations\nto prevent resource exhaustion.\n\nArgs:\n    queue_name: Name of the DLQ (detection or analysis)\n    redis: Redis client\n\nReturns:\n    DLQRequeueResponse with operation result and count",
        "operationId": "requeue_all_dlq_jobs_api_dlq_requeue_all__queue_name__post",
        "parameters": [
          {
            "in": "path",
            "name": "queue_name",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "in": "query",
            "name": "api_key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Api Key"
            }
          },
          {
            "in": "header",
            "name": "X-API-Key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQRequeueResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Requeue All Dlq Jobs",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/dlq/requeue/{queue_name}": {
      "post": {
        "description": "Requeue the oldest job from a DLQ back to its original processing queue.\n\nRemoves the oldest job from the specified DLQ and adds it back to the\noriginal processing queue for retry.\n\nArgs:\n    queue_name: Name of the DLQ (detection or analysis)\n    redis: Redis client\n\nReturns:\n    DLQRequeueResponse with operation result",
        "operationId": "requeue_dlq_job_api_dlq_requeue__queue_name__post",
        "parameters": [
          {
            "in": "path",
            "name": "queue_name",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "in": "query",
            "name": "api_key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Api Key"
            }
          },
          {
            "in": "header",
            "name": "X-API-Key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQRequeueResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Requeue Dlq Job",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/dlq/stats": {
      "get": {
        "description": "Get dead-letter queue statistics.\n\nReturns the number of jobs in each DLQ and the total count.\n\nReturns:\n    DLQStatsResponse with queue counts",
        "operationId": "get_dlq_stats_api_dlq_stats_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Dlq Stats",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/dlq/{queue_name}": {
      "delete": {
        "description": "Clear all jobs from a dead-letter queue.\n\nWARNING: This permanently removes all jobs from the specified DLQ.\nUse with caution.\n\nArgs:\n    queue_name: Name of the DLQ to clear\n    redis: Redis client\n\nReturns:\n    DLQClearResponse with operation result",
        "operationId": "clear_dlq_api_dlq__queue_name__delete",
        "parameters": [
          {
            "in": "path",
            "name": "queue_name",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "in": "query",
            "name": "api_key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Api Key"
            }
          },
          {
            "in": "header",
            "name": "X-API-Key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQClearResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Clear Dlq",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/entities": {
      "get": {
        "description": "List tracked entities with optional filtering.\n\nReturns a paginated list of entities that have been tracked via\nre-identification. Entities are grouped by their embedding clusters.\n\nArgs:\n    entity_type: Filter by entity type ('person' or 'vehicle')\n    camera_id: Filter by camera ID\n    since: Filter entities seen since this timestamp\n    limit: Maximum number of results (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    reid_service: Re-identification service dependency\n\nReturns:\n    EntityListResponse with filtered entities and pagination info",
        "operationId": "list_entities_api_entities_get",
        "parameters": [
          {
            "description": "Filter by entity type: 'person' or 'vehicle'",
            "in": "query",
            "name": "entity_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/EntityTypeEnum"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by entity type: 'person' or 'vehicle'",
              "title": "Entity Type"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter entities seen since this time",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter entities seen since this time",
              "title": "Since"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Entities",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/matches/{detection_id}": {
      "get": {
        "description": "Find entities matching a specific detection's embedding.\n\nSearches for entities similar to the specified detection's embedding\nacross all cameras. Used to show re-ID matches in the EventDetailModal.\n\nArgs:\n    detection_id: Detection ID to find matches for\n    entity_type: Type of entity to search ('person' or 'vehicle')\n    threshold: Minimum cosine similarity threshold (default 0.85)\n    reid_service: Re-identification service dependency\n\nReturns:\n    EntityMatchResponse with matching entities sorted by similarity\n\nRaises:\n    HTTPException: 404 if detection embedding not found, 503 if Redis unavailable",
        "operationId": "get_entity_matches_api_entities_matches__detection_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "string"
            }
          },
          {
            "description": "Type of entity to search for matches",
            "in": "query",
            "name": "entity_type",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/EntityTypeEnum",
              "default": "person",
              "description": "Type of entity to search for matches"
            }
          },
          {
            "description": "Minimum similarity threshold for matches",
            "in": "query",
            "name": "threshold",
            "required": false,
            "schema": {
              "default": 0.85,
              "description": "Minimum similarity threshold for matches",
              "maximum": 1.0,
              "minimum": 0.0,
              "title": "Threshold",
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityMatchResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Detection not found or no embedding stored"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Redis service unavailable"
          }
        },
        "summary": "Get Entity Matches",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/{entity_id}": {
      "get": {
        "description": "Get detailed information about a specific entity.\n\nReturns the entity's summary information along with all recorded appearances.\n\nArgs:\n    entity_id: Unique entity identifier (detection_id)\n    reid_service: Re-identification service dependency\n\nReturns:\n    EntityDetail with full entity information\n\nRaises:\n    HTTPException: 404 if entity not found, 503 if Redis unavailable",
        "operationId": "get_entity_api_entities__entity_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "entity_id",
            "required": true,
            "schema": {
              "title": "Entity Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityDetail"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Entity not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Redis service unavailable"
          }
        },
        "summary": "Get Entity",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/{entity_id}/history": {
      "get": {
        "description": "Get the appearance timeline for a specific entity.\n\nReturns a chronological list of all appearances for the entity\nacross all cameras.\n\nArgs:\n    entity_id: Unique entity identifier (detection_id)\n    reid_service: Re-identification service dependency\n\nReturns:\n    EntityHistoryResponse with appearance timeline\n\nRaises:\n    HTTPException: 404 if entity not found, 503 if Redis unavailable",
        "operationId": "get_entity_history_api_entities__entity_id__history_get",
        "parameters": [
          {
            "in": "path",
            "name": "entity_id",
            "required": true,
            "schema": {
              "title": "Entity Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Entity not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Redis service unavailable"
          }
        },
        "summary": "Get Entity History",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/events": {
      "get": {
        "description": "List events with optional filtering and cursor-based pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\nSparse Fieldsets (NEM-1434):\nUse the `fields` parameter to request only specific fields in the response,\nreducing payload size. Example: ?fields=id,camera_id,risk_level,summary,reviewed\n\nArgs:\n    camera_id: Optional camera ID to filter by\n    risk_level: Optional risk level to filter by (low, medium, high, critical)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    reviewed: Optional filter by reviewed status\n    object_type: Optional object type to filter by (person, vehicle, animal, etc.)\n    limit: Maximum number of results to return (1-100, default 50)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    fields: Comma-separated list of fields to include (sparse fieldsets)\n    db: Database session\n\nReturns:\n    EventListResponse containing filtered events and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid\n    HTTPException: 400 if invalid fields are requested",
        "operationId": "list_events_api_events_get",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by risk level (low, medium, high, critical)",
            "in": "query",
            "name": "risk_level",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by risk level (low, medium, high, critical)",
              "title": "Risk Level"
            }
          },
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Filter by reviewed status",
            "in": "query",
            "name": "reviewed",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by reviewed status",
              "title": "Reviewed"
            }
          },
          {
            "description": "Filter by detected object type",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by detected object type",
              "title": "Object Type"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip (deprecated, use cursor)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor from previous response",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            }
          },
          {
            "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, started_at, ended_at, risk_score, risk_level, summary, reasoning, reviewed, detection_count, detection_ids, thumbnail_url",
            "in": "query",
            "name": "fields",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, started_at, ended_at, risk_score, risk_level, summary, reasoning, reviewed, detection_count, detection_ids, thumbnail_url",
              "title": "Fields"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Events",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/analyze/{batch_id}/stream": {
      "get": {
        "description": "Stream LLM analysis progress for a batch via Server-Sent Events (NEM-1665).\n\nThis endpoint provides progressive LLM response updates during long inference\ntimes, allowing the frontend to display partial results and show typing\nindicators while the analysis is in progress.\n\nEvent Types:\n- progress: Partial LLM response chunk with accumulated_text\n- complete: Final event with risk assessment and event_id\n- error: Error information with error_code and recoverable flag\n\nArgs:\n    batch_id: Batch identifier to analyze\n    camera_id: Optional camera ID (uses Redis lookup if not provided)\n    detection_ids: Optional comma-separated detection IDs\n    analyzer: NemotronAnalyzer injected via Depends()\n\nReturns:\n    StreamingResponse with SSE event stream (text/event-stream)\n\nExample SSE output:\n    data: {\"event_type\": \"progress\", \"content\": \"Based on\", \"accumulated_text\": \"Based on\"}\n\n    data: {\"event_type\": \"progress\", \"content\": \" the\", \"accumulated_text\": \"Based on the\"}\n\n    data: {\"event_type\": \"complete\", \"event_id\": 123, \"risk_score\": 75, ...}",
        "operationId": "analyze_batch_streaming_api_events_analyze__batch_id__stream_get",
        "parameters": [
          {
            "in": "path",
            "name": "batch_id",
            "required": true,
            "schema": {
              "title": "Batch Id",
              "type": "string"
            }
          },
          {
            "description": "Camera ID for the batch",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Camera ID for the batch",
              "title": "Camera Id"
            }
          },
          {
            "description": "Comma-separated detection IDs (optional)",
            "in": "query",
            "name": "detection_ids",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated detection IDs (optional)",
              "title": "Detection Ids"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Analyze Batch Streaming",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/bulk": {
      "delete": {
        "description": "Delete multiple events in a single request.\n\nSupports partial success - some deletions may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nBy default uses soft delete (sets deleted_at timestamp) with cascade to\nrelated detections. Use soft_delete=false for permanent deletion.\nUse cascade=false to only delete the event without affecting detections.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk delete request with up to 100 event IDs\n    db: Database session\n    cache: Cache service for invalidation\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "bulk_delete_events_api_events_bulk_delete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventBulkDeleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Bulk delete events",
        "tags": [
          "events"
        ]
      },
      "patch": {
        "description": "Update multiple events in a single request.\n\nSupports partial success - some updates may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk update request with up to 100 event updates\n    db: Database session\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "bulk_update_events_api_events_bulk_patch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventBulkUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Bulk update events",
        "tags": [
          "events"
        ]
      },
      "post": {
        "description": "Create multiple events in a single request.\n\nSupports partial success - some events may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk create request with up to 100 events\n    db: Database session\n\nReturns:\n    EventBulkCreateResponse with per-item results",
        "operationId": "bulk_create_events_api_events_bulk_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventBulkCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventBulkCreateResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Bulk create events",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/deleted": {
      "get": {
        "description": "List all soft-deleted events for trash view.\n\nReturns events that have been soft-deleted (deleted_at is not null),\nordered by deleted_at descending (most recently deleted first).\n\nThis endpoint enables a \"trash\" view where users can see deleted events\nand optionally restore them.\n\nArgs:\n    db: Database session\n\nReturns:\n    DeletedEventsListResponse containing list of deleted events and count",
        "operationId": "list_deleted_events_api_events_deleted_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeletedEventsListResponse"
                }
              }
            },
            "description": "List of soft-deleted events"
          }
        },
        "summary": "List all soft-deleted events",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/export": {
      "get": {
        "description": "Export events as CSV or Excel file for external analysis or record-keeping.\n\nSupports content negotiation via HTTP Accept header:\n- `Accept: text/csv` or `Accept: application/csv` - CSV format (default)\n- `Accept: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet` - Excel (XLSX)\n- `Accept: application/vnd.ms-excel` or `Accept: application/xlsx` - Excel (XLSX)\n\nThis endpoint is rate-limited to 10 requests per minute per client IP\nto prevent abuse and protect against data exfiltration attacks.\n\nExports events with the following fields:\n- Event ID, camera name, timestamps\n- Risk score, risk level, summary\n- Detection count, reviewed status\n\nArgs:\n    request: FastAPI request object (includes Accept header for format selection)\n    camera_id: Optional camera ID to filter by\n    risk_level: Optional risk level to filter by (low, medium, high, critical)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    reviewed: Optional filter by reviewed status\n    db: Database session\n    _rate_limit: Rate limiter dependency (10 req/min, no burst)\n\nReturns:\n    StreamingResponse with CSV or Response with Excel file containing exported events\n\nRaises:\n    HTTPException: 429 if rate limit exceeded\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "export_events_api_events_export_get",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by risk level (low, medium, high, critical)",
            "in": "query",
            "name": "risk_level",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by risk level (low, medium, high, critical)",
              "title": "Risk Level"
            }
          },
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Filter by reviewed status",
            "in": "query",
            "name": "reviewed",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by reviewed status",
              "title": "Reviewed"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {}
              },
              "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              },
              "text/csv": {
                "example": "event_id,camera_name,started_at,...",
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              }
            },
            "description": "Exported events file"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Rate limit exceeded"
          }
        },
        "summary": "Export Events",
        "tags": [
          "events"
        ]
      },
      "post": {
        "description": "Start a background export job for events. Returns a job ID that can be used to track progress via GET /api/jobs/{job_id}.",
        "operationId": "start_export_job_api_events_export_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportJobRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportJobStartResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Start export job",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/events/search": {
      "get": {
        "description": "Search events using full-text search.\n\nThis endpoint provides PostgreSQL full-text search across event summaries,\nreasoning, object types, and camera names.\n\nSearch Query Syntax:\n- Basic words: \"person vehicle\" (implicit AND)\n- Phrase search: '\"suspicious person\"' (exact phrase)\n- Boolean OR: \"person OR animal\"\n- Boolean NOT: \"person NOT cat\"\n- Boolean AND: \"person AND vehicle\" (explicit)\n\nArgs:\n    q: Search query string (required)\n    camera_id: Optional comma-separated camera IDs to filter by\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    severity: Optional comma-separated risk levels (low, medium, high, critical)\n    risk_level: Alias for severity - accepts same format\n    object_type: Optional comma-separated object types (person, vehicle, animal)\n    reviewed: Optional filter by reviewed status\n    limit: Maximum number of results to return (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    db: Database session\n\nReturns:\n    SearchResponse with ranked results and pagination info\n\nRaises:\n    HTTPException: 400 if any severity value is invalid\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "search_events_endpoint_api_events_search_get",
        "parameters": [
          {
            "description": "Search query string",
            "in": "query",
            "name": "q",
            "required": true,
            "schema": {
              "description": "Search query string",
              "minLength": 1,
              "title": "Q",
              "type": "string"
            }
          },
          {
            "description": "Filter by camera ID (comma-separated for multiple)",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID (comma-separated for multiple)",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Filter by risk levels (comma-separated: low,medium,high,critical)",
            "in": "query",
            "name": "severity",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by risk levels (comma-separated: low,medium,high,critical)",
              "title": "Severity"
            }
          },
          {
            "description": "Alias for severity - filter by risk levels (comma-separated: low,medium,high,critical)",
            "in": "query",
            "name": "risk_level",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Alias for severity - filter by risk levels (comma-separated: low,medium,high,critical)",
              "title": "Risk Level"
            }
          },
          {
            "description": "Filter by object types (comma-separated: person,vehicle,animal)",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by object types (comma-separated: person,vehicle,animal)",
              "title": "Object Type"
            }
          },
          {
            "description": "Filter by reviewed status",
            "in": "query",
            "name": "reviewed",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by reviewed status",
              "title": "Reviewed"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Search Events Endpoint",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/stats": {
      "get": {
        "description": "Get aggregated event statistics.\n\nReturns statistics about events including:\n- Total event count\n- Events grouped by risk level (critical, high, medium, low)\n- Events grouped by camera with camera names\n\nUses Redis cache with cache-aside pattern to improve performance\nand generate cache hit metrics.\n\nArgs:\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    db: Database session\n    cache: Cache service injected via FastAPI DI\n\nReturns:\n    EventStatsResponse with aggregated statistics\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "get_event_stats_api_events_stats_get",
        "parameters": [
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event Stats",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}": {
      "delete": {
        "description": "Soft delete a single event with optional cascade to related detections.\n\nBy default, cascade=True soft deletes all related detections using the same\ntimestamp as the event. This enables cascade restore by matching timestamps.\n\nArgs:\n    event_id: ID of the event to delete\n    cascade: If True, cascade soft delete to related detections\n    db: Database session\n    cache: Cache service for invalidation\n\nRaises:\n    HTTPException: 404 if event not found, 409 if already deleted",
        "operationId": "delete_event_api_events__event_id__delete",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Cascade soft delete to related detections",
            "in": "query",
            "name": "cascade",
            "required": false,
            "schema": {
              "default": true,
              "description": "Cascade soft delete to related detections",
              "title": "Cascade",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Event deleted successfully"
          },
          "404": {
            "description": "Event not found"
          },
          "409": {
            "description": "Event already deleted"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Soft delete a single event",
        "tags": [
          "events"
        ]
      },
      "get": {
        "description": "Get a specific event by ID with HATEOAS links.\n\nArgs:\n    event_id: Event ID\n    request: FastAPI request object for building HATEOAS links\n    db: Database session\n\nReturns:\n    Event object with detection count and HATEOAS links\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "get_event_api_events__event_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event",
        "tags": [
          "events"
        ]
      },
      "patch": {
        "description": "Update an event (mark as reviewed).\n\nArgs:\n    event_id: Event ID\n    update_data: Update data (reviewed field)\n    request: FastAPI request for audit logging\n    db: Database session\n    cache: Cache service for cache invalidation (NEM-1938)\n\nReturns:\n    Updated event object\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "update_event_api_events__event_id__patch",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Event",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/clip": {
      "get": {
        "description": "Get clip information for a specific event.\n\nReturns information about whether a video clip is available for the event,\nand if so, provides the URL to access it along with metadata.\n\nArgs:\n    event_id: Event ID\n    db: Database session\n\nReturns:\n    ClipInfoResponse with clip availability and metadata\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "get_event_clip_api_events__event_id__clip_get",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClipInfoResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event Clip",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/clip/generate": {
      "post": {
        "description": "Trigger video clip generation for an event.\n\nIf a clip already exists and force=False, returns the existing clip info.\nIf force=True, regenerates the clip even if one exists.\n\nClip generation uses detection images to create a video sequence, or\nextracts from existing video if available.\n\nArgs:\n    event_id: Event ID\n    request: Clip generation parameters\n    db: Database session\n    clip_generator: ClipGenerator injected via Depends()\n\nReturns:\n    ClipGenerateResponse with generation status and clip info\n\nRaises:\n    HTTPException: 404 if event not found\n    HTTPException: 400 if event has no detections to generate clip from",
        "operationId": "generate_event_clip_api_events__event_id__clip_generate_post",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClipGenerateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClipGenerateResponse"
                }
              }
            },
            "description": "Clip already exists"
          },
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClipGenerateResponse"
                }
              }
            },
            "description": "Clip created successfully"
          },
          "400": {
            "description": "Cannot generate clip - event has no detections"
          },
          "404": {
            "description": "Event not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Generate Event Clip",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/detections": {
      "get": {
        "description": "Get detections for a specific event.\n\nArgs:\n    event_id: Event ID\n    limit: Maximum number of results to return (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    db: Database session\n\nReturns:\n    DetectionListResponse containing detections for the event\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "get_event_detections_api_events__event_id__detections_get",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event Detections",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/enrichments": {
      "get": {
        "description": "Get enrichment data for detections in an event with pagination.\n\nReturns structured vision model results from the enrichment pipeline for\neach detection in the event. Results include:\n- License plate detection and OCR\n- Face detection\n- Vehicle classification and damage detection\n- Clothing analysis (FashionCLIP and SegFormer)\n- Violence detection\n- Image quality assessment\n- Pet classification\n\nArgs:\n    event_id: Event ID\n    limit: Maximum number of enrichments to return (1-200, default 50)\n    offset: Number of enrichments to skip (default 0)\n    db: Database session\n\nReturns:\n    EventEnrichmentsResponse with enrichment data for each detection and pagination metadata\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "get_event_enrichments_api_events__event_id__enrichments_get",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of enrichments to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of enrichments to return",
              "maximum": 200,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of enrichments to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of enrichments to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventEnrichmentsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event Enrichments",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/restore": {
      "post": {
        "description": "Restore a soft-deleted event with optional cascade to related detections.\n\nWhen cascade=True, this restores detections that were deleted at the same\ntimestamp as the event, indicating they were cascade-deleted together.\n\nArgs:\n    event_id: ID of the event to restore\n    cascade: If True, cascade restore to related detections\n    db: Database session\n    cache: Cache service for invalidation\n\nReturns:\n    The restored event as EventResponse\n\nRaises:\n    HTTPException: 404 if event not found, 409 if not deleted",
        "operationId": "restore_event_api_events__event_id__restore_post",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Cascade restore to related detections",
            "in": "query",
            "name": "cascade",
            "required": false,
            "schema": {
              "default": true,
              "description": "Cascade restore to related detections",
              "title": "Cascade",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventResponse"
                }
              }
            },
            "description": "Event restored successfully"
          },
          "404": {
            "description": "Event not found"
          },
          "409": {
            "description": "Event is not deleted"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Restore a soft-deleted event",
        "tags": [
          "events"
        ]
      }
    },
    "/api/feedback": {
      "post": {
        "description": "Submit feedback for an event.\n\nAllows users to mark events as false positives, missed detections,\nwrong severity, or correctly classified. Only one feedback per event\nis allowed (enforced by unique constraint).\n\nThis feedback is used to calibrate personalized risk thresholds\nand improve the AI model's accuracy over time.\n\nArgs:\n    feedback_data: Feedback details including event_id and feedback_type\n    db: Database session\n\nReturns:\n    The created feedback record\n\nRaises:\n    HTTPException: 404 if event not found\n    HTTPException: 409 if feedback already exists for this event",
        "operationId": "create_feedback_api_feedback_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventFeedbackCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventFeedbackResponse"
                }
              }
            },
            "description": "Feedback created successfully"
          },
          "404": {
            "description": "Event not found"
          },
          "409": {
            "description": "Feedback already exists for this event"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Submit event feedback",
        "tags": [
          "feedback"
        ]
      }
    },
    "/api/feedback/event/{event_id}": {
      "get": {
        "description": "Get feedback for a specific event.\n\nArgs:\n    event_id: The event ID to get feedback for\n    db: Database session\n\nReturns:\n    The feedback record for the event\n\nRaises:\n    HTTPException: 404 if no feedback exists for the event",
        "operationId": "get_event_feedback_api_feedback_event__event_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventFeedbackResponse"
                }
              }
            },
            "description": "Feedback found"
          },
          "404": {
            "description": "No feedback found for this event"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Get feedback for an event",
        "tags": [
          "feedback"
        ]
      }
    },
    "/api/feedback/stats": {
      "get": {
        "description": "Get aggregate feedback statistics.\n\nReturns counts of feedback grouped by:\n- Feedback type (false_positive, missed_detection, wrong_severity, correct)\n- Camera ID\n\nThis data is useful for:\n- Identifying cameras with high false positive rates\n- Calibrating risk thresholds per camera\n- Tracking model accuracy over time\n\nArgs:\n    db: Database session\n\nReturns:\n    Aggregate statistics including total count and breakdowns",
        "operationId": "get_feedback_stats_api_feedback_stats_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeedbackStatsResponse"
                }
              }
            },
            "description": "Statistics retrieved successfully"
          }
        },
        "summary": "Get feedback statistics",
        "tags": [
          "feedback"
        ]
      }
    },
    "/api/jobs": {
      "get": {
        "description": "List all background jobs with optional filtering by type and status.",
        "operationId": "list_jobs_api_jobs_get",
        "parameters": [
          {
            "description": "Filter by job type (e.g., 'export', 'cleanup')",
            "in": "query",
            "name": "job_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by job type (e.g., 'export', 'cleanup')",
              "title": "Job Type"
            }
          },
          {
            "description": "Filter by job status",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/JobStatusEnum"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by job status",
              "title": "Status"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List all jobs",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/types": {
      "get": {
        "description": "List all available job types that can be created.",
        "operationId": "list_job_types_api_jobs_types_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobTypesResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List available job types",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/{job_id}": {
      "get": {
        "description": "Get the current status and progress of a background job.",
        "operationId": "get_job_status_api_jobs__job_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Job not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get job status",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/{job_id}/cancel": {
      "post": {
        "description": "Request cancellation of a background job. Jobs that are already completed or failed cannot be cancelled.",
        "operationId": "cancel_job_api_jobs__job_id__cancel_post",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobCancelResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Job not found"
          },
          "409": {
            "description": "Job cannot be cancelled (already completed or failed)"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Cancel a job",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/logs": {
      "get": {
        "description": "List logs with optional filtering and cursor-based pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\nArgs:\n    level: Optional log level to filter by (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    component: Optional component name to filter by\n    camera_id: Optional camera ID to filter by\n    source: Optional source to filter by (backend, frontend)\n    search: Optional search term for message text\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    limit: Maximum number of results to return (1-1000, default 100)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    db: Database session\n\nReturns:\n    LogsResponse containing filtered logs and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid",
        "operationId": "list_logs_api_logs_get",
        "parameters": [
          {
            "description": "Filter by log level",
            "in": "query",
            "name": "level",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by log level",
              "title": "Level"
            }
          },
          {
            "description": "Filter by component name",
            "in": "query",
            "name": "component",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by component name",
              "title": "Component"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by source (backend, frontend)",
            "in": "query",
            "name": "source",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by source (backend, frontend)",
              "title": "Source"
            }
          },
          {
            "description": "Search in message text",
            "in": "query",
            "name": "search",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Search in message text",
              "title": "Search"
            }
          },
          {
            "description": "Filter from date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter from date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter to date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter to date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Page size",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 100,
              "description": "Page size",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip (deprecated, use cursor)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor from previous response",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid date range or cursor"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Logs",
        "tags": [
          "logs"
        ]
      }
    },
    "/api/logs/frontend": {
      "post": {
        "description": "Receive and store a log from the frontend.",
        "operationId": "create_frontend_log_api_logs_frontend_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FrontendLogCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Create Frontend Log Api Logs Frontend Post",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Create Frontend Log",
        "tags": [
          "logs"
        ]
      }
    },
    "/api/logs/stats": {
      "get": {
        "description": "Get log statistics for dashboard.\n\nOptimized to use a single aggregation query with conditional counting\ninstead of 5 separate queries. This reduces database round-trips and\nimproves performance for high-volume log tables.",
        "operationId": "get_log_stats_api_logs_stats_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogStats"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid date range"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Log Stats",
        "tags": [
          "logs"
        ]
      }
    },
    "/api/logs/{log_id}": {
      "get": {
        "description": "Get a single log entry by ID.",
        "operationId": "get_log_api_logs__log_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "log_id",
            "required": true,
            "schema": {
              "title": "Log Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogEntry"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Log entry not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Log",
        "tags": [
          "logs"
        ]
      }
    },
    "/api/media/cameras/{camera_id}/{filename}": {
      "get": {
        "description": "Serve camera images or videos from Foscam storage.\n\nArgs:\n    camera_id: The camera identifier (directory name)\n    filename: The file to serve (can include subdirectories)\n\nReturns:\n    FileResponse with appropriate content-type header\n\nRaises:\n    HTTPException: 403 for invalid paths, 404 for missing files",
        "operationId": "serve_camera_file_api_media_cameras__camera_id___filename__get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "title": "Filename",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File served successfully"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "Access denied"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "File not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Serve Camera File",
        "tags": [
          "media"
        ]
      }
    },
    "/api/media/clips/{filename}": {
      "get": {
        "description": "Serve event video clips.\n\nClips are generated by the ClipGenerator service and stored in the\nconfigured clips directory.\n\nArgs:\n    filename: The clip filename (e.g., \"123_clip.mp4\")\n    clip_generator: ClipGenerator injected via Depends()\n\nReturns:\n    FileResponse with appropriate content-type header\n\nRaises:\n    HTTPException: 403 for invalid paths, 404 for missing files",
        "operationId": "serve_clip_api_media_clips__filename__get",
        "parameters": [
          {
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "title": "Filename",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Clip served successfully"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "Access denied"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "File not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Serve Clip",
        "tags": [
          "media"
        ]
      }
    },
    "/api/media/thumbnails/{filename}": {
      "get": {
        "description": "Serve detection thumbnail images.\n\nArgs:\n    filename: The thumbnail filename\n\nReturns:\n    FileResponse with appropriate content-type header\n\nRaises:\n    HTTPException: 403 for invalid paths, 404 for missing files",
        "operationId": "serve_thumbnail_api_media_thumbnails__filename__get",
        "parameters": [
          {
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "title": "Filename",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Thumbnail served successfully"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "Access denied"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "File not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Serve Thumbnail",
        "tags": [
          "media"
        ]
      }
    },
    "/api/media/{path}": {
      "get": {
        "description": "Compatibility route: serve media via design-spec-style /api/media/{path}.\n\nThis preserves the stricter behavior of the new routes:\n- Path traversal protection\n- Allowed file type allowlist\n- Must remain under configured base directories\n\nMapping rules:\n- `cameras/<camera_id>/<filename...>` -> camera media\n- `thumbnails/<filename>` -> thumbnails\n- `detections/<id>` -> detection images",
        "operationId": "serve_media_compat_api_media__path__get",
        "parameters": [
          {
            "in": "path",
            "name": "path",
            "required": true,
            "schema": {
              "title": "Path",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File served successfully"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "Access denied"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "File not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Serve Media Compat",
        "tags": [
          "media"
        ]
      }
    },
    "/api/metrics": {
      "get": {
        "description": "Return Prometheus metrics in exposition format.\n\nThis endpoint returns all registered metrics in the standard\nPrometheus exposition format for scraping.\n\nReturns:\n    Response with text/plain content type containing metrics",
        "operationId": "metrics_api_metrics_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "description": "Prometheus metrics in exposition format"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Metrics",
        "tags": [
          "metrics"
        ]
      }
    },
    "/api/notification-preferences/": {
      "get": {
        "description": "Get global notification preferences.\n\nReturns the global notification settings including:\n- Whether notifications are enabled\n- Notification sound selection\n- Risk level filters (which risk levels trigger notifications)\n\nReturns:\n    NotificationPreferencesResponse with current preferences",
        "operationId": "get_notification_preferences_api_notification_preferences__get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationPreferencesResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Notification Preferences",
        "tags": [
          "notification-preferences"
        ]
      },
      "put": {
        "description": "Update global notification preferences.\n\nArgs:\n    update: Preferences update data\n\nReturns:\n    NotificationPreferencesResponse with updated preferences\n\nRaises:\n    HTTPException: 400 if sound value is invalid",
        "operationId": "update_notification_preferences_api_notification_preferences__put",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NotificationPreferencesUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationPreferencesResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid sound or risk level value"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Notification Preferences",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification-preferences/cameras": {
      "get": {
        "description": "Get all camera notification settings.\n\nReturns:\n    CameraNotificationSettingsListResponse with all camera settings",
        "operationId": "get_all_camera_settings_api_notification_preferences_cameras_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraNotificationSettingsListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get All Camera Settings",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification-preferences/cameras/{camera_id}": {
      "get": {
        "description": "Get notification setting for a specific camera.\n\nArgs:\n    camera_id: Camera ID\n\nReturns:\n    CameraNotificationSettingResponse for the camera\n\nRaises:\n    HTTPException: 404 if setting not found",
        "operationId": "get_camera_setting_api_notification_preferences_cameras__camera_id__get",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraNotificationSettingResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Camera notification setting not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Camera Setting",
        "tags": [
          "notification-preferences"
        ]
      },
      "put": {
        "description": "Update or create notification setting for a camera.\n\nArgs:\n    camera_id: Camera ID\n    update: Setting update data\n\nReturns:\n    CameraNotificationSettingResponse with updated setting\n\nRaises:\n    HTTPException: 404 if camera doesn't exist",
        "operationId": "update_camera_setting_api_notification_preferences_cameras__camera_id__put",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraNotificationSettingUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraNotificationSettingResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Camera Setting",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification-preferences/quiet-hours": {
      "get": {
        "description": "Get all quiet hours periods.\n\nReturns:\n    QuietHoursPeriodsListResponse with all quiet periods",
        "operationId": "get_quiet_hours_api_notification_preferences_quiet_hours_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuietHoursPeriodsListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Quiet Hours",
        "tags": [
          "notification-preferences"
        ]
      },
      "post": {
        "description": "Create a new quiet hours period.\n\nArgs:\n    period: Quiet hours period data\n\nReturns:\n    QuietHoursPeriodResponse with created period\n\nRaises:\n    HTTPException: 400 if start_time equals end_time (zero-length period)\n\nNote:\n    Periods can span midnight (e.g., 22:00 to 06:00).\n    If start_time > end_time, the period wraps to the next day.",
        "operationId": "create_quiet_hours_period_api_notification_preferences_quiet_hours_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QuietHoursPeriodCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuietHoursPeriodResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid time range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Create Quiet Hours Period",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification-preferences/quiet-hours/{period_id}": {
      "delete": {
        "description": "Delete a quiet hours period.\n\nArgs:\n    period_id: Period UUID\n\nRaises:\n    HTTPException: 404 if period not found",
        "operationId": "delete_quiet_hours_period_api_notification_preferences_quiet_hours__period_id__delete",
        "parameters": [
          {
            "in": "path",
            "name": "period_id",
            "required": true,
            "schema": {
              "title": "Period Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "404": {
            "description": "Quiet hours period not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Delete Quiet Hours Period",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification/config": {
      "get": {
        "description": "Get notification configuration status.\n\nReturns the current notification configuration including:\n- Whether notifications are enabled\n- Which channels are configured (email, webhook, push)\n- SMTP host and port (if configured)\n- Default webhook URL (if configured)\n- Default email recipients\n\nNote: Sensitive fields like SMTP password are NOT returned.\n\nReturns:\n    NotificationConfigResponse with current notification settings",
        "operationId": "get_notification_config_api_notification_config_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Notification Config",
        "tags": [
          "notification"
        ]
      }
    },
    "/api/notification/test": {
      "post": {
        "description": "Test notification delivery for a specific channel.\n\nSends a test notification to verify the configuration is working.\nFor email, sends a test email to the specified recipients or default recipients.\nFor webhook, sends a test payload to the specified URL or default URL.\n\nArgs:\n    test_request: Test notification request with channel and optional overrides\n\nReturns:\n    TestNotificationResponse with test result",
        "operationId": "test_notification_api_notification_test_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookTestNotificationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestNotificationResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Test Notification",
        "tags": [
          "notification"
        ]
      }
    },
    "/api/rum": {
      "post": {
        "description": "Receive Core Web Vitals metrics from the frontend for Real User Monitoring.",
        "operationId": "ingest_rum_metrics_api_rum_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RUMBatchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RUMIngestResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Ingest RUM metrics",
        "tags": [
          "rum"
        ]
      }
    },
    "/api/system/anomaly-config": {
      "get": {
        "description": "Get current anomaly detection configuration.\n\nReturns the current settings for the baseline service including:\n- threshold_stdev: Number of standard deviations for anomaly detection\n- min_samples: Minimum samples required before anomaly detection is reliable\n- decay_factor: Exponential decay factor for EWMA (weights recent observations)\n- window_days: Rolling window size in days for baseline calculations\n\nArgs:\n    service: BaselineService injected via Depends()\n\nReturns:\n    AnomalyConfig with current anomaly detection settings",
        "operationId": "get_anomaly_config_api_system_anomaly_config_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnomalyConfig"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Anomaly Config",
        "tags": [
          "system"
        ]
      },
      "patch": {
        "description": "Update anomaly detection configuration.\n\nAllows updating the anomaly detection thresholds:\n- threshold_stdev: Number of standard deviations for anomaly detection\n- min_samples: Minimum samples required before anomaly detection is reliable\n\nNote: decay_factor and window_days are not configurable at runtime\nas they affect historical data calculations.\n\nRequires API key authentication.\n\nArgs:\n    config_update: Configuration values to update (only provided values are changed)\n    request: HTTP request for audit logging\n    db: Database session\n    service: BaselineService injected via Depends()\n\nReturns:\n    AnomalyConfig with updated settings",
        "operationId": "update_anomaly_config_api_system_anomaly_config_patch",
        "parameters": [
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AnomalyConfigUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnomalyConfig"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Anomaly Config",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/circuit-breakers": {
      "get": {
        "description": "Get status of all circuit breakers in the system.\n\nReturns the current state and metrics for each circuit breaker,\nwhich protect external services from cascading failures.\n\nCircuit breakers can be in one of three states:\n- CLOSED: Normal operation, calls pass through\n- OPEN: Service failing, calls rejected immediately\n- HALF_OPEN: Testing recovery, limited calls allowed\n\nReturns:\n    CircuitBreakersResponse with status of all circuit breakers",
        "operationId": "get_circuit_breakers_api_system_circuit_breakers_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CircuitBreakersResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Circuit Breakers",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/circuit-breakers/{name}/reset": {
      "post": {
        "description": "Reset a specific circuit breaker to CLOSED state.\n\nThis manually resets a circuit breaker, clearing failure counts\nand returning it to normal operation. Use this to recover from\ntransient failures or after fixing an underlying issue.\n\nRequires API key authentication when api_key_enabled is True.\n\nArgs:\n    name: Name of the circuit breaker to reset\n\nReturns:\n    CircuitBreakerResetResponse with reset confirmation\n\nRaises:\n    HTTPException 400: If name is invalid (empty, too long, or contains invalid characters)\n    HTTPException 404: If circuit breaker not found",
        "operationId": "reset_circuit_breaker_api_system_circuit_breakers__name__reset_post",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          },
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CircuitBreakerResetResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Reset Circuit Breaker",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/cleanup": {
      "post": {
        "description": "Trigger manual data cleanup based on retention settings.\n\nRequires API key authentication when api_key_enabled is True in settings.\nProvide the API key via X-API-Key header.\n\nThis endpoint runs the CleanupService to delete old data according to\nthe configured retention period. It deletes:\n- Events older than retention period\n- Detections older than retention period\n- GPU stats older than retention period\n- Logs older than log retention period\n- Associated thumbnail files\n- Optionally original image files (if delete_images is enabled)\n\nThe cleanup respects the current retention_days setting from the system\nconfiguration. To change the retention period before running cleanup,\nuse PATCH /api/system/config first.\n\nArgs:\n    dry_run: If True, calculate and return what would be deleted without\n             actually performing the deletion. Useful for verification\n             before destructive operations.\n\nReturns:\n    CleanupResponse with statistics about the cleanup operation.\n    When dry_run=True, the counts represent what would be deleted.",
        "operationId": "trigger_cleanup_api_system_cleanup_post",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "required": false,
            "schema": {
              "default": false,
              "title": "Dry Run",
              "type": "boolean"
            }
          },
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Trigger Cleanup",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/cleanup/status": {
      "get": {
        "description": "Get current status of the cleanup service.\n\nReturns information about the automated cleanup service including:\n- Whether the service is running\n- Current retention settings\n- Next scheduled cleanup time\n\nReturns:\n    CleanupStatusResponse with cleanup service status",
        "operationId": "get_cleanup_status_api_system_cleanup_status_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Cleanup Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/config": {
      "get": {
        "description": "Get public configuration settings.\n\nReturns non-sensitive application configuration values.\nDoes NOT expose database URLs, API keys, or other secrets.\n\nReturns:\n    ConfigResponse with public configuration settings",
        "operationId": "get_config_api_system_config_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Config",
        "tags": [
          "system"
        ]
      },
      "patch": {
        "description": "Patch processing-related configuration and persist runtime overrides.\n\nRequires API key authentication when api_key_enabled is True in settings.\nProvide the API key via X-API-Key header.\n\nNotes:\n- This updates a runtime override env file (see `HSI_RUNTIME_ENV_PATH`) and clears the\n  settings cache so subsequent `get_settings()` calls observe the new values.",
        "operationId": "patch_config_api_system_config_patch",
        "parameters": [
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfigUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Patch Config",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/gpu": {
      "get": {
        "description": "Get current GPU statistics.\n\nReturns the most recent GPU statistics including:\n- GPU name\n- GPU utilization percentage\n- Memory usage (used/total)\n- Temperature\n- Power usage\n- Inference FPS\n\nReturns:\n    GPUStatsResponse with GPU statistics (null values if unavailable)",
        "operationId": "get_gpu_stats_api_system_gpu_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GPUStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Gpu Stats",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/gpu/history": {
      "get": {
        "description": "Get recent GPU stats samples as a time-series.\n\nReturns GPU stats in standard pagination envelope format (NEM-2178):\n- items: GPU stats samples (renamed from 'samples')\n- pagination: Standard pagination metadata\n\nArgs:\n    since: Optional lower bound for recorded_at (ISO datetime)\n    limit: Maximum number of samples to return (default 300, max 5000)\n    db: Database session",
        "operationId": "get_gpu_stats_history_api_system_gpu_history_get",
        "parameters": [
          {
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Since"
            }
          },
          {
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 300,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GPUStatsHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Gpu Stats History",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/health": {
      "get": {
        "description": "Get detailed system health check.\n\nChecks the health of all system components:\n- Database connectivity\n- Redis connectivity\n- AI services status\n\nHealth checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).\nIf a health check times out, the service is marked as unhealthy.\n\nReturns:\n    HealthResponse with overall status and individual service statuses.\n    HTTP 200 if healthy, 503 if degraded or unhealthy.",
        "operationId": "get_health_api_system_health_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Health",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/health/full": {
      "get": {
        "description": "Get comprehensive health status for all system components.",
        "operationId": "get_full_health_api_system_health_full_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FullHealthResponse"
                }
              }
            },
            "description": "System is healthy"
          },
          "503": {
            "description": "One or more critical services are unhealthy"
          }
        },
        "summary": "Get Full System Health Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/health/ready": {
      "get": {
        "description": "Kubernetes-style readiness probe endpoint with detailed information.\n\nThis endpoint indicates whether the application is ready to receive\ntraffic and process uploads. It checks all critical dependencies:\n- Database connectivity (critical)\n- Redis connectivity (required for queue processing)\n- AI services availability\n- Background worker status\n\nNote: The canonical readiness probe is GET /ready at the root level.\nThis endpoint provides the same readiness check but with detailed\nservice and worker status information.\n\nUsed by Kubernetes/Docker to determine if traffic should be routed to this instance.\nIf this endpoint returns not_ready, the instance should not receive new requests.\n\nHealth checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).\nIf a health check times out, the service is marked as unhealthy.\n\nReturns:\n    ReadinessResponse with overall readiness status and detailed checks.\n    HTTP 200 if ready, 503 if degraded or not ready.",
        "operationId": "get_readiness_api_system_health_ready_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReadinessResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Readiness",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/health/websocket": {
      "get": {
        "description": "Get health status of WebSocket broadcasters and their circuit breakers.\n\nReturns the current state of circuit breakers for:\n- Event broadcaster: Handles real-time security event distribution\n- System broadcaster: Handles system status updates (GPU, cameras, queues)\n\nCircuit breakers protect the system from cascading failures by:\n- Opening after repeated connection failures\n- Blocking recovery attempts while open to allow stabilization\n- Gradually testing recovery in half-open state\n\nCircuit breaker states:\n- closed: Normal operation, WebSocket events flowing normally\n- open: Failures detected, events may be delayed or unavailable\n- half_open: Testing recovery, limited operations allowed\n\nReturns:\n    WebSocketHealthResponse with circuit breaker status for both broadcasters",
        "operationId": "get_websocket_health_api_system_health_websocket_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketHealthResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Websocket Health",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/model-zoo/latency/history": {
      "get": {
        "description": "Get latency history for a specific Model Zoo model.\n\nReturns time-series latency data for the dropdown-controlled chart.\nEach bucket contains aggregated statistics (avg, p50, p95).\n\nArgs:\n    model: Model name to get history for\n    since: Number of minutes of history to return (default 60)\n    bucket_seconds: Size of each time bucket in seconds (default 60)\n\nReturns:\n    ModelLatencyHistoryResponse with chronologically ordered snapshots\n\nRaises:\n    HTTPException: 404 if model not found in registry",
        "operationId": "get_model_zoo_latency_history_api_system_model_zoo_latency_history_get",
        "parameters": [
          {
            "description": "Model name to get latency history for (e.g., 'yolo11-license-plate')",
            "in": "query",
            "name": "model",
            "required": true,
            "schema": {
              "description": "Model name to get latency history for (e.g., 'yolo11-license-plate')",
              "title": "Model",
              "type": "string"
            }
          },
          {
            "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "default": 60,
              "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
              "maximum": 1440,
              "minimum": 1,
              "title": "Since",
              "type": "integer"
            }
          },
          {
            "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
            "in": "query",
            "name": "bucket_seconds",
            "required": false,
            "schema": {
              "default": 60,
              "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
              "maximum": 3600,
              "minimum": 10,
              "title": "Bucket Seconds",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelLatencyHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Model Zoo Latency History",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/model-zoo/status": {
      "get": {
        "description": "Get status information for all Model Zoo models.\n\nReturns status information for all 18 Model Zoo models, including:\n- Current status (loaded, unloaded, disabled)\n- VRAM usage when loaded\n- Last usage timestamp\n- Category grouping for UI display\n\nThis endpoint is optimized for the compact status card display\nin the AI Performance page.\n\nReturns:\n    ModelZooStatusResponse with all model statuses",
        "operationId": "get_model_zoo_status_api_system_model_zoo_status_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelZooStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Model Zoo Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/models": {
      "get": {
        "description": "Get the current status of all models in the Model Zoo.\n\nReturns comprehensive information about all AI models available in the system,\nincluding their VRAM requirements, loading status, and configuration.\n\n**VRAM Budget**: The Model Zoo has a dedicated VRAM budget of 1650 MB,\nseparate from the RT-DETRv2 detector and Nemotron LLM allocations.\n\n**Loading Strategy**: Models are loaded sequentially (one at a time) to\nprevent VRAM fragmentation and ensure stable operation.\n\n**Model Categories**:\n- detection: Object detection models (YOLO variants)\n- recognition: Face and license plate recognition\n- ocr: Optical character recognition\n- embedding: Visual embedding models (CLIP)\n- depth-estimation: Depth estimation models\n- pose: Human pose estimation\n\nReturns:\n    ModelRegistryResponse with VRAM stats and all model statuses",
        "operationId": "get_models_api_system_models_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelRegistryResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Model Zoo Registry",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/models/{model_name}": {
      "get": {
        "description": "Get detailed status information for a specific model.\n\nArgs:\n    model_name: Unique identifier of the model (e.g., 'yolo11-license-plate')\n\nReturns:\n    ModelStatusResponse with detailed model information\n\nRaises:\n    HTTPException: 404 if model not found in registry",
        "operationId": "get_model_api_system_models__model_name__get",
        "parameters": [
          {
            "in": "path",
            "name": "model_name",
            "required": true,
            "schema": {
              "title": "Model Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Model Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/pipeline": {
      "get": {
        "description": "Get combined status of all pipeline operations.\n\nReturns real-time visibility into the AI processing pipeline:\n\n**FileWatcher**: Monitors camera directories for new uploads\n- running: Whether the watcher is active\n- camera_root: Directory being watched\n- pending_tasks: Files waiting for debounce completion\n- observer_type: Filesystem observer type (native/polling)\n\n**BatchAggregator**: Groups detections into time-based batches\n- active_batches: Number of batches being aggregated\n- batches: Details of each active batch\n- batch_window_seconds: Configured window timeout\n- idle_timeout_seconds: Configured idle timeout\n\n**DegradationManager**: Handles graceful degradation\n- mode: Current degradation mode (normal/degraded/minimal/offline)\n- is_degraded: Whether system is in any degraded state\n- services: Health status of registered services\n- available_features: Features available in current mode\n\nReturns:\n    PipelineStatusResponse with status of all pipeline services",
        "operationId": "get_pipeline_status_api_system_pipeline_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Pipeline Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/pipeline-latency": {
      "get": {
        "description": "Get pipeline latency metrics with percentiles.\n\nReturns latency statistics for each stage transition in the AI pipeline:\n- watch_to_detect: Time from file watcher detecting image to RT-DETR processing start\n- detect_to_batch: Time from detection completion to batch aggregation\n- batch_to_analyze: Time from batch completion to Nemotron analysis start\n- total_pipeline: Total end-to-end processing time\n\nEach stage includes:\n- avg_ms: Average latency in milliseconds\n- min_ms: Minimum latency\n- max_ms: Maximum latency\n- p50_ms: 50th percentile (median)\n- p95_ms: 95th percentile\n- p99_ms: 99th percentile\n- sample_count: Number of samples used\n\nArgs:\n    window_minutes: Time window for statistics calculation (default 60 minutes)\n\nReturns:\n    PipelineLatencyResponse with latency statistics for each stage",
        "operationId": "get_pipeline_latency_api_system_pipeline_latency_get",
        "parameters": [
          {
            "in": "query",
            "name": "window_minutes",
            "required": false,
            "schema": {
              "default": 60,
              "title": "Window Minutes",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineLatencyResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Pipeline Latency",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/pipeline-latency/history": {
      "get": {
        "description": "Get pipeline latency history for time-series visualization.\n\nReturns latency data grouped into time buckets for charting.\nEach bucket contains aggregated statistics for all pipeline stages.\n\nArgs:\n    since: Number of minutes of history to return (1-1440, default 60)\n    bucket_seconds: Size of each time bucket in seconds (10-3600, default 60)\n\nReturns:\n    PipelineLatencyHistoryResponse with chronologically ordered snapshots",
        "operationId": "get_pipeline_latency_history_api_system_pipeline_latency_history_get",
        "parameters": [
          {
            "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "default": 60,
              "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
              "maximum": 1440,
              "minimum": 1,
              "title": "Since",
              "type": "integer"
            }
          },
          {
            "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
            "in": "query",
            "name": "bucket_seconds",
            "required": false,
            "schema": {
              "default": 60,
              "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
              "maximum": 3600,
              "minimum": 10,
              "title": "Bucket Seconds",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineLatencyHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Pipeline Latency History",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/services": {
      "get": {
        "description": "Get status of all managed services.\n\nArgs:\n    category: Optional filter by category (infrastructure, ai, monitoring)\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    List of services with status and category summaries.",
        "operationId": "list_services_api_system_services_get",
        "parameters": [
          {
            "in": "query",
            "name": "category",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ServiceCategory"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Category"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServicesResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "List Services",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/services/{name}/disable": {
      "post": {
        "description": "Manually disable a service.\n\nPrevents self-healing restarts.\n\nArgs:\n    name: Service name to disable\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found",
        "operationId": "disable_service_api_system_services__name__disable_post",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Service not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "Disable Service",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/services/{name}/enable": {
      "post": {
        "description": "Re-enable a disabled service.\n\nResets failure count and allows self-healing to resume.\n\nArgs:\n    name: Service name to enable\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found",
        "operationId": "enable_service_api_system_services__name__enable_post",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Service not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "Enable Service",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/services/{name}/restart": {
      "post": {
        "description": "Manually restart a service.\n\nResets failure count (manual restart is intentional).\n\nArgs:\n    name: Service name to restart\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found, 400 if service is disabled",
        "operationId": "restart_service_api_system_services__name__restart_post",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Service is disabled"
          },
          "404": {
            "description": "Service not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "Restart Service",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/services/{name}/start": {
      "post": {
        "description": "Start a stopped service container.\n\nArgs:\n    name: Service name to start\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found,\n                   400 if service is already running or disabled",
        "operationId": "start_service_api_system_services__name__start_post",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Service already running or disabled"
          },
          "404": {
            "description": "Service not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "Start Service",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/severity": {
      "get": {
        "description": "Get severity level definitions and thresholds.\n\nReturns complete information about the severity taxonomy including:\n- All severity level definitions (LOW, MEDIUM, HIGH, CRITICAL)\n- Risk score thresholds for each level\n- Color codes for UI display\n- Human-readable labels and descriptions\n\nThis endpoint is useful for frontends to:\n- Display severity information consistently\n- Show severity legends in the UI\n- Validate severity-related user inputs\n- Map risk scores to severity levels client-side\n\nReturns:\n    SeverityMetadataResponse with all severity definitions and current thresholds",
        "operationId": "get_severity_metadata_api_system_severity_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeverityMetadataResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Severity Metadata",
        "tags": [
          "system"
        ]
      },
      "put": {
        "description": "Update severity threshold configuration.\n\nUpdates the risk score thresholds for severity levels. The thresholds\ndefine how risk scores (0-100) are mapped to severity levels:\n- LOW: 0 to low_max\n- MEDIUM: low_max+1 to medium_max\n- HIGH: medium_max+1 to high_max\n- CRITICAL: high_max+1 to 100\n\nRequires API key authentication when api_key_enabled is True in settings.\nProvide the API key via X-API-Key header.\n\nValidation:\n- Thresholds must be strictly ordered: low_max < medium_max < high_max\n- All thresholds must be between 1 and 99\n- This ensures contiguous, non-overlapping ranges covering 0-100\n\nNote: Changes only affect new events. Existing events retain their\noriginal severity assignment.\n\nArgs:\n    update: New threshold values\n\nReturns:\n    SeverityMetadataResponse with updated definitions and thresholds\n\nRaises:\n    HTTPException 400: If thresholds are not strictly ordered",
        "operationId": "update_severity_thresholds_api_system_severity_put",
        "parameters": [
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeverityThresholdsUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeverityMetadataResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Severity Thresholds",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/stats": {
      "get": {
        "description": "Get system statistics.\n\nReturns aggregate statistics about the system:\n- Total number of cameras\n- Total number of events\n- Total number of detections\n- Application uptime\n\nReturns:\n    SystemStatsResponse with system statistics",
        "operationId": "get_stats_api_system_stats_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SystemStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Stats",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/storage": {
      "get": {
        "description": "Get storage statistics and disk usage metrics.\n\nReturns detailed storage usage information including:\n- Overall disk usage (used/total/free)\n- Storage breakdown by category (thumbnails, images, clips)\n- Database record counts (events, detections, GPU stats, logs)\n\nThis endpoint helps operators:\n- Monitor available storage space\n- Understand storage distribution across data types\n- Plan cleanup operations\n- Track database growth\n\nReturns:\n    StorageStatsResponse with comprehensive storage metrics",
        "operationId": "get_storage_stats_api_system_storage_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Storage Stats",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/telemetry": {
      "get": {
        "description": "Get pipeline telemetry data.\n\nReturns real-time metrics about the AI processing pipeline:\n- Queue depths: Items waiting in detection and analysis queues\n- Stage latencies: Processing time statistics for each pipeline stage\n\nThis endpoint helps operators:\n- Monitor pipeline health and throughput\n- Identify bottlenecks and backlogs\n- Debug pipeline stalls\n- Track performance trends\n\nReturns:\n    TelemetryResponse with queue depths and latency statistics",
        "operationId": "get_telemetry_api_system_telemetry_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TelemetryResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Telemetry",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/websocket/events": {
      "get": {
        "description": "List all available WebSocket event types with schemas.\n\nReturns the complete registry of WebSocket event types supported by the system,\nincluding their descriptions, payload schemas, and example payloads. This\nendpoint enables frontend developers and API consumers to discover and\nunderstand all available real-time event types.\n\nEvent types follow a hierarchical naming convention: {domain}.{action}\nFor example: detection.new, event.created, camera.status_changed\n\nChannels group related events:\n- detections: AI detection pipeline events\n- events: Security event lifecycle events\n- alerts: Alert notifications and state changes\n- cameras: Camera status and configuration changes\n- jobs: Background job lifecycle events\n- system: System health and status events\n\nNote: Some event types are marked as deprecated with suggested replacements.\nThese remain available for backward compatibility but should be avoided in\nnew implementations.\n\nReturns:\n    EventRegistryResponse containing:\n    - event_types: List of all event types with schemas and examples\n    - channels: List of available WebSocket channels\n    - total_count: Total number of event types\n    - deprecated_count: Number of deprecated event types",
        "operationId": "list_websocket_event_types_api_system_websocket_events_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventRegistryResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List Websocket Event Types",
        "tags": [
          "system"
        ]
      }
    },
    "/health": {
      "get": {
        "description": "Simple liveness health check endpoint (canonical liveness probe).\n\nThis endpoint indicates whether the process is running and able to\nrespond to HTTP requests. It always returns 200 with status \"alive\"\nif the process is up.\n\nThis is the canonical liveness probe endpoint. Use this for:\n- Docker HEALTHCHECK liveness checks\n- Kubernetes liveness probes\n- Simple \"is the server up?\" monitoring\n\nFor detailed health information, use:\n- GET /api/system/health - Detailed health check with service status\n- GET /ready - Readiness probe (checks dependencies)\n\nReturns:\n    LivenessResponse with status \"alive\".",
        "operationId": "health_health_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Health Health Get",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Health"
      }
    },
    "/ready": {
      "get": {
        "description": "Simple readiness health check endpoint (canonical readiness probe).\n\nThis endpoint indicates whether the application is ready to receive\ntraffic and process requests. It checks critical dependencies:\n- Database connectivity\n- Redis connectivity\n- Critical pipeline workers\n\nThis is the canonical readiness probe endpoint. Use this for:\n- Docker HEALTHCHECK readiness checks\n- Kubernetes readiness probes\n- Load balancer health checks\n\nFor detailed readiness information with service breakdown, use:\n- GET /api/system/health/ready - Full readiness response with details\n\nReturns:\n    SimpleReadinessResponse with ready bool and status. HTTP 200 if ready, 503 if not.",
        "operationId": "ready_ready_get",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Ready"
      }
    }
  },
  "servers": [
    {
      "description": "API server",
      "url": "http://localhost:8000"
    }
  ]
}
