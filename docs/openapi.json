{
  "openapi": "3.1.0",
  "info": {
    "title": "Home Security Intelligence API",
    "description": "AI-powered home security monitoring system",
    "version": "0.1.0"
  },
  "servers": [
    {
      "url": "http://localhost:8000",
      "description": "API server"
    }
  ],
  "paths": {
    "/api/admin/seed/cameras": {
      "post": {
        "tags": ["admin"],
        "summary": "Seed Cameras",
        "description": "Seed test cameras into the database.\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\n\nArgs:\n    request: Seed configuration (count, clear_existing, create_folders)\n    db: Database session\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of seeded cameras",
        "operationId": "seed_cameras_api_admin_seed_cameras_post",
        "parameters": [
          {
            "name": "x-admin-api-key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Admin-Api-Key"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedCamerasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedCamerasResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/admin/seed/events": {
      "post": {
        "tags": ["admin"],
        "summary": "Seed Events",
        "description": "Seed mock events and detections into the database.\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\nRequires cameras to exist first.\n\nArgs:\n    request: Seed configuration (count, clear_existing)\n    db: Database session\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of seeded events and detections",
        "operationId": "seed_events_api_admin_seed_events_post",
        "parameters": [
          {
            "name": "x-admin-api-key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Admin-Api-Key"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedEventsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedEventsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - No cameras found"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/admin/seed/clear": {
      "delete": {
        "tags": ["admin"],
        "summary": "Clear Seeded Data",
        "description": "Clear all seeded data (cameras, events, detections).\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\nRequires JSON body confirmation to prevent accidental data deletion:\n{\"confirm\": \"DELETE_ALL_DATA\"}\n\nArgs:\n    body: Request body with confirmation string\n    request: FastAPI request for audit logging\n    db: Database session\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of cleared data counts\n\nRaises:\n    HTTPException: 400 if confirmation string is incorrect",
        "operationId": "clear_seeded_data_api_admin_seed_clear_delete",
        "parameters": [
          {
            "name": "x-admin-api-key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Admin-Api-Key"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClearDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClearDataResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Confirmation required"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/ai-audit/events/{event_id}": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Get event audit details",
        "description": "Retrieve the AI pipeline audit record for a specific event.\n\nReturns comprehensive audit information including:\n- **Model contributions**: Which AI models (RT-DETR, Florence, CLIP, etc.) contributed to the analysis\n- **Quality scores**: Self-evaluation rubric scores (context usage, reasoning coherence, risk justification)\n- **Prompt improvements**: Suggestions for improving the AI prompt template\n- **Consistency metrics**: Cross-validation of risk scores",
        "operationId": "get_event_audit_api_ai_audit_events__event_id__get",
        "parameters": [
          {
            "name": "event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Event Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Audit details retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventAuditResponse"
                },
                "example": {
                  "id": 1,
                  "event_id": 42,
                  "audited_at": "2026-01-03T10:30:00Z",
                  "is_fully_evaluated": true,
                  "contributions": {
                    "rtdetr": true,
                    "florence": true,
                    "clip": false,
                    "violence": false,
                    "clothing": true,
                    "vehicle": false,
                    "pet": false,
                    "weather": true,
                    "image_quality": true,
                    "zones": true,
                    "baseline": false,
                    "cross_camera": false
                  },
                  "prompt_length": 2500,
                  "prompt_token_estimate": 625,
                  "enrichment_utilization": 0.85,
                  "scores": {
                    "context_usage": 4.2,
                    "reasoning_coherence": 4.5,
                    "risk_justification": 4.0,
                    "consistency": 4.3,
                    "overall": 4.25
                  },
                  "consistency_risk_score": 72,
                  "consistency_diff": 3,
                  "self_eval_critique": "Good context usage but could include more temporal patterns.",
                  "improvements": {
                    "missing_context": ["time since last event"],
                    "confusing_sections": [],
                    "unused_data": ["weather data not referenced"],
                    "format_suggestions": [],
                    "model_gaps": []
                  }
                }
              }
            }
          },
          "404": {
            "description": "Event or audit not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/ai-audit/events/{event_id}/evaluate": {
      "post": {
        "tags": ["ai-audit"],
        "summary": "Trigger event audit evaluation",
        "description": "Run the complete AI self-evaluation pipeline for an event's audit.\n\nThis endpoint triggers a comprehensive evaluation including:\n1. **Self-critique**: LLM reviews its own reasoning for blind spots\n2. **Rubric scoring**: Quality assessment on 1-5 scale across multiple dimensions\n3. **Consistency check**: Re-runs risk analysis to verify score stability\n4. **Prompt improvement**: Generates suggestions for better prompts\n\nUse `force=true` to re-evaluate events that have already been fully evaluated.",
        "operationId": "evaluate_event_api_ai_audit_events__event_id__evaluate_post",
        "parameters": [
          {
            "name": "event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Event Id"
            }
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Force re-evaluation even if already evaluated",
              "default": false,
              "title": "Force"
            },
            "description": "Force re-evaluation even if already evaluated"
          }
        ],
        "responses": {
          "200": {
            "description": "Evaluation completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventAuditResponse"
                },
                "example": {
                  "id": 1,
                  "event_id": 42,
                  "audited_at": "2026-01-03T10:30:00Z",
                  "is_fully_evaluated": true,
                  "contributions": {
                    "rtdetr": true,
                    "florence": true,
                    "clip": false
                  },
                  "prompt_length": 2500,
                  "prompt_token_estimate": 625,
                  "enrichment_utilization": 0.85,
                  "scores": {
                    "overall": 4.25
                  },
                  "consistency_risk_score": 72,
                  "consistency_diff": 3
                }
              }
            }
          },
          "404": {
            "description": "Event or audit not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/stats": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Get aggregate audit statistics",
        "description": "Retrieve aggregate AI audit statistics over a specified time period.\n\nReturns comprehensive metrics including:\n- **Event counts**: Total, audited, and fully evaluated events\n- **Quality metrics**: Average quality scores and consistency rates\n- **Model performance**: Contribution rates for each AI model\n- **Trends**: Daily audit counts for visualization\n\nUseful for monitoring AI pipeline health and identifying optimization opportunities.",
        "operationId": "get_audit_stats_api_ai_audit_stats_get",
        "parameters": [
          {
            "name": "days",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 90,
              "minimum": 1,
              "description": "Number of days to include",
              "default": 7,
              "title": "Days"
            },
            "description": "Number of days to include"
          },
          {
            "name": "camera_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            },
            "description": "Filter by camera ID"
          }
        ],
        "responses": {
          "200": {
            "description": "Statistics retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditStatsResponse"
                },
                "example": {
                  "total_events": 1250,
                  "audited_events": 1200,
                  "fully_evaluated_events": 950,
                  "avg_quality_score": 4.2,
                  "avg_consistency_rate": 0.92,
                  "avg_enrichment_utilization": 0.78,
                  "model_contribution_rates": {
                    "rtdetr": 0.98,
                    "florence": 0.85,
                    "clip": 0.45,
                    "clothing": 0.62,
                    "weather": 0.73,
                    "zones": 0.88
                  },
                  "audits_by_day": [
                    {
                      "date": "2026-01-01",
                      "count": 180
                    },
                    {
                      "date": "2026-01-02",
                      "count": 195
                    },
                    {
                      "date": "2026-01-03",
                      "count": 210
                    }
                  ]
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/leaderboard": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Get AI model leaderboard",
        "description": "Retrieve a ranked leaderboard of AI models by their contribution rate.\n\nThe leaderboard shows:\n- **Contribution rate**: How often each model contributes to event analysis (0-1)\n- **Quality correlation**: How model contribution correlates with quality scores\n- **Event count**: Number of events where the model contributed\n\nHelps identify which models are most valuable to the pipeline.",
        "operationId": "get_model_leaderboard_api_ai_audit_leaderboard_get",
        "parameters": [
          {
            "name": "days",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 90,
              "minimum": 1,
              "description": "Number of days to include",
              "default": 7,
              "title": "Days"
            },
            "description": "Number of days to include"
          }
        ],
        "responses": {
          "200": {
            "description": "Leaderboard retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardResponse"
                },
                "example": {
                  "entries": [
                    {
                      "model_name": "rtdetr",
                      "contribution_rate": 0.98,
                      "quality_correlation": 0.85,
                      "event_count": 1180
                    },
                    {
                      "model_name": "zones",
                      "contribution_rate": 0.88,
                      "quality_correlation": 0.72,
                      "event_count": 1056
                    },
                    {
                      "model_name": "florence",
                      "contribution_rate": 0.85,
                      "quality_correlation": 0.68,
                      "event_count": 1020
                    }
                  ],
                  "period_days": 7
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/recommendations": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Get prompt improvement recommendations",
        "description": "Get aggregated, prioritized recommendations for improving AI prompts.\n\nAnalyzes self-evaluation data from recent audits to identify:\n- **Missing context**: Information the LLM wishes it had\n- **Unused data**: Enrichments provided but not utilized\n- **Model gaps**: Missing model contributions that could help\n- **Format suggestions**: Ways to improve prompt structure\n\nRecommendations are prioritized by frequency and impact.",
        "operationId": "get_recommendations_api_ai_audit_recommendations_get",
        "parameters": [
          {
            "name": "days",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 90,
              "minimum": 1,
              "description": "Number of days to include",
              "default": 7,
              "title": "Days"
            },
            "description": "Number of days to include"
          }
        ],
        "responses": {
          "200": {
            "description": "Recommendations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecommendationsResponse"
                },
                "example": {
                  "recommendations": [
                    {
                      "category": "missing_context",
                      "suggestion": "Time since last detected motion or event",
                      "frequency": 45,
                      "priority": "high"
                    },
                    {
                      "category": "unused_data",
                      "suggestion": "Weather data rarely referenced in analysis",
                      "frequency": 28,
                      "priority": "medium"
                    },
                    {
                      "category": "model_gaps",
                      "suggestion": "Vehicle classification could help with driveway events",
                      "frequency": 15,
                      "priority": "low"
                    }
                  ],
                  "total_events_analyzed": 950
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/batch": {
      "post": {
        "tags": ["ai-audit"],
        "summary": "Trigger batch audit processing",
        "description": "Queue multiple events for audit evaluation based on filtering criteria.\n\nUse this endpoint to:\n- Backfill audits for events that haven't been evaluated\n- Re-evaluate events with updated self-evaluation logic\n- Process high-risk events for deeper analysis\n\nEvents are processed synchronously in this implementation.\nUse `force_reevaluate=true` to re-process already-evaluated events.",
        "operationId": "trigger_batch_audit_api_ai_audit_batch_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchAuditRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Batch processing completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchAuditResponse"
                },
                "example": {
                  "queued_count": 25,
                  "message": "Successfully processed 25 events for audit evaluation"
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/prompts": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Get all prompt configurations",
        "description": "Retrieve current prompt configurations for all supported AI models.\n\nReturns configurations for:\n- **nemotron**: LLM risk analysis system prompt and parameters\n- **florence2**: Visual question-answering queries\n- **yolo_world**: Object detection classes and thresholds\n- **xclip**: Action recognition classes\n- **fashion_clip**: Clothing analysis categories\n\nEach model configuration includes version number and last update timestamp.",
        "operationId": "get_all_prompts_api_ai_audit_prompts_get",
        "responses": {
          "200": {
            "description": "All configurations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AllPromptsResponse"
                },
                "example": {
                  "prompts": {
                    "nemotron": {
                      "model_name": "nemotron",
                      "config": {
                        "system_prompt": "You are a security analyst...",
                        "temperature": 0.7,
                        "max_tokens": 2048
                      },
                      "version": 5,
                      "updated_at": "2026-01-03T10:30:00Z"
                    },
                    "florence2": {
                      "model_name": "florence2",
                      "config": {
                        "vqa_queries": ["What is happening?", "Who is present?"]
                      },
                      "version": 3,
                      "updated_at": "2026-01-02T14:00:00Z"
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/test-prompt": {
      "post": {
        "tags": ["ai-audit"],
        "summary": "Test custom prompt (A/B testing)",
        "description": "Test a custom prompt against an existing event without persisting results.\n\nThis endpoint is designed for the Prompt Playground A/B testing feature:\n1. Fetches the specified event with its detections\n2. Builds context from the event data\n3. Runs inference with the custom prompt\n4. Returns analysis results WITHOUT saving to database\n\n**Use cases:**\n- Experiment with prompt variations before committing\n- Compare different prompt styles side-by-side\n- Test temperature and max_tokens settings\n\n**Limits:**\n- Maximum prompt length: 50,000 characters\n- Timeout: 60 seconds",
        "operationId": "test_custom_prompt_api_ai_audit_test_prompt_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CustomTestPromptRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Prompt test completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CustomTestPromptResponse"
                },
                "example": {
                  "risk_score": 45,
                  "risk_level": "medium",
                  "reasoning": "Person detected approaching front door during normal hours. No suspicious behavior observed.",
                  "summary": "Routine visitor activity at front entrance.",
                  "entities": [
                    {
                      "type": "person",
                      "confidence": 0.92
                    }
                  ],
                  "flags": [],
                  "recommended_action": "Review - Check event details when convenient",
                  "processing_time_ms": 1250,
                  "tokens_used": 825
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Invalid or too long prompt"
          },
          "404": {
            "description": "Event not found"
          },
          "408": {
            "description": "Request timeout"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "AI service unavailable"
          }
        }
      }
    },
    "/api/ai-audit/prompts/test": {
      "post": {
        "tags": ["ai-audit"],
        "summary": "Test prompt configuration change",
        "description": "Compare before/after results when modifying a model's prompt configuration.\n\nThis endpoint runs inference twice:\n1. With the **current** (saved) configuration\n2. With the **modified** (proposed) configuration\n\nReturns a side-by-side comparison to help evaluate whether the change improves results.\n\n**Supported models:** nemotron, florence2, yolo_world, xclip, fashion_clip\n\nNote: Currently returns mock results for demonstration purposes.",
        "operationId": "test_prompt_api_ai_audit_prompts_test_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptTestRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Test completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptTestResponse"
                },
                "example": {
                  "before": {
                    "score": 65,
                    "risk_level": "medium",
                    "summary": "Person detected at front door"
                  },
                  "after": {
                    "score": 45,
                    "risk_level": "medium",
                    "summary": "Delivery person at front door during business hours"
                  },
                  "improved": true,
                  "inference_time_ms": 2150
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Invalid configuration"
          },
          "404": {
            "description": "Model or event not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/prompts/history": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Get version history for all models",
        "description": "Retrieve prompt configuration version history for all AI models.\n\nReturns the most recent versions for each supported model, ordered by version\nnumber descending (newest first).\n\nUseful for:\n- Viewing recent changes across all models\n- Comparing configurations over time\n- Finding versions to restore",
        "operationId": "get_all_prompts_history_api_ai_audit_prompts_history_get",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Max versions per model",
              "default": 10,
              "title": "Limit"
            },
            "description": "Max versions per model"
          }
        ],
        "responses": {
          "200": {
            "description": "History retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/PromptHistoryResponse"
                  },
                  "title": "Response Get All Prompts History Api Ai Audit Prompts History Get"
                },
                "example": {
                  "nemotron": {
                    "model_name": "nemotron",
                    "versions": [
                      {
                        "version": 5,
                        "config": {
                          "system_prompt": "...",
                          "temperature": 0.7
                        },
                        "created_at": "2026-01-03T10:30:00Z",
                        "created_by": "user",
                        "description": "Added temporal context"
                      },
                      {
                        "version": 4,
                        "config": {
                          "system_prompt": "...",
                          "temperature": 0.8
                        },
                        "created_at": "2026-01-02T14:00:00Z",
                        "created_by": "user"
                      }
                    ],
                    "total_versions": 5
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/prompts/export": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Export all prompt configurations",
        "description": "Export all AI model configurations as a JSON bundle.\n\nThe export includes:\n- All current model configurations\n- Export timestamp\n- Format version for compatibility checking\n\n**Use cases:**\n- Backup configurations before major changes\n- Transfer configurations between environments\n- Version control of prompt templates",
        "operationId": "export_prompts_api_ai_audit_prompts_export_get",
        "responses": {
          "200": {
            "description": "Export generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptExportResponse"
                },
                "example": {
                  "exported_at": "2026-01-03T10:30:00Z",
                  "version": "1.0",
                  "prompts": {
                    "nemotron": {
                      "system_prompt": "You are a security analyst...",
                      "temperature": 0.7,
                      "max_tokens": 2048
                    },
                    "florence2": {
                      "vqa_queries": ["What is happening?", "Who is present?"]
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/prompts/import": {
      "post": {
        "tags": ["ai-audit"],
        "summary": "Import prompt configurations",
        "description": "Import AI model configurations from a JSON bundle.\n\nImports configurations for multiple models at once.\n\n**Behavior:**\n- By default, existing configurations are NOT overwritten (skipped)\n- Set `overwrite=true` to replace existing configurations\n- Invalid configurations are reported in the `errors` array\n- Unsupported model names are skipped with an error\n\n**Validation:**\n- Each configuration is validated against the model's schema\n- Import fails for a model if validation errors are found and overwrite=true",
        "operationId": "import_prompts_api_ai_audit_prompts_import_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptImportRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Import completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptImportResponse"
                },
                "example": {
                  "imported_count": 3,
                  "skipped_count": 2,
                  "errors": [],
                  "message": "Imported 3 model(s), skipped 2 (already exist)"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - No prompts provided"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/prompts/{model}": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Get model prompt configuration",
        "description": "Get the current prompt configuration for a specific AI model.\n\n**Supported models:**\n- `nemotron`: LLM risk analysis (system_prompt, temperature, max_tokens)\n- `florence2`: Visual QA (vqa_queries)\n- `yolo_world`: Object detection (object_classes, confidence_threshold)\n- `xclip`: Action recognition (action_classes)\n- `fashion_clip`: Clothing analysis (clothing_categories, suspicious_indicators)",
        "operationId": "get_model_prompt_api_ai_audit_prompts__model__get",
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Model"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Configuration retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelPromptResponse"
                },
                "example": {
                  "model_name": "nemotron",
                  "config": {
                    "system_prompt": "You are a security analyst reviewing camera footage...",
                    "temperature": 0.7,
                    "max_tokens": 2048
                  },
                  "version": 5,
                  "updated_at": "2026-01-03T10:30:00Z"
                }
              }
            }
          },
          "404": {
            "description": "Model not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      },
      "put": {
        "tags": ["ai-audit"],
        "summary": "Update model prompt configuration",
        "description": "Update the prompt configuration for a specific AI model.\n\nCreates a new version of the configuration while preserving the previous\nversion in history. Each update increments the version number.\n\n**Validation:**\n- Configuration must match the model's expected schema\n- Nemotron requires: system_prompt, temperature, max_tokens\n- Other models have model-specific required fields\n\n**Optional:** Include a `description` to document what changed.",
        "operationId": "update_model_prompt_api_ai_audit_prompts__model__put",
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Model"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Configuration updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptUpdateResponse"
                },
                "example": {
                  "model_name": "nemotron",
                  "version": 6,
                  "message": "Configuration updated to version 6",
                  "config": {
                    "system_prompt": "You are a security analyst...",
                    "temperature": 0.7,
                    "max_tokens": 2048
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Invalid configuration"
          },
          "404": {
            "description": "Model not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/prompts/history/{model}": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Get model version history",
        "description": "Get the version history for a specific AI model's prompt configuration.\n\nReturns all versions ordered by version number descending (newest first),\nwith pagination support.\n\nEach version entry includes:\n- Version number\n- Full configuration at that version\n- Creation timestamp\n- Who created it (user/system/import)\n- Optional description of changes",
        "operationId": "get_model_history_api_ai_audit_prompts_history__model__get",
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Model"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Max versions to return",
              "default": 50,
              "title": "Limit"
            },
            "description": "Max versions to return"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of versions to skip",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of versions to skip"
          }
        ],
        "responses": {
          "200": {
            "description": "History retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptHistoryResponse"
                },
                "example": {
                  "model_name": "nemotron",
                  "versions": [
                    {
                      "version": 5,
                      "config": {
                        "system_prompt": "...",
                        "temperature": 0.7
                      },
                      "created_at": "2026-01-03T10:30:00Z",
                      "created_by": "user",
                      "description": "Added temporal context guidance"
                    }
                  ],
                  "total_versions": 5
                }
              }
            }
          },
          "404": {
            "description": "Model not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/prompts/history/{version}": {
      "post": {
        "tags": ["ai-audit"],
        "summary": "Restore prompt version",
        "description": "Restore a previous version of a model's prompt configuration.\n\nThis operation:\n1. Retrieves the configuration from the specified version\n2. Creates a **new** version with that configuration\n3. Records the restore action in history\n\nThe restored configuration becomes the current active configuration.\nOriginal versions are preserved - this creates a new version, not a rollback.\n\n**Note:** Requires the `model` query parameter to specify which model to restore.",
        "operationId": "restore_prompt_version_api_ai_audit_prompts_history__version__post",
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Version"
            }
          },
          {
            "name": "model",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Model name to restore version for",
              "title": "Model"
            },
            "description": "Model name to restore version for"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/PromptRestoreRequest"
                  },
                  {
                    "type": "null"
                  }
                ],
                "title": "Request"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version restored successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptRestoreResponse"
                },
                "example": {
                  "model_name": "nemotron",
                  "restored_version": 3,
                  "new_version": 6,
                  "message": "Restored version 3 as new version 6"
                }
              }
            }
          },
          "404": {
            "description": "Model or version not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/ai-audit/prompt-config/{model}": {
      "get": {
        "tags": ["ai-audit"],
        "summary": "Get database-backed prompt config",
        "description": "Get the prompt configuration stored in the database for a model.\n\nThis endpoint is used by the Prompt Playground \"Save\" functionality.\n\n**Supported models:** nemotron, florence-2, yolo-world, x-clip, fashion-clip\n\nNote: Model names use hyphens (florence-2) unlike the file-based endpoints\nwhich use underscores (florence2).",
        "operationId": "get_prompt_config_api_ai_audit_prompt_config__model__get",
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Model"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Configuration retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptConfigResponse"
                },
                "example": {
                  "model": "nemotron",
                  "systemPrompt": "You are a security analyst reviewing camera footage...",
                  "temperature": 0.7,
                  "maxTokens": 2048,
                  "version": 3,
                  "updatedAt": "2026-01-03T10:30:00Z"
                }
              }
            }
          },
          "404": {
            "description": "Model not found or no configuration exists"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["ai-audit"],
        "summary": "Update database-backed prompt config",
        "description": "Create or update the prompt configuration in the database.\n\nThis endpoint is used by the Prompt Playground \"Save\" functionality.\n\n**Behavior:**\n- If no configuration exists: creates a new one at version 1\n- If configuration exists: updates it and increments version\n\n**Supported models:** nemotron, florence-2, yolo-world, x-clip, fashion-clip\n\n**Request body:**\n- `systemPrompt`: Full system prompt text (required)\n- `temperature`: LLM temperature 0.0-2.0 (default 0.7)\n- `maxTokens`: Max response tokens 100-8192 (default 2048)",
        "operationId": "update_prompt_config_api_ai_audit_prompt_config__model__put",
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Model"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Configuration updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptConfigResponse"
                },
                "example": {
                  "model": "nemotron",
                  "systemPrompt": "You are a security analyst...",
                  "temperature": 0.7,
                  "maxTokens": 2048,
                  "version": 4,
                  "updatedAt": "2026-01-03T10:35:00Z"
                }
              }
            }
          },
          "404": {
            "description": "Model not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/alerts/rules": {
      "get": {
        "tags": ["alert-rules"],
        "summary": "List Rules",
        "description": "List all alert rules with optional filtering and pagination.\n\nArgs:\n    enabled: Filter by enabled status\n    severity: Filter by severity level (low, medium, high, critical)\n    limit: Maximum number of results to return\n    offset: Number of results to skip for pagination\n    db: Database session\n\nReturns:\n    AlertRuleListResponse with rules and pagination info",
        "operationId": "list_rules_api_alerts_rules_get",
        "parameters": [
          {
            "name": "enabled",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by enabled status",
              "title": "Enabled"
            },
            "description": "Filter by enabled status"
          },
          {
            "name": "severity",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by severity level",
              "title": "Severity"
            },
            "description": "Filter by severity level"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "description": "Maximum number of results",
              "default": 50,
              "title": "Limit"
            },
            "description": "Maximum number of results"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of results to skip",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of results to skip"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      },
      "post": {
        "tags": ["alert-rules"],
        "summary": "Create Rule",
        "description": "Create a new alert rule.\n\nArgs:\n    rule_data: Rule creation data\n    db: Database session\n\nReturns:\n    Created AlertRule",
        "operationId": "create_rule_api_alerts_rules_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AlertRuleCreate"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/alerts/rules/{rule_id}": {
      "get": {
        "tags": ["alert-rules"],
        "summary": "Get Rule",
        "description": "Get a specific alert rule by ID.\n\nArgs:\n    rule_id: Rule UUID\n    db: Database session\n\nReturns:\n    AlertRule\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "get_rule_api_alerts_rules__rule_id__get",
        "parameters": [
          {
            "name": "rule_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Rule Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleResponse"
                }
              }
            }
          },
          "404": {
            "description": "Alert rule not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["alert-rules"],
        "summary": "Update Rule",
        "description": "Update an existing alert rule.\n\nArgs:\n    rule_id: Rule UUID\n    rule_data: Rule update data\n    db: Database session\n\nReturns:\n    Updated AlertRule\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "update_rule_api_alerts_rules__rule_id__put",
        "parameters": [
          {
            "name": "rule_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Rule Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AlertRuleUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleResponse"
                }
              }
            }
          },
          "404": {
            "description": "Alert rule not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      },
      "delete": {
        "tags": ["alert-rules"],
        "summary": "Delete Rule",
        "description": "Delete an alert rule.\n\nArgs:\n    rule_id: Rule UUID\n    db: Database session\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "delete_rule_api_alerts_rules__rule_id__delete",
        "parameters": [
          {
            "name": "rule_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Rule Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert rule not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/alerts/rules/{rule_id}/test": {
      "post": {
        "tags": ["alert-rules"],
        "summary": "Test Rule",
        "description": "Test a rule against historical events.\n\nThis endpoint allows testing rule configuration without actually\ncreating alerts. Useful for validating rules before enabling them.\n\nArgs:\n    rule_id: Rule UUID\n    test_data: Test configuration (event IDs, time override)\n    db: Database session\n\nReturns:\n    RuleTestResponse with per-event match results\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "test_rule_api_alerts_rules__rule_id__test_post",
        "parameters": [
          {
            "name": "rule_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Rule Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RuleTestRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RuleTestResponse"
                }
              }
            }
          },
          "404": {
            "description": "Alert rule not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/analytics/detection-trends": {
      "get": {
        "tags": ["analytics"],
        "summary": "Get detection trends over time",
        "description": "Retrieve detection counts aggregated by day for a specified date range.\n\nThis endpoint is useful for:\n- Monitoring detection activity over time\n- Identifying patterns in security events\n- Dashboard trend visualizations\n\nThe response includes one data point per day, with zero-fill for days without detections.\nDate parameters should be in ISO 8601 format (YYYY-MM-DD).",
        "operationId": "getDetectionTrends",
        "parameters": [
          {
            "name": "start_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date",
              "description": "Start date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)",
              "examples": ["2025-01-01"],
              "title": "Start Date"
            },
            "description": "Start date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date",
              "description": "End date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)",
              "examples": ["2025-01-07"],
              "title": "End Date"
            },
            "description": "End date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved detection trends",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionTrendsResponse"
                },
                "example": {
                  "data_points": [
                    {
                      "date": "2025-01-01",
                      "count": 20
                    },
                    {
                      "date": "2025-01-02",
                      "count": 25
                    },
                    {
                      "date": "2025-01-03",
                      "count": 18
                    }
                  ],
                  "total_detections": 63,
                  "start_date": "2025-01-01",
                  "end_date": "2025-01-03"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - start_date is after end_date",
            "content": {
              "application/json": {
                "example": {
                  "detail": "start_date must be before or equal to end_date"
                }
              }
            }
          },
          "422": {
            "description": "Validation error - invalid date format or missing required parameters"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/analytics/risk-history": {
      "get": {
        "tags": ["analytics"],
        "summary": "Get risk score distribution over time",
        "description": "Retrieve daily counts of events grouped by risk level for a specified date range.\n\nRisk levels:\n- **low**: Risk score 0-25 (routine activity)\n- **medium**: Risk score 26-50 (noteworthy events)\n- **high**: Risk score 51-75 (concerning activity)\n- **critical**: Risk score 76-100 (immediate attention required)\n\nThis endpoint is useful for:\n- Security posture assessment over time\n- Risk trend analysis and reporting\n- Identifying periods of elevated security concern\n\nThe response includes one data point per day, with zero counts for levels with no events.",
        "operationId": "getRiskHistory",
        "parameters": [
          {
            "name": "start_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date",
              "description": "Start date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)",
              "examples": ["2025-01-01"],
              "title": "Start Date"
            },
            "description": "Start date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date",
              "description": "End date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)",
              "examples": ["2025-01-07"],
              "title": "End Date"
            },
            "description": "End date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved risk history",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RiskHistoryResponse"
                },
                "example": {
                  "data_points": [
                    {
                      "date": "2025-01-01",
                      "low": 10,
                      "medium": 5,
                      "high": 2,
                      "critical": 1
                    },
                    {
                      "date": "2025-01-02",
                      "low": 12,
                      "medium": 4,
                      "high": 3,
                      "critical": 0
                    }
                  ],
                  "start_date": "2025-01-01",
                  "end_date": "2025-01-02"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - start_date is after end_date",
            "content": {
              "application/json": {
                "example": {
                  "detail": "start_date must be before or equal to end_date"
                }
              }
            }
          },
          "422": {
            "description": "Validation error - invalid date format or missing required parameters"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/analytics/camera-uptime": {
      "get": {
        "tags": ["analytics"],
        "summary": "Get camera uptime statistics",
        "description": "Retrieve uptime percentage and detection counts for each camera over a specified date range.\n\nUptime calculation:\n- A camera is considered \"active\" on a day if it recorded at least one detection\n- Uptime percentage = (active days / total days in range) * 100\n- Cameras with no detections in the range will show 0% uptime\n\nThis endpoint is useful for:\n- Monitoring camera health and reliability\n- Identifying offline or malfunctioning cameras\n- Infrastructure maintenance planning\n\nAll registered cameras are included in the response, even those with 0% uptime.",
        "operationId": "getCameraUptime",
        "parameters": [
          {
            "name": "start_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date",
              "description": "Start date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)",
              "examples": ["2025-01-01"],
              "title": "Start Date"
            },
            "description": "Start date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date",
              "description": "End date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)",
              "examples": ["2025-01-07"],
              "title": "End Date"
            },
            "description": "End date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved camera uptime statistics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraUptimeResponse"
                },
                "example": {
                  "cameras": [
                    {
                      "camera_id": "front_door",
                      "camera_name": "Front Door",
                      "uptime_percentage": 98.5,
                      "detection_count": 150
                    },
                    {
                      "camera_id": "back_door",
                      "camera_name": "Back Door",
                      "uptime_percentage": 95.2,
                      "detection_count": 120
                    }
                  ],
                  "start_date": "2025-01-01",
                  "end_date": "2025-01-07"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - start_date is after end_date",
            "content": {
              "application/json": {
                "example": {
                  "detail": "start_date must be before or equal to end_date"
                }
              }
            }
          },
          "422": {
            "description": "Validation error - invalid date format or missing required parameters"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/analytics/object-distribution": {
      "get": {
        "tags": ["analytics"],
        "summary": "Get detection counts by object type",
        "description": "Retrieve detection counts grouped by object type for a specified date range.\n\nCommon object types detected by RT-DETRv2:\n- **person**: Human beings\n- **car**, **truck**, **motorcycle**: Vehicles\n- **dog**, **cat**: Pets and animals\n- **bicycle**: Non-motorized vehicles\n\nThis endpoint is useful for:\n- Understanding what types of objects trigger detections\n- Tuning detection sensitivity by object type\n- Security pattern analysis (e.g., vehicle vs pedestrian traffic)\n\nResults are sorted by count (highest first) and include percentage of total.\nDetections without an object_type are excluded from results.",
        "operationId": "getObjectDistribution",
        "parameters": [
          {
            "name": "start_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date",
              "description": "Start date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)",
              "examples": ["2025-01-01"],
              "title": "Start Date"
            },
            "description": "Start date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date",
              "description": "End date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)",
              "examples": ["2025-01-07"],
              "title": "End Date"
            },
            "description": "End date for analytics (inclusive, ISO 8601 format: YYYY-MM-DD)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved object distribution",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectDistributionResponse"
                },
                "example": {
                  "object_types": [
                    {
                      "object_type": "person",
                      "count": 120,
                      "percentage": 45.5
                    },
                    {
                      "object_type": "car",
                      "count": 80,
                      "percentage": 30.3
                    },
                    {
                      "object_type": "dog",
                      "count": 64,
                      "percentage": 24.2
                    }
                  ],
                  "total_detections": 264,
                  "start_date": "2025-01-01",
                  "end_date": "2025-01-07"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - start_date is after end_date",
            "content": {
              "application/json": {
                "example": {
                  "detail": "start_date must be before or equal to end_date"
                }
              }
            }
          },
          "422": {
            "description": "Validation error - invalid date format or missing required parameters"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/audit": {
      "get": {
        "tags": ["audit"],
        "summary": "List Audit Logs",
        "description": "List audit logs with optional filtering and cursor-based pagination.\n\nThis endpoint is intended for admin use to review security-sensitive operations.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\nArgs:\n    action: Optional action type to filter by\n    resource_type: Optional resource type to filter by\n    resource_id: Optional specific resource ID to filter by\n    actor: Optional actor to filter by\n    status_filter: Optional status to filter by (success/failure)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    limit: Maximum number of results to return (1-1000, default 100)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    db: Database session\n\nReturns:\n    AuditLogListResponse containing filtered logs and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid",
        "operationId": "list_audit_logs_api_audit_get",
        "parameters": [
          {
            "name": "action",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by action type",
              "title": "Action"
            },
            "description": "Filter by action type"
          },
          {
            "name": "resource_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by resource type",
              "title": "Resource Type"
            },
            "description": "Filter by resource type"
          },
          {
            "name": "resource_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by resource ID",
              "title": "Resource Id"
            },
            "description": "Filter by resource ID"
          },
          {
            "name": "actor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by actor",
              "title": "Actor"
            },
            "description": "Filter by actor"
          },
          {
            "name": "status",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by status (success/failure)",
              "title": "Status"
            },
            "description": "Filter by status (success/failure)"
          },
          {
            "name": "start_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter from date (ISO format)",
              "title": "Start Date"
            },
            "description": "Filter from date (ISO format)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter to date (ISO format)",
              "title": "End Date"
            },
            "description": "Filter to date (ISO format)"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "description": "Page size",
              "default": 100,
              "title": "Limit"
            },
            "description": "Page size"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of results to skip (deprecated, use cursor)"
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            },
            "description": "Pagination cursor from previous response"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditLogListResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid date range or cursor"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/audit/stats": {
      "get": {
        "tags": ["audit"],
        "summary": "Get Audit Stats",
        "description": "Get audit log statistics for dashboard.\n\nReturns aggregated statistics about audit logs including:\n- Total log count\n- Logs today\n- Breakdown by action type\n- Breakdown by resource type\n- Breakdown by status\n- Recently active actors\n\nThis endpoint is optimized to use a single aggregation query for counts\n(total, today, by_action, by_resource_type, by_status) plus one query\nfor recent actors, reducing database round-trips from 6 to 2.\n\nArgs:\n    db: Database session\n\nReturns:\n    AuditLogStats with aggregated statistics",
        "operationId": "get_audit_stats_api_audit_stats_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditLogStats"
                }
              }
            }
          },
          "400": {
            "description": "Invalid date range"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/audit/{audit_id}": {
      "get": {
        "tags": ["audit"],
        "summary": "Get Audit Log",
        "description": "Get a specific audit log entry by ID.\n\nArgs:\n    audit_id: Audit log ID\n    db: Database session\n\nReturns:\n    AuditLog record\n\nRaises:\n    HTTPException: 404 if audit log not found",
        "operationId": "get_audit_log_api_audit__audit_id__get",
        "parameters": [
          {
            "name": "audit_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Audit Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditLogResponse"
                }
              }
            }
          },
          "404": {
            "description": "Audit log not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/cameras": {
      "get": {
        "tags": ["cameras"],
        "summary": "List Cameras",
        "description": "List all cameras with optional status filter.\n\nUses Redis cache with cache-aside pattern to improve performance\nand generate cache hit metrics.\n\n## Sparse Fieldsets (NEM-1434)\n\nUse the `fields` query parameter to request only specific fields in the response,\nreducing payload size and bandwidth usage.\n\n**Format:** Comma-separated list of field names (case-insensitive, whitespace ignored)\n\n**Example Request:**\n```\nGET /api/cameras?fields=id,name,status\n```\n\n**Example Response (with fields filter):**\n```json\n{\n  \"cameras\": [\n    {\n      \"id\": \"front_door\",\n      \"name\": \"Front Door Camera\",\n      \"status\": \"online\"\n    }\n  ],\n  \"count\": 1\n}\n```\n\n**Available Fields:**\n- `id` - Camera identifier\n- `name` - Human-readable camera name\n- `folder_path` - Path to camera image storage folder\n- `status` - Camera status (online, offline, error)\n- `created_at` - Camera creation timestamp\n- `last_seen_at` - Timestamp of last detected activity\n\nArgs:\n    response: FastAPI Response for setting cache headers\n    status_filter: Optional status to filter cameras by (online, offline, error)\n    fields: Comma-separated list of fields to include (sparse fieldsets)\n    db: Database session\n    cache: Cache service injected via FastAPI DI\n\nReturns:\n    CameraListResponse containing list of cameras and total count\n\nRaises:\n    HTTPException: 400 if invalid fields are requested",
        "operationId": "list_cameras_api_cameras_get",
        "parameters": [
          {
            "name": "status",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera status",
              "title": "Status"
            },
            "description": "Filter by camera status"
          },
          {
            "name": "fields",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated list of fields to include in response (sparse fieldsets). Use this to reduce payload size by requesting only the fields you need. If omitted, all fields are returned. Valid fields: id, name, folder_path, status, created_at, last_seen_at. Example: fields=id,name,status",
              "examples": ["id,name,status", "id,name,status,last_seen_at"],
              "title": "Fields"
            },
            "description": "Comma-separated list of fields to include in response (sparse fieldsets). Use this to reduce payload size by requesting only the fields you need. If omitted, all fields are returned. Valid fields: id, name, folder_path, status, created_at, last_seen_at. Example: fields=id,name,status",
            "examples": {
              "status_only": {
                "summary": "Status monitoring",
                "description": "Minimal fields for camera status checks",
                "value": "id,name,status"
              },
              "with_timestamps": {
                "summary": "Status with timestamps",
                "description": "Status check with activity timestamps",
                "value": "id,name,status,last_seen_at"
              },
              "full_details": {
                "summary": "All fields (default)",
                "description": "Omit the fields parameter to get all available fields"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraListResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid fields parameter"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["cameras"],
        "summary": "Create Camera",
        "description": "Create a new camera.\n\nArgs:\n    camera_data: Camera creation data\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    Created camera object with generated ID\n\nRaises:\n    HTTPException: 409 if camera with same name or folder_path already exists",
        "operationId": "create_camera_api_cameras_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraCreate"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            }
          },
          "409": {
            "description": "Camera with same name or folder_path already exists"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/cameras/{camera_id}": {
      "get": {
        "tags": ["cameras"],
        "summary": "Get Camera",
        "description": "Get a specific camera by ID.\n\nArgs:\n    camera_id: Normalized camera ID (e.g., \"front_door\", \"backyard\")\n    response: FastAPI Response for setting cache headers\n    db: Database session\n\nReturns:\n    Camera object\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_api_cameras__camera_id__get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": ["cameras"],
        "summary": "Update Camera",
        "description": "Update an existing camera.\n\nArgs:\n    camera_id: Normalized camera ID (e.g., \"front_door\", \"backyard\")\n    camera_data: Camera update data (all fields optional)\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    Updated camera object\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "update_camera_api_cameras__camera_id__patch",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      },
      "delete": {
        "tags": ["cameras"],
        "summary": "Delete Camera",
        "description": "Delete a camera.\n\nThis operation cascades to all related detections and events.\n\nArgs:\n    camera_id: Normalized camera ID (e.g., \"front_door\", \"backyard\")\n    request: FastAPI request for audit logging\n    db: Database session\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "delete_camera_api_cameras__camera_id__delete",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "404": {
            "description": "Camera not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/cameras/{camera_id}/snapshot": {
      "get": {
        "tags": ["cameras"],
        "summary": "Get Camera Snapshot",
        "description": "Return the latest image for a camera (best-effort snapshot).\n\nThis endpoint is exempt from API key authentication because:\n1. It serves static image content accessed directly by browsers via <img> tags\n2. It has its own security controls (path traversal protection, file type allowlist)\n3. It has rate limiting to prevent abuse\n\nThis endpoint uses the camera's configured `folder_path` and returns the most recently\nmodified image file under that directory.",
        "operationId": "get_camera_snapshot_api_cameras__camera_id__snapshot_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Snapshot served successfully"
          },
          "404": {
            "description": "Camera or snapshot not found"
          },
          "429": {
            "description": "Too many requests"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/cameras/validation/paths": {
      "get": {
        "tags": ["cameras"],
        "summary": "Validate Camera Paths",
        "description": "Validate all camera folder paths against the configured base path.\n\nThis endpoint checks each camera's folder_path to determine:\n1. Whether the path is under the configured FOSCAM_BASE_PATH\n2. Whether the directory exists on disk\n3. Whether the directory contains any images\n\nUse this to diagnose cameras that show \"No snapshot available\" errors.\n\nArgs:\n    response: FastAPI Response for setting cache headers\n    db: Database session\n\nReturns:\n    Dictionary with validation results for all cameras",
        "operationId": "validate_camera_paths_api_cameras_validation_paths_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": true,
                  "type": "object",
                  "title": "Response Validate Camera Paths Api Cameras Validation Paths Get"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/cameras/{camera_id}/baseline": {
      "get": {
        "tags": ["cameras"],
        "summary": "Get Camera Baseline",
        "description": "Get baseline activity data for a camera.\n\nReturns comprehensive baseline statistics including:\n- Hourly activity patterns (0-23 hours)\n- Daily patterns (by day of week)\n- Object-specific baselines\n- Current deviation from baseline\n\nArgs:\n    camera_id: ID of the camera\n    response: FastAPI Response for setting cache headers\n    db: Database session\n\nReturns:\n    BaselineSummaryResponse with all baseline data\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_baseline_api_cameras__camera_id__baseline_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BaselineSummaryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/cameras/{camera_id}/baseline/anomalies": {
      "get": {
        "tags": ["cameras"],
        "summary": "Get Camera Baseline Anomalies",
        "description": "Get recent anomaly events for a camera.\n\nReturns a list of anomaly events detected within the specified time period.\nAnomalies are detections that significantly deviate from the established\nbaseline activity patterns.\n\nArgs:\n    camera_id: ID of the camera\n    response: FastAPI Response for setting cache headers\n    days: Number of days to look back (default: 7, max: 90)\n    db: Database session\n\nReturns:\n    AnomalyListResponse with list of anomaly events\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_baseline_anomalies_api_cameras__camera_id__baseline_anomalies_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          },
          {
            "name": "days",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 90,
              "minimum": 1,
              "description": "Number of days to look back",
              "default": 7,
              "title": "Days"
            },
            "description": "Number of days to look back"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnomalyListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "description": "Validation error - invalid days parameter"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/cameras/{camera_id}/baseline/activity": {
      "get": {
        "tags": ["cameras"],
        "summary": "Get Camera Activity Baseline",
        "description": "Get raw activity baseline data for a camera.\n\nReturns up to 168 entries (24 hours x 7 days) representing the full\nweekly activity heatmap. Each entry contains the average count and\nsample count for that hour/day combination.\n\nArgs:\n    camera_id: ID of the camera\n    response: FastAPI Response for setting cache headers\n    db: Database session\n\nReturns:\n    ActivityBaselineResponse with entries for the heatmap\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_activity_baseline_api_cameras__camera_id__baseline_activity_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActivityBaselineResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/cameras/{camera_id}/baseline/classes": {
      "get": {
        "tags": ["cameras"],
        "summary": "Get Camera Class Baseline",
        "description": "Get class frequency baseline data for a camera.\n\nReturns baseline entries grouped by object class and hour, showing\nthe frequency of each object type at different times of day.\n\nArgs:\n    camera_id: ID of the camera\n    response: FastAPI Response for setting cache headers\n    db: Database session\n\nReturns:\n    ClassBaselineResponse with entries for each class/hour combination\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_class_baseline_api_cameras__camera_id__baseline_classes_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClassBaselineResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/cameras/{camera_id}/scene-changes": {
      "get": {
        "tags": ["cameras"],
        "summary": "Get Camera Scene Changes",
        "description": "Get scene changes for a camera with cursor-based pagination.\n\nReturns a list of detected scene changes that may indicate camera\ntampering, angle changes, or blocked views. Uses cursor-based pagination\nfor efficient navigation through large datasets.\n\nArgs:\n    camera_id: ID of the camera\n    response: FastAPI Response for setting cache headers\n    acknowledged: Filter by acknowledgement status (None = all)\n    limit: Maximum number of results (default: 50, max: 100)\n    cursor: Cursor for pagination (detected_at timestamp from previous response)\n    db: Database session\n\nReturns:\n    SceneChangeListResponse with list of scene changes and pagination info\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "get_camera_scene_changes_api_cameras__camera_id__scene_changes_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          },
          {
            "name": "acknowledged",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by acknowledgement status",
              "title": "Acknowledged"
            },
            "description": "Filter by acknowledgement status"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of results",
              "default": 50,
              "title": "Limit"
            },
            "description": "Maximum number of results"
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Cursor for pagination (detected_at timestamp)",
              "title": "Cursor"
            },
            "description": "Cursor for pagination (detected_at timestamp)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneChangeListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "description": "Validation error - invalid pagination parameters"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/cameras/{camera_id}/scene-changes/{scene_change_id}/acknowledge": {
      "post": {
        "tags": ["cameras"],
        "summary": "Acknowledge Scene Change",
        "description": "Acknowledge a scene change alert.\n\nMarks a scene change as acknowledged to indicate it has been reviewed.\n\nArgs:\n    camera_id: ID of the camera\n    scene_change_id: ID of the scene change to acknowledge\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    SceneChangeAcknowledgeResponse confirming acknowledgement\n\nRaises:\n    HTTPException: 404 if camera or scene change not found",
        "operationId": "acknowledge_scene_change_api_cameras__camera_id__scene_changes__scene_change_id__acknowledge_post",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          },
          {
            "name": "scene_change_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Scene Change Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneChangeAcknowledgeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera or scene change not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/debug/config": {
      "get": {
        "tags": ["debug"],
        "summary": "Get Config",
        "description": "Get current configuration with sensitive values redacted.\n\nReturns all configuration settings with passwords, API keys, and other\nsensitive values replaced with [REDACTED]. URLs containing passwords\nwill have only the password portion redacted, preserving the structure.\n\nNEM-1642: Debug endpoint for configuration inspection",
        "operationId": "get_config_api_debug_config_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebugConfigResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/debug/redis/info": {
      "get": {
        "tags": ["debug"],
        "summary": "Get Redis Info",
        "description": "Get Redis connection stats and pub/sub channel information.\n\nReturns Redis server info, memory usage, connection stats, and\nactive pub/sub channels with their subscriber counts.\n\nNEM-1642: Debug endpoint for Redis diagnostics",
        "operationId": "get_redis_info_api_debug_redis_info_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RedisInfoResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/debug/websocket/connections": {
      "get": {
        "tags": ["debug"],
        "summary": "Get Websocket Connections",
        "description": "Get active WebSocket connection states.\n\nReturns connection counts and health status for both the event broadcaster\n(security event stream) and system broadcaster (system status stream).\n\nNEM-1642: Debug endpoint for WebSocket diagnostics",
        "operationId": "get_websocket_connections_api_debug_websocket_connections_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketConnectionsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/debug/circuit-breakers": {
      "get": {
        "tags": ["debug"],
        "summary": "Get Circuit Breakers",
        "description": "Get all circuit breaker states.\n\nReturns the current state and metrics for all registered circuit breakers,\nincluding failure counts, success counts, and configuration.\n\nNEM-1642: Debug endpoint for circuit breaker diagnostics",
        "operationId": "get_circuit_breakers_api_debug_circuit_breakers_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebugCircuitBreakersResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/debug/pipeline-state": {
      "get": {
        "tags": ["debug"],
        "summary": "Get Pipeline State",
        "description": "Get current state of the AI processing pipeline.\n\nReturns queue depths, worker status, and recent errors for debugging\npipeline issues and monitoring system health.\n\nNEM-1470: Debug endpoint for pipeline state inspection",
        "operationId": "get_pipeline_state_api_debug_pipeline_state_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineStateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/debug/log-level": {
      "get": {
        "tags": ["debug"],
        "summary": "Get Log Level",
        "description": "Get current log level.\n\nNEM-1471: Log level inspection endpoint",
        "operationId": "get_log_level_api_debug_log_level_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogLevelResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      },
      "post": {
        "tags": ["debug"],
        "summary": "Set Log Level",
        "description": "Set log level at runtime for debugging.\n\nAllows changing the log level without restarting the application.\nUseful for temporarily enabling DEBUG logging to investigate issues.\n\nNEM-1471: Log level runtime override\n\nArgs:\n    request: Log level request with new level\n\nReturns:\n    Current and previous log level\n\nRaises:\n    HTTPException: If the log level is invalid",
        "operationId": "set_log_level_api_debug_log_level_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LogLevelRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogLevelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Invalid log level"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/debug/profile/start": {
      "post": {
        "tags": ["debug"],
        "summary": "Start Profiling",
        "description": "Start performance profiling.\n\nBegins collecting profiling data for performance analysis.\nProfile data is saved to disk when stop is called.\n\nNEM-1644: Debug endpoint for performance profiling\n\nReturns:\n    Profiling start status",
        "operationId": "start_profiling_api_debug_profile_start_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProfileStartResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/debug/profile/stop": {
      "post": {
        "tags": ["debug"],
        "summary": "Stop Profiling",
        "description": "Stop performance profiling and save results.\n\nStops the profiler and saves the profile data to a .prof file.\nThe file can be analyzed with snakeviz or py-spy.\n\nNEM-1644: Debug endpoint for performance profiling\n\nReturns:\n    Profiling stop status with path to saved profile",
        "operationId": "stop_profiling_api_debug_profile_stop_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProfileStopResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/debug/profile/stats": {
      "get": {
        "tags": ["debug"],
        "summary": "Get Profile Stats",
        "description": "Get current profiling statistics.\n\nReturns the current profiling state and statistics from the last\ncompleted profiling session.\n\nNEM-1644: Debug endpoint for performance profiling\n\nReturns:\n    Profiling status and statistics",
        "operationId": "get_profile_stats_api_debug_profile_stats_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProfileStatsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/debug/recordings": {
      "get": {
        "tags": ["debug"],
        "summary": "List request recordings",
        "description": "Returns a list of recorded HTTP requests sorted by timestamp (newest first). Use the recording_id from the response to retrieve full details or replay a request.",
        "operationId": "list_recordings_api_debug_recordings_get",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 500,
              "minimum": 1,
              "description": "Maximum number of recordings to return (1-500)",
              "default": 50,
              "title": "Limit"
            },
            "description": "Maximum number of recordings to return (1-500)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecordingsListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/debug/recordings/{recording_id}": {
      "get": {
        "tags": ["debug"],
        "summary": "Get recording details",
        "description": "Returns the full recording data including request headers, body, query parameters, and the original response. Useful for analyzing recorded requests before replaying them.",
        "operationId": "get_recording_api_debug_recordings__recording_id__get",
        "parameters": [
          {
            "name": "recording_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Recording Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Full recording data including headers, body, and response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Recording Api Debug Recordings  Recording Id  Get"
                },
                "example": {
                  "recording_id": "rec_20251230_103000_abc123",
                  "timestamp": "2025-12-30T10:30:00Z",
                  "method": "POST",
                  "path": "/api/events",
                  "headers": {
                    "content-type": "application/json"
                  },
                  "body": {
                    "camera_id": "front_door"
                  },
                  "query_params": {},
                  "status_code": 201,
                  "response": {
                    "id": 123,
                    "status": "created"
                  },
                  "duration_ms": 45.2,
                  "retrieved_at": "2025-12-30T11:00:00Z"
                }
              }
            }
          },
          "404": {
            "description": "Recording not found or debug mode disabled"
          },
          "500": {
            "description": "Failed to read recording file"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["debug"],
        "summary": "Delete a recording",
        "description": "Permanently deletes a recorded request from the recordings directory. This action cannot be undone.",
        "operationId": "delete_recording_api_debug_recordings__recording_id__delete",
        "parameters": [
          {
            "name": "recording_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Recording Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Recording deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Delete Recording Api Debug Recordings  Recording Id  Delete"
                },
                "example": {
                  "message": "Recording 'rec_20251230_103000_abc123' deleted successfully"
                }
              }
            }
          },
          "404": {
            "description": "Recording not found or debug mode disabled"
          },
          "500": {
            "description": "Failed to delete recording file"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/debug/replay/{recording_id}": {
      "post": {
        "tags": ["debug"],
        "summary": "Replay a recorded request",
        "description": "Reconstructs the original request from the recording and executes it against the current application. Useful for reproducing production issues locally, testing fixes for error scenarios, and debugging intermittent failures. The replayed request includes X-Replay-Request and X-Original-Recording-ID headers.",
        "operationId": "replay_request_api_debug_replay__recording_id__post",
        "parameters": [
          {
            "name": "recording_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Recording Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReplayResponse"
                }
              }
            }
          },
          "404": {
            "description": "Recording not found or debug mode disabled"
          },
          "500": {
            "description": "Failed to read recording file or replay request failed"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/detections": {
      "get": {
        "tags": ["detections"],
        "summary": "List Detections",
        "description": "List detections with optional filtering and cursor-based pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\n## Sparse Fieldsets (NEM-1434)\n\nUse the `fields` query parameter to request only specific fields in the response,\nreducing payload size and bandwidth usage. This is particularly useful for:\n\n- List views that only need summary information\n- Mobile clients with limited bandwidth\n- Canvas/overlay rendering that only needs bounding box data\n\n**Format:** Comma-separated list of field names (case-insensitive, whitespace ignored)\n\n**Example Request:**\n```\nGET /api/detections?fields=id,camera_id,object_type,confidence\n```\n\n**Example Response (with fields filter):**\n```json\n{\n  \"detections\": [\n    {\n      \"id\": 42,\n      \"camera_id\": \"front_door\",\n      \"object_type\": \"person\",\n      \"confidence\": 0.95\n    }\n  ],\n  \"count\": 1,\n  ...\n}\n```\n\n**Available Fields:**\n- `id` - Detection identifier\n- `camera_id` - Camera that captured the detection\n- `file_path` - Path to source image/video file\n- `file_type` - MIME type of source file\n- `detected_at` - Detection timestamp\n- `object_type` - Detected object class (person, car, truck, etc.)\n- `confidence` - Detection confidence score (0.0-1.0)\n- `bbox_x`, `bbox_y` - Bounding box top-left coordinates\n- `bbox_width`, `bbox_height` - Bounding box dimensions\n- `thumbnail_path` - Path to generated thumbnail\n- `media_type` - Media type (image or video)\n- `duration` - Video duration in seconds (video only)\n- `video_codec` - Video codec (video only)\n- `video_width`, `video_height` - Video dimensions (video only)\n- `enrichment_data` - AI enrichment results (faces, plates, clothing, etc.)\n\nArgs:\n    camera_id: Optional camera ID to filter by\n    object_type: Optional object type to filter by (person, car, etc.)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    min_confidence: Optional minimum confidence score (0-1)\n    limit: Maximum number of results to return (1-100, default 50)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    fields: Comma-separated list of fields to include (sparse fieldsets)\n    db: Database session\n\nReturns:\n    DetectionListResponse containing filtered detections and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid\n    HTTPException: 400 if invalid fields are requested",
        "operationId": "list_detections_api_detections_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            },
            "description": "Filter by camera ID"
          },
          {
            "name": "object_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by object type",
              "title": "Object Type"
            },
            "description": "Filter by object type"
          },
          {
            "name": "start_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            },
            "description": "Filter by start date (ISO format)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            },
            "description": "Filter by end date (ISO format)"
          },
          {
            "name": "min_confidence",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "number",
                  "maximum": 1.0,
                  "minimum": 0.0
                },
                {
                  "type": "null"
                }
              ],
              "description": "Minimum confidence score",
              "title": "Min Confidence"
            },
            "description": "Minimum confidence score"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of results",
              "default": 50,
              "title": "Limit"
            },
            "description": "Maximum number of results"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of results to skip (deprecated, use cursor)"
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            },
            "description": "Pagination cursor from previous response"
          },
          {
            "name": "fields",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated list of fields to include in response (sparse fieldsets). Use this to reduce payload size by requesting only the fields you need. If omitted, all fields are returned. Valid fields: id, camera_id, file_path, file_type, detected_at, object_type, confidence, bbox_x, bbox_y, bbox_width, bbox_height, thumbnail_path, media_type, duration, video_codec, video_width, video_height, enrichment_data. Example: fields=id,camera_id,object_type,confidence",
              "examples": [
                "id,camera_id,object_type,confidence",
                "id,detected_at,object_type,bbox_x,bbox_y,bbox_width,bbox_height"
              ],
              "title": "Fields"
            },
            "description": "Comma-separated list of fields to include in response (sparse fieldsets). Use this to reduce payload size by requesting only the fields you need. If omitted, all fields are returned. Valid fields: id, camera_id, file_path, file_type, detected_at, object_type, confidence, bbox_x, bbox_y, bbox_width, bbox_height, thumbnail_path, media_type, duration, video_codec, video_width, video_height, enrichment_data. Example: fields=id,camera_id,object_type,confidence",
            "examples": {
              "summary_view": {
                "summary": "Summary view",
                "description": "Minimal fields for detection list summaries",
                "value": "id,camera_id,object_type,confidence,detected_at"
              },
              "bounding_box_view": {
                "summary": "Bounding box data",
                "description": "Fields needed for drawing bounding boxes on images",
                "value": "id,object_type,confidence,bbox_x,bbox_y,bbox_width,bbox_height"
              },
              "video_metadata": {
                "summary": "Video detections",
                "description": "Fields for video detection playback",
                "value": "id,camera_id,detected_at,media_type,duration,video_codec"
              },
              "full_details": {
                "summary": "All fields (default)",
                "description": "Omit the fields parameter to get all available fields"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionListResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters (cursor, date range, or fields)"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/detections/stats": {
      "get": {
        "tags": ["detections"],
        "summary": "Get Detection Stats",
        "description": "Get aggregate detection statistics including class distribution.\n\nReturns:\n- Total detection count\n- Detection counts grouped by object class (person, car, truck, etc.)\n- Average confidence score across all detections\n\nUsed by the AI Performance page to display detection class distribution charts.\n\nOptimized to use a single query with window functions instead of 3 separate queries\n(NEM-1321). The query combines:\n- Per-class counts via GROUP BY\n- Total count via SUM(COUNT(*)) OVER() window function\n- Per-class avg confidence, then combined using weighted average formula\n\nArgs:\n    db: Database session\n\nReturns:\n    DetectionStatsResponse with aggregate detection statistics",
        "operationId": "get_detection_stats_api_detections_stats_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionStatsResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/detections/{detection_id}": {
      "get": {
        "tags": ["detections"],
        "summary": "Get Detection",
        "description": "Get a specific detection by ID.\n\nArgs:\n    detection_id: Detection ID\n    db: Database session\n\nReturns:\n    Detection object\n\nRaises:\n    HTTPException: 404 if detection not found",
        "operationId": "get_detection_api_detections__detection_id__get",
        "parameters": [
          {
            "name": "detection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Detection Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Detection not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/detections/{detection_id}/thumbnail": {
      "get": {
        "tags": ["detections"],
        "summary": "Get detection thumbnail",
        "description": "Serve the cropped thumbnail image with bounding box overlay.",
        "operationId": "get_detection_thumbnail_api_detections__detection_id__thumbnail_get",
        "parameters": [
          {
            "name": "detection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Detection Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "image/jpeg": {},
              "image/png": {}
            }
          },
          "404": {
            "description": "Detection or thumbnail not found"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Failed to generate thumbnail"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/detections/{detection_id}/enrichment": {
      "get": {
        "tags": ["detections"],
        "summary": "Get Detection Enrichment",
        "description": "Get structured enrichment data for a detection.\n\nReturns results from the 18+ vision models run during the enrichment pipeline:\n- License plate detection and OCR\n- Face detection\n- Vehicle classification and damage detection\n- Clothing analysis (FashionCLIP and SegFormer)\n- Violence detection\n- Image quality assessment\n- Pet classification\n\nArgs:\n    detection_id: Detection ID\n    db: Database session\n\nReturns:\n    EnrichmentResponse with structured vision model results\n\nRaises:\n    HTTPException: 404 if detection not found",
        "operationId": "get_detection_enrichment_api_detections__detection_id__enrichment_get",
        "parameters": [
          {
            "name": "detection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Detection Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EnrichmentResponse"
                }
              }
            }
          },
          "404": {
            "description": "Detection not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/detections/{detection_id}/image": {
      "get": {
        "tags": ["detections"],
        "summary": "Get Detection Image",
        "description": "Get detection image with bounding box overlay, or full-size original.\n\nThis endpoint is exempt from API key authentication because:\n1. It serves static image content accessed directly by browsers via <img> tags\n2. Detection IDs are not predictable (integer IDs require prior knowledge)\n3. It has rate limiting to prevent abuse\n\nBy default, returns the thumbnail image with bounding box drawn around the\ndetected object. If thumbnail doesn't exist, generates it on the fly from\nthe source image.\n\nWhen full=true is passed, returns the original source image without any\nbounding box overlay. This is used for the full-size image lightbox viewer.\n\nArgs:\n    detection_id: Detection ID\n    full: If true, return the original full-size image instead of thumbnail\n    db: Database session\n\nReturns:\n    JPEG image (thumbnail with bounding box, or full-size original)\n\nRaises:\n    HTTPException: 404 if detection not found or image file doesn't exist\n    HTTPException: 500 if image generation fails",
        "operationId": "get_detection_image_api_detections__detection_id__image_get",
        "parameters": [
          {
            "name": "detection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Detection Id"
            }
          },
          {
            "name": "full",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Return full-size original image instead of thumbnail",
              "default": false,
              "title": "Full"
            },
            "description": "Return full-size original image instead of thumbnail"
          }
        ],
        "responses": {
          "200": {
            "description": "Image served successfully"
          },
          "404": {
            "description": "Detection or image not found"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Failed to generate thumbnail"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/detections/{detection_id}/video": {
      "get": {
        "tags": ["detections"],
        "summary": "Stream Detection Video",
        "description": "Stream detection video with HTTP Range request support.\n\nThis endpoint is exempt from API key authentication because:\n1. It serves video content accessed directly by browsers via <video> tags\n2. Detection IDs are not predictable (integer IDs require prior knowledge)\n3. It has rate limiting to prevent abuse\n\nSupports partial content requests for video seeking and efficient playback.\nReturns 206 Partial Content for range requests, 200 OK for full content.\n\nArgs:\n    detection_id: Detection ID\n    range_header: HTTP Range header for partial content requests\n    db: Database session\n\nReturns:\n    StreamingResponse with video content\n\nRaises:\n    HTTPException: 404 if detection not found or not a video\n    HTTPException: 416 if range is not satisfiable",
        "operationId": "stream_detection_video_api_detections__detection_id__video_get",
        "parameters": [
          {
            "name": "detection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Detection Id"
            }
          },
          {
            "name": "Range",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Range"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Full video content"
          },
          "206": {
            "description": "Partial video content (range request)"
          },
          "400": {
            "description": "Detection is not a video"
          },
          "404": {
            "description": "Detection or video file not found"
          },
          "416": {
            "description": "Range not satisfiable"
          },
          "429": {
            "description": "Too many requests"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/detections/{detection_id}/video/thumbnail": {
      "get": {
        "tags": ["detections"],
        "summary": "Get Video Thumbnail",
        "description": "Get thumbnail frame from a video detection.\n\nThis endpoint is exempt from API key authentication because:\n1. It serves static image content accessed directly by browsers via <img> tags\n2. Detection IDs are not predictable (integer IDs require prior knowledge)\n3. It has rate limiting to prevent abuse\n\nExtracts and returns a thumbnail frame from the video. If thumbnail\ndoesn't exist, generates it on the fly using ffmpeg.\n\nArgs:\n    detection_id: Detection ID\n    db: Database session\n\nReturns:\n    JPEG thumbnail image\n\nRaises:\n    HTTPException: 404 if detection not found or not a video\n    HTTPException: 500 if thumbnail generation fails",
        "operationId": "get_video_thumbnail_api_detections__detection_id__video_thumbnail_get",
        "parameters": [
          {
            "name": "detection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Detection Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Thumbnail served successfully"
          },
          "400": {
            "description": "Detection is not a video"
          },
          "404": {
            "description": "Detection or video not found"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Failed to generate thumbnail"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/detections/bulk": {
      "post": {
        "tags": ["detections"],
        "summary": "Bulk create detections",
        "description": "Create multiple detections in a single request.\n\nSupports partial success - some detections may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk create request with up to 100 detections\n    db: Database session\n\nReturns:\n    DetectionBulkCreateResponse with per-item results",
        "operationId": "bulk_create_detections_api_detections_bulk_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetectionBulkCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "description": "Multi-status response with per-item results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionBulkCreateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        }
      },
      "delete": {
        "tags": ["detections"],
        "summary": "Bulk delete detections",
        "description": "Delete multiple detections in a single request.\n\nSupports partial success - some deletions may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nNote: Detection deletion is always hard delete as detections are raw data\nand soft-delete is not supported.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk delete request with up to 100 detection IDs\n    db: Database session\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "bulk_delete_detections_api_detections_bulk_delete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetectionBulkDeleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "description": "Multi-status response with per-item results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        }
      },
      "patch": {
        "tags": ["detections"],
        "summary": "Bulk update detections",
        "description": "Update multiple detections in a single request.\n\nSupports partial success - some updates may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk update request with up to 100 detection updates\n    db: Database session\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "bulk_update_detections_api_detections_bulk_patch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetectionBulkUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "description": "Multi-status response with per-item results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        }
      }
    },
    "/api/dlq/stats": {
      "get": {
        "tags": ["dlq"],
        "summary": "Get DLQ statistics",
        "description": "Retrieve statistics for all dead-letter queues in the system.\n\nReturns the count of failed jobs in each DLQ (detection and analysis)\nalong with a total count. Use this endpoint to monitor the health of\nthe AI processing pipeline and identify when jobs are failing.\n\n**No authentication required** for this read-only endpoint.",
        "operationId": "get_dlq_stats",
        "responses": {
          "200": {
            "description": "Successfully retrieved DLQ statistics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQStatsResponse"
                },
                "example": {
                  "detection_queue_count": 2,
                  "analysis_queue_count": 1,
                  "total_count": 3
                }
              }
            }
          },
          "500": {
            "description": "Internal server error - Redis connection failed"
          }
        }
      }
    },
    "/api/dlq/jobs/{queue_name}": {
      "get": {
        "tags": ["dlq"],
        "summary": "List jobs in a DLQ",
        "description": "List failed jobs in a specific dead-letter queue with enriched error context.\n\nReturns jobs in the specified DLQ without removing them. Use pagination\nparameters to efficiently browse through large numbers of failed jobs.\n\n**Available queues:**\n- `dlq:detection_queue` - Jobs that failed during RT-DETRv2 object detection\n- `dlq:analysis_queue` - Jobs that failed during Nemotron risk analysis\n\n**Enriched error context (NEM-1474):**\nEach job includes detailed debugging information:\n- `error_type`: Exception class name (e.g., 'ConnectionRefusedError') for categorization\n- `stack_trace`: Truncated stack trace (max 4KB) for debugging\n- `http_status`: HTTP status code if the error was from a network request\n- `response_body`: Truncated AI service response (max 2KB)\n- `retry_delays`: List of delays (seconds) applied between retry attempts\n- `context`: System state snapshot at failure time (queue depths, circuit breaker states)\n\n**No authentication required** for this read-only endpoint.",
        "operationId": "get_dlq_jobs",
        "parameters": [
          {
            "name": "queue_name",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "name": "start",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Start index for pagination (0-based). Use with `limit` to page through results.",
              "default": 0,
              "title": "Start"
            },
            "description": "Start index for pagination (0-based). Use with `limit` to page through results."
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "description": "Maximum number of jobs to return (1-1000). Default is 100.",
              "default": 100,
              "title": "Limit"
            },
            "description": "Maximum number of jobs to return (1-1000). Default is 100."
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved jobs from the DLQ",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQJobsResponse"
                },
                "example": {
                  "queue_name": "dlq:detection_queue",
                  "jobs": [
                    {
                      "original_job": {
                        "camera_id": "front_door",
                        "file_path": "/export/foscam/front_door/image_001.jpg",
                        "timestamp": "2025-12-23T10:30:00.000000"
                      },
                      "error": "Connection refused: detector service unavailable",
                      "attempt_count": 3,
                      "first_failed_at": "2025-12-23T10:30:05.000000",
                      "last_failed_at": "2025-12-23T10:30:15.000000",
                      "queue_name": "detection_queue",
                      "error_type": "ConnectionRefusedError",
                      "stack_trace": "Traceback (most recent call last):\n  ...",
                      "retry_delays": [1.0, 2.0],
                      "context": {
                        "detection_queue_depth": 150,
                        "analysis_queue_depth": 25,
                        "dlq_circuit_breaker_state": "closed"
                      }
                    }
                  ],
                  "count": 1
                }
              }
            }
          },
          "422": {
            "description": "Validation error - invalid queue name or pagination parameters",
            "content": {
              "application/json": {
                "example": {
                  "detail": [
                    {
                      "type": "enum",
                      "loc": ["path", "queue_name"],
                      "msg": "Input should be 'dlq:detection_queue' or 'dlq:analysis_queue'"
                    }
                  ]
                }
              }
            }
          },
          "500": {
            "description": "Internal server error - Redis connection failed"
          }
        }
      }
    },
    "/api/dlq/requeue/{queue_name}": {
      "post": {
        "tags": ["dlq"],
        "summary": "Requeue oldest job from DLQ",
        "description": "Requeue the oldest (first) job from a dead-letter queue back to its original processing queue.\n\nThis operation:\n1. Removes the oldest job from the specified DLQ (FIFO order)\n2. Adds it back to the original processing queue for retry\n3. Returns success/failure status\n\n**Queue mapping:**\n- `dlq:detection_queue` -> `detection_queue` (RT-DETRv2 processing)\n- `dlq:analysis_queue` -> `analysis_queue` (Nemotron risk analysis)\n\n**Use cases:**\n- Retry a single job after fixing a transient issue (e.g., AI service restart)\n- Gradually reprocess failed jobs one at a time\n- Test if the processing pipeline is working before requeuing all jobs\n\n**Authentication required:** This destructive operation requires an API key when `api_key_enabled=True`.\nProvide the key via `X-API-Key` header or `api_key` query parameter.",
        "operationId": "requeue_dlq_job",
        "parameters": [
          {
            "name": "queue_name",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "name": "api_key",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Api Key"
            }
          },
          {
            "name": "X-API-Key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Job successfully requeued or no jobs available",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQRequeueResponse"
                },
                "examples": {
                  "success": {
                    "summary": "Job requeued successfully",
                    "value": {
                      "success": true,
                      "message": "Job requeued from dlq:detection_queue to detection_queue"
                    }
                  },
                  "empty_queue": {
                    "summary": "No jobs in DLQ",
                    "value": {
                      "success": false,
                      "message": "No jobs to requeue from dlq:detection_queue"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - API key required or invalid",
            "content": {
              "application/json": {
                "examples": {
                  "missing_key": {
                    "summary": "API key not provided",
                    "value": {
                      "detail": "API key required. Provide via X-API-Key header or api_key query parameter."
                    }
                  },
                  "invalid_key": {
                    "summary": "Invalid API key",
                    "value": {
                      "detail": "Invalid API key"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation error - invalid queue name",
            "content": {
              "application/json": {
                "example": {
                  "detail": [
                    {
                      "type": "enum",
                      "loc": ["path", "queue_name"],
                      "msg": "Input should be 'dlq:detection_queue' or 'dlq:analysis_queue'"
                    }
                  ]
                }
              }
            }
          },
          "500": {
            "description": "Internal server error - Redis connection failed"
          }
        }
      }
    },
    "/api/dlq/requeue-all/{queue_name}": {
      "post": {
        "tags": ["dlq"],
        "summary": "Requeue all jobs from DLQ",
        "description": "Requeue all jobs from a dead-letter queue back to their original processing queue.\n\nThis bulk operation:\n1. Removes all jobs from the specified DLQ\n2. Adds them back to the original processing queue for retry\n3. Returns the count of requeued jobs\n\n**Queue mapping:**\n- `dlq:detection_queue` -> `detection_queue` (RT-DETRv2 processing)\n- `dlq:analysis_queue` -> `analysis_queue` (Nemotron risk analysis)\n\n**Safety limits:**\nThis operation is limited to `max_requeue_iterations` (configurable in settings)\nto prevent resource exhaustion. If the DLQ contains more jobs than the limit,\na partial requeue will occur and the response will indicate the limit was hit.\n\n**Use cases:**\n- Bulk retry after fixing a systemic issue (e.g., AI service configuration)\n- Clear DLQ after investigating and resolving root cause\n- Recovery after a prolonged outage\n\n**Authentication required:** This destructive operation requires an API key when `api_key_enabled=True`.\nProvide the key via `X-API-Key` header or `api_key` query parameter.",
        "operationId": "requeue_all_dlq_jobs",
        "parameters": [
          {
            "name": "queue_name",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "name": "api_key",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Api Key"
            }
          },
          {
            "name": "X-API-Key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Jobs requeued (fully or partially) or no jobs available",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQRequeueResponse"
                },
                "examples": {
                  "success": {
                    "summary": "All jobs requeued successfully",
                    "value": {
                      "success": true,
                      "message": "Requeued 15 jobs from dlq:detection_queue to detection_queue"
                    }
                  },
                  "partial": {
                    "summary": "Partial requeue (hit limit)",
                    "value": {
                      "success": true,
                      "message": "Requeued 1000 jobs from dlq:detection_queue to detection_queue (hit limit of 1000)"
                    }
                  },
                  "empty_queue": {
                    "summary": "No jobs in DLQ",
                    "value": {
                      "success": false,
                      "message": "No jobs to requeue from dlq:detection_queue"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - API key required or invalid",
            "content": {
              "application/json": {
                "examples": {
                  "missing_key": {
                    "summary": "API key not provided",
                    "value": {
                      "detail": "API key required. Provide via X-API-Key header or api_key query parameter."
                    }
                  },
                  "invalid_key": {
                    "summary": "Invalid API key",
                    "value": {
                      "detail": "Invalid API key"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation error - invalid queue name",
            "content": {
              "application/json": {
                "example": {
                  "detail": [
                    {
                      "type": "enum",
                      "loc": ["path", "queue_name"],
                      "msg": "Input should be 'dlq:detection_queue' or 'dlq:analysis_queue'"
                    }
                  ]
                }
              }
            }
          },
          "500": {
            "description": "Internal server error - Redis connection failed"
          }
        }
      }
    },
    "/api/dlq/{queue_name}": {
      "delete": {
        "tags": ["dlq"],
        "summary": "Clear all jobs from DLQ",
        "description": "**WARNING:** Permanently delete all jobs from a dead-letter queue.\n\nThis destructive operation:\n1. Counts jobs in the specified DLQ\n2. Deletes all jobs permanently (they cannot be recovered)\n3. Returns the count of deleted jobs\n\n**Available queues:**\n- `dlq:detection_queue` - Failed RT-DETRv2 object detection jobs\n- `dlq:analysis_queue` - Failed Nemotron risk analysis jobs\n\n**Use cases:**\n- Clear stale jobs that are no longer relevant (e.g., images already deleted)\n- Reset after testing or debugging\n- Clean up after resolving issues and selectively requeuing important jobs\n\n**Caution:** Unlike requeue operations, cleared jobs cannot be recovered.\nConsider using `/jobs/{queue_name}` to inspect jobs before clearing.\n\n**Authentication required:** This destructive operation requires an API key when `api_key_enabled=True`.\nProvide the key via `X-API-Key` header or `api_key` query parameter.",
        "operationId": "clear_dlq",
        "parameters": [
          {
            "name": "queue_name",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "name": "api_key",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Api Key"
            }
          },
          {
            "name": "X-API-Key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "DLQ cleared successfully or operation failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQClearResponse"
                },
                "examples": {
                  "success": {
                    "summary": "DLQ cleared successfully",
                    "value": {
                      "success": true,
                      "message": "Cleared 5 jobs from dlq:detection_queue",
                      "queue_name": "dlq:detection_queue"
                    }
                  },
                  "empty_queue": {
                    "summary": "DLQ was already empty",
                    "value": {
                      "success": true,
                      "message": "Cleared 0 jobs from dlq:detection_queue",
                      "queue_name": "dlq:detection_queue"
                    }
                  },
                  "failure": {
                    "summary": "Clear operation failed",
                    "value": {
                      "success": false,
                      "message": "Failed to clear dlq:detection_queue",
                      "queue_name": "dlq:detection_queue"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - API key required or invalid",
            "content": {
              "application/json": {
                "examples": {
                  "missing_key": {
                    "summary": "API key not provided",
                    "value": {
                      "detail": "API key required. Provide via X-API-Key header or api_key query parameter."
                    }
                  },
                  "invalid_key": {
                    "summary": "Invalid API key",
                    "value": {
                      "detail": "Invalid API key"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation error - invalid queue name",
            "content": {
              "application/json": {
                "example": {
                  "detail": [
                    {
                      "type": "enum",
                      "loc": ["path", "queue_name"],
                      "msg": "Input should be 'dlq:detection_queue' or 'dlq:analysis_queue'"
                    }
                  ]
                }
              }
            }
          },
          "500": {
            "description": "Internal server error - Redis connection failed"
          }
        }
      }
    },
    "/api/entities": {
      "get": {
        "tags": ["entities"],
        "summary": "List Entities",
        "description": "List tracked entities with optional filtering.\n\nReturns a paginated list of entities that have been tracked via\nre-identification. Entities are grouped by their embedding clusters.\n\nArgs:\n    entity_type: Filter by entity type ('person' or 'vehicle')\n    camera_id: Filter by camera ID\n    since: Filter entities seen since this timestamp\n    limit: Maximum number of results (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    reid_service: Re-identification service dependency\n\nReturns:\n    EntityListResponse with filtered entities and pagination info",
        "operationId": "list_entities_api_entities_get",
        "parameters": [
          {
            "name": "entity_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/EntityTypeEnum"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by entity type: 'person' or 'vehicle'",
              "title": "Entity Type"
            },
            "description": "Filter by entity type: 'person' or 'vehicle'"
          },
          {
            "name": "camera_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            },
            "description": "Filter by camera ID"
          },
          {
            "name": "since",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter entities seen since this time",
              "title": "Since"
            },
            "description": "Filter entities seen since this time"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "description": "Maximum number of results",
              "default": 50,
              "title": "Limit"
            },
            "description": "Maximum number of results"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of results to skip",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of results to skip"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/entities/{entity_id}": {
      "get": {
        "tags": ["entities"],
        "summary": "Get Entity",
        "description": "Get detailed information about a specific entity.\n\nReturns the entity's summary information along with all recorded appearances.\n\nArgs:\n    entity_id: Unique entity identifier (detection_id)\n    reid_service: Re-identification service dependency\n\nReturns:\n    EntityDetail with full entity information\n\nRaises:\n    HTTPException: 404 if entity not found, 503 if Redis unavailable",
        "operationId": "get_entity_api_entities__entity_id__get",
        "parameters": [
          {
            "name": "entity_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Entity Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityDetail"
                }
              }
            }
          },
          "404": {
            "description": "Entity not found"
          },
          "503": {
            "description": "Redis service unavailable"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/entities/{entity_id}/history": {
      "get": {
        "tags": ["entities"],
        "summary": "Get Entity History",
        "description": "Get the appearance timeline for a specific entity.\n\nReturns a chronological list of all appearances for the entity\nacross all cameras.\n\nArgs:\n    entity_id: Unique entity identifier (detection_id)\n    reid_service: Re-identification service dependency\n\nReturns:\n    EntityHistoryResponse with appearance timeline\n\nRaises:\n    HTTPException: 404 if entity not found, 503 if Redis unavailable",
        "operationId": "get_entity_history_api_entities__entity_id__history_get",
        "parameters": [
          {
            "name": "entity_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Entity Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityHistoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entity not found"
          },
          "503": {
            "description": "Redis service unavailable"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events": {
      "get": {
        "tags": ["events"],
        "summary": "List Events",
        "description": "List events with optional filtering and cursor-based pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\n## Sparse Fieldsets (NEM-1434)\n\nUse the `fields` query parameter to request only specific fields in the response,\nreducing payload size and bandwidth usage. This is particularly useful for:\n\n- Dashboard views that only need summary information\n- Mobile clients with limited bandwidth\n- High-frequency polling scenarios\n\n**Format:** Comma-separated list of field names (case-insensitive, whitespace ignored)\n\n**Example Request:**\n```\nGET /api/events?fields=id,camera_id,risk_level,summary,reviewed\n```\n\n**Example Response (with fields filter):**\n```json\n{\n  \"events\": [\n    {\n      \"id\": 123,\n      \"camera_id\": \"front_door\",\n      \"risk_level\": \"medium\",\n      \"summary\": \"Person detected near entrance\",\n      \"reviewed\": false\n    }\n  ],\n  \"count\": 1,\n  ...\n}\n```\n\n**Available Fields:**\n- `id` - Event identifier\n- `camera_id` - Camera that captured the event\n- `started_at` - Event start timestamp\n- `ended_at` - Event end timestamp\n- `risk_score` - Numeric risk score (0-100)\n- `risk_level` - Risk level (low, medium, high, critical)\n- `summary` - AI-generated event summary\n- `reasoning` - AI reasoning for risk assessment\n- `reviewed` - Whether event has been reviewed\n- `detection_count` - Number of detections in event\n- `detection_ids` - List of detection IDs\n- `thumbnail_url` - URL to event thumbnail image\n\nArgs:\n    camera_id: Optional camera ID to filter by\n    risk_level: Optional risk level to filter by (low, medium, high, critical)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    reviewed: Optional filter by reviewed status\n    object_type: Optional object type to filter by (person, vehicle, animal, etc.)\n    limit: Maximum number of results to return (1-100, default 50)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    fields: Comma-separated list of fields to include (sparse fieldsets)\n    db: Database session\n\nReturns:\n    EventListResponse containing filtered events and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid\n    HTTPException: 400 if invalid fields are requested",
        "operationId": "list_events_api_events_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            },
            "description": "Filter by camera ID"
          },
          {
            "name": "risk_level",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by risk level (low, medium, high, critical)",
              "title": "Risk Level"
            },
            "description": "Filter by risk level (low, medium, high, critical)"
          },
          {
            "name": "start_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            },
            "description": "Filter by start date (ISO format)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            },
            "description": "Filter by end date (ISO format)"
          },
          {
            "name": "reviewed",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by reviewed status",
              "title": "Reviewed"
            },
            "description": "Filter by reviewed status"
          },
          {
            "name": "object_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by detected object type",
              "title": "Object Type"
            },
            "description": "Filter by detected object type"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of results",
              "default": 50,
              "title": "Limit"
            },
            "description": "Maximum number of results"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of results to skip (deprecated, use cursor)"
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            },
            "description": "Pagination cursor from previous response"
          },
          {
            "name": "fields",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated list of fields to include in response (sparse fieldsets). Use this to reduce payload size by requesting only the fields you need. If omitted, all fields are returned. Valid fields: id, camera_id, started_at, ended_at, risk_score, risk_level, summary, reasoning, reviewed, detection_count, detection_ids, thumbnail_url. Example: fields=id,camera_id,risk_level,summary,reviewed",
              "examples": ["id,camera_id,risk_level,summary,reviewed", "id,started_at,risk_score"],
              "title": "Fields"
            },
            "description": "Comma-separated list of fields to include in response (sparse fieldsets). Use this to reduce payload size by requesting only the fields you need. If omitted, all fields are returned. Valid fields: id, camera_id, started_at, ended_at, risk_score, risk_level, summary, reasoning, reviewed, detection_count, detection_ids, thumbnail_url. Example: fields=id,camera_id,risk_level,summary,reviewed",
            "examples": {
              "dashboard_view": {
                "summary": "Dashboard minimal fields",
                "description": "Fields commonly needed for dashboard event lists",
                "value": "id,camera_id,risk_level,summary,reviewed"
              },
              "timeline_view": {
                "summary": "Timeline view fields",
                "description": "Fields needed for event timeline display",
                "value": "id,camera_id,started_at,ended_at,risk_score,thumbnail_url"
              },
              "full_details": {
                "summary": "All fields (default)",
                "description": "Omit the fields parameter to get all available fields"
              }
            }
          },
          {
            "name": "include_deleted",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include soft-deleted events (for admin/trash views)",
              "default": false,
              "title": "Include Deleted"
            },
            "description": "Include soft-deleted events (for admin/trash views)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventListResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters (cursor, date range, or fields)"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events/stats": {
      "get": {
        "tags": ["events"],
        "summary": "Get Event Stats",
        "description": "Get aggregated event statistics.\n\nReturns statistics about events including:\n- Total event count\n- Events grouped by risk level (critical, high, medium, low)\n- Events grouped by camera with camera names\n\nUses Redis cache with cache-aside pattern to improve performance\nand generate cache hit metrics.\n\nArgs:\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    db: Database session\n    cache: Cache service injected via FastAPI DI\n\nReturns:\n    EventStatsResponse with aggregated statistics\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "get_event_stats_api_events_stats_get",
        "parameters": [
          {
            "name": "start_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            },
            "description": "Filter by start date (ISO format)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            },
            "description": "Filter by end date (ISO format)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventStatsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid date range"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events/search": {
      "get": {
        "tags": ["events"],
        "summary": "Search Events Endpoint",
        "description": "Search events using full-text search.\n\nThis endpoint provides PostgreSQL full-text search across event summaries,\nreasoning, object types, and camera names.\n\nSearch Query Syntax:\n- Basic words: \"person vehicle\" (implicit AND)\n- Phrase search: '\"suspicious person\"' (exact phrase)\n- Boolean OR: \"person OR animal\"\n- Boolean NOT: \"person NOT cat\"\n- Boolean AND: \"person AND vehicle\" (explicit)\n\nArgs:\n    q: Search query string (required)\n    camera_id: Optional comma-separated camera IDs to filter by\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    severity: Optional comma-separated risk levels (low, medium, high, critical)\n    risk_level: Alias for severity - accepts same format\n    object_type: Optional comma-separated object types (person, vehicle, animal)\n    reviewed: Optional filter by reviewed status\n    limit: Maximum number of results to return (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    db: Database session\n\nReturns:\n    SearchResponse with ranked results and pagination info\n\nRaises:\n    HTTPException: 400 if any severity value is invalid\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "search_events_endpoint_api_events_search_get",
        "parameters": [
          {
            "name": "q",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 1,
              "description": "Search query string",
              "title": "Q"
            },
            "description": "Search query string"
          },
          {
            "name": "camera_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID (comma-separated for multiple)",
              "title": "Camera Id"
            },
            "description": "Filter by camera ID (comma-separated for multiple)"
          },
          {
            "name": "start_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            },
            "description": "Filter by start date (ISO format)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            },
            "description": "Filter by end date (ISO format)"
          },
          {
            "name": "severity",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by risk levels (comma-separated: low,medium,high,critical)",
              "title": "Severity"
            },
            "description": "Filter by risk levels (comma-separated: low,medium,high,critical)"
          },
          {
            "name": "risk_level",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Alias for severity - filter by risk levels (comma-separated: low,medium,high,critical)",
              "title": "Risk Level"
            },
            "description": "Alias for severity - filter by risk levels (comma-separated: low,medium,high,critical)"
          },
          {
            "name": "object_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by object types (comma-separated: person,vehicle,animal)",
              "title": "Object Type"
            },
            "description": "Filter by object types (comma-separated: person,vehicle,animal)"
          },
          {
            "name": "reviewed",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by reviewed status",
              "title": "Reviewed"
            },
            "description": "Filter by reviewed status"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "description": "Maximum number of results",
              "default": 50,
              "title": "Limit"
            },
            "description": "Maximum number of results"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of results to skip",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of results to skip"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid search parameters (severity, date range)"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events/export": {
      "get": {
        "tags": ["events"],
        "summary": "Export Events",
        "description": "Export events as CSV file for external analysis or record-keeping.\n\nThis endpoint is rate-limited to 10 requests per minute per client IP\nto prevent abuse and protect against data exfiltration attacks.\n\nExports events with the following fields:\n- Event ID, camera name, timestamps\n- Risk score, risk level, summary\n- Detection count, reviewed status\n\nArgs:\n    request: FastAPI request object\n    camera_id: Optional camera ID to filter by\n    risk_level: Optional risk level to filter by (low, medium, high, critical)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    reviewed: Optional filter by reviewed status\n    db: Database session\n    _rate_limit: Rate limiter dependency (10 req/min, no burst)\n\nReturns:\n    StreamingResponse with CSV file containing exported events\n\nRaises:\n    HTTPException: 429 if rate limit exceeded\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "export_events_api_events_export_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            },
            "description": "Filter by camera ID"
          },
          {
            "name": "risk_level",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by risk level (low, medium, high, critical)",
              "title": "Risk Level"
            },
            "description": "Filter by risk level (low, medium, high, critical)"
          },
          {
            "name": "start_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            },
            "description": "Filter by start date (ISO format)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            },
            "description": "Filter by end date (ISO format)"
          },
          {
            "name": "reviewed",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by reviewed status",
              "title": "Reviewed"
            },
            "description": "Filter by reviewed status"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Invalid date range"
          },
          "429": {
            "description": "Rate limit exceeded"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events/{event_id}": {
      "get": {
        "tags": ["events"],
        "summary": "Get Event",
        "description": "Get a specific event by ID with HATEOAS links.\n\nArgs:\n    event_id: Event ID\n    request: FastAPI request object for building HATEOAS links\n    db: Database session\n\nReturns:\n    Event object with detection count and HATEOAS links\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "get_event_api_events__event_id__get",
        "parameters": [
          {
            "name": "event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Event Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventResponse"
                }
              }
            }
          },
          "404": {
            "description": "Event not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": ["events"],
        "summary": "Update Event",
        "description": "Update an event (mark as reviewed).\n\nArgs:\n    event_id: Event ID\n    update_data: Update data (reviewed field)\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    Updated event object\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "update_event_api_events__event_id__patch",
        "parameters": [
          {
            "name": "event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Event Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventResponse"
                }
              }
            }
          },
          "404": {
            "description": "Event not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/events/{event_id}/detections": {
      "get": {
        "tags": ["events"],
        "summary": "Get Event Detections",
        "description": "Get detections for a specific event.\n\nArgs:\n    event_id: Event ID\n    limit: Maximum number of results to return (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    db: Database session\n\nReturns:\n    DetectionListResponse containing detections for the event\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "get_event_detections_api_events__event_id__detections_get",
        "parameters": [
          {
            "name": "event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Event Id"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "description": "Maximum number of results",
              "default": 50,
              "title": "Limit"
            },
            "description": "Maximum number of results"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of results to skip",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of results to skip"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Event not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events/{event_id}/enrichments": {
      "get": {
        "tags": ["events"],
        "summary": "Get Event Enrichments",
        "description": "Get enrichment data for detections in an event with pagination.\n\nReturns structured vision model results from the enrichment pipeline for\neach detection in the event. Results include:\n- License plate detection and OCR\n- Face detection\n- Vehicle classification and damage detection\n- Clothing analysis (FashionCLIP and SegFormer)\n- Violence detection\n- Image quality assessment\n- Pet classification\n\nArgs:\n    event_id: Event ID\n    limit: Maximum number of enrichments to return (1-200, default 50)\n    offset: Number of enrichments to skip (default 0)\n    db: Database session\n\nReturns:\n    EventEnrichmentsResponse with enrichment data for each detection and pagination metadata\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "get_event_enrichments_api_events__event_id__enrichments_get",
        "parameters": [
          {
            "name": "event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Event Id"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 200,
              "minimum": 1,
              "description": "Maximum number of enrichments to return",
              "default": 50,
              "title": "Limit"
            },
            "description": "Maximum number of enrichments to return"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of enrichments to skip",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of enrichments to skip"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventEnrichmentsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Event not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events/{event_id}/clip": {
      "get": {
        "tags": ["events"],
        "summary": "Get Event Clip",
        "description": "Get clip information for a specific event.\n\nReturns information about whether a video clip is available for the event,\nand if so, provides the URL to access it along with metadata.\n\nArgs:\n    event_id: Event ID\n    db: Database session\n\nReturns:\n    ClipInfoResponse with clip availability and metadata\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "get_event_clip_api_events__event_id__clip_get",
        "parameters": [
          {
            "name": "event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Event Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClipInfoResponse"
                }
              }
            }
          },
          "404": {
            "description": "Event not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events/{event_id}/clip/generate": {
      "post": {
        "tags": ["events"],
        "summary": "Generate Event Clip",
        "description": "Trigger video clip generation for an event.\n\nIf a clip already exists and force=False, returns the existing clip info.\nIf force=True, regenerates the clip even if one exists.\n\nClip generation uses detection images to create a video sequence, or\nextracts from existing video if available.\n\nArgs:\n    event_id: Event ID\n    request: Clip generation parameters\n    db: Database session\n\nReturns:\n    ClipGenerateResponse with generation status and clip info\n\nRaises:\n    HTTPException: 404 if event not found\n    HTTPException: 400 if event has no detections to generate clip from",
        "operationId": "generate_event_clip_api_events__event_id__clip_generate_post",
        "parameters": [
          {
            "name": "event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Event Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClipGenerateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClipGenerateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Cannot generate clip (no detections or images)"
          },
          "404": {
            "description": "Event not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events/analyze/{batch_id}/stream": {
      "get": {
        "tags": ["events"],
        "summary": "Analyze Batch Streaming",
        "description": "Stream LLM analysis progress for a batch via Server-Sent Events (NEM-1665).\n\nThis endpoint provides progressive LLM response updates during long inference\ntimes, allowing the frontend to display partial results and show typing\nindicators while the analysis is in progress.\n\nEvent Types:\n- progress: Partial LLM response chunk with accumulated_text\n- complete: Final event with risk assessment and event_id\n- error: Error information with error_code and recoverable flag\n\nArgs:\n    batch_id: Batch identifier to analyze\n    camera_id: Optional camera ID (uses Redis lookup if not provided)\n    detection_ids: Optional comma-separated detection IDs\n\nReturns:\n    StreamingResponse with SSE event stream (text/event-stream)\n\nExample SSE output:\n    data: {\"event_type\": \"progress\", \"content\": \"Based on\", \"accumulated_text\": \"Based on\"}\n\n    data: {\"event_type\": \"progress\", \"content\": \" the\", \"accumulated_text\": \"Based on the\"}\n\n    data: {\"event_type\": \"complete\", \"event_id\": 123, \"risk_score\": 75, ...}",
        "operationId": "analyze_batch_streaming_api_events_analyze__batch_id__stream_get",
        "parameters": [
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Batch Id"
            }
          },
          {
            "name": "camera_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Camera ID for the batch",
              "title": "Camera Id"
            },
            "description": "Camera ID for the batch"
          },
          {
            "name": "detection_ids",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated detection IDs (optional)",
              "title": "Detection Ids"
            },
            "description": "Comma-separated detection IDs (optional)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/events/bulk": {
      "post": {
        "tags": ["events"],
        "summary": "Bulk create events",
        "description": "Create multiple events in a single request.\n\nSupports partial success - some events may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk create request with up to 100 events\n    db: Database session\n\nReturns:\n    EventBulkCreateResponse with per-item results",
        "operationId": "bulk_create_events_api_events_bulk_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventBulkCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "description": "Multi-status response with per-item results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventBulkCreateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        }
      },
      "delete": {
        "tags": ["events"],
        "summary": "Bulk delete events",
        "description": "Delete multiple events in a single request.\n\nSupports partial success - some deletions may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nBy default uses soft delete (sets deleted_at timestamp). Use soft_delete=false\nfor permanent deletion.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk delete request with up to 100 event IDs\n    db: Database session\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "bulk_delete_events_api_events_bulk_delete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventBulkDeleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "description": "Multi-status response with per-item results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        }
      },
      "patch": {
        "tags": ["events"],
        "summary": "Bulk update events",
        "description": "Update multiple events in a single request.\n\nSupports partial success - some updates may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Consider implementing RateLimitTier.BULK for production use.\n\nArgs:\n    request: Bulk update request with up to 100 event updates\n    db: Database session\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "bulk_update_events_api_events_bulk_patch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventBulkUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "description": "Multi-status response with per-item results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          }
        }
      }
    },
    "/api/logs": {
      "get": {
        "tags": ["logs"],
        "summary": "List Logs",
        "description": "List logs with optional filtering and cursor-based pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\nArgs:\n    level: Optional log level to filter by (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    component: Optional component name to filter by\n    camera_id: Optional camera ID to filter by\n    source: Optional source to filter by (backend, frontend)\n    search: Optional search term for message text\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    limit: Maximum number of results to return (1-1000, default 100)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    db: Database session\n\nReturns:\n    LogsResponse containing filtered logs and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid",
        "operationId": "list_logs_api_logs_get",
        "parameters": [
          {
            "name": "level",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by log level",
              "title": "Level"
            },
            "description": "Filter by log level"
          },
          {
            "name": "component",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by component name",
              "title": "Component"
            },
            "description": "Filter by component name"
          },
          {
            "name": "camera_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            },
            "description": "Filter by camera ID"
          },
          {
            "name": "source",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by source (backend, frontend)",
              "title": "Source"
            },
            "description": "Filter by source (backend, frontend)"
          },
          {
            "name": "search",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Search in message text",
              "title": "Search"
            },
            "description": "Search in message text"
          },
          {
            "name": "start_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter from date (ISO format)",
              "title": "Start Date"
            },
            "description": "Filter from date (ISO format)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter to date (ISO format)",
              "title": "End Date"
            },
            "description": "Filter to date (ISO format)"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "description": "Page size",
              "default": 100,
              "title": "Limit"
            },
            "description": "Page size"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of results to skip (deprecated, use cursor)"
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            },
            "description": "Pagination cursor from previous response"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid date range or cursor"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/logs/stats": {
      "get": {
        "tags": ["logs"],
        "summary": "Get Log Stats",
        "description": "Get log statistics for dashboard.\n\nOptimized to use a single aggregation query with conditional counting\ninstead of 5 separate queries. This reduces database round-trips and\nimproves performance for high-volume log tables.",
        "operationId": "get_log_stats_api_logs_stats_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogStats"
                }
              }
            }
          },
          "400": {
            "description": "Invalid date range"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/logs/{log_id}": {
      "get": {
        "tags": ["logs"],
        "summary": "Get Log",
        "description": "Get a single log entry by ID.",
        "operationId": "get_log_api_logs__log_id__get",
        "parameters": [
          {
            "name": "log_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Log Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogEntry"
                }
              }
            }
          },
          "404": {
            "description": "Log entry not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/logs/frontend": {
      "post": {
        "tags": ["logs"],
        "summary": "Create Frontend Log",
        "description": "Receive and store a log from the frontend.",
        "operationId": "create_frontend_log_api_logs_frontend_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FrontendLogCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object",
                  "title": "Response Create Frontend Log Api Logs Frontend Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/media/{path}": {
      "get": {
        "tags": ["media"],
        "summary": "Serve Media Compat",
        "description": "Compatibility route: serve media via design-spec-style /api/media/{path}.\n\nThis preserves the stricter behavior of the new routes:\n- Path traversal protection\n- Allowed file type allowlist\n- Must remain under configured base directories\n\nMapping rules:\n- `cameras/<camera_id>/<filename...>` \u2192 camera media\n- `thumbnails/<filename>` \u2192 thumbnails\n- `detections/<id>` \u2192 detection images",
        "operationId": "serve_media_compat_api_media__path__get",
        "parameters": [
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Path"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File served successfully"
          },
          "403": {
            "description": "Access denied",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Too many requests"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/media/cameras/{camera_id}/{filename}": {
      "get": {
        "tags": ["media"],
        "summary": "Serve Camera File",
        "description": "Serve camera images or videos from Foscam storage.\n\nArgs:\n    camera_id: The camera identifier (directory name)\n    filename: The file to serve (can include subdirectories)\n\nReturns:\n    FileResponse with appropriate content-type header\n\nRaises:\n    HTTPException: 403 for invalid paths, 404 for missing files",
        "operationId": "serve_camera_file_api_media_cameras__camera_id___filename__get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          },
          {
            "name": "filename",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Filename"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File served successfully"
          },
          "403": {
            "description": "Access denied",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Too many requests"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/media/thumbnails/{filename}": {
      "get": {
        "tags": ["media"],
        "summary": "Serve Thumbnail",
        "description": "Serve detection thumbnail images.\n\nArgs:\n    filename: The thumbnail filename\n\nReturns:\n    FileResponse with appropriate content-type header\n\nRaises:\n    HTTPException: 403 for invalid paths, 404 for missing files",
        "operationId": "serve_thumbnail_api_media_thumbnails__filename__get",
        "parameters": [
          {
            "name": "filename",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Filename"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Thumbnail served successfully"
          },
          "403": {
            "description": "Access denied",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Too many requests"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/media/clips/{filename}": {
      "get": {
        "tags": ["media"],
        "summary": "Serve Clip",
        "description": "Serve event video clips.\n\nClips are generated by the ClipGenerator service and stored in the\nconfigured clips directory.\n\nArgs:\n    filename: The clip filename (e.g., \"123_clip.mp4\")\n\nReturns:\n    FileResponse with appropriate content-type header\n\nRaises:\n    HTTPException: 403 for invalid paths, 404 for missing files",
        "operationId": "serve_clip_api_media_clips__filename__get",
        "parameters": [
          {
            "name": "filename",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Filename"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Clip served successfully"
          },
          "403": {
            "description": "Access denied",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Too many requests"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/metrics": {
      "get": {
        "tags": ["metrics"],
        "summary": "Metrics",
        "description": "Return Prometheus metrics in exposition format.\n\nThis endpoint returns all registered metrics in the standard\nPrometheus exposition format for scraping.\n\nReturns:\n    Response with text/plain content type containing metrics",
        "operationId": "metrics_api_metrics_get",
        "responses": {
          "200": {
            "description": "Prometheus metrics in exposition format",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/notification/config": {
      "get": {
        "tags": ["notification"],
        "summary": "Get Notification Config",
        "description": "Get notification configuration status.\n\nReturns the current notification configuration including:\n- Whether notifications are enabled\n- Which channels are configured (email, webhook, push)\n- SMTP host and port (if configured)\n- Default webhook URL (if configured)\n- Default email recipients\n\nNote: Sensitive fields like SMTP password are NOT returned.\n\nReturns:\n    NotificationConfigResponse with current notification settings",
        "operationId": "get_notification_config_api_notification_config_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationConfigResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/notification/test": {
      "post": {
        "tags": ["notification"],
        "summary": "Test Notification",
        "description": "Test notification delivery for a specific channel.\n\nSends a test notification to verify the configuration is working.\nFor email, sends a test email to the specified recipients or default recipients.\nFor webhook, sends a test payload to the specified URL or default URL.\n\nArgs:\n    test_request: Test notification request with channel and optional overrides\n\nReturns:\n    TestNotificationResponse with test result",
        "operationId": "test_notification_api_notification_test_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookTestNotificationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestNotificationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/notification-preferences/": {
      "get": {
        "tags": ["notification-preferences"],
        "summary": "Get Notification Preferences",
        "description": "Get global notification preferences.\n\nReturns the global notification settings including:\n- Whether notifications are enabled\n- Notification sound selection\n- Risk level filters (which risk levels trigger notifications)\n\nReturns:\n    NotificationPreferencesResponse with current preferences",
        "operationId": "get_notification_preferences_api_notification_preferences__get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationPreferencesResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      },
      "put": {
        "tags": ["notification-preferences"],
        "summary": "Update Notification Preferences",
        "description": "Update global notification preferences.\n\nArgs:\n    update: Preferences update data\n\nReturns:\n    NotificationPreferencesResponse with updated preferences\n\nRaises:\n    HTTPException: 400 if sound value is invalid",
        "operationId": "update_notification_preferences_api_notification_preferences__put",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NotificationPreferencesUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationPreferencesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Invalid sound or risk level value"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/notification-preferences/cameras": {
      "get": {
        "tags": ["notification-preferences"],
        "summary": "Get All Camera Settings",
        "description": "Get all camera notification settings.\n\nReturns:\n    CameraNotificationSettingsListResponse with all camera settings",
        "operationId": "get_all_camera_settings_api_notification_preferences_cameras_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraNotificationSettingsListResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/notification-preferences/cameras/{camera_id}": {
      "get": {
        "tags": ["notification-preferences"],
        "summary": "Get Camera Setting",
        "description": "Get notification setting for a specific camera.\n\nArgs:\n    camera_id: Camera ID\n\nReturns:\n    CameraNotificationSettingResponse for the camera\n\nRaises:\n    HTTPException: 404 if setting not found",
        "operationId": "get_camera_setting_api_notification_preferences_cameras__camera_id__get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraNotificationSettingResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera notification setting not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["notification-preferences"],
        "summary": "Update Camera Setting",
        "description": "Update or create notification setting for a camera.\n\nArgs:\n    camera_id: Camera ID\n    update: Setting update data\n\nReturns:\n    CameraNotificationSettingResponse with updated setting\n\nRaises:\n    HTTPException: 404 if camera doesn't exist",
        "operationId": "update_camera_setting_api_notification_preferences_cameras__camera_id__put",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraNotificationSettingUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraNotificationSettingResponse"
                }
              }
            }
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/notification-preferences/quiet-hours": {
      "get": {
        "tags": ["notification-preferences"],
        "summary": "Get Quiet Hours",
        "description": "Get all quiet hours periods.\n\nReturns:\n    QuietHoursPeriodsListResponse with all quiet periods",
        "operationId": "get_quiet_hours_api_notification_preferences_quiet_hours_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuietHoursPeriodsListResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      },
      "post": {
        "tags": ["notification-preferences"],
        "summary": "Create Quiet Hours Period",
        "description": "Create a new quiet hours period.\n\nArgs:\n    period: Quiet hours period data\n\nReturns:\n    QuietHoursPeriodResponse with created period\n\nRaises:\n    HTTPException: 400 if time range is invalid",
        "operationId": "create_quiet_hours_period_api_notification_preferences_quiet_hours_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QuietHoursPeriodCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuietHoursPeriodResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Invalid time range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/notification-preferences/quiet-hours/{period_id}": {
      "delete": {
        "tags": ["notification-preferences"],
        "summary": "Delete Quiet Hours Period",
        "description": "Delete a quiet hours period.\n\nArgs:\n    period_id: Period UUID\n\nRaises:\n    HTTPException: 404 if period not found",
        "operationId": "delete_quiet_hours_period_api_notification_preferences_quiet_hours__period_id__delete",
        "parameters": [
          {
            "name": "period_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Period Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "404": {
            "description": "Quiet hours period not found"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/rum": {
      "post": {
        "tags": ["rum"],
        "summary": "Ingest RUM metrics",
        "description": "Receive Core Web Vitals metrics from the frontend for Real User Monitoring.",
        "operationId": "ingest_rum_metrics_api_rum_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RUMBatchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RUMIngestResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/system/services": {
      "get": {
        "tags": ["services"],
        "summary": "List Services",
        "description": "Get status of all managed services.\n\nArgs:\n    category: Optional filter by category (infrastructure, ai, monitoring)\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    List of services with status and category summaries.",
        "operationId": "list_services_api_system_services_get",
        "parameters": [
          {
            "name": "category",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ServiceCategory"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Category"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServicesResponse"
                }
              }
            }
          },
          "503": {
            "description": "Container orchestrator not available"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/services/{name}/restart": {
      "post": {
        "tags": ["services"],
        "summary": "Restart Service",
        "description": "Manually restart a service.\n\nResets failure count (manual restart is intentional).\n\nArgs:\n    name: Service name to restart\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found, 400 if service is disabled",
        "operationId": "restart_service_api_system_services__name__restart_post",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Service is disabled"
          },
          "404": {
            "description": "Service not found"
          },
          "503": {
            "description": "Container orchestrator not available"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/services/{name}/enable": {
      "post": {
        "tags": ["services"],
        "summary": "Enable Service",
        "description": "Re-enable a disabled service.\n\nResets failure count and allows self-healing to resume.\n\nArgs:\n    name: Service name to enable\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found",
        "operationId": "enable_service_api_system_services__name__enable_post",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Service not found"
          },
          "503": {
            "description": "Container orchestrator not available"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/services/{name}/disable": {
      "post": {
        "tags": ["services"],
        "summary": "Disable Service",
        "description": "Manually disable a service.\n\nPrevents self-healing restarts.\n\nArgs:\n    name: Service name to disable\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found",
        "operationId": "disable_service_api_system_services__name__disable_post",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Service not found"
          },
          "503": {
            "description": "Container orchestrator not available"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/services/{name}/start": {
      "post": {
        "tags": ["services"],
        "summary": "Start Service",
        "description": "Start a stopped service container.\n\nArgs:\n    name: Service name to start\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found,\n                   400 if service is already running or disabled",
        "operationId": "start_service_api_system_services__name__start_post",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Service already running or disabled"
          },
          "404": {
            "description": "Service not found"
          },
          "503": {
            "description": "Container orchestrator not available"
          },
          "500": {
            "description": "Internal server error"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/health": {
      "get": {
        "tags": ["system"],
        "summary": "Get System Health Status",
        "description": "Comprehensive health check of all system components including database, Redis, and AI services.",
        "operationId": "get_health_api_system_health_get",
        "responses": {
          "200": {
            "description": "System is healthy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthResponse"
                }
              }
            }
          },
          "503": {
            "description": "System is degraded or unhealthy"
          }
        }
      }
    },
    "/api/system/health/ready": {
      "get": {
        "tags": ["system"],
        "summary": "Get Readiness Status",
        "description": "Kubernetes-style readiness probe indicating if the application can receive traffic and process requests.",
        "operationId": "get_readiness_api_system_health_ready_get",
        "responses": {
          "200": {
            "description": "System is ready to receive traffic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReadinessResponse"
                }
              }
            }
          },
          "503": {
            "description": "System is not ready (degraded or critical services down)"
          }
        }
      }
    },
    "/api/system/health/websocket": {
      "get": {
        "tags": ["system"],
        "summary": "Get WebSocket Health Status",
        "description": "Health status of WebSocket broadcasters and their circuit breakers for real-time event distribution.",
        "operationId": "get_websocket_health_api_system_health_websocket_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketHealthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/gpu": {
      "get": {
        "tags": ["system"],
        "summary": "Get Current GPU Statistics",
        "description": "Latest GPU metrics including utilization, memory usage, temperature, and inference performance.",
        "operationId": "get_gpu_stats_api_system_gpu_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GPUStatsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/gpu/history": {
      "get": {
        "tags": ["system"],
        "summary": "Get GPU Statistics History",
        "description": "Time-series GPU metrics for charting historical utilization, memory, and temperature trends.",
        "operationId": "get_gpu_stats_history_api_system_gpu_history_get",
        "parameters": [
          {
            "name": "since",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional lower bound for recorded_at (ISO datetime). If not provided, returns the most recent samples.",
              "title": "Since"
            },
            "description": "Optional lower bound for recorded_at (ISO datetime). If not provided, returns the most recent samples."
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 5000,
              "minimum": 1,
              "description": "Maximum number of samples to return (1-5000, default 300)",
              "default": 300,
              "title": "Limit"
            },
            "description": "Maximum number of samples to return (1-5000, default 300)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GPUStatsHistoryResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/config": {
      "get": {
        "tags": ["system"],
        "summary": "Get System Configuration",
        "description": "Public configuration settings including retention period, batch processing, and detection thresholds.",
        "operationId": "get_config_api_system_config_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": ["system"],
        "summary": "Update System Configuration",
        "description": "Partially update processing-related configuration. Requires API key authentication.",
        "operationId": "patch_config_api_system_config_patch",
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfigUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Configuration updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/system/anomaly-config": {
      "get": {
        "tags": ["system"],
        "summary": "Get Anomaly Detection Configuration",
        "description": "Current settings for baseline anomaly detection including thresholds and window parameters.",
        "operationId": "get_anomaly_config_api_system_anomaly_config_get",
        "responses": {
          "200": {
            "description": "Anomaly configuration retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnomalyConfig"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      },
      "patch": {
        "tags": ["system"],
        "summary": "Update Anomaly Detection Configuration",
        "description": "Update anomaly detection thresholds and parameters. Requires API key authentication.",
        "operationId": "update_anomaly_config_api_system_anomaly_config_patch",
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AnomalyConfigUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anomaly configuration updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnomalyConfig"
                }
              }
            }
          },
          "400": {
            "description": "Invalid configuration values"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/system/stats": {
      "get": {
        "tags": ["system"],
        "summary": "Get System Statistics",
        "description": "Aggregate statistics including camera count, event count, detection count, and application uptime.",
        "operationId": "get_stats_api_system_stats_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SystemStatsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/telemetry": {
      "get": {
        "tags": ["system"],
        "summary": "Get Pipeline Telemetry",
        "description": "Real-time metrics for AI pipeline monitoring including queue depths and stage latencies.",
        "operationId": "get_telemetry_api_system_telemetry_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TelemetryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/pipeline-latency": {
      "get": {
        "tags": ["system"],
        "summary": "Get Pipeline Latency Metrics",
        "description": "Latency statistics with percentiles for each stage transition in the AI processing pipeline.",
        "operationId": "get_pipeline_latency_api_system_pipeline_latency_get",
        "parameters": [
          {
            "name": "window_minutes",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1440,
              "minimum": 1,
              "description": "Time window for statistics calculation in minutes (1-1440, default 60)",
              "default": 60,
              "title": "Window Minutes"
            },
            "description": "Time window for statistics calculation in minutes (1-1440, default 60)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineLatencyResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/pipeline-latency/history": {
      "get": {
        "tags": ["system"],
        "summary": "Get Pipeline Latency History",
        "description": "Time-series latency data grouped into buckets for charting pipeline performance trends.",
        "operationId": "get_pipeline_latency_history_api_system_pipeline_latency_history_get",
        "parameters": [
          {
            "name": "since",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1440,
              "minimum": 1,
              "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
              "default": 60,
              "title": "Since"
            },
            "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)"
          },
          {
            "name": "bucket_seconds",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 3600,
              "minimum": 10,
              "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
              "default": 60,
              "title": "Bucket Seconds"
            },
            "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineLatencyHistoryResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/cleanup": {
      "post": {
        "tags": ["system"],
        "summary": "Trigger Data Cleanup",
        "description": "Manually trigger cleanup of old data based on retention settings. Requires API key authentication.",
        "operationId": "trigger_cleanup_api_system_cleanup_post",
        "parameters": [
          {
            "name": "dry_run",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If True, calculate and return what would be deleted without actually performing the deletion",
              "default": false,
              "title": "Dry Run"
            },
            "description": "If True, calculate and return what would be deleted without actually performing the deletion"
          },
          {
            "name": "x-api-key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Cleanup completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "500": {
            "description": "Cleanup operation failed"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/severity": {
      "get": {
        "tags": ["system"],
        "summary": "Get Severity Metadata",
        "description": "Severity level definitions, risk score thresholds, and color codes for UI display.",
        "operationId": "get_severity_metadata_api_system_severity_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeverityMetadataResponse"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["system"],
        "summary": "Update Severity Thresholds",
        "description": "Update risk score thresholds for severity level classification. Requires API key authentication.",
        "operationId": "update_severity_thresholds_api_system_severity_put",
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeverityThresholdsUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Severity thresholds updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeverityMetadataResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid threshold values (not strictly ordered)"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          }
        }
      }
    },
    "/api/system/storage": {
      "get": {
        "tags": ["system"],
        "summary": "Get Storage Statistics",
        "description": "Disk usage, storage breakdown by category, and database record counts for capacity planning.",
        "operationId": "get_storage_stats_api_system_storage_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageStatsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/circuit-breakers": {
      "get": {
        "tags": ["system"],
        "summary": "Get Circuit Breakers Status",
        "description": "Current state and metrics for all circuit breakers protecting external services from cascading failures.",
        "operationId": "get_circuit_breakers_api_system_circuit_breakers_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CircuitBreakersResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/circuit-breakers/{name}/reset": {
      "post": {
        "tags": ["system"],
        "summary": "Reset Circuit Breaker",
        "description": "Manually reset a circuit breaker to CLOSED state for recovery from transient failures. Requires API key authentication.",
        "operationId": "reset_circuit_breaker_api_system_circuit_breakers__name__reset_post",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Circuit breaker reset successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CircuitBreakerResetResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid circuit breaker name"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "404": {
            "description": "Circuit breaker not found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/cleanup/status": {
      "get": {
        "tags": ["system"],
        "summary": "Get Cleanup Service Status",
        "description": "Current status of the automated cleanup service including retention settings and next scheduled run.",
        "operationId": "get_cleanup_status_api_system_cleanup_status_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupStatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/pipeline": {
      "get": {
        "tags": ["system"],
        "summary": "Get Pipeline Status",
        "description": "Combined status of all AI pipeline operations including FileWatcher, BatchAggregator, and DegradationManager.",
        "operationId": "get_pipeline_status_api_system_pipeline_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineStatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/models": {
      "get": {
        "tags": ["system"],
        "summary": "Get Model Zoo Registry",
        "description": "Get the current status of all models in the Model Zoo.\n\nReturns comprehensive information about all AI models available in the system,\nincluding their VRAM requirements, loading status, and configuration.\n\n**VRAM Budget**: The Model Zoo has a dedicated VRAM budget of 1650 MB,\nseparate from the RT-DETRv2 detector and Nemotron LLM allocations.\n\n**Loading Strategy**: Models are loaded sequentially (one at a time) to\nprevent VRAM fragmentation and ensure stable operation.\n\n**Model Categories**:\n- detection: Object detection models (YOLO variants)\n- recognition: Face and license plate recognition\n- ocr: Optical character recognition\n- embedding: Visual embedding models (CLIP)\n- depth-estimation: Depth estimation models\n- pose: Human pose estimation\n\nReturns:\n    ModelRegistryResponse with VRAM stats and all model statuses",
        "operationId": "get_models_api_system_models_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelRegistryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/models/{model_name}": {
      "get": {
        "tags": ["system"],
        "summary": "Get Model Status",
        "description": "Get detailed status information for a specific model.\n\nArgs:\n    model_name: Unique identifier of the model (e.g., 'yolo11-license-plate')\n\nReturns:\n    ModelStatusResponse with detailed model information\n\nRaises:\n    HTTPException: 404 if model not found in registry",
        "operationId": "get_model_api_system_models__model_name__get",
        "parameters": [
          {
            "name": "model_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Model Name"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelStatusResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/model-zoo/status": {
      "get": {
        "tags": ["system"],
        "summary": "Get Model Zoo Status",
        "description": "Get status information for all Model Zoo models.\n\nReturns status information for all 18 Model Zoo models, including:\n- Current status (loaded, unloaded, disabled)\n- VRAM usage when loaded\n- Last usage timestamp\n- Category grouping for UI display\n\nThis endpoint is optimized for the compact status card display\nin the AI Performance page.\n\nReturns:\n    ModelZooStatusResponse with all model statuses",
        "operationId": "get_model_zoo_status_api_system_model_zoo_status_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelZooStatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/model-zoo/latency/history": {
      "get": {
        "tags": ["system"],
        "summary": "Get Model Zoo Latency History",
        "description": "Get latency history for a specific Model Zoo model.\n\nReturns time-series latency data for the dropdown-controlled chart.\nEach bucket contains aggregated statistics (avg, p50, p95).\n\nArgs:\n    model: Model name to get history for\n    since: Number of minutes of history to return (default 60)\n    bucket_seconds: Size of each time bucket in seconds (default 60)\n\nReturns:\n    ModelLatencyHistoryResponse with chronologically ordered snapshots\n\nRaises:\n    HTTPException: 404 if model not found in registry",
        "operationId": "get_model_zoo_latency_history_api_system_model_zoo_latency_history_get",
        "parameters": [
          {
            "name": "model",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Model name to get latency history for (e.g., 'yolo11-license-plate')",
              "title": "Model"
            },
            "description": "Model name to get latency history for (e.g., 'yolo11-license-plate')"
          },
          {
            "name": "since",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1440,
              "minimum": 1,
              "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
              "default": 60,
              "title": "Since"
            },
            "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)"
          },
          {
            "name": "bucket_seconds",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 3600,
              "minimum": 10,
              "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
              "default": 60,
              "title": "Bucket Seconds"
            },
            "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelLatencyHistoryResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/system/health/full": {
      "get": {
        "tags": ["system"],
        "summary": "Get Full System Health Status",
        "description": "Get comprehensive health status for all system components.",
        "operationId": "get_full_health_api_system_health_full_get",
        "responses": {
          "200": {
            "description": "System is healthy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FullHealthResponse"
                }
              }
            }
          },
          "503": {
            "description": "One or more critical services are unhealthy"
          }
        }
      }
    },
    "/api/cameras/{camera_id}/zones": {
      "get": {
        "tags": ["zones"],
        "summary": "List Zones",
        "description": "List all zones for a camera with optional filtering.\n\nArgs:\n    camera_id: ID of the camera\n    enabled: Optional filter for enabled/disabled zones\n    db: Database session\n\nReturns:\n    ZoneListResponse containing list of zones and total count",
        "operationId": "list_zones_api_cameras__camera_id__zones_get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          },
          {
            "name": "enabled",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by enabled status",
              "title": "Enabled"
            },
            "description": "Filter by enabled status"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["zones"],
        "summary": "Create Zone",
        "description": "Create a new zone for a camera.\n\nArgs:\n    camera_id: ID of the camera\n    zone_data: Zone creation data\n    db: Database session\n\nReturns:\n    Created zone object with generated ID",
        "operationId": "create_zone_api_cameras__camera_id__zones_post",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZoneCreate"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/api/cameras/{camera_id}/zones/{zone_id}": {
      "get": {
        "tags": ["zones"],
        "summary": "Get Zone",
        "description": "Get a specific zone by ID.\n\nArgs:\n    camera_id: ID of the camera\n    zone_id: ID of the zone\n    db: Database session\n\nReturns:\n    Zone object\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "get_zone_api_cameras__camera_id__zones__zone_id__get",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          },
          {
            "name": "zone_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Zone Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["zones"],
        "summary": "Update Zone",
        "description": "Update an existing zone.\n\nArgs:\n    camera_id: ID of the camera\n    zone_id: ID of the zone to update\n    zone_data: Zone update data (all fields optional)\n    db: Database session\n\nReturns:\n    Updated zone object\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "update_zone_api_cameras__camera_id__zones__zone_id__put",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          },
          {
            "name": "zone_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Zone Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZoneUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["zones"],
        "summary": "Delete Zone",
        "description": "Delete a zone.\n\nArgs:\n    camera_id: ID of the camera\n    zone_id: ID of the zone to delete\n    db: Database session\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "delete_zone_api_cameras__camera_id__zones__zone_id__delete",
        "parameters": [
          {
            "name": "camera_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Camera Id"
            }
          },
          {
            "name": "zone_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Zone Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/": {
      "get": {
        "summary": "Root",
        "description": "Health check endpoint.",
        "operationId": "root__get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object",
                  "title": "Response Root  Get"
                }
              }
            }
          }
        }
      }
    },
    "/health": {
      "get": {
        "summary": "Health",
        "description": "Simple liveness health check endpoint (canonical liveness probe).\n\nThis endpoint indicates whether the process is running and able to\nrespond to HTTP requests. It always returns 200 with status \"alive\"\nif the process is up.\n\nThis is the canonical liveness probe endpoint. Use this for:\n- Docker HEALTHCHECK liveness checks\n- Kubernetes liveness probes\n- Simple \"is the server up?\" monitoring\n\nFor detailed health information, use:\n- GET /api/system/health - Detailed health check with service status\n- GET /ready - Readiness probe (checks dependencies)\n\nReturns:\n    LivenessResponse with status \"alive\".",
        "operationId": "health_health_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object",
                  "title": "Response Health Health Get"
                }
              }
            }
          }
        }
      }
    },
    "/ready": {
      "get": {
        "summary": "Ready",
        "description": "Simple readiness health check endpoint (canonical readiness probe).\n\nThis endpoint indicates whether the application is ready to receive\ntraffic and process requests. It checks critical dependencies:\n- Database connectivity\n- Redis connectivity\n- Critical pipeline workers\n\nThis is the canonical readiness probe endpoint. Use this for:\n- Docker HEALTHCHECK readiness checks\n- Kubernetes readiness probes\n- Load balancer health checks\n\nFor detailed readiness information with service breakdown, use:\n- GET /api/system/health/ready - Full readiness response with details\n\nReturns:\n    SimpleReadinessResponse with ready bool and status. HTTP 200 if ready, 503 if not.",
        "operationId": "ready_ready_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AIServiceHealthStatus": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Service identifier (e.g., 'rtdetr', 'nemotron')"
          },
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "Human-readable service name"
          },
          "status": {
            "$ref": "#/components/schemas/ServiceHealthState",
            "description": "Current health state"
          },
          "url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Url",
            "description": "Service URL if configured"
          },
          "response_time_ms": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Response Time Ms",
            "description": "Health check response time in milliseconds"
          },
          "circuit_state": {
            "$ref": "#/components/schemas/CircuitState",
            "description": "Circuit breaker state",
            "default": "closed"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Error message if unhealthy"
          },
          "last_check": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Check",
            "description": "Timestamp of last health check"
          }
        },
        "type": "object",
        "required": ["name", "display_name", "status"],
        "title": "AIServiceHealthStatus",
        "description": "Health status for an AI service.\n\nIncludes service identification, health state, circuit breaker state,\nand response time metrics.",
        "example": {
          "circuit_state": "closed",
          "display_name": "RT-DETRv2 Object Detection",
          "last_check": "2026-01-08T10:30:00Z",
          "name": "rtdetr",
          "response_time_ms": 45.2,
          "status": "healthy",
          "url": "http://ai-detector:8090"
        }
      },
      "ActivityBaselineEntry": {
        "properties": {
          "hour": {
            "type": "integer",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Hour",
            "description": "Hour of day (0-23)"
          },
          "day_of_week": {
            "type": "integer",
            "maximum": 6.0,
            "minimum": 0.0,
            "title": "Day Of Week",
            "description": "Day of week (0=Monday, 6=Sunday)"
          },
          "avg_count": {
            "type": "number",
            "minimum": 0.0,
            "title": "Avg Count",
            "description": "Average activity count for this time slot"
          },
          "sample_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Sample Count",
            "description": "Number of samples used to calculate this average"
          },
          "is_peak": {
            "type": "boolean",
            "title": "Is Peak",
            "description": "Whether this time slot has above-average activity",
            "default": false
          }
        },
        "type": "object",
        "required": ["hour", "day_of_week", "avg_count", "sample_count"],
        "title": "ActivityBaselineEntry",
        "description": "A single activity baseline entry for a specific hour and day combination.\n\nThis represents one cell in the 24x7 activity heatmap (168 total entries).",
        "example": {
          "avg_count": 5.2,
          "day_of_week": 0,
          "hour": 17,
          "is_peak": true,
          "sample_count": 30
        }
      },
      "ActivityBaselineResponse": {
        "properties": {
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "entries": {
            "items": {
              "$ref": "#/components/schemas/ActivityBaselineEntry"
            },
            "type": "array",
            "title": "Entries",
            "description": "Activity baseline entries (up to 168 = 24h x 7 days)"
          },
          "total_samples": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Samples",
            "description": "Total number of samples across all entries"
          },
          "peak_hour": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 23.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Peak Hour",
            "description": "Hour with highest average activity (0-23)"
          },
          "peak_day": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 6.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Peak Day",
            "description": "Day with highest average activity (0=Monday, 6=Sunday)"
          },
          "learning_complete": {
            "type": "boolean",
            "title": "Learning Complete",
            "description": "Whether baseline has sufficient samples for reliable anomaly detection",
            "default": false
          },
          "min_samples_required": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Min Samples Required",
            "description": "Minimum samples required per time slot for learning completion",
            "default": 10
          }
        },
        "type": "object",
        "required": ["camera_id", "total_samples"],
        "title": "ActivityBaselineResponse",
        "description": "Response for camera activity baseline endpoint.\n\nContains 168 entries (24 hours x 7 days) representing the full weekly\nactivity heatmap for a camera.",
        "example": {
          "camera_id": "front_door",
          "entries": [
            {
              "avg_count": 0.5,
              "day_of_week": 0,
              "hour": 0,
              "is_peak": false,
              "sample_count": 30
            },
            {
              "avg_count": 5.2,
              "day_of_week": 4,
              "hour": 17,
              "is_peak": true,
              "sample_count": 30
            }
          ],
          "learning_complete": true,
          "min_samples_required": 10,
          "peak_day": 4,
          "peak_hour": 17,
          "total_samples": 720
        }
      },
      "AlertRuleConditions": {
        "properties": {
          "risk_threshold": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Threshold",
            "description": "Minimum risk score to trigger alert"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Types",
            "description": "Object types that trigger alerts (e.g., person, vehicle)"
          },
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Camera Ids",
            "description": "Specific camera IDs that trigger alerts"
          },
          "time_ranges": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Time Ranges",
            "description": "Time ranges when alerts are active (start/end in HH:MM format)"
          }
        },
        "type": "object",
        "title": "AlertRuleConditions",
        "description": "Schema for legacy alert rule conditions (backward compatibility).\n\nNew rules should use explicit fields on AlertRuleCreate/AlertRuleUpdate.\nThis schema is kept for backward compatibility with existing rules.",
        "example": {
          "camera_ids": ["front_door", "backyard"],
          "object_types": ["person", "vehicle"],
          "risk_threshold": 70,
          "time_ranges": [
            {
              "end": "06:00",
              "start": "22:00"
            }
          ]
        }
      },
      "AlertRuleCreate": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "description": "Rule name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Rule description"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the rule is active",
            "default": true
          },
          "severity": {
            "$ref": "#/components/schemas/AlertSeverity",
            "description": "Severity level for triggered alerts",
            "default": "medium"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Threshold",
            "description": "Alert when risk_score >= threshold"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Types",
            "description": "Object types to match (e.g., ['person', 'vehicle'])"
          },
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Camera Ids",
            "description": "Camera IDs to apply rule to (empty = all cameras)"
          },
          "zone_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Zone Ids",
            "description": "Zone IDs to match (empty = any zone)"
          },
          "min_confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Confidence",
            "description": "Minimum detection confidence (0.0-1.0)"
          },
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleSchedule"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based conditions (null = always active)"
          },
          "conditions": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleConditions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Legacy conditions (use explicit fields instead)"
          },
          "dedup_key_template": {
            "type": "string",
            "maxLength": 255,
            "title": "Dedup Key Template",
            "description": "Template for dedup key. Variables: {camera_id}, {rule_id}, {object_type}",
            "default": "{camera_id}:{rule_id}"
          },
          "cooldown_seconds": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Cooldown Seconds",
            "description": "Minimum seconds between duplicate alerts",
            "default": 300
          },
          "channels": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Channels",
            "description": "Notification channels for this rule"
          }
        },
        "type": "object",
        "required": ["name"],
        "title": "AlertRuleCreate",
        "description": "Schema for creating an alert rule.\n\nAll conditions use AND logic - all specified conditions must match for the rule to trigger.\nLeave a condition as null/empty to not filter on that criterion.",
        "example": {
          "camera_ids": ["front_door", "backyard"],
          "channels": ["pushover", "webhook"],
          "cooldown_seconds": 300,
          "dedup_key_template": "{camera_id}:{rule_id}",
          "description": "High-priority alert for person detection at night",
          "enabled": true,
          "min_confidence": 0.8,
          "name": "Night Intruder Alert",
          "object_types": ["person"],
          "risk_threshold": 70,
          "schedule": {
            "days": ["monday", "tuesday", "wednesday", "thursday", "friday"],
            "end_time": "06:00",
            "start_time": "22:00",
            "timezone": "America/New_York"
          },
          "severity": "critical"
        }
      },
      "AlertRuleListResponse": {
        "properties": {
          "rules": {
            "items": {
              "$ref": "#/components/schemas/AlertRuleResponse"
            },
            "type": "array",
            "title": "Rules",
            "description": "List of alert rules"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Total number of rules"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Maximum number of results returned"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Number of results skipped"
          }
        },
        "type": "object",
        "required": ["rules", "count", "limit", "offset"],
        "title": "AlertRuleListResponse",
        "description": "Schema for alert rule list response with pagination.",
        "example": {
          "count": 1,
          "limit": 50,
          "offset": 0,
          "rules": [
            {
              "channels": ["pushover"],
              "conditions": {
                "risk_threshold": 70
              },
              "cooldown_seconds": 300,
              "created_at": "2025-12-28T12:00:00Z",
              "enabled": true,
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "name": "High Risk Alert",
              "updated_at": "2025-12-28T12:00:00Z"
            }
          ]
        }
      },
      "AlertRuleResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Alert rule UUID"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Rule name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Rule description"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the rule is active"
          },
          "severity": {
            "$ref": "#/components/schemas/AlertSeverity",
            "description": "Severity level"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Threshold",
            "description": "Risk score threshold"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Types",
            "description": "Object types to match"
          },
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Camera Ids",
            "description": "Camera IDs to apply to"
          },
          "zone_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Zone Ids",
            "description": "Zone IDs to match"
          },
          "min_confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Confidence",
            "description": "Minimum confidence"
          },
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleSchedule"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based conditions"
          },
          "conditions": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleConditions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Legacy conditions"
          },
          "dedup_key_template": {
            "type": "string",
            "title": "Dedup Key Template",
            "description": "Template for dedup key"
          },
          "cooldown_seconds": {
            "type": "integer",
            "title": "Cooldown Seconds",
            "description": "Minimum seconds between duplicate alerts"
          },
          "channels": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Channels",
            "description": "Notification channels"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Last update timestamp"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "enabled",
          "severity",
          "dedup_key_template",
          "cooldown_seconds",
          "created_at",
          "updated_at"
        ],
        "title": "AlertRuleResponse",
        "description": "Schema for alert rule response.",
        "example": {
          "camera_ids": ["front_door", "backyard"],
          "channels": ["pushover", "webhook"],
          "cooldown_seconds": 300,
          "created_at": "2025-12-28T12:00:00Z",
          "dedup_key_template": "{camera_id}:{rule_id}",
          "description": "High-priority alert for person detection at night",
          "enabled": true,
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "min_confidence": 0.8,
          "name": "Night Intruder Alert",
          "object_types": ["person"],
          "risk_threshold": 70,
          "schedule": {
            "days": ["monday", "tuesday", "wednesday", "thursday", "friday"],
            "end_time": "06:00",
            "start_time": "22:00",
            "timezone": "America/New_York"
          },
          "severity": "critical",
          "updated_at": "2025-12-28T12:00:00Z"
        }
      },
      "AlertRuleSchedule": {
        "properties": {
          "days": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Days",
            "description": "Days of week when rule is active (empty = all days). Values: monday, tuesday, wednesday, thursday, friday, saturday, sunday"
          },
          "start_time": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^\\d{2}:\\d{2}$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Start Time",
            "description": "Start time in HH:MM format (00:00-23:59)"
          },
          "end_time": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^\\d{2}:\\d{2}$"
              },
              {
                "type": "null"
              }
            ],
            "title": "End Time",
            "description": "End time in HH:MM format (00:00-23:59)"
          },
          "timezone": {
            "type": "string",
            "title": "Timezone",
            "description": "Timezone for time evaluation",
            "default": "UTC"
          }
        },
        "type": "object",
        "title": "AlertRuleSchedule",
        "description": "Schema for alert rule schedule (time-based conditions).\n\nIf start_time > end_time, the schedule spans midnight (e.g., 22:00-06:00).\nEmpty days array means all days. No schedule = always active (vacation mode).\n\nValidation:\n- Days must be valid day names (monday-sunday)\n- Times must be valid HH:MM format with hours 00-23, minutes 00-59\n- Start and end times are validated but can span midnight",
        "example": {
          "days": ["monday", "tuesday", "wednesday", "thursday", "friday"],
          "end_time": "06:00",
          "start_time": "22:00",
          "timezone": "America/New_York"
        }
      },
      "AlertRuleUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Rule name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Rule description"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enabled",
            "description": "Whether the rule is active"
          },
          "severity": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertSeverity"
              },
              {
                "type": "null"
              }
            ],
            "description": "Severity level"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Threshold",
            "description": "Alert when risk_score >= threshold"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Types",
            "description": "Object types to match"
          },
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Camera Ids",
            "description": "Camera IDs to apply rule to"
          },
          "zone_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Zone Ids",
            "description": "Zone IDs to match"
          },
          "min_confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Confidence",
            "description": "Minimum detection confidence"
          },
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleSchedule"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based conditions"
          },
          "conditions": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleConditions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Legacy conditions"
          },
          "dedup_key_template": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255
              },
              {
                "type": "null"
              }
            ],
            "title": "Dedup Key Template",
            "description": "Template for dedup key"
          },
          "cooldown_seconds": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Cooldown Seconds",
            "description": "Minimum seconds between duplicate alerts"
          },
          "channels": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Channels",
            "description": "Notification channels for this rule"
          }
        },
        "type": "object",
        "title": "AlertRuleUpdate",
        "description": "Schema for updating an alert rule (PATCH).\n\nOnly provided fields will be updated. Null values clear the field.",
        "example": {
          "cooldown_seconds": 600,
          "enabled": false,
          "risk_threshold": 80
        }
      },
      "AlertSeverity": {
        "type": "string",
        "enum": ["low", "medium", "high", "critical"],
        "title": "AlertSeverity",
        "description": "Alert severity levels."
      },
      "AllPromptsResponse": {
        "properties": {
          "prompts": {
            "additionalProperties": {
              "$ref": "#/components/schemas/ModelPromptResponse"
            },
            "type": "object",
            "title": "Prompts",
            "description": "Dictionary mapping model names to their configurations"
          }
        },
        "type": "object",
        "required": ["prompts"],
        "title": "AllPromptsResponse",
        "description": "Response containing prompts for all supported AI models.\n\nReturns configurations for all models in the AI pipeline:\nnemotron, florence2, yolo_world, xclip, and fashion_clip.",
        "example": {
          "prompts": {
            "florence2": {
              "config": {
                "vqa_queries": ["What is happening?", "Who is present?"]
              },
              "model_name": "florence2",
              "updated_at": "2026-01-02T14:00:00Z",
              "version": 3
            },
            "nemotron": {
              "config": {
                "max_tokens": 2048,
                "system_prompt": "You are a security analyst...",
                "temperature": 0.7
              },
              "model_name": "nemotron",
              "updated_at": "2026-01-03T10:30:00Z",
              "version": 5
            }
          }
        }
      },
      "AnomalyConfig": {
        "properties": {
          "threshold_stdev": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Threshold Stdev",
            "description": "Number of standard deviations from mean for anomaly detection"
          },
          "min_samples": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Min Samples",
            "description": "Minimum samples required before anomaly detection is reliable"
          },
          "decay_factor": {
            "type": "number",
            "maximum": 1.0,
            "exclusiveMinimum": 0.0,
            "title": "Decay Factor",
            "description": "Exponential decay factor for EWMA (0 < factor <= 1)"
          },
          "window_days": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Window Days",
            "description": "Rolling window size in days for baseline calculations"
          }
        },
        "type": "object",
        "required": ["threshold_stdev", "min_samples", "decay_factor", "window_days"],
        "title": "AnomalyConfig",
        "description": "Current anomaly detection configuration.",
        "example": {
          "decay_factor": 0.1,
          "min_samples": 10,
          "threshold_stdev": 2.0,
          "window_days": 30
        }
      },
      "AnomalyConfigUpdate": {
        "properties": {
          "threshold_stdev": {
            "anyOf": [
              {
                "type": "number",
                "exclusiveMinimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Threshold Stdev",
            "description": "Number of standard deviations from mean for anomaly detection"
          },
          "min_samples": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Samples",
            "description": "Minimum samples required before anomaly detection is reliable"
          }
        },
        "type": "object",
        "title": "AnomalyConfigUpdate",
        "description": "Request to update anomaly detection configuration.",
        "example": {
          "min_samples": 15,
          "threshold_stdev": 2.5
        }
      },
      "AnomalyEvent": {
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "When the anomaly was detected"
          },
          "detection_class": {
            "type": "string",
            "title": "Detection Class",
            "description": "Object class that triggered the anomaly"
          },
          "anomaly_score": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Anomaly Score",
            "description": "Anomaly score (0.0-1.0, higher is more anomalous)"
          },
          "expected_frequency": {
            "type": "number",
            "minimum": 0.0,
            "title": "Expected Frequency",
            "description": "Expected frequency for this class at this time"
          },
          "observed_frequency": {
            "type": "number",
            "minimum": 0.0,
            "title": "Observed Frequency",
            "description": "Observed frequency that triggered the anomaly"
          },
          "reason": {
            "type": "string",
            "title": "Reason",
            "description": "Human-readable explanation of why this is anomalous"
          }
        },
        "type": "object",
        "required": [
          "timestamp",
          "detection_class",
          "anomaly_score",
          "expected_frequency",
          "observed_frequency",
          "reason"
        ],
        "title": "AnomalyEvent",
        "description": "A single anomaly event detected for a camera.",
        "example": {
          "anomaly_score": 0.95,
          "detection_class": "vehicle",
          "expected_frequency": 0.1,
          "observed_frequency": 5.0,
          "reason": "Vehicle detected at 2:30 AM when rarely seen at this hour",
          "timestamp": "2026-01-03T02:30:00Z"
        }
      },
      "AnomalyListResponse": {
        "properties": {
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "anomalies": {
            "items": {
              "$ref": "#/components/schemas/AnomalyEvent"
            },
            "type": "array",
            "title": "Anomalies",
            "description": "List of recent anomaly events"
          },
          "count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Count",
            "description": "Total number of anomalies returned"
          },
          "period_days": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Period Days",
            "description": "Number of days covered by this query"
          }
        },
        "type": "object",
        "required": ["camera_id", "count", "period_days"],
        "title": "AnomalyListResponse",
        "description": "Response schema for camera anomaly list endpoint.",
        "example": {
          "anomalies": [
            {
              "anomaly_score": 0.95,
              "detection_class": "vehicle",
              "expected_frequency": 0.1,
              "observed_frequency": 5.0,
              "reason": "Vehicle detected at 2:30 AM when rarely seen",
              "timestamp": "2026-01-03T02:30:00Z"
            }
          ],
          "camera_id": "front_door",
          "count": 1,
          "period_days": 7
        }
      },
      "AuditLogListResponse": {
        "properties": {
          "logs": {
            "items": {
              "$ref": "#/components/schemas/AuditLogResponse"
            },
            "type": "array",
            "title": "Logs",
            "description": "List of audit log entries"
          },
          "count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Count",
            "description": "Total count matching filters"
          },
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Page size (1-1000)"
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Page offset (0-based, deprecated)"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Cursor",
            "description": "Cursor for next page (use this instead of offset)"
          },
          "has_more": {
            "type": "boolean",
            "title": "Has More",
            "description": "Whether more results are available",
            "default": false
          },
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Deprecation Warning",
            "description": "Warning when using deprecated offset pagination"
          }
        },
        "type": "object",
        "required": ["logs", "count", "limit", "offset"],
        "title": "AuditLogListResponse",
        "description": "Schema for paginated audit log response.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.",
        "example": {
          "count": 1,
          "has_more": false,
          "limit": 50,
          "logs": [
            {
              "action": "acknowledge",
              "actor": "admin@example.com",
              "id": 1,
              "ip_address": "192.168.1.100",
              "resource_id": "123",
              "resource_type": "event",
              "status": "success",
              "timestamp": "2026-01-03T10:30:00Z"
            }
          ],
          "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjYtMDEtMDNUMTA6MzA6MDBaIn0=",
          "offset": 0
        }
      },
      "AuditLogResponse": {
        "properties": {
          "id": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Id",
            "description": "Audit log entry ID"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "When the action occurred (UTC)"
          },
          "action": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Action",
            "description": "The action performed (e.g., 'create', 'update', 'delete', 'acknowledge')"
          },
          "resource_type": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Resource Type",
            "description": "Type of resource (event, alert, rule, camera, settings)"
          },
          "resource_id": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 128
              },
              {
                "type": "null"
              }
            ],
            "title": "Resource Id",
            "description": "ID of the specific resource"
          },
          "actor": {
            "type": "string",
            "maxLength": 200,
            "minLength": 1,
            "title": "Actor",
            "description": "User or system that performed the action"
          },
          "ip_address": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 45
              },
              {
                "type": "null"
              }
            ],
            "title": "Ip Address",
            "description": "IP address of the client (IPv4 or IPv6)"
          },
          "user_agent": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 500
              },
              {
                "type": "null"
              }
            ],
            "title": "User Agent",
            "description": "User agent string of the client"
          },
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Details",
            "description": "Action-specific details (JSON-serializable)"
          },
          "status": {
            "type": "string",
            "pattern": "^(success|failure)$",
            "title": "Status",
            "description": "Status of the action (success/failure)"
          }
        },
        "type": "object",
        "required": ["id", "timestamp", "action", "resource_type", "actor", "status"],
        "title": "AuditLogResponse",
        "description": "Schema for a single audit log entry.",
        "example": {
          "action": "acknowledge",
          "actor": "admin@example.com",
          "details": {
            "new_status": "acknowledged",
            "previous_status": "unacknowledged"
          },
          "id": 1,
          "ip_address": "192.168.1.100",
          "resource_id": "123",
          "resource_type": "event",
          "status": "success",
          "timestamp": "2026-01-03T10:30:00Z",
          "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0"
        }
      },
      "AuditLogStats": {
        "properties": {
          "total_logs": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Logs",
            "description": "Total number of audit logs"
          },
          "logs_today": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Logs Today",
            "description": "Number of logs today"
          },
          "by_action": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "By Action",
            "description": "Counts by action type"
          },
          "by_resource_type": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "By Resource Type",
            "description": "Counts by resource type"
          },
          "by_status": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "By Status",
            "description": "Counts by status"
          },
          "recent_actors": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Recent Actors",
            "description": "Recently active actors"
          }
        },
        "type": "object",
        "required": [
          "total_logs",
          "logs_today",
          "by_action",
          "by_resource_type",
          "by_status",
          "recent_actors"
        ],
        "title": "AuditLogStats",
        "description": "Schema for audit log statistics.",
        "example": {
          "by_action": {
            "acknowledge": 50,
            "create": 30,
            "delete": 25,
            "update": 45
          },
          "by_resource_type": {
            "alert": 40,
            "camera": 20,
            "event": 80,
            "settings": 10
          },
          "by_status": {
            "failure": 5,
            "success": 145
          },
          "logs_today": 150,
          "recent_actors": ["admin@example.com", "system", "scheduler"],
          "total_logs": 5000
        }
      },
      "AuditStatsResponse": {
        "properties": {
          "total_events": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Events",
            "description": "Total events in the period"
          },
          "audited_events": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Audited Events",
            "description": "Events with audit records"
          },
          "fully_evaluated_events": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Fully Evaluated Events",
            "description": "Events with complete self-evaluation"
          },
          "avg_quality_score": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 5.0,
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Quality Score",
            "description": "Average overall quality score (1-5)"
          },
          "avg_consistency_rate": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Consistency Rate",
            "description": "Average consistency rate"
          },
          "avg_enrichment_utilization": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Enrichment Utilization",
            "description": "Average enrichment utilization (0-1)"
          },
          "model_contribution_rates": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Model Contribution Rates",
            "description": "Contribution rate for each AI model (0-1)"
          },
          "audits_by_day": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Audits By Day",
            "description": "Daily audit counts for trend visualization"
          }
        },
        "type": "object",
        "required": [
          "total_events",
          "audited_events",
          "fully_evaluated_events",
          "model_contribution_rates",
          "audits_by_day"
        ],
        "title": "AuditStatsResponse",
        "description": "Aggregate audit statistics over a time period.\n\nProvides summary metrics for monitoring AI pipeline health and\nidentifying optimization opportunities.",
        "example": {
          "audited_events": 1200,
          "audits_by_day": [
            {
              "count": 180,
              "date": "2026-01-01"
            },
            {
              "count": 195,
              "date": "2026-01-02"
            }
          ],
          "avg_consistency_rate": 0.92,
          "avg_enrichment_utilization": 0.78,
          "avg_quality_score": 4.2,
          "fully_evaluated_events": 950,
          "model_contribution_rates": {
            "clip": 0.45,
            "clothing": 0.62,
            "florence": 0.85,
            "rtdetr": 0.98,
            "weather": 0.73,
            "zones": 0.88
          },
          "total_events": 1250
        }
      },
      "BaselineSummaryResponse": {
        "properties": {
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "camera_name": {
            "type": "string",
            "title": "Camera Name",
            "description": "Human-readable camera name"
          },
          "baseline_established": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Baseline Established",
            "description": "When baseline data collection started (null if no data)"
          },
          "data_points": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Data Points",
            "description": "Total number of data points in baseline"
          },
          "hourly_patterns": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HourlyPattern"
            },
            "type": "object",
            "title": "Hourly Patterns",
            "description": "Activity patterns by hour (0-23)"
          },
          "daily_patterns": {
            "additionalProperties": {
              "$ref": "#/components/schemas/DailyPattern"
            },
            "type": "object",
            "title": "Daily Patterns",
            "description": "Activity patterns by day of week (monday-sunday)"
          },
          "object_baselines": {
            "additionalProperties": {
              "$ref": "#/components/schemas/ObjectBaseline"
            },
            "type": "object",
            "title": "Object Baselines",
            "description": "Baseline statistics by object type"
          },
          "current_deviation": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CurrentDeviation"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current deviation from baseline (null if insufficient data)"
          }
        },
        "type": "object",
        "required": ["camera_id", "camera_name", "data_points"],
        "title": "BaselineSummaryResponse",
        "description": "Response schema for camera baseline summary endpoint.\n\nProvides comprehensive baseline data for a camera including:\n- Hourly activity patterns (0-23 hours)\n- Daily patterns (by day of week)\n- Object-specific baselines\n- Current deviation from baseline",
        "example": {
          "baseline_established": "2026-01-01T00:00:00Z",
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "current_deviation": {
            "contributing_factors": ["person_count_elevated"],
            "interpretation": "slightly_above_normal",
            "score": 1.8
          },
          "daily_patterns": {
            "monday": {
              "avg_detections": 45,
              "peak_hour": 17,
              "total_samples": 24
            }
          },
          "data_points": 720,
          "hourly_patterns": {
            "0": {
              "avg_detections": 0.5,
              "sample_count": 30,
              "std_dev": 0.3
            },
            "17": {
              "avg_detections": 5.2,
              "sample_count": 30,
              "std_dev": 1.1
            }
          },
          "object_baselines": {
            "person": {
              "avg_hourly": 2.3,
              "peak_hour": 17,
              "total_detections": 550
            }
          }
        }
      },
      "BatchAggregatorStatusResponse": {
        "properties": {
          "active_batches": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Active Batches",
            "description": "Number of active batches being aggregated"
          },
          "batches": {
            "items": {
              "$ref": "#/components/schemas/BatchInfoResponse"
            },
            "type": "array",
            "title": "Batches",
            "description": "Details of active batches"
          },
          "batch_window_seconds": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Batch Window Seconds",
            "description": "Configured batch window timeout in seconds"
          },
          "idle_timeout_seconds": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Idle Timeout Seconds",
            "description": "Configured idle timeout in seconds"
          }
        },
        "type": "object",
        "required": ["active_batches", "batch_window_seconds", "idle_timeout_seconds"],
        "title": "BatchAggregatorStatusResponse",
        "description": "Status information for the BatchAggregator service.",
        "example": {
          "active_batches": 2,
          "batch_window_seconds": 90,
          "batches": [
            {
              "age_seconds": 45.5,
              "batch_id": "abc123",
              "camera_id": "front_door",
              "detection_count": 5,
              "last_activity_seconds": 10.2,
              "started_at": 1735500000.0
            }
          ],
          "idle_timeout_seconds": 30
        }
      },
      "BatchAuditRequest": {
        "properties": {
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Maximum number of events to process",
            "default": 100
          },
          "min_risk_score": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Risk Score",
            "description": "Only process events with risk >= this score"
          },
          "force_reevaluate": {
            "type": "boolean",
            "title": "Force Reevaluate",
            "description": "Re-evaluate even if already fully evaluated",
            "default": false
          }
        },
        "type": "object",
        "title": "BatchAuditRequest",
        "description": "Request for batch audit processing.\n\nSpecify criteria for selecting events to audit in bulk.",
        "example": {
          "force_reevaluate": false,
          "limit": 100,
          "min_risk_score": 50
        }
      },
      "BatchAuditResponse": {
        "properties": {
          "queued_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Queued Count",
            "description": "Number of events processed"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Status message with details"
          }
        },
        "type": "object",
        "required": ["queued_count", "message"],
        "title": "BatchAuditResponse",
        "description": "Response from batch audit processing.\n\nReports how many events were queued for processing.",
        "example": {
          "message": "Successfully processed 25 events for audit evaluation",
          "queued_count": 25
        }
      },
      "BatchInfoResponse": {
        "properties": {
          "batch_id": {
            "type": "string",
            "title": "Batch Id",
            "description": "Unique batch identifier"
          },
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID this batch belongs to"
          },
          "detection_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Detection Count",
            "description": "Number of detections in this batch"
          },
          "started_at": {
            "type": "number",
            "title": "Started At",
            "description": "Batch start time (Unix timestamp)"
          },
          "age_seconds": {
            "type": "number",
            "minimum": 0.0,
            "title": "Age Seconds",
            "description": "Time since batch started in seconds"
          },
          "last_activity_seconds": {
            "type": "number",
            "minimum": 0.0,
            "title": "Last Activity Seconds",
            "description": "Time since last activity in seconds"
          }
        },
        "type": "object",
        "required": [
          "batch_id",
          "camera_id",
          "detection_count",
          "started_at",
          "age_seconds",
          "last_activity_seconds"
        ],
        "title": "BatchInfoResponse",
        "description": "Information about an active batch."
      },
      "BulkItemResult": {
        "properties": {
          "index": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Index",
            "description": "Zero-based index of the item in the request"
          },
          "status": {
            "$ref": "#/components/schemas/BulkOperationStatus",
            "description": "Operation status"
          },
          "id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Id",
            "description": "ID of the created/updated resource"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Error message for failed operations"
          }
        },
        "type": "object",
        "required": ["index", "status"],
        "title": "BulkItemResult",
        "description": "Result for a single item in a bulk operation.\n\nAttributes:\n    index: Zero-based index of the item in the request array\n    status: Operation status (success, failed, skipped)\n    id: ID of the created/updated resource (for successful operations)\n    error: Error message (for failed operations)"
      },
      "BulkOperationResponse": {
        "properties": {
          "total": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total",
            "description": "Total number of items in the request"
          },
          "succeeded": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Succeeded",
            "description": "Number of successful operations"
          },
          "failed": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Failed",
            "description": "Number of failed operations"
          },
          "skipped": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Skipped",
            "description": "Number of skipped operations",
            "default": 0
          },
          "results": {
            "items": {
              "$ref": "#/components/schemas/BulkItemResult"
            },
            "type": "array",
            "title": "Results",
            "description": "Per-item results"
          }
        },
        "type": "object",
        "required": ["total", "succeeded", "failed"],
        "title": "BulkOperationResponse",
        "description": "Base response for bulk operations with partial success support.\n\nUses HTTP 207 Multi-Status when some operations succeed and others fail.\n\nAttributes:\n    total: Total number of items in the request\n    succeeded: Number of successful operations\n    failed: Number of failed operations\n    skipped: Number of skipped operations\n    results: Per-item results with status and error details"
      },
      "BulkOperationStatus": {
        "type": "string",
        "enum": ["success", "failed", "skipped"],
        "title": "BulkOperationStatus",
        "description": "Status of individual items in a bulk operation."
      },
      "CameraCreate": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "description": "Camera name"
          },
          "folder_path": {
            "type": "string",
            "maxLength": 500,
            "minLength": 1,
            "title": "Folder Path",
            "description": "File system path for camera uploads"
          },
          "status": {
            "$ref": "#/components/schemas/CameraStatus",
            "description": "Camera status (online, offline, error, unknown)",
            "default": "online"
          }
        },
        "type": "object",
        "required": ["name", "folder_path"],
        "title": "CameraCreate",
        "description": "Schema for creating a new camera.",
        "example": {
          "folder_path": "/export/foscam/front_door",
          "name": "Front Door Camera",
          "status": "online"
        }
      },
      "CameraListResponse": {
        "properties": {
          "cameras": {
            "items": {
              "$ref": "#/components/schemas/CameraResponse"
            },
            "type": "array",
            "title": "Cameras",
            "description": "List of cameras"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Total number of cameras"
          }
        },
        "type": "object",
        "required": ["cameras", "count"],
        "title": "CameraListResponse",
        "description": "Schema for camera list response.",
        "example": {
          "cameras": [
            {
              "created_at": "2025-12-23T10:00:00Z",
              "folder_path": "/export/foscam/front_door",
              "id": "front_door",
              "last_seen_at": "2025-12-23T12:00:00Z",
              "name": "Front Door Camera",
              "status": "online"
            }
          ],
          "count": 1
        }
      },
      "CameraNotificationSettingResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Setting UUID"
          },
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether notifications are enabled for this camera"
          },
          "risk_threshold": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Risk Threshold",
            "description": "Minimum risk score to trigger notifications (0-100)"
          }
        },
        "type": "object",
        "required": ["id", "camera_id", "enabled", "risk_threshold"],
        "title": "CameraNotificationSettingResponse",
        "description": "Schema for camera notification setting response.",
        "example": {
          "camera_id": "front_door",
          "enabled": true,
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "risk_threshold": 50
        }
      },
      "CameraNotificationSettingUpdate": {
        "properties": {
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enabled",
            "description": "Whether notifications are enabled for this camera"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Threshold",
            "description": "Minimum risk score to trigger notifications (0-100)"
          }
        },
        "type": "object",
        "title": "CameraNotificationSettingUpdate",
        "description": "Schema for updating camera notification setting.",
        "example": {
          "enabled": false,
          "risk_threshold": 70
        }
      },
      "CameraNotificationSettingsListResponse": {
        "properties": {
          "settings": {
            "items": {
              "$ref": "#/components/schemas/CameraNotificationSettingResponse"
            },
            "type": "array",
            "title": "Settings",
            "description": "List of camera notification settings"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Total number of settings"
          }
        },
        "type": "object",
        "required": ["settings", "count"],
        "title": "CameraNotificationSettingsListResponse",
        "description": "Schema for camera notification settings list response.",
        "example": {
          "count": 2,
          "settings": [
            {
              "camera_id": "front_door",
              "enabled": true,
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "risk_threshold": 50
            },
            {
              "camera_id": "back_yard",
              "enabled": false,
              "id": "550e8400-e29b-41d4-a716-446655440001",
              "risk_threshold": 70
            }
          ]
        }
      },
      "CameraResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Normalized camera ID derived from folder name (e.g., 'front_door')"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Camera name"
          },
          "folder_path": {
            "type": "string",
            "title": "Folder Path",
            "description": "File system path for camera uploads"
          },
          "status": {
            "$ref": "#/components/schemas/CameraStatus",
            "description": "Camera status (online, offline, error, unknown)"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp when camera was created"
          },
          "last_seen_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Seen At",
            "description": "Last time camera was active"
          }
        },
        "type": "object",
        "required": ["id", "name", "folder_path", "status", "created_at"],
        "title": "CameraResponse",
        "description": "Schema for camera response.",
        "example": {
          "created_at": "2025-12-23T10:00:00Z",
          "folder_path": "/export/foscam/front_door",
          "id": "front_door",
          "last_seen_at": "2025-12-23T12:00:00Z",
          "name": "Front Door Camera",
          "status": "online"
        }
      },
      "CameraStatus": {
        "type": "string",
        "enum": ["online", "offline", "error", "unknown"],
        "title": "CameraStatus",
        "description": "Camera status values.\n\nIndicates the operational state of a camera:\n- ONLINE: Camera is active and receiving images\n- OFFLINE: Camera is not currently active (e.g., disconnected)\n- ERROR: Camera is experiencing an error condition\n- UNKNOWN: Camera status cannot be determined"
      },
      "CameraUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Camera name"
          },
          "folder_path": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 500,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Folder Path",
            "description": "File system path for camera uploads"
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CameraStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera status (online, offline, error, unknown)"
          }
        },
        "type": "object",
        "title": "CameraUpdate",
        "description": "Schema for updating an existing camera.",
        "example": {
          "name": "Front Door Camera - Updated",
          "status": "offline"
        }
      },
      "CameraUptimeDataPoint": {
        "properties": {
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Normalized camera ID (e.g., 'front_door')"
          },
          "camera_name": {
            "type": "string",
            "title": "Camera Name",
            "description": "Camera name"
          },
          "uptime_percentage": {
            "type": "number",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Uptime Percentage",
            "description": "Uptime percentage (0-100)"
          },
          "detection_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Detection Count",
            "description": "Total detections in date range"
          }
        },
        "type": "object",
        "required": ["camera_id", "camera_name", "uptime_percentage", "detection_count"],
        "title": "CameraUptimeDataPoint",
        "description": "Schema for a single camera uptime data point.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "detection_count": 150,
          "uptime_percentage": 98.5
        }
      },
      "CameraUptimeResponse": {
        "properties": {
          "cameras": {
            "items": {
              "$ref": "#/components/schemas/CameraUptimeDataPoint"
            },
            "type": "array",
            "title": "Cameras",
            "description": "Uptime data per camera"
          },
          "start_date": {
            "type": "string",
            "format": "date",
            "title": "Start Date",
            "description": "Start date of the date range"
          },
          "end_date": {
            "type": "string",
            "format": "date",
            "title": "End Date",
            "description": "End date of the date range"
          }
        },
        "type": "object",
        "required": ["cameras", "start_date", "end_date"],
        "title": "CameraUptimeResponse",
        "description": "Schema for camera uptime percentage per camera.",
        "example": {
          "cameras": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_count": 150,
              "uptime_percentage": 98.5
            },
            {
              "camera_id": "back_door",
              "camera_name": "Back Door",
              "detection_count": 120,
              "uptime_percentage": 95.2
            }
          ],
          "end_date": "2025-01-07",
          "start_date": "2025-01-01"
        }
      },
      "CategorySummary": {
        "properties": {
          "total": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total",
            "description": "Total number of services in this category"
          },
          "healthy": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Healthy",
            "description": "Number of healthy (running) services"
          },
          "unhealthy": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Unhealthy",
            "description": "Number of unhealthy/stopped/disabled services"
          }
        },
        "type": "object",
        "required": ["total", "healthy", "unhealthy"],
        "title": "CategorySummary",
        "description": "Summary of services in a category.\n\nProvides a quick overview of service health within a category\nfor dashboard displays.",
        "example": {
          "healthy": 3,
          "total": 5,
          "unhealthy": 2
        }
      },
      "CircuitBreakerConfigResponse": {
        "properties": {
          "failure_threshold": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Failure Threshold",
            "description": "Number of failures before opening circuit"
          },
          "recovery_timeout": {
            "type": "number",
            "minimum": 0.0,
            "title": "Recovery Timeout",
            "description": "Seconds to wait before transitioning to half-open"
          },
          "half_open_max_calls": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Half Open Max Calls",
            "description": "Maximum calls allowed in half-open state"
          },
          "success_threshold": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Success Threshold",
            "description": "Successes needed in half-open to close circuit"
          }
        },
        "type": "object",
        "required": [
          "failure_threshold",
          "recovery_timeout",
          "half_open_max_calls",
          "success_threshold"
        ],
        "title": "CircuitBreakerConfigResponse",
        "description": "Configuration for a circuit breaker."
      },
      "CircuitBreakerResetResponse": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name of the circuit breaker that was reset"
          },
          "previous_state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "State before reset"
          },
          "new_state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "State after reset (should be closed)"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable result message"
          }
        },
        "type": "object",
        "required": ["name", "previous_state", "new_state", "message"],
        "title": "CircuitBreakerResetResponse",
        "description": "Response for circuit breaker reset operation."
      },
      "CircuitBreakerStateEnum": {
        "type": "string",
        "enum": ["closed", "open", "half_open", "unavailable"],
        "title": "CircuitBreakerStateEnum",
        "description": "Circuit breaker states."
      },
      "CircuitBreakerStatusResponse": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Circuit breaker name"
          },
          "state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "Current circuit state: closed (normal), open (failing), half_open (testing)"
          },
          "failure_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Failure Count",
            "description": "Current consecutive failure count"
          },
          "success_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Success Count",
            "description": "Current consecutive success count (relevant in half-open)"
          },
          "total_calls": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Calls",
            "description": "Total calls attempted through this circuit"
          },
          "rejected_calls": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Rejected Calls",
            "description": "Calls rejected due to open circuit"
          },
          "last_failure_time": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Failure Time",
            "description": "Monotonic time of last failure (seconds)"
          },
          "opened_at": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Opened At",
            "description": "Monotonic time when circuit opened (seconds)"
          },
          "config": {
            "$ref": "#/components/schemas/CircuitBreakerConfigResponse",
            "description": "Circuit breaker configuration"
          }
        },
        "type": "object",
        "required": [
          "name",
          "state",
          "failure_count",
          "success_count",
          "total_calls",
          "rejected_calls",
          "config"
        ],
        "title": "CircuitBreakerStatusResponse",
        "description": "Status of a single circuit breaker.",
        "example": {
          "config": {
            "failure_threshold": 5,
            "half_open_max_calls": 3,
            "recovery_timeout": 30.0,
            "success_threshold": 2
          },
          "failure_count": 0,
          "name": "ai_service",
          "rejected_calls": 0,
          "state": "closed",
          "success_count": 0,
          "total_calls": 150
        }
      },
      "CircuitBreakerSummary": {
        "properties": {
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of circuit breakers"
          },
          "closed": {
            "type": "integer",
            "title": "Closed",
            "description": "Number of breakers in closed state"
          },
          "open": {
            "type": "integer",
            "title": "Open",
            "description": "Number of breakers in open state"
          },
          "half_open": {
            "type": "integer",
            "title": "Half Open",
            "description": "Number of breakers in half-open state"
          },
          "breakers": {
            "additionalProperties": {
              "$ref": "#/components/schemas/CircuitState"
            },
            "type": "object",
            "title": "Breakers",
            "description": "Individual circuit breaker states keyed by service name"
          }
        },
        "type": "object",
        "required": ["total", "closed", "open", "half_open", "breakers"],
        "title": "CircuitBreakerSummary",
        "description": "Summary of all circuit breakers in the system.\n\nProvides counts by state and individual breaker states for monitoring.",
        "example": {
          "breakers": {
            "clip": "closed",
            "enrichment": "closed",
            "florence": "open",
            "nemotron": "closed",
            "rtdetr": "closed"
          },
          "closed": 4,
          "half_open": 0,
          "open": 1,
          "total": 5
        }
      },
      "CircuitBreakersResponse": {
        "properties": {
          "circuit_breakers": {
            "additionalProperties": {
              "$ref": "#/components/schemas/CircuitBreakerStatusResponse"
            },
            "type": "object",
            "title": "Circuit Breakers",
            "description": "Status of all circuit breakers keyed by name"
          },
          "total_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Count",
            "description": "Total number of circuit breakers"
          },
          "open_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Open Count",
            "description": "Number of circuit breakers currently open"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of status snapshot"
          }
        },
        "type": "object",
        "required": ["circuit_breakers", "total_count", "open_count", "timestamp"],
        "title": "CircuitBreakersResponse",
        "description": "Response schema for circuit breakers status endpoint.",
        "example": {
          "circuit_breakers": {
            "rtdetr": {
              "config": {
                "failure_threshold": 5,
                "half_open_max_calls": 3,
                "recovery_timeout": 30.0,
                "success_threshold": 2
              },
              "failure_count": 0,
              "name": "rtdetr",
              "rejected_calls": 0,
              "state": "closed",
              "success_count": 0,
              "total_calls": 100
            }
          },
          "open_count": 0,
          "timestamp": "2025-12-30T10:30:00Z",
          "total_count": 2
        }
      },
      "CircuitState": {
        "type": "string",
        "enum": ["closed", "open", "half_open"],
        "title": "CircuitState",
        "description": "Circuit breaker state for a service.\n\nStates:\n- closed: Normal operation, requests pass through\n- open: Service failing, requests fail immediately\n- half_open: Testing recovery, limited requests allowed"
      },
      "ClassBaselineEntry": {
        "properties": {
          "object_class": {
            "type": "string",
            "title": "Object Class",
            "description": "Object class (e.g., person, vehicle, animal)"
          },
          "hour": {
            "type": "integer",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Hour",
            "description": "Hour of day (0-23)"
          },
          "frequency": {
            "type": "number",
            "minimum": 0.0,
            "title": "Frequency",
            "description": "Frequency of this class at this hour"
          },
          "sample_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Sample Count",
            "description": "Number of samples for this class/hour combination"
          }
        },
        "type": "object",
        "required": ["object_class", "hour", "frequency", "sample_count"],
        "title": "ClassBaselineEntry",
        "description": "Baseline entry for a specific object class at a specific hour.",
        "example": {
          "frequency": 3.5,
          "hour": 17,
          "object_class": "person",
          "sample_count": 45
        }
      },
      "ClassBaselineResponse": {
        "properties": {
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "entries": {
            "items": {
              "$ref": "#/components/schemas/ClassBaselineEntry"
            },
            "type": "array",
            "title": "Entries",
            "description": "Class baseline entries grouped by class and hour"
          },
          "unique_classes": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Unique Classes",
            "description": "List of unique object classes detected for this camera"
          },
          "total_samples": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Samples",
            "description": "Total number of samples across all entries"
          },
          "most_common_class": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Most Common Class",
            "description": "Most frequently detected object class"
          }
        },
        "type": "object",
        "required": ["camera_id", "total_samples"],
        "title": "ClassBaselineResponse",
        "description": "Response for camera class frequency baseline endpoint.",
        "example": {
          "camera_id": "front_door",
          "entries": [
            {
              "frequency": 3.5,
              "hour": 17,
              "object_class": "person",
              "sample_count": 45
            },
            {
              "frequency": 2.1,
              "hour": 8,
              "object_class": "vehicle",
              "sample_count": 30
            }
          ],
          "most_common_class": "person",
          "total_samples": 150,
          "unique_classes": ["person", "vehicle", "animal"]
        }
      },
      "CleanupResponse": {
        "properties": {
          "events_deleted": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Events Deleted",
            "description": "Number of events deleted (or would be deleted in dry run)"
          },
          "detections_deleted": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Detections Deleted",
            "description": "Number of detections deleted (or would be deleted in dry run)"
          },
          "gpu_stats_deleted": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Gpu Stats Deleted",
            "description": "Number of GPU stat records deleted (or would be deleted in dry run)"
          },
          "logs_deleted": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Logs Deleted",
            "description": "Number of log records deleted (or would be deleted in dry run)"
          },
          "thumbnails_deleted": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Thumbnails Deleted",
            "description": "Number of thumbnail files deleted (or would be deleted in dry run)"
          },
          "images_deleted": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Images Deleted",
            "description": "Number of original image files deleted (or would be deleted in dry run)"
          },
          "space_reclaimed": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Space Reclaimed",
            "description": "Estimated disk space freed in bytes (or would be freed in dry run)"
          },
          "retention_days": {
            "type": "integer",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Retention Days",
            "description": "Retention period used for cleanup"
          },
          "dry_run": {
            "type": "boolean",
            "title": "Dry Run",
            "description": "Whether this was a dry run (no actual deletion performed)",
            "default": false
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of cleanup operation"
          }
        },
        "type": "object",
        "required": [
          "events_deleted",
          "detections_deleted",
          "gpu_stats_deleted",
          "logs_deleted",
          "thumbnails_deleted",
          "images_deleted",
          "space_reclaimed",
          "retention_days",
          "timestamp"
        ],
        "title": "CleanupResponse",
        "description": "Response schema for data cleanup endpoint.\n\nReturns statistics about the cleanup operation including counts of\ndeleted records and files. When dry_run is True, the counts represent\nwhat would be deleted without actually deleting.",
        "example": {
          "detections_deleted": 89,
          "dry_run": false,
          "events_deleted": 15,
          "gpu_stats_deleted": 2880,
          "images_deleted": 0,
          "logs_deleted": 150,
          "retention_days": 30,
          "space_reclaimed": 524288000,
          "thumbnails_deleted": 89,
          "timestamp": "2025-12-27T10:30:00Z"
        }
      },
      "CleanupStatusResponse": {
        "properties": {
          "running": {
            "type": "boolean",
            "title": "Running",
            "description": "Whether the cleanup service is currently running"
          },
          "retention_days": {
            "type": "integer",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Retention Days",
            "description": "Current retention period in days"
          },
          "cleanup_time": {
            "type": "string",
            "title": "Cleanup Time",
            "description": "Scheduled daily cleanup time in HH:MM format"
          },
          "delete_images": {
            "type": "boolean",
            "title": "Delete Images",
            "description": "Whether original images are deleted during cleanup"
          },
          "next_cleanup": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Cleanup",
            "description": "ISO timestamp of next scheduled cleanup (null if not running)"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of status snapshot"
          }
        },
        "type": "object",
        "required": ["running", "retention_days", "cleanup_time", "delete_images", "timestamp"],
        "title": "CleanupStatusResponse",
        "description": "Response schema for cleanup service status endpoint.",
        "example": {
          "cleanup_time": "03:00",
          "delete_images": false,
          "next_cleanup": "2025-12-31T03:00:00Z",
          "retention_days": 30,
          "running": true,
          "timestamp": "2025-12-30T10:30:00Z"
        }
      },
      "ClearDataRequest": {
        "properties": {
          "confirm": {
            "type": "string",
            "title": "Confirm",
            "description": "Must be exactly 'DELETE_ALL_DATA' to confirm deletion"
          }
        },
        "type": "object",
        "required": ["confirm"],
        "title": "ClearDataRequest",
        "description": "Request schema for clearing data - requires confirmation."
      },
      "ClearDataResponse": {
        "properties": {
          "cameras_cleared": {
            "type": "integer",
            "title": "Cameras Cleared"
          },
          "events_cleared": {
            "type": "integer",
            "title": "Events Cleared"
          },
          "detections_cleared": {
            "type": "integer",
            "title": "Detections Cleared"
          }
        },
        "type": "object",
        "required": ["cameras_cleared", "events_cleared", "detections_cleared"],
        "title": "ClearDataResponse",
        "description": "Response schema for clear data endpoint."
      },
      "ClipGenerateRequest": {
        "properties": {
          "start_offset_seconds": {
            "type": "integer",
            "maximum": 3600.0,
            "minimum": -30.0,
            "title": "Start Offset Seconds",
            "description": "Seconds relative to event start to begin clip (negative = before event, range: -30 to 3600)",
            "default": -15
          },
          "end_offset_seconds": {
            "type": "integer",
            "maximum": 3600.0,
            "minimum": -30.0,
            "title": "End Offset Seconds",
            "description": "Seconds relative to event start to end clip (range: -30 to 3600, must be >= start_offset_seconds)",
            "default": 30
          },
          "force": {
            "type": "boolean",
            "title": "Force",
            "description": "Force regeneration even if clip already exists",
            "default": false
          }
        },
        "type": "object",
        "title": "ClipGenerateRequest",
        "description": "Schema for clip generation request (POST /api/events/{event_id}/clip/generate).\n\nOffset validation (NEM-1355):\n- start_offset_seconds: -30 to 3600 seconds\n- end_offset_seconds: -30 to 3600 seconds\n- end_offset_seconds must be >= start_offset_seconds",
        "example": {
          "end_offset_seconds": 30,
          "force": false,
          "start_offset_seconds": -15
        }
      },
      "ClipGenerateResponse": {
        "properties": {
          "event_id": {
            "type": "integer",
            "title": "Event Id",
            "description": "Event ID"
          },
          "status": {
            "$ref": "#/components/schemas/ClipStatus",
            "description": "Status of clip generation"
          },
          "clip_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Clip Url",
            "description": "URL to access the clip (if completed)"
          },
          "generated_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Generated At",
            "description": "Timestamp when the clip was generated"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Status message or error details"
          }
        },
        "type": "object",
        "required": ["event_id", "status"],
        "title": "ClipGenerateResponse",
        "description": "Schema for clip generation response.",
        "example": {
          "clip_url": "/api/media/clips/123_clip.mp4",
          "event_id": 123,
          "generated_at": "2026-01-03T10:30:00Z",
          "message": "Clip generated successfully",
          "status": "completed"
        }
      },
      "ClipInfoResponse": {
        "properties": {
          "event_id": {
            "type": "integer",
            "title": "Event Id",
            "description": "Event ID"
          },
          "clip_available": {
            "type": "boolean",
            "title": "Clip Available",
            "description": "Whether a clip is available for this event"
          },
          "clip_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Clip Url",
            "description": "URL to access the clip (if available)"
          },
          "duration_seconds": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Duration Seconds",
            "description": "Duration of the clip in seconds"
          },
          "generated_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Generated At",
            "description": "Timestamp when the clip was generated"
          },
          "file_size_bytes": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Size Bytes",
            "description": "File size of the clip in bytes"
          }
        },
        "type": "object",
        "required": ["event_id", "clip_available"],
        "title": "ClipInfoResponse",
        "description": "Schema for clip info response (GET /api/events/{event_id}/clip).",
        "example": {
          "clip_available": true,
          "clip_url": "/api/media/clips/123_clip.mp4",
          "duration_seconds": 30,
          "event_id": 123,
          "file_size_bytes": 5242880,
          "generated_at": "2026-01-03T10:30:00Z"
        }
      },
      "ClipStatus": {
        "type": "string",
        "enum": ["pending", "completed", "failed"],
        "title": "ClipStatus",
        "description": "Status of clip generation."
      },
      "ClothingEnrichment": {
        "properties": {
          "upper": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upper",
            "description": "Upper body clothing description"
          },
          "lower": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lower",
            "description": "Lower body clothing description"
          },
          "is_suspicious": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Suspicious",
            "description": "Whether clothing is flagged as suspicious"
          },
          "is_service_uniform": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Service Uniform",
            "description": "Whether wearing service uniform"
          },
          "has_face_covered": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Has Face Covered",
            "description": "Whether face is covered (hat/sunglasses/mask)"
          },
          "has_bag": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Has Bag",
            "description": "Whether person is carrying a bag"
          },
          "clothing_items": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Clothing Items",
            "description": "List of detected clothing items"
          }
        },
        "type": "object",
        "title": "ClothingEnrichment",
        "description": "Clothing classification and segmentation results.",
        "example": {
          "has_bag": true,
          "has_face_covered": false,
          "is_service_uniform": false,
          "is_suspicious": false,
          "lower": "blue jeans",
          "upper": "red t-shirt"
        }
      },
      "ConfigResponse": {
        "properties": {
          "app_name": {
            "type": "string",
            "title": "App Name",
            "description": "Application name"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Application version"
          },
          "retention_days": {
            "type": "integer",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Retention Days",
            "description": "Number of days to retain events and detections"
          },
          "batch_window_seconds": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Batch Window Seconds",
            "description": "Time window for batch processing detections"
          },
          "batch_idle_timeout_seconds": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Batch Idle Timeout Seconds",
            "description": "Idle timeout before processing incomplete batch"
          },
          "detection_confidence_threshold": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Detection Confidence Threshold",
            "description": "Minimum confidence threshold for detections (0.0-1.0)"
          },
          "grafana_url": {
            "type": "string",
            "title": "Grafana Url",
            "description": "Grafana dashboard URL for frontend link"
          }
        },
        "type": "object",
        "required": [
          "app_name",
          "version",
          "retention_days",
          "batch_window_seconds",
          "batch_idle_timeout_seconds",
          "detection_confidence_threshold",
          "grafana_url"
        ],
        "title": "ConfigResponse",
        "description": "Response schema for configuration endpoint.\n\nOnly includes public, non-sensitive configuration values.",
        "example": {
          "app_name": "Home Security Intelligence",
          "batch_idle_timeout_seconds": 30,
          "batch_window_seconds": 90,
          "detection_confidence_threshold": 0.5,
          "grafana_url": "http://localhost:3002",
          "retention_days": 30,
          "version": "0.1.0"
        }
      },
      "ConfigUpdateRequest": {
        "properties": {
          "retention_days": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 365.0,
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Retention Days",
            "description": "Number of days to retain events and detections"
          },
          "batch_window_seconds": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Batch Window Seconds",
            "description": "Time window for batch processing detections"
          },
          "batch_idle_timeout_seconds": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Batch Idle Timeout Seconds",
            "description": "Idle timeout before processing incomplete batch"
          },
          "detection_confidence_threshold": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Detection Confidence Threshold",
            "description": "Minimum confidence threshold for detections (0.0-1.0)"
          }
        },
        "type": "object",
        "title": "ConfigUpdateRequest",
        "description": "Request schema for PATCH /api/system/config.\n\nOnly supports a subset of processing-related settings."
      },
      "ContainerServiceStatus": {
        "type": "string",
        "enum": ["running", "starting", "unhealthy", "stopped", "disabled", "not_found"],
        "title": "ContainerServiceStatus",
        "description": "Current status of a managed container service.\n\nStatus values:\n- RUNNING: Container is up and passing health checks\n- STARTING: Container is starting, not yet healthy\n- UNHEALTHY: Running but failing health checks\n- STOPPED: Container is not running\n- DISABLED: Exceeded failure limit, requires manual reset\n- NOT_FOUND: Container doesn't exist yet"
      },
      "CurrentDeviation": {
        "properties": {
          "score": {
            "type": "number",
            "title": "Score",
            "description": "Deviation score (standard deviations from mean, can be negative)"
          },
          "interpretation": {
            "$ref": "#/components/schemas/DeviationInterpretation",
            "description": "Human-readable interpretation of the deviation"
          },
          "contributing_factors": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Contributing Factors",
            "description": "Factors contributing to current deviation"
          }
        },
        "type": "object",
        "required": ["score", "interpretation"],
        "title": "CurrentDeviation",
        "description": "Current activity deviation from established baseline.",
        "example": {
          "contributing_factors": ["person_count_elevated", "unusual_hour"],
          "interpretation": "slightly_above_normal",
          "score": 1.8
        }
      },
      "CustomTestPromptRequest": {
        "properties": {
          "event_id": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Event Id",
            "description": "Event ID to test the prompt against"
          },
          "custom_prompt": {
            "type": "string",
            "minLength": 1,
            "title": "Custom Prompt",
            "description": "Custom prompt text to test"
          },
          "temperature": {
            "type": "number",
            "maximum": 2.0,
            "minimum": 0.0,
            "title": "Temperature",
            "description": "LLM temperature setting",
            "default": 0.7
          },
          "max_tokens": {
            "type": "integer",
            "maximum": 8192.0,
            "minimum": 100.0,
            "title": "Max Tokens",
            "description": "Maximum tokens in response",
            "default": 2048
          },
          "model": {
            "type": "string",
            "title": "Model",
            "description": "Model name to use for testing",
            "default": "nemotron"
          }
        },
        "type": "object",
        "required": ["event_id", "custom_prompt"],
        "title": "CustomTestPromptRequest",
        "description": "Request to test a custom prompt against an existing event.\n\nThis is used for A/B testing in the Prompt Playground - testing a\nmodified prompt without persisting results to the database.",
        "example": {
          "custom_prompt": "You are an expert security analyst. Analyze the following detections and assess the risk level considering time of day, location, and behavioral patterns...",
          "event_id": 42,
          "max_tokens": 2048,
          "model": "nemotron",
          "temperature": 0.7
        }
      },
      "CustomTestPromptResponse": {
        "properties": {
          "risk_score": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Risk Score",
            "description": "Computed risk score (0-100)"
          },
          "risk_level": {
            "type": "string",
            "title": "Risk Level",
            "description": "Risk level: low, medium, high, or critical"
          },
          "reasoning": {
            "type": "string",
            "title": "Reasoning",
            "description": "LLM reasoning for the risk assessment"
          },
          "summary": {
            "type": "string",
            "title": "Summary",
            "description": "Brief summary of the event analysis"
          },
          "entities": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Entities",
            "description": "Detected entities in the analysis"
          },
          "flags": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Flags",
            "description": "Risk flags identified in the analysis"
          },
          "recommended_action": {
            "type": "string",
            "title": "Recommended Action",
            "description": "Recommended action based on risk analysis",
            "default": ""
          },
          "processing_time_ms": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Processing Time Ms",
            "description": "Time taken for inference in milliseconds"
          },
          "tokens_used": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Tokens Used",
            "description": "Number of tokens used in inference"
          }
        },
        "type": "object",
        "required": [
          "risk_score",
          "risk_level",
          "reasoning",
          "summary",
          "processing_time_ms",
          "tokens_used"
        ],
        "title": "CustomTestPromptResponse",
        "description": "Response from testing a custom prompt against an event.\n\nResults are NOT persisted - this is for A/B testing only.",
        "example": {
          "entities": [
            {
              "bbox": [120, 80, 340, 520],
              "confidence": 0.92,
              "type": "person"
            },
            {
              "bbox": [180, 400, 260, 480],
              "confidence": 0.87,
              "type": "package"
            }
          ],
          "flags": [],
          "processing_time_ms": 1250,
          "reasoning": "Person detected approaching front door during normal business hours. No suspicious behavior patterns observed - appears to be routine delivery activity based on movement patterns and timing.",
          "recommended_action": "Review - Check event details when convenient",
          "risk_level": "medium",
          "risk_score": 45,
          "summary": "Routine visitor activity at front entrance.",
          "tokens_used": 825
        }
      },
      "DLQClearResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether the clear operation succeeded. True even if the queue was already empty."
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable status message including the count of deleted jobs. Format: 'Cleared N jobs from {queue_name}'."
          },
          "queue_name": {
            "type": "string",
            "title": "Queue Name",
            "description": "Name of the cleared queue (e.g., 'dlq:detection_queue')."
          }
        },
        "type": "object",
        "required": ["success", "message", "queue_name"],
        "title": "DLQClearResponse",
        "description": "Response schema for clearing a DLQ.\n\nWARNING: This is a destructive operation. Cleared jobs cannot be recovered.",
        "example": {
          "message": "Cleared 5 jobs from dlq:detection_queue",
          "queue_name": "dlq:detection_queue",
          "success": true
        }
      },
      "DLQJobResponse": {
        "properties": {
          "original_job": {
            "additionalProperties": true,
            "type": "object",
            "title": "Original Job",
            "description": "Original job payload that failed"
          },
          "error": {
            "type": "string",
            "title": "Error",
            "description": "Error message from the last failure attempt"
          },
          "attempt_count": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Attempt Count",
            "description": "Number of processing attempts made"
          },
          "first_failed_at": {
            "type": "string",
            "title": "First Failed At",
            "description": "ISO timestamp of the first failure"
          },
          "last_failed_at": {
            "type": "string",
            "title": "Last Failed At",
            "description": "ISO timestamp of the last failure"
          },
          "queue_name": {
            "type": "string",
            "title": "Queue Name",
            "description": "Name of the original queue where the job came from"
          },
          "error_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error Type",
            "description": "Exception class name (e.g., 'ConnectionRefusedError')"
          },
          "stack_trace": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stack Trace",
            "description": "Truncated stack trace (max 4KB) for debugging"
          },
          "http_status": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Http Status",
            "description": "HTTP status code if the error was from a network request"
          },
          "response_body": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Response Body",
            "description": "Truncated response body (max 2KB) from AI service"
          },
          "retry_delays": {
            "anyOf": [
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Retry Delays",
            "description": "Delays (in seconds) applied between retry attempts"
          },
          "context": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Context",
            "description": "System state snapshot at failure time (queue depths, circuit breaker states)"
          }
        },
        "type": "object",
        "required": [
          "original_job",
          "error",
          "attempt_count",
          "first_failed_at",
          "last_failed_at",
          "queue_name"
        ],
        "title": "DLQJobResponse",
        "description": "Response schema for a single job in the dead-letter queue.\n\nIncludes enriched error context (NEM-1474) for faster debugging:\n- error_type: Exception class name for categorization\n- stack_trace: Truncated stack trace for debugging\n- http_status: HTTP status code (for network errors)\n- response_body: Truncated AI service response (for debugging)\n- retry_delays: Delays applied between retry attempts\n- context: System state snapshot at failure time",
        "example": {
          "attempt_count": 3,
          "context": {
            "analysis_queue_depth": 25,
            "detection_queue_depth": 150,
            "dlq_circuit_breaker_state": "closed"
          },
          "error": "Connection refused: detector service unavailable",
          "error_type": "ConnectionRefusedError",
          "first_failed_at": "2025-12-23T10:30:05.000000",
          "last_failed_at": "2025-12-23T10:30:15.000000",
          "original_job": {
            "camera_id": "front_door",
            "file_path": "/export/foscam/front_door/image_001.jpg",
            "timestamp": "2025-12-23T10:30:00.000000"
          },
          "queue_name": "detection_queue",
          "retry_delays": [1.0, 2.0],
          "stack_trace": "Traceback (most recent call last):\n  ..."
        }
      },
      "DLQJobsResponse": {
        "properties": {
          "queue_name": {
            "type": "string",
            "title": "Queue Name",
            "description": "Name of the dead-letter queue (e.g., 'dlq:detection_queue')"
          },
          "jobs": {
            "items": {
              "$ref": "#/components/schemas/DLQJobResponse"
            },
            "type": "array",
            "title": "Jobs",
            "description": "List of jobs in the queue with enriched error context"
          },
          "count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Count",
            "description": "Number of jobs returned in this response (may be less than total in queue due to pagination)"
          }
        },
        "type": "object",
        "required": ["queue_name", "jobs", "count"],
        "title": "DLQJobsResponse",
        "description": "Response schema for listing jobs in a DLQ.\n\nContains a paginated list of failed jobs with enriched error context\nfor debugging and categorization.",
        "example": {
          "count": 1,
          "jobs": [
            {
              "attempt_count": 3,
              "context": {
                "analysis_queue_depth": 25,
                "detection_queue_depth": 150,
                "dlq_circuit_breaker_state": "closed"
              },
              "error": "Connection refused: detector service unavailable",
              "error_type": "ConnectionRefusedError",
              "first_failed_at": "2025-12-23T10:30:05.000000",
              "last_failed_at": "2025-12-23T10:30:15.000000",
              "original_job": {
                "camera_id": "front_door",
                "file_path": "/export/foscam/front_door/image_001.jpg",
                "timestamp": "2025-12-23T10:30:00.000000"
              },
              "queue_name": "detection_queue",
              "retry_delays": [1.0, 2.0],
              "stack_trace": "Traceback (most recent call last):\n  File \"/app/backend/services/detector_client.py\", line 45, in detect\n    ..."
            }
          ],
          "queue_name": "dlq:detection_queue"
        }
      },
      "DLQName": {
        "type": "string",
        "enum": ["dlq:detection_queue", "dlq:analysis_queue"],
        "title": "DLQName",
        "description": "Available dead-letter queue names.\n\nThe system has two dead-letter queues corresponding to the two stages\nof the AI processing pipeline:\n\n- DETECTION: Jobs that failed during RT-DETRv2 object detection\n  (e.g., detector service unavailable, image processing errors)\n- ANALYSIS: Jobs that failed during Nemotron risk analysis\n  (e.g., LLM service unavailable, response parsing errors)\n\nEach DLQ stores failed jobs with enriched error context for debugging."
      },
      "DLQRequeueResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether the requeue operation succeeded. False if the DLQ was empty or the operation failed."
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable status message describing the result. Includes count of requeued jobs and target queue name."
          },
          "job": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Job",
            "description": "The requeued job data (if available). Note: Currently always None as job data is not preserved during the move operation."
          }
        },
        "type": "object",
        "required": ["success", "message"],
        "title": "DLQRequeueResponse",
        "description": "Response schema for requeuing job(s) from a DLQ.\n\nUsed by both single-job requeue (`/requeue/{queue_name}`) and\nbulk requeue (`/requeue-all/{queue_name}`) endpoints.",
        "example": {
          "message": "Job requeued from dlq:detection_queue to detection_queue",
          "success": true
        }
      },
      "DLQStatsResponse": {
        "properties": {
          "detection_queue_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Detection Queue Count",
            "description": "Number of jobs in the detection DLQ (dlq:detection_queue). These are jobs that failed during RT-DETRv2 object detection."
          },
          "analysis_queue_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Analysis Queue Count",
            "description": "Number of jobs in the analysis DLQ (dlq:analysis_queue). These are jobs that failed during Nemotron risk analysis."
          },
          "total_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Count",
            "description": "Total number of failed jobs across all DLQs. High values may indicate systemic issues with AI services."
          }
        },
        "type": "object",
        "required": ["detection_queue_count", "analysis_queue_count", "total_count"],
        "title": "DLQStatsResponse",
        "description": "Response schema for DLQ statistics.\n\nProvides counts of failed jobs in each dead-letter queue, useful for\nmonitoring the health of the AI processing pipeline and identifying\nwhen jobs are failing at a particular stage.",
        "example": {
          "analysis_queue_count": 1,
          "detection_queue_count": 2,
          "total_count": 3
        }
      },
      "DailyPattern": {
        "properties": {
          "avg_detections": {
            "type": "number",
            "minimum": 0.0,
            "title": "Avg Detections",
            "description": "Average number of detections for this day"
          },
          "peak_hour": {
            "type": "integer",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Peak Hour",
            "description": "Hour with most activity (0-23)"
          },
          "total_samples": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Samples",
            "description": "Total samples for this day"
          }
        },
        "type": "object",
        "required": ["avg_detections", "peak_hour", "total_samples"],
        "title": "DailyPattern",
        "description": "Activity pattern for a specific day of the week.",
        "example": {
          "avg_detections": 45.0,
          "peak_hour": 17,
          "total_samples": 168
        }
      },
      "DebugCircuitBreakersResponse": {
        "properties": {
          "circuit_breakers": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "object",
            "title": "Circuit Breakers",
            "description": "All circuit breaker states keyed by name with state, failure_count, config",
            "example": {
              "nemotron": {
                "failure_count": 0,
                "rejected_calls": 0,
                "state": "CLOSED",
                "success_count": 0,
                "total_calls": 50
              },
              "rtdetr": {
                "failure_count": 0,
                "rejected_calls": 0,
                "state": "CLOSED",
                "success_count": 0,
                "total_calls": 150
              }
            }
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when circuit breaker status was retrieved",
            "example": "2025-12-30T10:30:00Z"
          }
        },
        "type": "object",
        "required": ["circuit_breakers", "timestamp"],
        "title": "DebugCircuitBreakersResponse",
        "description": "Response for circuit breaker states.\n\nReturns status information for all registered circuit breakers in the system,\nincluding AI services, WebSocket broadcasters, and external service clients.\nCircuit breakers prevent cascading failures by temporarily stopping calls\nto failing services."
      },
      "DebugConfigResponse": {
        "properties": {
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "Current configuration dict with sensitive values showing [REDACTED]",
            "example": {
              "app_name": "Home Security Intelligence",
              "database_url": "postgresql+asyncpg://user:[REDACTED]@localhost:5432/db",
              "debug": true,
              "redis_url": "redis://localhost:6379/0",
              "retention_days": 30
            }
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when configuration was retrieved",
            "example": "2025-12-30T10:30:00Z"
          }
        },
        "type": "object",
        "required": ["config", "timestamp"],
        "title": "DebugConfigResponse",
        "description": "Response for configuration inspection.\n\nReturns all application configuration settings with sensitive values\n(passwords, API keys, secrets) automatically redacted. URLs containing\ncredentials have only the password portion redacted, preserving structure."
      },
      "DebugWebSocketBroadcasterStatus": {
        "properties": {
          "connection_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Connection Count",
            "description": "Number of active WebSocket client connections",
            "example": 3
          },
          "is_listening": {
            "type": "boolean",
            "title": "Is Listening",
            "description": "Whether the broadcaster is actively listening for Redis pub/sub events"
          },
          "is_degraded": {
            "type": "boolean",
            "title": "Is Degraded",
            "description": "Whether the broadcaster has fallen back to degraded mode due to errors"
          },
          "circuit_state": {
            "type": "string",
            "title": "Circuit State",
            "description": "Circuit breaker state: CLOSED (normal), OPEN (failing), HALF_OPEN (testing), UNKNOWN",
            "example": "CLOSED"
          },
          "channel_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Channel Name",
            "description": "Redis pub/sub channel being monitored (null for system broadcaster)",
            "example": "events"
          }
        },
        "type": "object",
        "required": ["connection_count", "is_listening", "is_degraded", "circuit_state"],
        "title": "DebugWebSocketBroadcasterStatus",
        "description": "Status of a WebSocket broadcaster.\n\nTracks the health of WebSocket broadcasters including connection counts,\ncircuit breaker state, and degradation mode for resilient real-time updates."
      },
      "DegradationModeEnum": {
        "type": "string",
        "enum": ["normal", "degraded", "minimal", "offline"],
        "title": "DegradationModeEnum",
        "description": "System degradation modes."
      },
      "DegradationStatusResponse": {
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/DegradationModeEnum",
            "description": "Current degradation mode"
          },
          "is_degraded": {
            "type": "boolean",
            "title": "Is Degraded",
            "description": "Whether system is in any degraded state"
          },
          "redis_healthy": {
            "type": "boolean",
            "title": "Redis Healthy",
            "description": "Whether Redis is healthy"
          },
          "memory_queue_size": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Memory Queue Size",
            "description": "Number of jobs in in-memory fallback queue"
          },
          "fallback_queues": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Fallback Queues",
            "description": "Count of items in disk-based fallback queues by name"
          },
          "services": {
            "items": {
              "$ref": "#/components/schemas/ServiceHealthStatusResponse"
            },
            "type": "array",
            "title": "Services",
            "description": "Health status of registered services"
          },
          "available_features": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Available Features",
            "description": "Features available in current degradation mode"
          }
        },
        "type": "object",
        "required": ["mode", "is_degraded", "redis_healthy", "memory_queue_size"],
        "title": "DegradationStatusResponse",
        "description": "Status information for the DegradationManager service.",
        "example": {
          "available_features": ["detection", "analysis", "events", "media"],
          "fallback_queues": {},
          "is_degraded": false,
          "memory_queue_size": 0,
          "mode": "normal",
          "redis_healthy": true,
          "services": [
            {
              "consecutive_failures": 0,
              "last_check": 1735500000.0,
              "name": "rtdetr",
              "status": "healthy"
            }
          ]
        }
      },
      "DepthEnrichment": {
        "properties": {
          "estimated_distance_m": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Estimated Distance M",
            "description": "Estimated distance in meters"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Estimation confidence"
          }
        },
        "type": "object",
        "title": "DepthEnrichment",
        "description": "Depth estimation results (placeholder for future Depth Anything V2).",
        "example": {
          "confidence": 0.78,
          "estimated_distance_m": 4.2
        }
      },
      "DetectionBulkCreateItem": {
        "properties": {
          "camera_id": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_-]+$",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "object_type": {
            "type": "string",
            "maxLength": 100,
            "minLength": 1,
            "title": "Object Type",
            "description": "Object type (person, vehicle, etc.)"
          },
          "confidence": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Confidence",
            "description": "Confidence score (0.0-1.0)"
          },
          "detected_at": {
            "type": "string",
            "format": "date-time",
            "title": "Detected At",
            "description": "Detection timestamp"
          },
          "file_path": {
            "type": "string",
            "maxLength": 1000,
            "minLength": 1,
            "title": "File Path",
            "description": "Image file path"
          },
          "bbox_x": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Bbox X",
            "description": "Bounding box X coordinate"
          },
          "bbox_y": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Bbox Y",
            "description": "Bounding box Y coordinate"
          },
          "bbox_width": {
            "type": "integer",
            "exclusiveMinimum": 0.0,
            "title": "Bbox Width",
            "description": "Bounding box width"
          },
          "bbox_height": {
            "type": "integer",
            "exclusiveMinimum": 0.0,
            "title": "Bbox Height",
            "description": "Bounding box height"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enrichment Data",
            "description": "Enrichment pipeline results"
          }
        },
        "type": "object",
        "required": [
          "camera_id",
          "object_type",
          "confidence",
          "detected_at",
          "file_path",
          "bbox_x",
          "bbox_y",
          "bbox_width",
          "bbox_height"
        ],
        "title": "DetectionBulkCreateItem",
        "description": "Schema for a single detection in a bulk create request.\n\nAttributes:\n    camera_id: Camera ID that captured this detection\n    object_type: Type of detected object (person, vehicle, etc.)\n    confidence: Detection confidence score (0.0-1.0)\n    detected_at: Detection timestamp\n    file_path: Path to the detection image\n    bbox_x: Bounding box X coordinate\n    bbox_y: Bounding box Y coordinate\n    bbox_width: Bounding box width\n    bbox_height: Bounding box height\n    enrichment_data: Optional enrichment pipeline results"
      },
      "DetectionBulkCreateRequest": {
        "properties": {
          "detections": {
            "items": {
              "$ref": "#/components/schemas/DetectionBulkCreateItem"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Detections",
            "description": "Detections to create (max 100)"
          }
        },
        "type": "object",
        "required": ["detections"],
        "title": "DetectionBulkCreateRequest",
        "description": "Request schema for bulk detection creation.\n\nAttributes:\n    detections: List of detections to create (max 100 per request)"
      },
      "DetectionBulkCreateResponse": {
        "properties": {
          "total": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total",
            "description": "Total number of items in the request"
          },
          "succeeded": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Succeeded",
            "description": "Number of successful operations"
          },
          "failed": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Failed",
            "description": "Number of failed operations"
          },
          "skipped": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Skipped",
            "description": "Number of skipped operations",
            "default": 0
          },
          "results": {
            "items": {
              "$ref": "#/components/schemas/BulkItemResult"
            },
            "type": "array",
            "title": "Results",
            "description": "Per-item results"
          }
        },
        "type": "object",
        "required": ["total", "succeeded", "failed"],
        "title": "DetectionBulkCreateResponse",
        "description": "Response schema for bulk detection creation.\n\nExtends BulkOperationResponse with created detection IDs."
      },
      "DetectionBulkDeleteRequest": {
        "properties": {
          "detection_ids": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Detection Ids",
            "description": "Detection IDs to delete (max 100)"
          }
        },
        "type": "object",
        "required": ["detection_ids"],
        "title": "DetectionBulkDeleteRequest",
        "description": "Request schema for bulk detection deletion.\n\nNote: Detection deletion is always hard delete as detections\nare raw data and soft-delete is not supported.\n\nAttributes:\n    detection_ids: List of detection IDs to delete (max 100 per request)"
      },
      "DetectionBulkUpdateItem": {
        "properties": {
          "id": {
            "type": "integer",
            "exclusiveMinimum": 0.0,
            "title": "Id",
            "description": "Detection ID to update"
          },
          "object_type": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 100,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Type",
            "description": "Object type"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Confidence score"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enrichment Data",
            "description": "Enrichment pipeline results"
          }
        },
        "type": "object",
        "required": ["id"],
        "title": "DetectionBulkUpdateItem",
        "description": "Schema for a single detection update in a bulk update request.\n\nAttributes:\n    id: Detection ID to update\n    object_type: Updated object type\n    confidence: Updated confidence score\n    enrichment_data: Updated enrichment data"
      },
      "DetectionBulkUpdateRequest": {
        "properties": {
          "detections": {
            "items": {
              "$ref": "#/components/schemas/DetectionBulkUpdateItem"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Detections",
            "description": "Detection updates (max 100)"
          }
        },
        "type": "object",
        "required": ["detections"],
        "title": "DetectionBulkUpdateRequest",
        "description": "Request schema for bulk detection updates.\n\nAttributes:\n    detections: List of detection updates (max 100 per request)"
      },
      "DetectionListResponse": {
        "properties": {
          "detections": {
            "items": {
              "$ref": "#/components/schemas/DetectionResponse"
            },
            "type": "array",
            "title": "Detections",
            "description": "List of detections"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Total number of detections matching filters"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Maximum number of results returned"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Number of results skipped (deprecated, use cursor)"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Cursor",
            "description": "Cursor for fetching the next page. Pass this as the 'cursor' parameter."
          },
          "has_more": {
            "type": "boolean",
            "title": "Has More",
            "description": "Whether there are more results available after this page",
            "default": false
          },
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Deprecation Warning",
            "description": "Warning message when using deprecated offset pagination"
          }
        },
        "type": "object",
        "required": ["detections", "count", "limit", "offset"],
        "title": "DetectionListResponse",
        "description": "Schema for detection list response with pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nUse cursor-based pagination for better performance with large datasets.",
        "example": {
          "count": 1,
          "detections": [
            {
              "bbox_height": 400,
              "bbox_width": 200,
              "bbox_x": 100,
              "bbox_y": 150,
              "camera_id": "front_door",
              "confidence": 0.95,
              "detected_at": "2025-12-23T12:00:00Z",
              "file_path": "/export/foscam/front_door/20251223_120000.jpg",
              "file_type": "image/jpeg",
              "id": 1,
              "object_type": "person",
              "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
            }
          ],
          "has_more": false,
          "limit": 50,
          "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=",
          "offset": 0
        }
      },
      "DetectionResponse": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Detection ID"
          },
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Normalized camera ID (e.g., 'front_door')"
          },
          "file_path": {
            "type": "string",
            "title": "File Path",
            "description": "Path to source image or video file"
          },
          "file_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Type",
            "description": "MIME type of source file"
          },
          "detected_at": {
            "type": "string",
            "format": "date-time",
            "title": "Detected At",
            "description": "Timestamp when detection was made"
          },
          "object_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Type",
            "description": "Type of detected object (person, car, etc.)"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Detection confidence score (0-1)"
          },
          "bbox_x": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox X",
            "description": "Bounding box X coordinate"
          },
          "bbox_y": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox Y",
            "description": "Bounding box Y coordinate"
          },
          "bbox_width": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox Width",
            "description": "Bounding box width"
          },
          "bbox_height": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox Height",
            "description": "Bounding box height"
          },
          "thumbnail_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Thumbnail Path",
            "description": "Path to thumbnail image with bbox overlay"
          },
          "media_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Media Type",
            "description": "Media type: 'image' or 'video'",
            "default": "image"
          },
          "duration": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Duration",
            "description": "Video duration in seconds (video only)"
          },
          "video_codec": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Video Codec",
            "description": "Video codec (e.g., h264, hevc)"
          },
          "video_width": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Video Width",
            "description": "Video resolution width"
          },
          "video_height": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Video Height",
            "description": "Video resolution height"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enrichment Data",
            "description": "AI enrichment data including vehicle classification, pet identification, person attributes, license plates, weather, and image quality scores"
          }
        },
        "type": "object",
        "required": ["id", "camera_id", "file_path", "detected_at"],
        "title": "DetectionResponse",
        "description": "Schema for detection response.",
        "example": {
          "bbox_height": 400,
          "bbox_width": 200,
          "bbox_x": 100,
          "bbox_y": 150,
          "camera_id": "front_door",
          "confidence": 0.95,
          "detected_at": "2025-12-23T12:00:00Z",
          "enrichment_data": {
            "errors": [],
            "person": {
              "action": "walking",
              "carrying": ["backpack"],
              "clothing_description": "dark jacket",
              "is_suspicious": false
            },
            "vehicle": {
              "has_damage": false,
              "is_commercial": false,
              "vehicle_color": "blue",
              "vehicle_type": "sedan"
            },
            "weather": "sunny"
          },
          "file_path": "/export/foscam/front_door/20251223_120000.jpg",
          "file_type": "image/jpeg",
          "id": 1,
          "media_type": "image",
          "object_type": "person",
          "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
        }
      },
      "DetectionStatsResponse": {
        "properties": {
          "total_detections": {
            "type": "integer",
            "title": "Total Detections",
            "description": "Total number of detections"
          },
          "detections_by_class": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Detections By Class",
            "description": "Detection counts grouped by object class (e.g., person, car, truck)"
          },
          "average_confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Average Confidence",
            "description": "Average confidence score across all detections"
          }
        },
        "type": "object",
        "required": ["total_detections", "detections_by_class"],
        "title": "DetectionStatsResponse",
        "description": "Schema for detection statistics response.\n\nReturns aggregate statistics about detections including counts by object class.\nUsed by the AI Performance page to display detection class distribution.",
        "example": {
          "average_confidence": 0.87,
          "detections_by_class": {
            "bicycle": 1,
            "car": 20,
            "person": 23,
            "truck": 6
          },
          "total_detections": 107
        }
      },
      "DetectionTrendDataPoint": {
        "properties": {
          "date": {
            "type": "string",
            "format": "date",
            "title": "Date",
            "description": "Date of the data point"
          },
          "count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Count",
            "description": "Number of detections on this date"
          }
        },
        "type": "object",
        "required": ["date", "count"],
        "title": "DetectionTrendDataPoint",
        "description": "Schema for a single detection trend data point.",
        "example": {
          "count": 25,
          "date": "2025-01-07"
        }
      },
      "DetectionTrendsResponse": {
        "properties": {
          "data_points": {
            "items": {
              "$ref": "#/components/schemas/DetectionTrendDataPoint"
            },
            "type": "array",
            "title": "Data Points",
            "description": "Detection counts aggregated by day"
          },
          "total_detections": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Detections",
            "description": "Total detections in date range"
          },
          "start_date": {
            "type": "string",
            "format": "date",
            "title": "Start Date",
            "description": "Start date of the date range"
          },
          "end_date": {
            "type": "string",
            "format": "date",
            "title": "End Date",
            "description": "End date of the date range"
          }
        },
        "type": "object",
        "required": ["data_points", "total_detections", "start_date", "end_date"],
        "title": "DetectionTrendsResponse",
        "description": "Schema for detection trends aggregated by day.",
        "example": {
          "data_points": [
            {
              "count": 20,
              "date": "2025-01-01"
            },
            {
              "count": 25,
              "date": "2025-01-02"
            },
            {
              "count": 18,
              "date": "2025-01-03"
            }
          ],
          "end_date": "2025-01-03",
          "start_date": "2025-01-01",
          "total_detections": 63
        }
      },
      "DeviationInterpretation": {
        "type": "string",
        "enum": [
          "far_below_normal",
          "below_normal",
          "normal",
          "slightly_above_normal",
          "above_normal",
          "far_above_normal"
        ],
        "title": "DeviationInterpretation",
        "description": "Interpretation of current deviation from baseline."
      },
      "EnrichmentResponse": {
        "properties": {
          "detection_id": {
            "type": "integer",
            "title": "Detection Id",
            "description": "Detection ID"
          },
          "enriched_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enriched At",
            "description": "Timestamp when enrichment was performed"
          },
          "license_plate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LicensePlateEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "title": "License Plate",
            "description": "License plate detection results"
          },
          "face": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FaceEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "title": "Face",
            "description": "Face detection results"
          },
          "vehicle": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VehicleEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Vehicle",
            "description": "Vehicle classification results"
          },
          "clothing": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ClothingEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Clothing",
            "description": "Clothing analysis results"
          },
          "violence": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ViolenceEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "title": "Violence",
            "description": "Violence detection results"
          },
          "weather": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WeatherEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Weather",
            "description": "Weather classification results"
          },
          "pose": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PoseEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pose",
            "description": "Pose estimation results"
          },
          "depth": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DepthEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Depth",
            "description": "Depth estimation results"
          },
          "image_quality": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ImageQualityEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Image Quality",
            "description": "Image quality assessment"
          },
          "pet": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PetEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pet",
            "description": "Pet classification results"
          },
          "processing_time_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Processing Time Ms",
            "description": "Enrichment processing time in milliseconds"
          },
          "errors": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Errors",
            "description": "Errors encountered during enrichment"
          }
        },
        "type": "object",
        "required": ["detection_id"],
        "title": "EnrichmentResponse",
        "description": "Structured enrichment data for a single detection.\n\nContains results from all vision models run during the enrichment pipeline.",
        "example": {
          "clothing": {
            "lower": "blue jeans",
            "upper": "red t-shirt"
          },
          "detection_id": 12345,
          "enriched_at": "2026-01-03T10:30:00Z",
          "errors": [],
          "face": {
            "confidence": 0.88,
            "count": 1,
            "detected": true
          },
          "image_quality": {
            "is_blurry": false,
            "score": 0.85
          },
          "license_plate": {
            "confidence": 0.92,
            "detected": true,
            "text": "ABC-1234"
          },
          "processing_time_ms": 125.5,
          "vehicle": {
            "color": "silver",
            "confidence": 0.91,
            "type": "sedan"
          },
          "violence": {
            "detected": false,
            "score": 0.12
          },
          "weather": {
            "condition": "clear",
            "confidence": 0.95
          }
        }
      },
      "EnrichmentStatusEnum": {
        "type": "string",
        "enum": ["full", "partial", "failed", "skipped"],
        "title": "EnrichmentStatusEnum",
        "description": "Status of enrichment pipeline execution for an event.\n\nValues:\n    full: All enrichment models succeeded\n    partial: Some models succeeded, some failed\n    failed: All models failed (no enrichment data)\n    skipped: Enrichment was not attempted"
      },
      "EnrichmentStatusResponse": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/EnrichmentStatusEnum",
            "description": "Overall enrichment status (full, partial, failed, skipped)"
          },
          "successful_models": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Successful Models",
            "description": "List of enrichment models that succeeded"
          },
          "failed_models": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Failed Models",
            "description": "List of enrichment models that failed"
          },
          "errors": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Errors",
            "description": "Model name to error message mapping"
          },
          "success_rate": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Success Rate",
            "description": "Success rate (0.0 to 1.0)"
          }
        },
        "type": "object",
        "required": ["status", "success_rate"],
        "title": "EnrichmentStatusResponse",
        "description": "Schema for enrichment status in event responses (NEM-1672).\n\nProvides visibility into which enrichment models succeeded/failed\nfor a given event, instead of silently degrading.",
        "example": {
          "errors": {
            "clothing": "Model not loaded"
          },
          "failed_models": ["clothing"],
          "status": "partial",
          "success_rate": 0.75,
          "successful_models": ["violence", "weather", "face"]
        }
      },
      "EntityAppearance": {
        "properties": {
          "detection_id": {
            "type": "string",
            "title": "Detection Id",
            "description": "Detection ID from original detection"
          },
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID where entity was seen"
          },
          "camera_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Camera Name",
            "description": "Human-readable camera name"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "When the entity was detected"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Thumbnail Url",
            "description": "URL to thumbnail image of this appearance"
          },
          "similarity_score": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Similarity Score",
            "description": "Similarity score to the entity's reference embedding"
          },
          "attributes": {
            "additionalProperties": true,
            "type": "object",
            "title": "Attributes",
            "description": "Additional attributes extracted from the detection (clothing, carrying, etc.)"
          }
        },
        "type": "object",
        "required": ["detection_id", "camera_id", "timestamp"],
        "title": "EntityAppearance",
        "description": "Schema for a single entity appearance at a specific time and camera.\n\nRepresents one sighting of an entity, including the detection it came from\nand additional attributes extracted from the image.",
        "example": {
          "attributes": {
            "carrying": "backpack",
            "clothing": "blue jacket"
          },
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "detection_id": "det_abc123",
          "similarity_score": 0.92,
          "thumbnail_url": "/api/detections/123/image",
          "timestamp": "2025-12-23T14:30:00Z"
        }
      },
      "EntityDetail": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique entity identifier"
          },
          "entity_type": {
            "type": "string",
            "title": "Entity Type",
            "description": "Type of entity: 'person' or 'vehicle'"
          },
          "first_seen": {
            "type": "string",
            "format": "date-time",
            "title": "First Seen",
            "description": "Timestamp of first appearance"
          },
          "last_seen": {
            "type": "string",
            "format": "date-time",
            "title": "Last Seen",
            "description": "Timestamp of most recent appearance"
          },
          "appearance_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Appearance Count",
            "description": "Total number of appearances"
          },
          "cameras_seen": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Cameras Seen",
            "description": "List of camera IDs where entity was detected"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Thumbnail Url",
            "description": "URL to the most recent thumbnail image"
          },
          "appearances": {
            "items": {
              "$ref": "#/components/schemas/EntityAppearance"
            },
            "type": "array",
            "title": "Appearances",
            "description": "List of all appearances for this entity"
          }
        },
        "type": "object",
        "required": ["id", "entity_type", "first_seen", "last_seen", "appearance_count"],
        "title": "EntityDetail",
        "description": "Schema for detailed entity information including appearance history.\n\nExtends EntitySummary with the full list of appearances.",
        "example": {
          "appearance_count": 3,
          "appearances": [
            {
              "attributes": {
                "clothing": "blue jacket"
              },
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_id": "det_001",
              "similarity_score": 1.0,
              "thumbnail_url": "/api/detections/1/image",
              "timestamp": "2025-12-23T10:00:00Z"
            },
            {
              "attributes": {
                "carrying": "bag",
                "clothing": "blue jacket"
              },
              "camera_id": "backyard",
              "camera_name": "Backyard",
              "detection_id": "det_002",
              "similarity_score": 0.94,
              "thumbnail_url": "/api/detections/2/image",
              "timestamp": "2025-12-23T12:15:00Z"
            }
          ],
          "cameras_seen": ["front_door", "backyard"],
          "entity_type": "person",
          "first_seen": "2025-12-23T10:00:00Z",
          "id": "entity_abc123",
          "last_seen": "2025-12-23T14:30:00Z",
          "thumbnail_url": "/api/detections/123/image"
        }
      },
      "EntityHistoryResponse": {
        "properties": {
          "entity_id": {
            "type": "string",
            "title": "Entity Id",
            "description": "Entity identifier"
          },
          "entity_type": {
            "type": "string",
            "title": "Entity Type",
            "description": "Type of entity"
          },
          "appearances": {
            "items": {
              "$ref": "#/components/schemas/EntityAppearance"
            },
            "type": "array",
            "title": "Appearances",
            "description": "List of appearances in chronological order"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Total number of appearances"
          }
        },
        "type": "object",
        "required": ["entity_id", "entity_type", "appearances", "count"],
        "title": "EntityHistoryResponse",
        "description": "Schema for entity appearance history response.",
        "example": {
          "appearances": [
            {
              "attributes": {},
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_id": "det_001",
              "similarity_score": 1.0,
              "thumbnail_url": "/api/detections/1/image",
              "timestamp": "2025-12-23T10:00:00Z"
            }
          ],
          "count": 1,
          "entity_id": "entity_abc123",
          "entity_type": "person"
        }
      },
      "EntityListResponse": {
        "properties": {
          "entities": {
            "items": {
              "$ref": "#/components/schemas/EntitySummary"
            },
            "type": "array",
            "title": "Entities",
            "description": "List of tracked entities"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Total number of entities matching filters"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Maximum number of results returned"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Number of results skipped"
          }
        },
        "type": "object",
        "required": ["entities", "count", "limit", "offset"],
        "title": "EntityListResponse",
        "description": "Schema for paginated entity list response.",
        "example": {
          "count": 1,
          "entities": [
            {
              "appearance_count": 5,
              "cameras_seen": ["front_door", "backyard"],
              "entity_type": "person",
              "first_seen": "2025-12-23T10:00:00Z",
              "id": "entity_abc123",
              "last_seen": "2025-12-23T14:30:00Z",
              "thumbnail_url": "/api/detections/123/image"
            }
          ],
          "limit": 50,
          "offset": 0
        }
      },
      "EntitySummary": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique entity identifier"
          },
          "entity_type": {
            "type": "string",
            "title": "Entity Type",
            "description": "Type of entity: 'person' or 'vehicle'"
          },
          "first_seen": {
            "type": "string",
            "format": "date-time",
            "title": "First Seen",
            "description": "Timestamp of first appearance"
          },
          "last_seen": {
            "type": "string",
            "format": "date-time",
            "title": "Last Seen",
            "description": "Timestamp of most recent appearance"
          },
          "appearance_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Appearance Count",
            "description": "Total number of appearances"
          },
          "cameras_seen": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Cameras Seen",
            "description": "List of camera IDs where entity was detected"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Thumbnail Url",
            "description": "URL to the most recent thumbnail image"
          }
        },
        "type": "object",
        "required": ["id", "entity_type", "first_seen", "last_seen", "appearance_count"],
        "title": "EntitySummary",
        "description": "Schema for entity summary in list responses.\n\nProvides an overview of a tracked entity without the full appearance history.",
        "example": {
          "appearance_count": 5,
          "cameras_seen": ["front_door", "backyard", "driveway"],
          "entity_type": "person",
          "first_seen": "2025-12-23T10:00:00Z",
          "id": "entity_abc123",
          "last_seen": "2025-12-23T14:30:00Z",
          "thumbnail_url": "/api/detections/123/image"
        }
      },
      "EntityTypeEnum": {
        "type": "string",
        "enum": ["person", "vehicle"],
        "title": "EntityTypeEnum",
        "description": "Valid entity types for filtering."
      },
      "EventAuditResponse": {
        "properties": {
          "id": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Id",
            "description": "Unique audit record ID"
          },
          "event_id": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Event Id",
            "description": "ID of the audited event"
          },
          "audited_at": {
            "type": "string",
            "format": "date-time",
            "title": "Audited At",
            "description": "When the audit was created (UTC)"
          },
          "is_fully_evaluated": {
            "type": "boolean",
            "title": "Is Fully Evaluated",
            "description": "Whether full self-evaluation has been run"
          },
          "contributions": {
            "$ref": "#/components/schemas/ModelContributions",
            "description": "Which AI models contributed to the event analysis"
          },
          "prompt_length": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Prompt Length",
            "description": "Character count of the LLM prompt"
          },
          "prompt_token_estimate": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Prompt Token Estimate",
            "description": "Estimated token count (chars/4)"
          },
          "enrichment_utilization": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Enrichment Utilization",
            "description": "Fraction of enrichments used in reasoning (0-1)"
          },
          "scores": {
            "$ref": "#/components/schemas/QualityScores",
            "description": "Self-evaluation rubric scores (1-5 scale)"
          },
          "consistency_risk_score": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Consistency Risk Score",
            "description": "Risk score from consistency re-evaluation"
          },
          "consistency_diff": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Consistency Diff",
            "description": "Difference between original and consistency risk scores"
          },
          "self_eval_critique": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Self Eval Critique",
            "description": "LLM's self-critique text identifying blind spots"
          },
          "improvements": {
            "$ref": "#/components/schemas/PromptImprovements",
            "description": "Suggestions for improving the prompt template"
          }
        },
        "type": "object",
        "required": [
          "id",
          "event_id",
          "audited_at",
          "is_fully_evaluated",
          "contributions",
          "prompt_length",
          "prompt_token_estimate",
          "enrichment_utilization",
          "scores",
          "improvements"
        ],
        "title": "EventAuditResponse",
        "description": "Full audit response containing all evaluation data for a single event.\n\nIncludes model contributions, quality scores, consistency metrics,\nand prompt improvement suggestions.",
        "example": {
          "audited_at": "2026-01-03T10:30:00Z",
          "consistency_diff": 3,
          "consistency_risk_score": 72,
          "contributions": {
            "baseline": false,
            "clip": false,
            "clothing": true,
            "cross_camera": false,
            "florence": true,
            "image_quality": true,
            "pet": false,
            "rtdetr": true,
            "vehicle": false,
            "violence": false,
            "weather": true,
            "zones": true
          },
          "enrichment_utilization": 0.85,
          "event_id": 42,
          "id": 1,
          "improvements": {
            "confusing_sections": [],
            "format_suggestions": [],
            "missing_context": ["time since last event"],
            "model_gaps": [],
            "unused_data": ["weather data not referenced"]
          },
          "is_fully_evaluated": true,
          "prompt_length": 2500,
          "prompt_token_estimate": 625,
          "scores": {
            "consistency": 4.3,
            "context_usage": 4.2,
            "overall": 4.25,
            "reasoning_coherence": 4.5,
            "risk_justification": 4.0
          },
          "self_eval_critique": "Good context usage but could include more temporal patterns."
        }
      },
      "EventBulkCreateItem": {
        "properties": {
          "camera_id": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_-]+$",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "started_at": {
            "type": "string",
            "format": "date-time",
            "title": "Started At",
            "description": "Event start timestamp"
          },
          "ended_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ended At",
            "description": "Event end timestamp"
          },
          "risk_score": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Risk Score",
            "description": "Risk score (0-100)"
          },
          "risk_level": {
            "type": "string",
            "pattern": "^(low|medium|high|critical)$",
            "title": "Risk Level",
            "description": "Risk level"
          },
          "summary": {
            "type": "string",
            "maxLength": 1000,
            "minLength": 1,
            "title": "Summary",
            "description": "Event summary"
          },
          "reasoning": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 5000
              },
              {
                "type": "null"
              }
            ],
            "title": "Reasoning",
            "description": "LLM reasoning"
          },
          "detection_ids": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "title": "Detection Ids",
            "description": "Associated detection IDs"
          }
        },
        "type": "object",
        "required": ["camera_id", "started_at", "risk_score", "risk_level", "summary"],
        "title": "EventBulkCreateItem",
        "description": "Schema for a single event in a bulk create request.\n\nAttributes:\n    camera_id: Camera ID that generated this event\n    started_at: Event start timestamp\n    ended_at: Optional event end timestamp\n    risk_score: Risk score from 0-100\n    risk_level: Risk level (low, medium, high, critical)\n    summary: Brief event summary\n    reasoning: Detailed reasoning from LLM analysis\n    detection_ids: List of detection IDs associated with this event"
      },
      "EventBulkCreateRequest": {
        "properties": {
          "events": {
            "items": {
              "$ref": "#/components/schemas/EventBulkCreateItem"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Events",
            "description": "Events to create (max 100)"
          }
        },
        "type": "object",
        "required": ["events"],
        "title": "EventBulkCreateRequest",
        "description": "Request schema for bulk event creation.\n\nAttributes:\n    events: List of events to create (max 100 per request)"
      },
      "EventBulkCreateResponse": {
        "properties": {
          "total": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total",
            "description": "Total number of items in the request"
          },
          "succeeded": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Succeeded",
            "description": "Number of successful operations"
          },
          "failed": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Failed",
            "description": "Number of failed operations"
          },
          "skipped": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Skipped",
            "description": "Number of skipped operations",
            "default": 0
          },
          "results": {
            "items": {
              "$ref": "#/components/schemas/BulkItemResult"
            },
            "type": "array",
            "title": "Results",
            "description": "Per-item results"
          }
        },
        "type": "object",
        "required": ["total", "succeeded", "failed"],
        "title": "EventBulkCreateResponse",
        "description": "Response schema for bulk event creation.\n\nExtends BulkOperationResponse with created event IDs."
      },
      "EventBulkDeleteRequest": {
        "properties": {
          "event_ids": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Event Ids",
            "description": "Event IDs to delete (max 100)"
          },
          "soft_delete": {
            "type": "boolean",
            "title": "Soft Delete",
            "description": "Soft delete (default) vs hard delete",
            "default": true
          }
        },
        "type": "object",
        "required": ["event_ids"],
        "title": "EventBulkDeleteRequest",
        "description": "Request schema for bulk event deletion.\n\nAttributes:\n    event_ids: List of event IDs to delete (max 100 per request)\n    soft_delete: If true, mark as deleted instead of removing"
      },
      "EventBulkUpdateItem": {
        "properties": {
          "id": {
            "type": "integer",
            "exclusiveMinimum": 0.0,
            "title": "Id",
            "description": "Event ID to update"
          },
          "reviewed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewed",
            "description": "Mark as reviewed"
          },
          "notes": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 2000
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Notes"
          }
        },
        "type": "object",
        "required": ["id"],
        "title": "EventBulkUpdateItem",
        "description": "Schema for a single event update in a bulk update request.\n\nAttributes:\n    id: Event ID to update\n    reviewed: Mark event as reviewed/dismissed\n    notes: Optional notes for the event"
      },
      "EventBulkUpdateRequest": {
        "properties": {
          "events": {
            "items": {
              "$ref": "#/components/schemas/EventBulkUpdateItem"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Events",
            "description": "Event updates (max 100)"
          }
        },
        "type": "object",
        "required": ["events"],
        "title": "EventBulkUpdateRequest",
        "description": "Request schema for bulk event updates.\n\nAttributes:\n    events: List of event updates (max 100 per request)"
      },
      "EventEnrichmentsResponse": {
        "properties": {
          "event_id": {
            "type": "integer",
            "title": "Event Id",
            "description": "Event ID"
          },
          "enrichments": {
            "items": {
              "$ref": "#/components/schemas/EnrichmentResponse"
            },
            "type": "array",
            "title": "Enrichments",
            "description": "Enrichment data per detection"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Number of enrichments in this response (page size)"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of detections with enrichment data for this event"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Maximum number of results requested"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Number of results skipped"
          },
          "has_more": {
            "type": "boolean",
            "title": "Has More",
            "description": "Whether there are more results available"
          }
        },
        "type": "object",
        "required": ["event_id", "enrichments", "count", "total", "limit", "offset", "has_more"],
        "title": "EventEnrichmentsResponse",
        "description": "Enrichment data for all detections in an event with pagination support.",
        "example": {
          "count": 2,
          "enrichments": [
            {
              "detection_id": 1,
              "enriched_at": "2026-01-03T10:30:00Z",
              "face": {
                "count": 0,
                "detected": false
              },
              "license_plate": {
                "detected": true,
                "text": "ABC-1234"
              },
              "violence": {
                "detected": false,
                "score": 0.0
              }
            },
            {
              "detection_id": 2,
              "enriched_at": "2026-01-03T10:30:05Z",
              "face": {
                "count": 1,
                "detected": true
              },
              "license_plate": {
                "detected": false
              },
              "violence": {
                "detected": false,
                "score": 0.0
              }
            }
          ],
          "event_id": 100,
          "has_more": false,
          "limit": 50,
          "offset": 0,
          "total": 10
        }
      },
      "EventListResponse": {
        "properties": {
          "events": {
            "items": {
              "$ref": "#/components/schemas/EventResponse"
            },
            "type": "array",
            "title": "Events",
            "description": "List of events"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Total number of events matching filters"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Maximum number of results returned"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Number of results skipped (deprecated, use cursor)"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Cursor",
            "description": "Cursor for fetching the next page. Pass this as the 'cursor' parameter."
          },
          "has_more": {
            "type": "boolean",
            "title": "Has More",
            "description": "Whether there are more results available after this page",
            "default": false
          },
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Deprecation Warning",
            "description": "Warning message when using deprecated offset pagination"
          }
        },
        "type": "object",
        "required": ["events", "count", "limit", "offset"],
        "title": "EventListResponse",
        "description": "Schema for event list response with pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nUse cursor-based pagination for better performance with large datasets.",
        "example": {
          "count": 1,
          "events": [
            {
              "camera_id": "front_door",
              "detection_count": 5,
              "detection_ids": [1, 2, 3, 4, 5],
              "ended_at": "2025-12-23T12:02:30Z",
              "id": 1,
              "llm_prompt": "<|im_start|>system\nYou are a home security risk analyzer...",
              "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
              "reviewed": false,
              "risk_level": "medium",
              "risk_score": 75,
              "started_at": "2025-12-23T12:00:00Z",
              "summary": "Person detected near front entrance",
              "thumbnail_url": "/api/media/detections/1"
            }
          ],
          "has_more": false,
          "limit": 50,
          "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=",
          "offset": 0
        }
      },
      "EventResponse": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Event ID"
          },
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Normalized camera ID (e.g., 'front_door')"
          },
          "started_at": {
            "type": "string",
            "format": "date-time",
            "title": "Started At",
            "description": "Event start timestamp"
          },
          "ended_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ended At",
            "description": "Event end timestamp"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Score",
            "description": "Risk score (0-100)"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Level",
            "description": "Risk level (low, medium, high, critical)"
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Summary",
            "description": "LLM-generated event summary"
          },
          "reasoning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reasoning",
            "description": "LLM reasoning for risk score"
          },
          "llm_prompt": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Llm Prompt",
            "description": "Full prompt sent to Nemotron LLM (for debugging/improvement)"
          },
          "reviewed": {
            "type": "boolean",
            "title": "Reviewed",
            "description": "Whether event has been reviewed",
            "default": false
          },
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "User notes for the event"
          },
          "detection_count": {
            "type": "integer",
            "title": "Detection Count",
            "description": "Number of detections in this event",
            "default": 0
          },
          "detection_ids": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "title": "Detection Ids",
            "description": "List of detection IDs associated with this event"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Thumbnail Url",
            "description": "URL to thumbnail image (first detection's media)"
          },
          "enrichment_status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enrichment pipeline status (NEM-1672) - shows which models succeeded/failed"
          }
        },
        "type": "object",
        "required": ["id", "camera_id", "started_at"],
        "title": "EventResponse",
        "description": "Schema for event response.",
        "example": {
          "camera_id": "front_door",
          "detection_count": 5,
          "detection_ids": [1, 2, 3, 4, 5],
          "ended_at": "2025-12-23T12:02:30Z",
          "enrichment_status": {
            "errors": {},
            "failed_models": [],
            "status": "full",
            "success_rate": 1.0,
            "successful_models": ["violence", "weather", "face", "clothing"]
          },
          "id": 1,
          "llm_prompt": "<|im_start|>system\nYou are a home security risk analyzer...",
          "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
          "reviewed": false,
          "risk_level": "medium",
          "risk_score": 75,
          "started_at": "2025-12-23T12:00:00Z",
          "summary": "Person detected near front entrance",
          "thumbnail_url": "/api/media/detections/1"
        }
      },
      "EventStatsResponse": {
        "properties": {
          "total_events": {
            "type": "integer",
            "title": "Total Events",
            "description": "Total number of events"
          },
          "events_by_risk_level": {
            "$ref": "#/components/schemas/EventsByRiskLevel",
            "description": "Events grouped by risk level"
          },
          "events_by_camera": {
            "items": {
              "$ref": "#/components/schemas/EventsByCamera"
            },
            "type": "array",
            "title": "Events By Camera",
            "description": "Events grouped by camera"
          }
        },
        "type": "object",
        "required": ["total_events", "events_by_risk_level", "events_by_camera"],
        "title": "EventStatsResponse",
        "description": "Schema for aggregated event statistics.",
        "example": {
          "events_by_camera": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "event_count": 30
            },
            {
              "camera_id": "back_door",
              "camera_name": "Back Door",
              "event_count": 14
            }
          ],
          "events_by_risk_level": {
            "critical": 2,
            "high": 5,
            "low": 25,
            "medium": 12
          },
          "total_events": 44
        }
      },
      "EventUpdate": {
        "properties": {
          "reviewed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewed",
            "description": "Mark event as reviewed or not reviewed"
          },
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "User notes for the event"
          }
        },
        "type": "object",
        "title": "EventUpdate",
        "description": "Schema for updating an event (PATCH).",
        "example": {
          "notes": "Verified - delivery person",
          "reviewed": true
        }
      },
      "EventsByCamera": {
        "properties": {
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Normalized camera ID (e.g., 'front_door')"
          },
          "camera_name": {
            "type": "string",
            "title": "Camera Name",
            "description": "Camera name"
          },
          "event_count": {
            "type": "integer",
            "title": "Event Count",
            "description": "Number of events for this camera"
          }
        },
        "type": "object",
        "required": ["camera_id", "camera_name", "event_count"],
        "title": "EventsByCamera",
        "description": "Schema for events count by camera.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "event_count": 15
        }
      },
      "EventsByRiskLevel": {
        "properties": {
          "critical": {
            "type": "integer",
            "title": "Critical",
            "description": "Number of critical risk events",
            "default": 0
          },
          "high": {
            "type": "integer",
            "title": "High",
            "description": "Number of high risk events",
            "default": 0
          },
          "medium": {
            "type": "integer",
            "title": "Medium",
            "description": "Number of medium risk events",
            "default": 0
          },
          "low": {
            "type": "integer",
            "title": "Low",
            "description": "Number of low risk events",
            "default": 0
          }
        },
        "type": "object",
        "title": "EventsByRiskLevel",
        "description": "Schema for events count by risk level.",
        "example": {
          "critical": 2,
          "high": 5,
          "low": 25,
          "medium": 12
        }
      },
      "FaceEnrichment": {
        "properties": {
          "detected": {
            "type": "boolean",
            "title": "Detected",
            "description": "Whether faces were detected",
            "default": false
          },
          "count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Count",
            "description": "Number of faces detected",
            "default": 0
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Highest face confidence"
          }
        },
        "type": "object",
        "title": "FaceEnrichment",
        "description": "Face detection results.",
        "example": {
          "confidence": 0.88,
          "count": 1,
          "detected": true
        }
      },
      "FileWatcherStatusResponse": {
        "properties": {
          "running": {
            "type": "boolean",
            "title": "Running",
            "description": "Whether the file watcher is currently running"
          },
          "camera_root": {
            "type": "string",
            "title": "Camera Root",
            "description": "Root directory being watched for camera uploads"
          },
          "pending_tasks": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Pending Tasks",
            "description": "Number of files pending processing (debouncing)"
          },
          "observer_type": {
            "type": "string",
            "title": "Observer Type",
            "description": "Type of filesystem observer (native or polling)"
          }
        },
        "type": "object",
        "required": ["running", "camera_root", "pending_tasks", "observer_type"],
        "title": "FileWatcherStatusResponse",
        "description": "Status information for the FileWatcher service.",
        "example": {
          "camera_root": "/export/foscam",
          "observer_type": "native",
          "pending_tasks": 3,
          "running": true
        }
      },
      "FrontendLogCreate": {
        "properties": {
          "level": {
            "type": "string",
            "pattern": "^(DEBUG|INFO|WARNING|ERROR|CRITICAL)$",
            "title": "Level",
            "description": "Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)"
          },
          "component": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Component",
            "description": "Frontend component name (e.g., 'RiskGauge', 'CameraGrid')"
          },
          "message": {
            "type": "string",
            "maxLength": 2000,
            "minLength": 1,
            "title": "Message",
            "description": "Log message content"
          },
          "extra": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Extra",
            "description": "Additional context (JSON-serializable)"
          },
          "user_agent": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 500
              },
              {
                "type": "null"
              }
            ],
            "title": "User Agent",
            "description": "Browser user agent string"
          },
          "url": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 2000
              },
              {
                "type": "null"
              }
            ],
            "title": "Url",
            "description": "Page URL where log occurred"
          }
        },
        "type": "object",
        "required": ["level", "component", "message"],
        "title": "FrontendLogCreate",
        "description": "Schema for frontend log submission.",
        "example": {
          "component": "RiskGauge",
          "extra": {
            "last_error": "Connection refused",
            "reconnect_attempts": 3
          },
          "level": "ERROR",
          "message": "WebSocket connection lost",
          "url": "https://localhost:5173/dashboard",
          "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0"
        }
      },
      "FullHealthResponse": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/ServiceHealthState",
            "description": "Overall system health status"
          },
          "ready": {
            "type": "boolean",
            "title": "Ready",
            "description": "Whether system is ready to receive traffic"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable status message"
          },
          "postgres": {
            "$ref": "#/components/schemas/InfrastructureHealthStatus",
            "description": "PostgreSQL health status"
          },
          "redis": {
            "$ref": "#/components/schemas/InfrastructureHealthStatus",
            "description": "Redis health status"
          },
          "ai_services": {
            "items": {
              "$ref": "#/components/schemas/AIServiceHealthStatus"
            },
            "type": "array",
            "title": "Ai Services",
            "description": "Health status of all AI services"
          },
          "circuit_breakers": {
            "$ref": "#/components/schemas/CircuitBreakerSummary",
            "description": "Circuit breaker summary"
          },
          "workers": {
            "items": {
              "$ref": "#/components/schemas/WorkerHealthStatus"
            },
            "type": "array",
            "title": "Workers",
            "description": "Background worker statuses"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Response timestamp"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Application version"
          }
        },
        "type": "object",
        "required": [
          "status",
          "ready",
          "message",
          "postgres",
          "redis",
          "ai_services",
          "circuit_breakers",
          "workers",
          "timestamp",
          "version"
        ],
        "title": "FullHealthResponse",
        "description": "Comprehensive health check response for GET /api/system/health/full.\n\nAggregates health status from all services:\n- Infrastructure (postgres, redis)\n- AI services (rtdetr, nemotron, florence, clip, enrichment)\n- Circuit breakers\n- Background workers\n\nHTTP Status Codes:\n- 200: System is healthy or degraded (can still serve traffic)\n- 503: Critical services are unhealthy (should not receive traffic)",
        "example": {
          "ai_services": [
            {
              "circuit_state": "closed",
              "display_name": "RT-DETRv2 Object Detection",
              "last_check": "2026-01-08T10:30:00Z",
              "name": "rtdetr",
              "response_time_ms": 45.2,
              "status": "healthy",
              "url": "http://ai-detector:8090"
            }
          ],
          "circuit_breakers": {
            "breakers": {
              "nemotron": "closed",
              "rtdetr": "closed"
            },
            "closed": 5,
            "half_open": 0,
            "open": 0,
            "total": 5
          },
          "message": "All systems operational",
          "postgres": {
            "message": "Database operational",
            "name": "postgres",
            "status": "healthy"
          },
          "ready": true,
          "redis": {
            "details": {
              "redis_version": "7.4.0"
            },
            "message": "Redis connected",
            "name": "redis",
            "status": "healthy"
          },
          "status": "healthy",
          "timestamp": "2026-01-08T10:30:00Z",
          "version": "0.1.0",
          "workers": [
            {
              "critical": true,
              "name": "file_watcher",
              "running": true
            }
          ]
        }
      },
      "GPUStatsHistoryResponse": {
        "properties": {
          "samples": {
            "items": {
              "$ref": "#/components/schemas/GPUStatsSample"
            },
            "type": "array",
            "title": "Samples",
            "description": "GPU stats samples (chronological order)"
          },
          "count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Count",
            "description": "Number of samples returned"
          },
          "limit": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Limit",
            "description": "Applied limit"
          }
        },
        "type": "object",
        "required": ["samples", "count", "limit"],
        "title": "GPUStatsHistoryResponse",
        "description": "Response schema for GPU stats history endpoint."
      },
      "GPUStatsResponse": {
        "properties": {
          "gpu_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gpu Name",
            "description": "GPU device name (e.g., 'NVIDIA RTX A5500')"
          },
          "utilization": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Utilization",
            "description": "GPU utilization percentage (0-100)"
          },
          "memory_used": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Memory Used",
            "description": "GPU memory used in MB"
          },
          "memory_total": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Memory Total",
            "description": "Total GPU memory in MB"
          },
          "temperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Temperature",
            "description": "GPU temperature in Celsius"
          },
          "power_usage": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Power Usage",
            "description": "GPU power usage in watts"
          },
          "inference_fps": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Inference Fps",
            "description": "Inference frames per second"
          }
        },
        "type": "object",
        "title": "GPUStatsResponse",
        "description": "Response schema for GPU statistics endpoint.",
        "example": {
          "gpu_name": "NVIDIA RTX A5500",
          "inference_fps": 30.5,
          "memory_total": 24000,
          "memory_used": 12000,
          "power_usage": 150.0,
          "temperature": 65.0,
          "utilization": 75.5
        }
      },
      "GPUStatsSample": {
        "properties": {
          "recorded_at": {
            "type": "string",
            "format": "date-time",
            "title": "Recorded At",
            "description": "When the GPU sample was recorded (UTC)"
          },
          "gpu_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gpu Name",
            "description": "GPU device name"
          },
          "utilization": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Utilization",
            "description": "GPU utilization percentage (0-100)"
          },
          "memory_used": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Memory Used",
            "description": "GPU memory used in MB"
          },
          "memory_total": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Memory Total",
            "description": "Total GPU memory in MB"
          },
          "temperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Temperature",
            "description": "GPU temperature in Celsius"
          },
          "power_usage": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Power Usage",
            "description": "GPU power usage in watts"
          },
          "inference_fps": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Inference Fps",
            "description": "Inference frames per second"
          }
        },
        "type": "object",
        "required": ["recorded_at"],
        "title": "GPUStatsSample",
        "description": "Single time-series sample of GPU statistics."
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "HealthCheckServiceStatus": {
        "properties": {
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Service status: healthy, unhealthy, or not_initialized"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Optional status message or error details"
          },
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Details",
            "description": "Additional service-specific details (may contain nested objects)"
          }
        },
        "type": "object",
        "required": ["status"],
        "title": "HealthCheckServiceStatus",
        "description": "Status information for a service component in health checks.\n\nNote: Renamed from ServiceStatus to avoid name collision with\nbackend.api.schemas.services.ServiceStatus (orchestrator enum)."
      },
      "HealthEventResponse": {
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "When the event occurred (UTC)"
          },
          "service": {
            "type": "string",
            "title": "Service",
            "description": "Name of the service this event relates to"
          },
          "event_type": {
            "type": "string",
            "title": "Event Type",
            "description": "Type of event: 'failure', 'recovery', or 'restart'"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Optional descriptive message about the event"
          }
        },
        "type": "object",
        "required": ["timestamp", "service", "event_type"],
        "title": "HealthEventResponse",
        "description": "Schema for a health event in the failure history.\n\nRepresents a single health-related event such as a failure, recovery, or restart.",
        "example": {
          "event_type": "failure",
          "message": "Health check failed: connection refused",
          "service": "redis",
          "timestamp": "2025-12-23T10:30:00Z"
        }
      },
      "HealthResponse": {
        "properties": {
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Overall system status: healthy, degraded, or unhealthy"
          },
          "services": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HealthCheckServiceStatus"
            },
            "type": "object",
            "title": "Services",
            "description": "Status of individual services (database, redis, ai)"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of health check"
          },
          "recent_events": {
            "items": {
              "$ref": "#/components/schemas/HealthEventResponse"
            },
            "type": "array",
            "title": "Recent Events",
            "description": "Recent health events for debugging intermittent issues"
          }
        },
        "type": "object",
        "required": ["status", "services", "timestamp"],
        "title": "HealthResponse",
        "description": "Response schema for health check endpoint.",
        "example": {
          "recent_events": [
            {
              "event_type": "recovery",
              "message": "Service recovered",
              "service": "redis",
              "timestamp": "2025-12-23T10:25:00Z"
            },
            {
              "event_type": "failure",
              "message": "Health check failed",
              "service": "redis",
              "timestamp": "2025-12-23T10:20:00Z"
            }
          ],
          "services": {
            "ai": {
              "message": "AI services operational",
              "status": "healthy"
            },
            "database": {
              "message": "Database operational",
              "status": "healthy"
            },
            "redis": {
              "details": {
                "redis_version": "7.0.0"
              },
              "message": "Redis connected",
              "status": "healthy"
            }
          },
          "status": "healthy",
          "timestamp": "2025-12-23T10:30:00"
        }
      },
      "HourlyPattern": {
        "properties": {
          "avg_detections": {
            "type": "number",
            "minimum": 0.0,
            "title": "Avg Detections",
            "description": "Average number of detections during this hour"
          },
          "std_dev": {
            "type": "number",
            "minimum": 0.0,
            "title": "Std Dev",
            "description": "Standard deviation of detection count"
          },
          "sample_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Sample Count",
            "description": "Number of samples used for this calculation"
          }
        },
        "type": "object",
        "required": ["avg_detections", "std_dev", "sample_count"],
        "title": "HourlyPattern",
        "description": "Activity pattern for a specific hour.",
        "example": {
          "avg_detections": 2.5,
          "sample_count": 30,
          "std_dev": 0.8
        }
      },
      "ImageQualityEnrichment": {
        "properties": {
          "score": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Score",
            "description": "Quality score (0-100)"
          },
          "is_blurry": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Blurry",
            "description": "Whether image is blurry"
          },
          "is_low_quality": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Low Quality",
            "description": "Whether image has low quality"
          },
          "quality_issues": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quality Issues",
            "description": "List of detected quality issues"
          },
          "quality_change_detected": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quality Change Detected",
            "description": "Whether sudden quality change was detected"
          }
        },
        "type": "object",
        "title": "ImageQualityEnrichment",
        "description": "Image quality assessment results.",
        "example": {
          "is_blurry": false,
          "is_low_quality": false,
          "quality_issues": [],
          "score": 0.85
        }
      },
      "InfrastructureHealthStatus": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Service name (e.g., 'postgres', 'redis')"
          },
          "status": {
            "$ref": "#/components/schemas/ServiceHealthState",
            "description": "Current health state"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Status message or error description"
          },
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Details",
            "description": "Additional details (e.g., redis version)"
          }
        },
        "type": "object",
        "required": ["name", "status", "message"],
        "title": "InfrastructureHealthStatus",
        "description": "Health status for infrastructure services (postgres, redis).\n\nProvides detailed status including connection info and any error details.",
        "example": {
          "message": "Database operational",
          "name": "postgres",
          "status": "healthy"
        }
      },
      "LatencyHistorySnapshot": {
        "properties": {
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "Bucket start time (ISO format)"
          },
          "stages": {
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LatencyHistoryStageStats"
                },
                {
                  "type": "null"
                }
              ]
            },
            "type": "object",
            "title": "Stages",
            "description": "Latency stats for each pipeline stage (None if no samples)"
          }
        },
        "type": "object",
        "required": ["timestamp", "stages"],
        "title": "LatencyHistorySnapshot",
        "description": "Single time-bucket snapshot of pipeline latency metrics."
      },
      "LatencyHistoryStageStats": {
        "properties": {
          "avg_ms": {
            "type": "number",
            "title": "Avg Ms",
            "description": "Average latency in milliseconds"
          },
          "p50_ms": {
            "type": "number",
            "title": "P50 Ms",
            "description": "50th percentile (median) latency"
          },
          "p95_ms": {
            "type": "number",
            "title": "P95 Ms",
            "description": "95th percentile latency"
          },
          "p99_ms": {
            "type": "number",
            "title": "P99 Ms",
            "description": "99th percentile latency"
          },
          "sample_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Sample Count",
            "description": "Number of samples in this bucket"
          }
        },
        "type": "object",
        "required": ["avg_ms", "p50_ms", "p95_ms", "p99_ms", "sample_count"],
        "title": "LatencyHistoryStageStats",
        "description": "Latency statistics for a single stage in a history snapshot."
      },
      "LeaderboardResponse": {
        "properties": {
          "entries": {
            "items": {
              "$ref": "#/components/schemas/ModelLeaderboardEntry"
            },
            "type": "array",
            "title": "Entries",
            "description": "Ranked list of model entries"
          },
          "period_days": {
            "type": "integer",
            "maximum": 90.0,
            "minimum": 1.0,
            "title": "Period Days",
            "description": "Number of days in the analysis period"
          }
        },
        "type": "object",
        "required": ["entries", "period_days"],
        "title": "LeaderboardResponse",
        "description": "Model leaderboard ranked by contribution rate.\n\nLists AI models ordered by their contribution frequency, with\nquality correlation data to identify which models most improve results.",
        "example": {
          "entries": [
            {
              "contribution_rate": 0.98,
              "event_count": 1180,
              "model_name": "rtdetr",
              "quality_correlation": 0.85
            },
            {
              "contribution_rate": 0.88,
              "event_count": 1056,
              "model_name": "zones",
              "quality_correlation": 0.72
            }
          ],
          "period_days": 7
        }
      },
      "LicensePlateEnrichment": {
        "properties": {
          "detected": {
            "type": "boolean",
            "title": "Detected",
            "description": "Whether a license plate was detected",
            "default": false
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Detection confidence"
          },
          "text": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Text",
            "description": "OCR-extracted plate text"
          },
          "ocr_confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Ocr Confidence",
            "description": "OCR confidence"
          },
          "bbox": {
            "anyOf": [
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox",
            "description": "Bounding box [x1, y1, x2, y2]"
          }
        },
        "type": "object",
        "title": "LicensePlateEnrichment",
        "description": "License plate detection and OCR results.",
        "example": {
          "bbox": [100.0, 200.0, 300.0, 250.0],
          "confidence": 0.92,
          "detected": true,
          "ocr_confidence": 0.88,
          "text": "ABC-1234"
        }
      },
      "LogEntry": {
        "properties": {
          "id": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Id",
            "description": "Log entry ID"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Log timestamp (UTC)"
          },
          "level": {
            "type": "string",
            "pattern": "^(DEBUG|INFO|WARNING|ERROR|CRITICAL)$",
            "title": "Level",
            "description": "Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)"
          },
          "component": {
            "type": "string",
            "maxLength": 200,
            "minLength": 1,
            "title": "Component",
            "description": "Component/module name (e.g., 'backend.services.detector')"
          },
          "message": {
            "type": "string",
            "maxLength": 5000,
            "minLength": 1,
            "title": "Message",
            "description": "Log message content"
          },
          "camera_id": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 64,
                "pattern": "^[a-zA-Z0-9_-]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Camera Id",
            "description": "Associated camera ID (alphanumeric, underscore, hyphen only)"
          },
          "event_id": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Event Id",
            "description": "Associated event ID"
          },
          "request_id": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 128
              },
              {
                "type": "null"
              }
            ],
            "title": "Request Id",
            "description": "Request correlation ID for tracing"
          },
          "detection_id": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Detection Id",
            "description": "Associated detection ID"
          },
          "duration_ms": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Duration Ms",
            "description": "Operation duration in milliseconds"
          },
          "extra": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Extra",
            "description": "Additional structured data (JSON-serializable)"
          },
          "source": {
            "type": "string",
            "pattern": "^(backend|frontend)$",
            "title": "Source",
            "description": "Log source (backend, frontend)",
            "default": "backend"
          }
        },
        "type": "object",
        "required": ["id", "timestamp", "level", "component", "message"],
        "title": "LogEntry",
        "description": "Schema for a single log entry.",
        "example": {
          "camera_id": "front_door",
          "component": "backend.services.detector",
          "detection_id": 456,
          "duration_ms": 150,
          "event_id": 123,
          "extra": {
            "confidence_avg": 0.87,
            "detections_count": 3
          },
          "id": 1,
          "level": "INFO",
          "message": "Detection completed for front_door camera",
          "request_id": "req-550e8400-e29b-41d4",
          "source": "backend",
          "timestamp": "2026-01-03T10:30:00Z"
        }
      },
      "LogLevelRequest": {
        "properties": {
          "level": {
            "type": "string",
            "title": "Level",
            "description": "New log level to set (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
            "example": "DEBUG"
          }
        },
        "type": "object",
        "required": ["level"],
        "title": "LogLevelRequest",
        "description": "Request to change log level at runtime.\n\nAllows temporarily adjusting the application log level without restarting.\nUseful for enabling DEBUG logging to investigate issues in production."
      },
      "LogLevelResponse": {
        "properties": {
          "level": {
            "type": "string",
            "title": "Level",
            "description": "Current log level after the operation",
            "example": "DEBUG"
          },
          "previous_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Previous Level",
            "description": "Previous log level before change (only set on POST requests)",
            "example": "INFO"
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when the operation completed",
            "example": "2025-12-30T10:30:00Z"
          }
        },
        "type": "object",
        "required": ["level", "timestamp"],
        "title": "LogLevelResponse",
        "description": "Response for log level operations.\n\nReturns the current log level and, when changing the level,\nthe previous level for auditing purposes."
      },
      "LogStats": {
        "properties": {
          "total_today": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Today",
            "description": "Total logs today"
          },
          "errors_today": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Errors Today",
            "description": "Error count today"
          },
          "warnings_today": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Warnings Today",
            "description": "Warning count today"
          },
          "by_component": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "By Component",
            "description": "Counts by component"
          },
          "by_level": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "By Level",
            "description": "Counts by level"
          },
          "top_component": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Top Component",
            "description": "Most active component"
          }
        },
        "type": "object",
        "required": ["total_today", "errors_today", "warnings_today", "by_component", "by_level"],
        "title": "LogStats",
        "description": "Schema for log statistics (dashboard).",
        "example": {
          "by_component": {
            "backend.api.routes": 300,
            "backend.services.analyzer": 400,
            "backend.services.detector": 800
          },
          "by_level": {
            "CRITICAL": 0,
            "DEBUG": 500,
            "ERROR": 12,
            "INFO": 900,
            "WARNING": 45
          },
          "errors_today": 12,
          "top_component": "backend.services.detector",
          "total_today": 1500,
          "warnings_today": 45
        }
      },
      "LogsResponse": {
        "properties": {
          "logs": {
            "items": {
              "$ref": "#/components/schemas/LogEntry"
            },
            "type": "array",
            "title": "Logs",
            "description": "List of log entries"
          },
          "count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Count",
            "description": "Total count matching filters"
          },
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Page size (1-1000)"
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Page offset (0-based, deprecated)"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Cursor",
            "description": "Cursor for next page (use this instead of offset)"
          },
          "has_more": {
            "type": "boolean",
            "title": "Has More",
            "description": "Whether more results are available",
            "default": false
          },
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Deprecation Warning",
            "description": "Warning when using deprecated offset pagination"
          }
        },
        "type": "object",
        "required": ["logs", "count", "limit", "offset"],
        "title": "LogsResponse",
        "description": "Schema for paginated logs response.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.",
        "example": {
          "count": 1,
          "has_more": false,
          "limit": 50,
          "logs": [
            {
              "camera_id": "front_door",
              "component": "backend.services.detector",
              "detection_id": 456,
              "duration_ms": 150,
              "event_id": 123,
              "id": 1,
              "level": "INFO",
              "message": "Detection completed",
              "source": "backend",
              "timestamp": "2026-01-03T10:30:00Z"
            }
          ],
          "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjYtMDEtMDNUMTA6MzA6MDBaIn0=",
          "offset": 0
        }
      },
      "MediaErrorResponse": {
        "properties": {
          "error": {
            "type": "string",
            "maxLength": 500,
            "minLength": 1,
            "title": "Error",
            "description": "Error message describing what went wrong"
          },
          "path": {
            "type": "string",
            "maxLength": 4096,
            "minLength": 0,
            "title": "Path",
            "description": "The path that was attempted to be accessed"
          }
        },
        "type": "object",
        "required": ["error", "path"],
        "title": "MediaErrorResponse",
        "description": "Error response for media access failures.",
        "example": {
          "error": "File not found",
          "path": "/export/foscam/front_door/image_001.jpg"
        }
      },
      "ModelContributions": {
        "properties": {
          "rtdetr": {
            "type": "boolean",
            "title": "Rtdetr",
            "description": "RT-DETR object detection contributed",
            "default": false
          },
          "florence": {
            "type": "boolean",
            "title": "Florence",
            "description": "Florence-2 vision attributes contributed",
            "default": false
          },
          "clip": {
            "type": "boolean",
            "title": "Clip",
            "description": "CLIP embeddings contributed",
            "default": false
          },
          "violence": {
            "type": "boolean",
            "title": "Violence",
            "description": "Violence detection model contributed",
            "default": false
          },
          "clothing": {
            "type": "boolean",
            "title": "Clothing",
            "description": "Clothing analysis model contributed",
            "default": false
          },
          "vehicle": {
            "type": "boolean",
            "title": "Vehicle",
            "description": "Vehicle classification model contributed",
            "default": false
          },
          "pet": {
            "type": "boolean",
            "title": "Pet",
            "description": "Pet classification model contributed",
            "default": false
          },
          "weather": {
            "type": "boolean",
            "title": "Weather",
            "description": "Weather classification model contributed",
            "default": false
          },
          "image_quality": {
            "type": "boolean",
            "title": "Image Quality",
            "description": "Image quality assessment contributed",
            "default": false
          },
          "zones": {
            "type": "boolean",
            "title": "Zones",
            "description": "Zone analysis model contributed",
            "default": false
          },
          "baseline": {
            "type": "boolean",
            "title": "Baseline",
            "description": "Baseline comparison model contributed",
            "default": false
          },
          "cross_camera": {
            "type": "boolean",
            "title": "Cross Camera",
            "description": "Cross-camera correlation contributed",
            "default": false
          }
        },
        "type": "object",
        "title": "ModelContributions",
        "description": "Model contribution flags indicating which AI models contributed to an event's analysis.\n\nEach flag is True if that model provided data for the event analysis,\nFalse if the model was not used or had no relevant detections.",
        "example": {
          "baseline": false,
          "clip": false,
          "clothing": true,
          "cross_camera": false,
          "florence": true,
          "image_quality": true,
          "pet": false,
          "rtdetr": true,
          "vehicle": false,
          "violence": false,
          "weather": true,
          "zones": true
        }
      },
      "ModelLatencyHistoryResponse": {
        "properties": {
          "model_name": {
            "type": "string",
            "title": "Model Name",
            "description": "Name of the model this data is for"
          },
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "Human-readable display name"
          },
          "snapshots": {
            "items": {
              "$ref": "#/components/schemas/ModelLatencyHistorySnapshot"
            },
            "type": "array",
            "title": "Snapshots",
            "description": "Chronologically ordered latency snapshots"
          },
          "window_minutes": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Window Minutes",
            "description": "Time window covered by the history"
          },
          "bucket_seconds": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Bucket Seconds",
            "description": "Bucket size for aggregation"
          },
          "has_data": {
            "type": "boolean",
            "title": "Has Data",
            "description": "Whether any latency data exists for this model"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp when history was retrieved"
          }
        },
        "type": "object",
        "required": [
          "model_name",
          "display_name",
          "snapshots",
          "window_minutes",
          "bucket_seconds",
          "has_data",
          "timestamp"
        ],
        "title": "ModelLatencyHistoryResponse",
        "description": "Response schema for Model Zoo latency history endpoint.\n\nReturns time-series latency data for a specific Model Zoo model.\nUsed to populate the dropdown-controlled latency chart.",
        "example": {
          "bucket_seconds": 60,
          "display_name": "YOLO11 License Plate",
          "has_data": true,
          "model_name": "yolo11-license-plate",
          "snapshots": [
            {
              "stats": {
                "avg_ms": 45.0,
                "p50_ms": 42.0,
                "p95_ms": 68.0,
                "sample_count": 15
              },
              "timestamp": "2026-01-04T10:00:00+00:00"
            }
          ],
          "timestamp": "2026-01-04T10:30:00Z",
          "window_minutes": 60
        }
      },
      "ModelLatencyHistorySnapshot": {
        "properties": {
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "Bucket start time (ISO format)"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModelLatencyStageStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency statistics for this time bucket (None if no data)"
          }
        },
        "type": "object",
        "required": ["timestamp"],
        "title": "ModelLatencyHistorySnapshot",
        "description": "Single time-bucket snapshot of Model Zoo model latency."
      },
      "ModelLatencyStageStats": {
        "properties": {
          "avg_ms": {
            "type": "number",
            "minimum": 0.0,
            "title": "Avg Ms",
            "description": "Average latency in milliseconds"
          },
          "p50_ms": {
            "type": "number",
            "minimum": 0.0,
            "title": "P50 Ms",
            "description": "50th percentile (median) latency in milliseconds"
          },
          "p95_ms": {
            "type": "number",
            "minimum": 0.0,
            "title": "P95 Ms",
            "description": "95th percentile latency in milliseconds"
          },
          "sample_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Sample Count",
            "description": "Number of samples in this time bucket"
          }
        },
        "type": "object",
        "required": ["avg_ms", "p50_ms", "p95_ms", "sample_count"],
        "title": "ModelLatencyStageStats",
        "description": "Latency statistics for a Model Zoo model at a point in time."
      },
      "ModelLeaderboardEntry": {
        "properties": {
          "model_name": {
            "type": "string",
            "title": "Model Name",
            "description": "Name of the AI model"
          },
          "contribution_rate": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Contribution Rate",
            "description": "Rate of contribution to events (0-1)"
          },
          "quality_correlation": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": -1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Quality Correlation",
            "description": "Correlation between model use and quality score"
          },
          "event_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Event Count",
            "description": "Number of events where model contributed"
          }
        },
        "type": "object",
        "required": ["model_name", "contribution_rate", "event_count"],
        "title": "ModelLeaderboardEntry",
        "description": "Single entry in the AI model leaderboard.\n\nRepresents one model's performance metrics for ranking.",
        "example": {
          "contribution_rate": 0.98,
          "event_count": 1180,
          "model_name": "rtdetr",
          "quality_correlation": 0.85
        }
      },
      "ModelPromptResponse": {
        "properties": {
          "model_name": {
            "type": "string",
            "title": "Model Name",
            "description": "Name of the AI model"
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "Current configuration for this model"
          },
          "version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Version",
            "description": "Current version number"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "When last updated"
          }
        },
        "type": "object",
        "required": ["model_name", "config", "version", "updated_at"],
        "title": "ModelPromptResponse",
        "description": "Response for a single model's prompt configuration.\n\nContains the current active configuration for an AI model\nalong with version tracking metadata.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "You are a security analyst reviewing camera footage...",
            "temperature": 0.7
          },
          "model_name": "nemotron",
          "updated_at": "2026-01-03T10:30:00Z",
          "version": 5
        }
      },
      "ModelRegistryResponse": {
        "properties": {
          "vram_budget_mb": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Vram Budget Mb",
            "description": "Total VRAM budget available for Model Zoo models (excludes Nemotron and RT-DETRv2)"
          },
          "vram_used_mb": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Vram Used Mb",
            "description": "Currently used VRAM by loaded models"
          },
          "vram_available_mb": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Vram Available Mb",
            "description": "Available VRAM for loading additional models"
          },
          "models": {
            "items": {
              "$ref": "#/components/schemas/ModelStatusResponse"
            },
            "type": "array",
            "title": "Models",
            "description": "List of all models in the registry with their status"
          },
          "loading_strategy": {
            "type": "string",
            "title": "Loading Strategy",
            "description": "Model loading strategy (sequential = one at a time)",
            "default": "sequential"
          },
          "max_concurrent_models": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Max Concurrent Models",
            "description": "Maximum number of models that can be loaded concurrently",
            "default": 1
          }
        },
        "type": "object",
        "required": ["vram_budget_mb", "vram_used_mb", "vram_available_mb", "models"],
        "title": "ModelRegistryResponse",
        "description": "Response schema for model registry endpoint.\n\nReturns comprehensive information about all models in the Model Zoo\nincluding VRAM budget, current usage, and individual model statuses.",
        "example": {
          "loading_strategy": "sequential",
          "max_concurrent_models": 1,
          "models": [],
          "vram_available_mb": 1350,
          "vram_budget_mb": 1650,
          "vram_used_mb": 300
        }
      },
      "ModelStatusEnum": {
        "type": "string",
        "enum": ["loaded", "unloaded", "disabled", "loading", "error"],
        "title": "ModelStatusEnum",
        "description": "Model loading status."
      },
      "ModelStatusResponse": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique identifier for the model (e.g., 'yolo11-license-plate')"
          },
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "Human-readable display name for the model"
          },
          "vram_mb": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Vram Mb",
            "description": "Estimated VRAM usage in megabytes when loaded"
          },
          "status": {
            "$ref": "#/components/schemas/ModelStatusEnum",
            "description": "Current loading status: loaded, unloaded, disabled, loading, error"
          },
          "category": {
            "type": "string",
            "title": "Category",
            "description": "Model category (detection, recognition, ocr, embedding, etc.)"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the model is enabled for use"
          },
          "available": {
            "type": "boolean",
            "title": "Available",
            "description": "Whether the model has been successfully loaded at least once"
          },
          "path": {
            "type": "string",
            "title": "Path",
            "description": "HuggingFace repo path or local file path for the model"
          },
          "load_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Load Count",
            "description": "Current reference count for loaded model (0 if not loaded)",
            "default": 0
          }
        },
        "type": "object",
        "required": [
          "name",
          "display_name",
          "vram_mb",
          "status",
          "category",
          "enabled",
          "available",
          "path"
        ],
        "title": "ModelStatusResponse",
        "description": "Status information for a single model in the Model Zoo.\n\nProvides detailed information about a model including:\n- Identity: name, display_name, category\n- Configuration: vram_mb, enabled, available, path\n- Runtime status: status, load_count",
        "example": {
          "available": false,
          "category": "detection",
          "display_name": "YOLO11 License Plate",
          "enabled": true,
          "load_count": 0,
          "name": "yolo11-license-plate",
          "path": "/models/model-zoo/yolo11-license-plate/license-plate-finetune-v1n.pt",
          "status": "unloaded",
          "vram_mb": 300
        }
      },
      "ModelZooStatusItem": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Model identifier (e.g., 'yolo11-license-plate')"
          },
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "Human-readable display name"
          },
          "category": {
            "type": "string",
            "title": "Category",
            "description": "Model category (detection, classification, segmentation, etc.)"
          },
          "status": {
            "$ref": "#/components/schemas/ModelStatusEnum",
            "description": "Current status: loaded (green), unloaded (gray), disabled (yellow)"
          },
          "vram_mb": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Vram Mb",
            "description": "VRAM usage in megabytes when loaded"
          },
          "last_used_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Used At",
            "description": "Timestamp of last model usage (null if never used)"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the model is enabled for use"
          }
        },
        "type": "object",
        "required": ["name", "display_name", "category", "status", "vram_mb", "enabled"],
        "title": "ModelZooStatusItem",
        "description": "Status information for a single Model Zoo model.\n\nUsed in the compact status card display for Model Zoo models."
      },
      "ModelZooStatusResponse": {
        "properties": {
          "models": {
            "items": {
              "$ref": "#/components/schemas/ModelZooStatusItem"
            },
            "type": "array",
            "title": "Models",
            "description": "List of all Model Zoo models with their current status"
          },
          "total_models": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Models",
            "description": "Total number of models in the registry"
          },
          "loaded_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Loaded Count",
            "description": "Number of currently loaded models"
          },
          "disabled_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Disabled Count",
            "description": "Number of disabled models"
          },
          "vram_budget_mb": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Vram Budget Mb",
            "description": "Total VRAM budget for Model Zoo"
          },
          "vram_used_mb": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Vram Used Mb",
            "description": "Currently used VRAM"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of status snapshot"
          }
        },
        "type": "object",
        "required": [
          "models",
          "total_models",
          "loaded_count",
          "disabled_count",
          "vram_budget_mb",
          "vram_used_mb",
          "timestamp"
        ],
        "title": "ModelZooStatusResponse",
        "description": "Response schema for Model Zoo status endpoint.\n\nReturns status information for all 18 Model Zoo models organized by category.\nUsed to populate the compact status cards in the UI.",
        "example": {
          "disabled_count": 3,
          "loaded_count": 0,
          "models": [
            {
              "category": "detection",
              "display_name": "YOLO11 License Plate",
              "enabled": true,
              "name": "yolo11-license-plate",
              "status": "unloaded",
              "vram_mb": 300
            }
          ],
          "timestamp": "2026-01-04T10:30:00Z",
          "total_models": 18,
          "vram_budget_mb": 1650,
          "vram_used_mb": 0
        }
      },
      "NotificationChannel": {
        "type": "string",
        "enum": ["email", "webhook", "push"],
        "title": "NotificationChannel",
        "description": "Notification channel types."
      },
      "NotificationConfigResponse": {
        "properties": {
          "notification_enabled": {
            "type": "boolean",
            "title": "Notification Enabled",
            "description": "Whether notifications are enabled"
          },
          "email_configured": {
            "type": "boolean",
            "title": "Email Configured",
            "description": "Whether email (SMTP) is configured"
          },
          "webhook_configured": {
            "type": "boolean",
            "title": "Webhook Configured",
            "description": "Whether webhook is configured"
          },
          "push_configured": {
            "type": "boolean",
            "title": "Push Configured",
            "description": "Whether push notifications are configured"
          },
          "available_channels": {
            "items": {
              "$ref": "#/components/schemas/NotificationChannel"
            },
            "type": "array",
            "title": "Available Channels",
            "description": "List of channels that are properly configured"
          },
          "smtp_host": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Smtp Host",
            "description": "Configured SMTP host (if any)"
          },
          "smtp_port": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Smtp Port",
            "description": "Configured SMTP port"
          },
          "smtp_from_address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Smtp From Address",
            "description": "Configured sender email"
          },
          "smtp_use_tls": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Smtp Use Tls",
            "description": "Whether TLS is enabled for SMTP"
          },
          "default_webhook_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Default Webhook Url",
            "description": "Default webhook URL"
          },
          "webhook_timeout_seconds": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Webhook Timeout Seconds",
            "description": "Webhook request timeout"
          },
          "default_email_recipients": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Default Email Recipients",
            "description": "Default email recipients"
          }
        },
        "type": "object",
        "required": [
          "notification_enabled",
          "email_configured",
          "webhook_configured",
          "push_configured",
          "available_channels"
        ],
        "title": "NotificationConfigResponse",
        "description": "Schema for notification configuration status.",
        "example": {
          "available_channels": ["email", "webhook"],
          "default_email_recipients": ["user@example.com"],
          "default_webhook_url": "https://example.com/webhook",
          "email_configured": true,
          "notification_enabled": true,
          "push_configured": false,
          "smtp_from_address": "alerts@example.com",
          "smtp_host": "smtp.example.com",
          "smtp_port": 587,
          "smtp_use_tls": true,
          "webhook_configured": true,
          "webhook_timeout_seconds": 30
        }
      },
      "NotificationPreferencesResponse": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Preferences ID (always 1, singleton)",
            "default": 1
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether notifications are globally enabled"
          },
          "sound": {
            "type": "string",
            "title": "Sound",
            "description": "Notification sound (none, default, alert, chime, urgent)"
          },
          "risk_filters": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Risk Filters",
            "description": "Risk levels that trigger notifications (critical, high, medium, low)"
          }
        },
        "type": "object",
        "required": ["enabled", "sound", "risk_filters"],
        "title": "NotificationPreferencesResponse",
        "description": "Schema for notification preferences response.",
        "example": {
          "enabled": true,
          "id": 1,
          "risk_filters": ["critical", "high", "medium"],
          "sound": "default"
        }
      },
      "NotificationPreferencesUpdate": {
        "properties": {
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enabled",
            "description": "Whether notifications are globally enabled"
          },
          "sound": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sound",
            "description": "Notification sound (none, default, alert, chime, urgent)"
          },
          "risk_filters": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Filters",
            "description": "Risk levels that trigger notifications (critical, high, medium, low)"
          }
        },
        "type": "object",
        "title": "NotificationPreferencesUpdate",
        "description": "Schema for updating notification preferences.",
        "example": {
          "enabled": true,
          "risk_filters": ["critical", "high"],
          "sound": "alert"
        }
      },
      "ObjectBaseline": {
        "properties": {
          "avg_hourly": {
            "type": "number",
            "minimum": 0.0,
            "title": "Avg Hourly",
            "description": "Average hourly detection count for this object type"
          },
          "peak_hour": {
            "type": "integer",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Peak Hour",
            "description": "Hour with most detections of this type (0-23)"
          },
          "total_detections": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Detections",
            "description": "Total detections of this type in the baseline period"
          }
        },
        "type": "object",
        "required": ["avg_hourly", "peak_hour", "total_detections"],
        "title": "ObjectBaseline",
        "description": "Baseline statistics for a specific object class.",
        "example": {
          "avg_hourly": 2.3,
          "peak_hour": 17,
          "total_detections": 550
        }
      },
      "ObjectDistributionDataPoint": {
        "properties": {
          "object_type": {
            "type": "string",
            "title": "Object Type",
            "description": "Detected object type (e.g., 'person', 'car')"
          },
          "count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Count",
            "description": "Number of detections for this object type"
          },
          "percentage": {
            "type": "number",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Percentage",
            "description": "Percentage of total detections (0-100)"
          }
        },
        "type": "object",
        "required": ["object_type", "count", "percentage"],
        "title": "ObjectDistributionDataPoint",
        "description": "Schema for a single object distribution data point.",
        "example": {
          "count": 120,
          "object_type": "person",
          "percentage": 45.5
        }
      },
      "ObjectDistributionResponse": {
        "properties": {
          "object_types": {
            "items": {
              "$ref": "#/components/schemas/ObjectDistributionDataPoint"
            },
            "type": "array",
            "title": "Object Types",
            "description": "Detection counts by object type"
          },
          "total_detections": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Detections",
            "description": "Total detections in date range"
          },
          "start_date": {
            "type": "string",
            "format": "date",
            "title": "Start Date",
            "description": "Start date of the date range"
          },
          "end_date": {
            "type": "string",
            "format": "date",
            "title": "End Date",
            "description": "End date of the date range"
          }
        },
        "type": "object",
        "required": ["object_types", "total_detections", "start_date", "end_date"],
        "title": "ObjectDistributionResponse",
        "description": "Schema for detection counts by object type.",
        "example": {
          "end_date": "2025-01-07",
          "object_types": [
            {
              "count": 120,
              "object_type": "person",
              "percentage": 45.5
            },
            {
              "count": 80,
              "object_type": "car",
              "percentage": 30.3
            },
            {
              "count": 64,
              "object_type": "dog",
              "percentage": 24.2
            }
          ],
          "start_date": "2025-01-01",
          "total_detections": 264
        }
      },
      "PetEnrichment": {
        "properties": {
          "detected": {
            "type": "boolean",
            "title": "Detected",
            "description": "Whether a pet was detected",
            "default": false
          },
          "type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Type",
            "description": "Pet type (cat, dog)"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Classification confidence"
          },
          "is_household_pet": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Household Pet",
            "description": "Whether classified as household pet"
          }
        },
        "type": "object",
        "title": "PetEnrichment",
        "description": "Pet classification results for false positive reduction.",
        "example": {
          "confidence": 0.94,
          "detected": true,
          "is_household_pet": true,
          "type": "dog"
        }
      },
      "PipelineLatencies": {
        "properties": {
          "watch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "File watcher stage latency (file event to queue)"
          },
          "detect": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object detection stage latency (RT-DETRv2 inference)"
          },
          "batch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Batch aggregation window time"
          },
          "analyze": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM analysis stage latency (Nemotron inference)"
          }
        },
        "type": "object",
        "title": "PipelineLatencies",
        "description": "Latency statistics for all pipeline stages.\n\nPipeline stages:\n- watch: File watcher detecting new images (file event -> queue)\n- detect: RT-DETRv2 object detection (image -> detections)\n- batch: Batch aggregation window (detections -> batch)\n- analyze: Nemotron LLM risk analysis (batch -> event)",
        "example": {
          "analyze": {
            "avg_ms": 5000.0,
            "max_ms": 15000.0,
            "min_ms": 2000.0,
            "p50_ms": 4500.0,
            "p95_ms": 12000.0,
            "p99_ms": 14000.0,
            "sample_count": 100
          },
          "batch": {
            "avg_ms": 30000.0,
            "max_ms": 90000.0,
            "min_ms": 5000.0,
            "p50_ms": 25000.0,
            "p95_ms": 80000.0,
            "p99_ms": 88000.0,
            "sample_count": 100
          },
          "detect": {
            "avg_ms": 200.0,
            "max_ms": 800.0,
            "min_ms": 100.0,
            "p50_ms": 180.0,
            "p95_ms": 600.0,
            "p99_ms": 750.0,
            "sample_count": 500
          },
          "watch": {
            "avg_ms": 10.0,
            "max_ms": 50.0,
            "min_ms": 5.0,
            "p50_ms": 8.0,
            "p95_ms": 40.0,
            "p99_ms": 48.0,
            "sample_count": 500
          }
        }
      },
      "PipelineLatencyHistoryResponse": {
        "properties": {
          "snapshots": {
            "items": {
              "$ref": "#/components/schemas/LatencyHistorySnapshot"
            },
            "type": "array",
            "title": "Snapshots",
            "description": "Chronologically ordered latency snapshots"
          },
          "window_minutes": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Window Minutes",
            "description": "Time window covered by the history"
          },
          "bucket_seconds": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Bucket Seconds",
            "description": "Bucket size for aggregation"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp when history was retrieved"
          }
        },
        "type": "object",
        "required": ["snapshots", "window_minutes", "bucket_seconds", "timestamp"],
        "title": "PipelineLatencyHistoryResponse",
        "description": "Response schema for pipeline latency history endpoint.\n\nProvides time-series latency data for charting and trend analysis.\nEach snapshot contains aggregated metrics for a time bucket.",
        "example": {
          "bucket_seconds": 60,
          "snapshots": [
            {
              "stages": {
                "watch_to_detect": {
                  "avg_ms": 50.0,
                  "p50_ms": 45.0,
                  "p95_ms": 120.0,
                  "p99_ms": 150.0,
                  "sample_count": 15
                }
              },
              "timestamp": "2025-12-28T10:00:00+00:00"
            }
          ],
          "timestamp": "2025-12-28T10:30:00Z",
          "window_minutes": 60
        }
      },
      "PipelineLatencyResponse": {
        "properties": {
          "watch_to_detect": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency from file detection to RT-DETR processing"
          },
          "detect_to_batch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency from detection to batch aggregation"
          },
          "batch_to_analyze": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency from batch to Nemotron analysis"
          },
          "total_pipeline": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total end-to-end pipeline latency"
          },
          "window_minutes": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Window Minutes",
            "description": "Time window used for calculating statistics"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of latency snapshot"
          }
        },
        "type": "object",
        "required": ["window_minutes", "timestamp"],
        "title": "PipelineLatencyResponse",
        "description": "Response schema for pipeline latency endpoint.\n\nProvides latency metrics for each stage transition in the AI pipeline:\n- watch_to_detect: Time from file watcher detecting image to RT-DETR processing start\n- detect_to_batch: Time from detection completion to batch aggregation\n- batch_to_analyze: Time from batch completion to Nemotron analysis start\n- total_pipeline: Total end-to-end processing time",
        "example": {
          "batch_to_analyze": {
            "avg_ms": 5000.0,
            "max_ms": 15000.0,
            "min_ms": 2000.0,
            "p50_ms": 4500.0,
            "p95_ms": 12000.0,
            "p99_ms": 14000.0,
            "sample_count": 100
          },
          "detect_to_batch": {
            "avg_ms": 100.0,
            "max_ms": 500.0,
            "min_ms": 20.0,
            "p50_ms": 80.0,
            "p95_ms": 400.0,
            "p99_ms": 480.0,
            "sample_count": 500
          },
          "timestamp": "2025-12-28T10:30:00Z",
          "total_pipeline": {
            "avg_ms": 35000.0,
            "max_ms": 120000.0,
            "min_ms": 10000.0,
            "p50_ms": 30000.0,
            "p95_ms": 100000.0,
            "p99_ms": 110000.0,
            "sample_count": 100
          },
          "watch_to_detect": {
            "avg_ms": 50.0,
            "max_ms": 200.0,
            "min_ms": 10.0,
            "p50_ms": 40.0,
            "p95_ms": 150.0,
            "p99_ms": 180.0,
            "sample_count": 500
          },
          "window_minutes": 60
        }
      },
      "PipelineStageLatency": {
        "properties": {
          "avg_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Ms",
            "description": "Average latency in milliseconds"
          },
          "min_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Ms",
            "description": "Minimum latency in milliseconds"
          },
          "max_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Ms",
            "description": "Maximum latency in milliseconds"
          },
          "p50_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "P50 Ms",
            "description": "50th percentile (median) latency in milliseconds"
          },
          "p95_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "P95 Ms",
            "description": "95th percentile latency in milliseconds"
          },
          "p99_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "P99 Ms",
            "description": "99th percentile latency in milliseconds"
          },
          "sample_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Sample Count",
            "description": "Number of samples used to calculate statistics"
          }
        },
        "type": "object",
        "required": ["sample_count"],
        "title": "PipelineStageLatency",
        "description": "Latency statistics for a single pipeline transition stage.\n\nTracks time between pipeline stages:\n- watch_to_detect: File detection to RT-DETR processing\n- detect_to_batch: Detection to batch aggregation\n- batch_to_analyze: Batch to Nemotron analysis\n- total_pipeline: End-to-end latency",
        "example": {
          "avg_ms": 150.5,
          "max_ms": 500.0,
          "min_ms": 50.0,
          "p50_ms": 120.0,
          "p95_ms": 400.0,
          "p99_ms": 480.0,
          "sample_count": 100
        }
      },
      "PipelineStateResponse": {
        "properties": {
          "queue_depths": {
            "$ref": "#/components/schemas/QueueDepths",
            "description": "Current queue depths for detection and analysis queues"
          },
          "workers": {
            "$ref": "#/components/schemas/PipelineWorkersStatus",
            "description": "Status of all pipeline workers (file_watcher, detector, analyzer)"
          },
          "recent_errors": {
            "items": {
              "$ref": "#/components/schemas/RecentError"
            },
            "type": "array",
            "title": "Recent Errors",
            "description": "Recent errors from the last 10 pipeline failures (placeholder)"
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when the snapshot was taken",
            "example": "2025-12-30T10:30:00Z"
          },
          "correlation_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correlation Id",
            "description": "Correlation ID echoed from X-Correlation-ID header for request tracing",
            "example": "req-abc123-def456"
          }
        },
        "type": "object",
        "required": ["queue_depths", "workers", "timestamp"],
        "title": "PipelineStateResponse",
        "description": "Response for pipeline state inspection.\n\nProvides a comprehensive snapshot of the AI processing pipeline state,\nincluding queue depths, worker health, and recent errors. Useful for\ndebugging pipeline stalls, identifying bottlenecks, and monitoring\nsystem health during development."
      },
      "PipelineStatusResponse": {
        "properties": {
          "file_watcher": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FileWatcherStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "FileWatcher service status (null if not running)"
          },
          "batch_aggregator": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BatchAggregatorStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "BatchAggregator service status (null if not running)"
          },
          "degradation": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DegradationStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "DegradationManager service status (null if not initialized)"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of status snapshot"
          }
        },
        "type": "object",
        "required": ["timestamp"],
        "title": "PipelineStatusResponse",
        "description": "Combined status of all pipeline operations.\n\nProvides visibility into:\n- FileWatcher: Monitoring camera directories for new uploads\n- BatchAggregator: Grouping detections into time-based batches\n- DegradationManager: Graceful degradation and service health",
        "example": {
          "batch_aggregator": {
            "active_batches": 1,
            "batch_window_seconds": 90,
            "batches": [],
            "idle_timeout_seconds": 30
          },
          "degradation": {
            "available_features": ["detection", "analysis", "events", "media"],
            "fallback_queues": {},
            "is_degraded": false,
            "memory_queue_size": 0,
            "mode": "normal",
            "redis_healthy": true,
            "services": []
          },
          "file_watcher": {
            "camera_root": "/export/foscam",
            "observer_type": "native",
            "pending_tasks": 0,
            "running": true
          },
          "timestamp": "2025-12-30T10:30:00Z"
        }
      },
      "PipelineWorkerStatus": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Worker name (file_watcher, detector, or analyzer)",
            "example": "file_watcher"
          },
          "running": {
            "type": "boolean",
            "title": "Running",
            "description": "Whether worker is currently running based on heartbeat presence"
          },
          "last_activity": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Activity",
            "description": "ISO timestamp of last heartbeat activity (null if never active)",
            "example": "2025-12-30T10:30:00Z"
          },
          "error_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Error Count",
            "description": "Number of recent errors tracked in Redis",
            "default": 0
          }
        },
        "type": "object",
        "required": ["name", "running"],
        "title": "PipelineWorkerStatus",
        "description": "Status of a pipeline worker.\n\nTracks the health and activity of individual pipeline workers including\nfile watcher, detector, and analyzer components."
      },
      "PipelineWorkersStatus": {
        "properties": {
          "file_watcher": {
            "$ref": "#/components/schemas/PipelineWorkerStatus",
            "description": "File watcher worker status - monitors /export/foscam for new images"
          },
          "detector": {
            "$ref": "#/components/schemas/PipelineWorkerStatus",
            "description": "Detector worker status - RT-DETRv2 object detection"
          },
          "analyzer": {
            "$ref": "#/components/schemas/PipelineWorkerStatus",
            "description": "Analyzer worker status - Nemotron LLM risk analysis"
          }
        },
        "type": "object",
        "required": ["file_watcher", "detector", "analyzer"],
        "title": "PipelineWorkersStatus",
        "description": "Status of all pipeline workers.\n\nGroups status information for the three main pipeline components:\n- file_watcher: Monitors camera directories for new image uploads\n- detector: Runs RT-DETRv2 object detection on queued images\n- analyzer: Runs Nemotron LLM analysis on detection batches"
      },
      "PoseEnrichment": {
        "properties": {
          "keypoints": {
            "anyOf": [
              {
                "items": {
                  "items": {
                    "type": "number"
                  },
                  "type": "array"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Keypoints",
            "description": "Body keypoints [[x, y, conf], ...]"
          },
          "action": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Action",
            "description": "Recognized action (walking, running, etc.)"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Action confidence"
          }
        },
        "type": "object",
        "title": "PoseEnrichment",
        "description": "Pose estimation results (placeholder for future ViTPose integration).",
        "example": {
          "action": "walking",
          "confidence": 0.82,
          "keypoints": [
            [100, 150, 0.9],
            [120, 160, 0.85]
          ]
        }
      },
      "ProfileStartResponse": {
        "properties": {
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Profiling status: 'started' (newly started) or 'already_running'",
            "example": "started"
          },
          "started_at": {
            "type": "string",
            "title": "Started At",
            "description": "ISO timestamp when profiling started (may be earlier if already running)",
            "example": "2025-12-30T10:30:00Z"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable status message",
            "example": "Profiling started successfully"
          }
        },
        "type": "object",
        "required": ["status", "started_at", "message"],
        "title": "ProfileStartResponse",
        "description": "Response for starting profiling.\n\nIndicates whether profiling was successfully started or was already running.\nUse with snakeviz or py-spy to analyze the generated .prof files."
      },
      "ProfileStatsResponse": {
        "properties": {
          "is_profiling": {
            "type": "boolean",
            "title": "Is Profiling",
            "description": "Whether profiling is currently active and collecting data"
          },
          "stats_text": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stats Text",
            "description": "Human-readable profiling statistics from last completed session (null if profiling active or never run)"
          },
          "last_profile_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Profile Path",
            "description": "Path to the most recently saved .prof file",
            "example": "/app/data/profiles/profile_20251230_103000.prof"
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when statistics were retrieved",
            "example": "2025-12-30T10:35:00Z"
          }
        },
        "type": "object",
        "required": ["is_profiling", "timestamp"],
        "title": "ProfileStatsResponse",
        "description": "Response for profiling statistics.\n\nReturns the current profiling state and, if profiling has completed,\na human-readable summary of the profiling statistics from the last session."
      },
      "ProfileStopResponse": {
        "properties": {
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Profiling status: 'stopped' (was running) or 'not_running'",
            "example": "stopped"
          },
          "profile_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Profile Path",
            "description": "Absolute path to the saved .prof file (null if profiling wasn't running)",
            "example": "/app/data/profiles/profile_20251230_103000.prof"
          },
          "stopped_at": {
            "type": "string",
            "title": "Stopped At",
            "description": "ISO timestamp when profiling was stopped",
            "example": "2025-12-30T10:35:00Z"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable status message with file path if saved",
            "example": "Profiling stopped. Profile saved to: /app/data/profiles/profile.prof"
          }
        },
        "type": "object",
        "required": ["status", "stopped_at", "message"],
        "title": "ProfileStopResponse",
        "description": "Response for stopping profiling.\n\nStops the profiler and saves the profile data to a .prof file.\nThe file path is returned for subsequent analysis with tools like\nsnakeviz (web UI) or py-spy (flame graphs)."
      },
      "PromptConfigRequest": {
        "properties": {
          "systemPrompt": {
            "type": "string",
            "minLength": 1,
            "title": "Systemprompt",
            "description": "Full system prompt text for the model"
          },
          "temperature": {
            "type": "number",
            "maximum": 2.0,
            "minimum": 0.0,
            "title": "Temperature",
            "description": "LLM temperature setting (0-2)",
            "default": 0.7
          },
          "maxTokens": {
            "type": "integer",
            "maximum": 8192.0,
            "minimum": 100.0,
            "title": "Maxtokens",
            "description": "Maximum tokens in response (100-8192)",
            "default": 2048
          }
        },
        "type": "object",
        "required": ["systemPrompt"],
        "title": "PromptConfigRequest",
        "description": "Request to update a model's prompt configuration (database-backed).\n\nUsed by the Prompt Playground \"Save\" functionality to persist\nprompt configurations to the database.",
        "example": {
          "maxTokens": 2048,
          "systemPrompt": "You are a security analyst reviewing camera footage. Analyze the detected objects and assess the risk level...",
          "temperature": 0.7
        }
      },
      "PromptConfigResponse": {
        "properties": {
          "model": {
            "type": "string",
            "title": "Model",
            "description": "Model name"
          },
          "systemPrompt": {
            "type": "string",
            "title": "Systemprompt",
            "description": "Full system prompt text for the model"
          },
          "temperature": {
            "type": "number",
            "title": "Temperature",
            "description": "LLM temperature setting (0-2)"
          },
          "maxTokens": {
            "type": "integer",
            "title": "Maxtokens",
            "description": "Maximum tokens in response (100-8192)"
          },
          "version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Version",
            "description": "Configuration version number"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "Updatedat",
            "description": "When the configuration was last updated"
          }
        },
        "type": "object",
        "required": ["model", "systemPrompt", "temperature", "maxTokens", "version", "updatedAt"],
        "title": "PromptConfigResponse",
        "description": "Response containing a model's prompt configuration (database-backed).\n\nReturned when retrieving or updating prompt configurations.",
        "example": {
          "maxTokens": 2048,
          "model": "nemotron",
          "systemPrompt": "You are a security analyst reviewing camera footage...",
          "temperature": 0.7,
          "updatedAt": "2026-01-03T10:30:00Z",
          "version": 3
        }
      },
      "PromptExportResponse": {
        "properties": {
          "exported_at": {
            "type": "string",
            "format": "date-time",
            "title": "Exported At",
            "description": "When the export was created"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Export format version",
            "default": "1.0"
          },
          "prompts": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "object",
            "title": "Prompts",
            "description": "All model configurations keyed by model name"
          }
        },
        "type": "object",
        "required": ["exported_at", "prompts"],
        "title": "PromptExportResponse",
        "description": "Response containing all prompt configurations for export.\n\nProvides a complete snapshot of all AI model configurations\nthat can be imported to another instance or used for backup.",
        "example": {
          "exported_at": "2026-01-03T10:30:00Z",
          "prompts": {
            "florence2": {
              "vqa_queries": ["What is happening?", "Who is present?"]
            },
            "nemotron": {
              "max_tokens": 2048,
              "system_prompt": "You are a security analyst...",
              "temperature": 0.7
            }
          },
          "version": "1.0"
        }
      },
      "PromptHistoryEntry": {
        "properties": {
          "version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Version",
            "description": "Version number"
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "Configuration at this version"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "When this version was created"
          },
          "created_by": {
            "type": "string",
            "title": "Created By",
            "description": "Who created this version",
            "default": "system"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of changes"
          }
        },
        "type": "object",
        "required": ["version", "config", "created_at"],
        "title": "PromptHistoryEntry",
        "description": "A single entry in prompt version history.\n\nRepresents one version of a model's configuration with metadata\nabout who created it and why.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "You are a security analyst...",
            "temperature": 0.7
          },
          "created_at": "2026-01-03T10:30:00Z",
          "created_by": "user",
          "description": "Added temporal context guidance",
          "version": 5
        }
      },
      "PromptHistoryResponse": {
        "properties": {
          "model_name": {
            "type": "string",
            "title": "Model Name",
            "description": "Name of the AI model"
          },
          "versions": {
            "items": {
              "$ref": "#/components/schemas/PromptHistoryEntry"
            },
            "type": "array",
            "title": "Versions",
            "description": "List of version entries, newest first"
          },
          "total_versions": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Versions",
            "description": "Total number of versions available"
          }
        },
        "type": "object",
        "required": ["model_name", "versions", "total_versions"],
        "title": "PromptHistoryResponse",
        "description": "Response containing version history for a model's prompts.\n\nReturns all versions ordered by version number descending (newest first),\nwith pagination support through limit/offset query parameters.",
        "example": {
          "model_name": "nemotron",
          "total_versions": 5,
          "versions": [
            {
              "config": {
                "system_prompt": "...",
                "temperature": 0.7
              },
              "created_at": "2026-01-03T10:30:00Z",
              "created_by": "user",
              "description": "Added temporal context guidance",
              "version": 5
            },
            {
              "config": {
                "system_prompt": "...",
                "temperature": 0.8
              },
              "created_at": "2026-01-02T14:00:00Z",
              "created_by": "user",
              "version": 4
            }
          ]
        }
      },
      "PromptImportRequest": {
        "properties": {
          "prompts": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "object",
            "title": "Prompts",
            "description": "Model configurations to import, keyed by model name"
          },
          "overwrite": {
            "type": "boolean",
            "title": "Overwrite",
            "description": "Whether to overwrite existing configurations",
            "default": false
          }
        },
        "type": "object",
        "required": ["prompts"],
        "title": "PromptImportRequest",
        "description": "Request to import prompt configurations.\n\nImport configurations for multiple models at once.\nBy default, existing configurations are skipped unless overwrite=true.",
        "example": {
          "overwrite": false,
          "prompts": {
            "florence2": {
              "vqa_queries": ["What is happening?", "Who is present?"]
            },
            "nemotron": {
              "max_tokens": 2048,
              "system_prompt": "You are a security analyst...",
              "temperature": 0.7
            }
          }
        }
      },
      "PromptImportResponse": {
        "properties": {
          "imported_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Imported Count",
            "description": "Number of models imported"
          },
          "skipped_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Skipped Count",
            "description": "Number of models skipped"
          },
          "errors": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Errors",
            "description": "Any errors encountered"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Summary message of import results"
          }
        },
        "type": "object",
        "required": ["imported_count", "skipped_count", "message"],
        "title": "PromptImportResponse",
        "description": "Response after importing prompt configurations.\n\nReports the results of the import operation including how many\nmodels were imported, skipped, or encountered errors.",
        "example": {
          "errors": [],
          "imported_count": 3,
          "message": "Imported 3 model(s), skipped 2 (already exist)",
          "skipped_count": 2
        }
      },
      "PromptImprovements": {
        "properties": {
          "missing_context": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Missing Context",
            "description": "Context the LLM wished it had for better analysis"
          },
          "confusing_sections": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Confusing Sections",
            "description": "Parts of the prompt that were unclear or ambiguous"
          },
          "unused_data": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Unused Data",
            "description": "Enrichment data provided but not utilized in reasoning"
          },
          "format_suggestions": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Format Suggestions",
            "description": "Suggestions for better prompt structure or formatting"
          },
          "model_gaps": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Model Gaps",
            "description": "AI models that could help but were not available"
          }
        },
        "type": "object",
        "title": "PromptImprovements",
        "description": "Prompt improvement suggestions generated during self-evaluation.\n\nThe LLM identifies areas where the prompt template could be improved\nto produce better risk analysis results.",
        "example": {
          "confusing_sections": [],
          "format_suggestions": ["Consider grouping detection context by confidence"],
          "missing_context": [
            "Time since last detected motion",
            "Historical activity patterns for this camera"
          ],
          "model_gaps": ["Vehicle classification could help with driveway events"],
          "unused_data": ["Weather data provided but not referenced"]
        }
      },
      "PromptRestoreRequest": {
        "properties": {
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Optional description for the restore action"
          }
        },
        "type": "object",
        "title": "PromptRestoreRequest",
        "description": "Request to restore a specific version of a prompt.\n\nThe restore operation creates a new version with the configuration\nfrom the specified version. Original versions are preserved.",
        "example": {
          "description": "Reverting to version 3 due to quality regression"
        }
      },
      "PromptRestoreResponse": {
        "properties": {
          "model_name": {
            "type": "string",
            "title": "Model Name",
            "description": "Name of the AI model"
          },
          "restored_version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Restored Version",
            "description": "Version that was restored"
          },
          "new_version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "New Version",
            "description": "New version number created"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Success message with details"
          }
        },
        "type": "object",
        "required": ["model_name", "restored_version", "new_version", "message"],
        "title": "PromptRestoreResponse",
        "description": "Response after restoring a prompt version.\n\nConfirms which version was restored and the new version number created.",
        "example": {
          "message": "Restored version 3 as new version 6",
          "model_name": "nemotron",
          "new_version": 6,
          "restored_version": 3
        }
      },
      "PromptTestRequest": {
        "properties": {
          "model": {
            "type": "string",
            "title": "Model",
            "description": "Model name to test (nemotron, florence2, etc.)"
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "Modified configuration to test"
          },
          "event_id": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Event Id",
            "description": "Event ID to test against"
          }
        },
        "type": "object",
        "required": ["model", "config", "event_id"],
        "title": "PromptTestRequest",
        "description": "Request to test a modified prompt against an event.\n\nUsed for A/B testing prompt changes by comparing results from\nthe current and modified configurations on the same event.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "You are a security analyst with expertise in behavioral analysis...",
            "temperature": 0.6
          },
          "event_id": 42,
          "model": "nemotron"
        }
      },
      "PromptTestResponse": {
        "properties": {
          "before": {
            "$ref": "#/components/schemas/PromptTestResultBefore",
            "description": "Results from original prompt"
          },
          "after": {
            "$ref": "#/components/schemas/PromptTestResultAfter",
            "description": "Results from modified prompt"
          },
          "improved": {
            "type": "boolean",
            "title": "Improved",
            "description": "Whether the modification improved results"
          },
          "inference_time_ms": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Inference Time Ms",
            "description": "Time taken for inference in ms"
          }
        },
        "type": "object",
        "required": ["before", "after", "improved", "inference_time_ms"],
        "title": "PromptTestResponse",
        "description": "Response from testing a modified prompt configuration.\n\nProvides a side-by-side comparison of before/after results\nto help evaluate whether the change improves risk analysis.",
        "example": {
          "after": {
            "risk_level": "medium",
            "score": 45,
            "summary": "Delivery person at front door during business hours"
          },
          "before": {
            "risk_level": "high",
            "score": 65,
            "summary": "Person detected at front door"
          },
          "improved": true,
          "inference_time_ms": 2150
        }
      },
      "PromptTestResultAfter": {
        "properties": {
          "score": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Score",
            "description": "Risk score from modified prompt"
          },
          "risk_level": {
            "type": "string",
            "title": "Risk Level",
            "description": "Risk level (low, medium, high, critical)"
          },
          "summary": {
            "type": "string",
            "title": "Summary",
            "description": "Summary from modified analysis"
          }
        },
        "type": "object",
        "required": ["score", "risk_level", "summary"],
        "title": "PromptTestResultAfter",
        "description": "Result from the modified prompt.\n\nShows results after applying the proposed configuration changes.",
        "example": {
          "risk_level": "medium",
          "score": 45,
          "summary": "Delivery person at front door during business hours"
        }
      },
      "PromptTestResultBefore": {
        "properties": {
          "score": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Score",
            "description": "Risk score from original prompt"
          },
          "risk_level": {
            "type": "string",
            "title": "Risk Level",
            "description": "Risk level (low, medium, high, critical)"
          },
          "summary": {
            "type": "string",
            "title": "Summary",
            "description": "Summary from original analysis"
          }
        },
        "type": "object",
        "required": ["score", "risk_level", "summary"],
        "title": "PromptTestResultBefore",
        "description": "Result from the original (current) prompt.\n\nShows the baseline results that will be compared against the modified version.",
        "example": {
          "risk_level": "high",
          "score": 65,
          "summary": "Person detected at front door"
        }
      },
      "PromptUpdateRequest": {
        "properties": {
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "New configuration for the model"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the changes"
          }
        },
        "type": "object",
        "required": ["config"],
        "title": "PromptUpdateRequest",
        "description": "Request to update a model's prompt configuration.\n\nThe config dict must contain all required fields for the target model.\nOptional description helps track changes in version history.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "You are a security analyst reviewing camera footage. Analyze detections and assess risk level...",
            "temperature": 0.7
          },
          "description": "Added temporal context guidance for better risk assessment"
        }
      },
      "PromptUpdateResponse": {
        "properties": {
          "model_name": {
            "type": "string",
            "title": "Model Name",
            "description": "Name of the updated model"
          },
          "version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Version",
            "description": "New version number after update"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Success message with version info"
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "The updated configuration"
          }
        },
        "type": "object",
        "required": ["model_name", "version", "message", "config"],
        "title": "PromptUpdateResponse",
        "description": "Response after updating a model's prompt configuration.\n\nConfirms the update was successful and returns the new version number.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "You are a security analyst...",
            "temperature": 0.7
          },
          "message": "Configuration updated to version 6",
          "model_name": "nemotron",
          "version": 6
        }
      },
      "QualityScores": {
        "properties": {
          "context_usage": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 5.0,
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Context Usage",
            "description": "How well enrichment context was used (1-5)"
          },
          "reasoning_coherence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 5.0,
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Reasoning Coherence",
            "description": "Logical flow and clarity of reasoning (1-5)"
          },
          "risk_justification": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 5.0,
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Justification",
            "description": "Quality of evidence supporting risk score (1-5)"
          },
          "consistency": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 5.0,
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Consistency",
            "description": "Score stability across re-evaluations (1-5)"
          },
          "overall": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 5.0,
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Overall",
            "description": "Weighted average of all quality dimensions (1-5)"
          }
        },
        "type": "object",
        "title": "QualityScores",
        "description": "Self-evaluation quality scores on a 1-5 rubric scale.\n\nScores are generated by the LLM self-evaluation process:\n- 1: Poor - major issues with this dimension\n- 2: Below Average - notable problems\n- 3: Average - acceptable but room for improvement\n- 4: Good - solid performance with minor issues\n- 5: Excellent - exemplary quality",
        "example": {
          "consistency": 4.3,
          "context_usage": 4.2,
          "overall": 4.25,
          "reasoning_coherence": 4.5,
          "risk_justification": 4.0
        }
      },
      "QueueDepths": {
        "properties": {
          "detection_queue": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Detection Queue",
            "description": "Number of items in detection queue waiting for RT-DETRv2 processing"
          },
          "analysis_queue": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Analysis Queue",
            "description": "Number of batches in analysis queue waiting for Nemotron LLM analysis"
          }
        },
        "type": "object",
        "required": ["detection_queue", "analysis_queue"],
        "title": "QueueDepths",
        "description": "Queue depth information for pipeline queues.",
        "example": {
          "analysis_queue": 2,
          "detection_queue": 5
        }
      },
      "QuietHoursPeriodCreate": {
        "properties": {
          "label": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Label",
            "description": "Period label"
          },
          "start_time": {
            "type": "string",
            "format": "time",
            "title": "Start Time",
            "description": "Start time (HH:MM:SS)"
          },
          "end_time": {
            "type": "string",
            "format": "time",
            "title": "End Time",
            "description": "End time (HH:MM:SS)"
          },
          "days": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Days",
            "description": "Days of week when period is active"
          }
        },
        "type": "object",
        "required": ["label", "start_time", "end_time"],
        "title": "QuietHoursPeriodCreate",
        "description": "Schema for creating a quiet hours period.",
        "example": {
          "days": ["monday", "tuesday", "wednesday", "thursday", "friday"],
          "end_time": "06:00:00",
          "label": "Night Time",
          "start_time": "22:00:00"
        }
      },
      "QuietHoursPeriodResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Period UUID"
          },
          "label": {
            "type": "string",
            "title": "Label",
            "description": "Period label"
          },
          "start_time": {
            "type": "string",
            "format": "time",
            "title": "Start Time",
            "description": "Start time"
          },
          "end_time": {
            "type": "string",
            "format": "time",
            "title": "End Time",
            "description": "End time"
          },
          "days": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Days",
            "description": "Days of week when period is active"
          }
        },
        "type": "object",
        "required": ["id", "label", "start_time", "end_time", "days"],
        "title": "QuietHoursPeriodResponse",
        "description": "Schema for quiet hours period response.",
        "example": {
          "days": ["monday", "tuesday", "wednesday", "thursday", "friday"],
          "end_time": "06:00:00",
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "label": "Night Time",
          "start_time": "22:00:00"
        }
      },
      "QuietHoursPeriodsListResponse": {
        "properties": {
          "periods": {
            "items": {
              "$ref": "#/components/schemas/QuietHoursPeriodResponse"
            },
            "type": "array",
            "title": "Periods",
            "description": "List of quiet hours periods"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Total number of periods"
          }
        },
        "type": "object",
        "required": ["periods", "count"],
        "title": "QuietHoursPeriodsListResponse",
        "description": "Schema for quiet hours periods list response.",
        "example": {
          "count": 1,
          "periods": [
            {
              "days": ["monday", "tuesday", "wednesday", "thursday", "friday"],
              "end_time": "06:00:00",
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "label": "Night Time",
              "start_time": "22:00:00"
            }
          ]
        }
      },
      "RUMBatchRequest": {
        "properties": {
          "metrics": {
            "items": {
              "$ref": "#/components/schemas/WebVitalMetric"
            },
            "type": "array",
            "minItems": 1,
            "title": "Metrics",
            "description": "List of metrics to ingest (non-empty)"
          },
          "session_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Session Id",
            "description": "Optional session identifier"
          },
          "user_agent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Agent",
            "description": "Optional user agent string"
          }
        },
        "type": "object",
        "required": ["metrics"],
        "title": "RUMBatchRequest",
        "description": "Batch request for multiple Core Web Vitals metrics.\n\nThe frontend batches metrics to reduce API calls. Each batch may contain\nmetrics from different pages or navigation events.\n\nAttributes:\n    metrics: List of Core Web Vital metrics to ingest\n    session_id: Optional session identifier for correlating metrics\n    user_agent: Optional user agent string for device/browser analysis",
        "example": {
          "metrics": [
            {
              "delta": 2500.0,
              "id": "v1-1234567890123-1234567890123",
              "name": "LCP",
              "rating": "good",
              "value": 2500.0
            },
            {
              "delta": 0.02,
              "id": "v1-1234567890123-1234567890124",
              "name": "CLS",
              "rating": "good",
              "value": 0.05
            }
          ],
          "session_id": "sess-12345"
        }
      },
      "RUMIngestResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether ingestion was successful"
          },
          "metrics_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Metrics Count",
            "description": "Number of metrics successfully ingested"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable status message"
          },
          "errors": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Errors",
            "description": "List of any errors encountered"
          }
        },
        "type": "object",
        "required": ["success", "metrics_count", "message"],
        "title": "RUMIngestResponse",
        "description": "Response from the RUM metrics ingestion endpoint.\n\nAttributes:\n    success: Whether the ingestion was successful\n    metrics_count: Number of metrics successfully ingested\n    message: Human-readable status message\n    errors: List of any errors encountered during ingestion",
        "example": {
          "errors": [],
          "message": "Successfully ingested 5 metrics",
          "metrics_count": 5,
          "success": true
        }
      },
      "ReadinessResponse": {
        "properties": {
          "ready": {
            "type": "boolean",
            "title": "Ready",
            "description": "Overall readiness status: True if system can process requests"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Status string: 'ready', 'degraded', or 'not_ready'"
          },
          "services": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HealthCheckServiceStatus"
            },
            "type": "object",
            "title": "Services",
            "description": "Status of infrastructure services (database, redis, ai)"
          },
          "workers": {
            "items": {
              "$ref": "#/components/schemas/WorkerStatus"
            },
            "type": "array",
            "title": "Workers",
            "description": "Status of background workers"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of readiness check"
          },
          "ai_warmth_status": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ai Warmth Status",
            "description": "Warmth status of AI models (NEM-1670). Keys are model names (e.g., 'rtdetr', 'nemotron'), values are states: 'cold', 'warming', 'warm'"
          }
        },
        "type": "object",
        "required": ["ready", "status", "services", "timestamp"],
        "title": "ReadinessResponse",
        "description": "Response schema for readiness probe endpoint.\n\nReadiness probes indicate whether the application is ready to receive\ntraffic and process requests. This checks all dependencies:\n- Database connectivity\n- Redis connectivity\n- AI services availability\n- Background worker status",
        "example": {
          "ready": true,
          "services": {
            "ai": {
              "message": "AI services operational",
              "status": "healthy"
            },
            "database": {
              "message": "Database operational",
              "status": "healthy"
            },
            "redis": {
              "details": {
                "redis_version": "7.0.0"
              },
              "message": "Redis connected",
              "status": "healthy"
            }
          },
          "status": "ready",
          "timestamp": "2025-12-23T10:30:00",
          "workers": [
            {
              "name": "gpu_monitor",
              "running": true
            },
            {
              "name": "cleanup_service",
              "running": true
            }
          ]
        }
      },
      "RecentError": {
        "properties": {
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when the error occurred",
            "example": "2025-12-30T10:30:00Z"
          },
          "error_type": {
            "type": "string",
            "title": "Error Type",
            "description": "Type/class of the error (e.g., TimeoutError, ConnectionError)",
            "example": "TimeoutError"
          },
          "component": {
            "type": "string",
            "title": "Component",
            "description": "Pipeline component that generated the error",
            "example": "detector"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Human-readable error message with details",
            "example": "RT-DETR inference timed out after 30s"
          }
        },
        "type": "object",
        "required": ["timestamp", "error_type", "component"],
        "title": "RecentError",
        "description": "Recent error information.\n\nCaptures details about errors that occurred in the AI pipeline,\nuseful for debugging intermittent issues and identifying patterns."
      },
      "RecommendationItem": {
        "properties": {
          "category": {
            "type": "string",
            "title": "Category",
            "description": "Category: missing_context, unused_data, model_gaps, format_suggestions"
          },
          "suggestion": {
            "type": "string",
            "title": "Suggestion",
            "description": "The improvement suggestion text"
          },
          "frequency": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Frequency",
            "description": "Number of events mentioning this suggestion"
          },
          "priority": {
            "type": "string",
            "pattern": "^(high|medium|low)$",
            "title": "Priority",
            "description": "Priority: high, medium, low"
          }
        },
        "type": "object",
        "required": ["category", "suggestion", "frequency", "priority"],
        "title": "RecommendationItem",
        "description": "Single prompt improvement recommendation.\n\nAggregated from multiple event audits to identify common improvement opportunities.",
        "example": {
          "category": "missing_context",
          "frequency": 45,
          "priority": "high",
          "suggestion": "Time since last detected motion or event"
        }
      },
      "RecommendationsResponse": {
        "properties": {
          "recommendations": {
            "items": {
              "$ref": "#/components/schemas/RecommendationItem"
            },
            "type": "array",
            "title": "Recommendations",
            "description": "Prioritized list of improvement suggestions"
          },
          "total_events_analyzed": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Events Analyzed",
            "description": "Number of fully-evaluated events analyzed"
          }
        },
        "type": "object",
        "required": ["recommendations", "total_events_analyzed"],
        "title": "RecommendationsResponse",
        "description": "Aggregated prompt improvement recommendations.\n\nCompiles suggestions from multiple event audits, prioritized by frequency and impact.",
        "example": {
          "recommendations": [
            {
              "category": "missing_context",
              "frequency": 45,
              "priority": "high",
              "suggestion": "Time since last detected motion or event"
            },
            {
              "category": "unused_data",
              "frequency": 28,
              "priority": "medium",
              "suggestion": "Weather data rarely referenced in analysis"
            }
          ],
          "total_events_analyzed": 950
        }
      },
      "RecordingResponse": {
        "properties": {
          "recording_id": {
            "type": "string",
            "title": "Recording Id",
            "description": "Unique recording ID (alphanumeric with hyphens/underscores)",
            "example": "rec_20251230_103000_abc123"
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when the original request was recorded",
            "example": "2025-12-30T10:30:00Z"
          },
          "method": {
            "type": "string",
            "title": "Method",
            "description": "HTTP method of the recorded request",
            "example": "POST"
          },
          "path": {
            "type": "string",
            "title": "Path",
            "description": "Request path including query string if present",
            "example": "/api/events?limit=10"
          },
          "status_code": {
            "type": "integer",
            "maximum": 599.0,
            "minimum": 100.0,
            "title": "Status Code",
            "description": "HTTP response status code from the original request",
            "example": 200
          },
          "duration_ms": {
            "type": "number",
            "minimum": 0.0,
            "title": "Duration Ms",
            "description": "Original request duration in milliseconds",
            "example": 45.2
          },
          "body_truncated": {
            "type": "boolean",
            "title": "Body Truncated",
            "description": "Whether the request/response body was truncated due to size limits",
            "default": false
          }
        },
        "type": "object",
        "required": ["recording_id", "timestamp", "method", "path", "status_code", "duration_ms"],
        "title": "RecordingResponse",
        "description": "Response for a single recording.\n\nSummarizes a recorded HTTP request for listing purposes.\nUse the recording_id to retrieve full details or replay the request."
      },
      "RecordingsListResponse": {
        "properties": {
          "recordings": {
            "items": {
              "$ref": "#/components/schemas/RecordingResponse"
            },
            "type": "array",
            "title": "Recordings",
            "description": "List of recording summaries (newest first)"
          },
          "total": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total",
            "description": "Total number of recordings returned (may be less than available if limited)",
            "example": 25
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when the list was retrieved",
            "example": "2025-12-30T10:30:00Z"
          }
        },
        "type": "object",
        "required": ["recordings", "total", "timestamp"],
        "title": "RecordingsListResponse",
        "description": "Response for listing recordings.\n\nReturns a paginated list of recorded HTTP requests, sorted by timestamp\nwith newest first. Use limit parameter to control page size."
      },
      "RedisInfoResponse": {
        "properties": {
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Redis connection status: 'connected', 'unavailable', or 'error'",
            "example": "connected"
          },
          "info": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Info",
            "description": "Redis INFO command output with version, memory, connections, uptime",
            "example": {
              "connected_clients": 5,
              "redis_version": "7.0.0",
              "total_commands_processed": 12500,
              "total_connections_received": 150,
              "uptime_in_seconds": 86400,
              "used_memory_human": "2.5M",
              "used_memory_peak_human": "3.1M"
            }
          },
          "pubsub": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pubsub",
            "description": "Active pub/sub channels and their subscriber counts",
            "example": {
              "channels": ["events", "system"],
              "subscriber_counts": {
                "events": 3,
                "system": 2
              }
            }
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when Redis info was retrieved",
            "example": "2025-12-30T10:30:00Z"
          }
        },
        "type": "object",
        "required": ["status", "timestamp"],
        "title": "RedisInfoResponse",
        "description": "Response for Redis connection stats.\n\nProvides Redis server diagnostics including memory usage, connection counts,\nuptime, and active pub/sub channels with subscriber counts."
      },
      "ReplayResponse": {
        "properties": {
          "recording_id": {
            "type": "string",
            "title": "Recording Id",
            "description": "ID of the recording that was replayed",
            "example": "rec_20251230_103000_abc123"
          },
          "original_status_code": {
            "type": "integer",
            "maximum": 599.0,
            "minimum": 100.0,
            "title": "Original Status Code",
            "description": "HTTP status code from the original recorded request",
            "example": 500
          },
          "replay_status_code": {
            "type": "integer",
            "maximum": 599.0,
            "minimum": 100.0,
            "title": "Replay Status Code",
            "description": "HTTP status code from the replayed request",
            "example": 200
          },
          "replay_response": {
            "title": "Replay Response",
            "description": "Response body from the replayed request (JSON or text)",
            "example": {
              "data": [],
              "status": "ok"
            }
          },
          "replay_metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Replay Metadata",
            "description": "Metadata about the replay including timing and original request details",
            "example": {
              "original_method": "GET",
              "original_path": "/api/events",
              "original_timestamp": "2025-12-30T10:30:00Z",
              "replay_duration_ms": 42.5,
              "replayed_at": "2025-12-30T11:00:00Z"
            }
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when the replay completed",
            "example": "2025-12-30T11:00:00Z"
          }
        },
        "type": "object",
        "required": [
          "recording_id",
          "original_status_code",
          "replay_status_code",
          "replay_response",
          "replay_metadata",
          "timestamp"
        ],
        "title": "ReplayResponse",
        "description": "Response for request replay.\n\nCompares the original recorded response with the replayed response,\nuseful for reproducing production issues, testing fixes, and debugging\nintermittent failures."
      },
      "RiskHistoryDataPoint": {
        "properties": {
          "date": {
            "type": "string",
            "format": "date",
            "title": "Date",
            "description": "Date of the data point"
          },
          "low": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Low",
            "description": "Count of low risk events",
            "default": 0
          },
          "medium": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Medium",
            "description": "Count of medium risk events",
            "default": 0
          },
          "high": {
            "type": "integer",
            "minimum": 0.0,
            "title": "High",
            "description": "Count of high risk events",
            "default": 0
          },
          "critical": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Critical",
            "description": "Count of critical risk events",
            "default": 0
          }
        },
        "type": "object",
        "required": ["date"],
        "title": "RiskHistoryDataPoint",
        "description": "Schema for a single risk history data point.",
        "example": {
          "critical": 1,
          "date": "2025-01-07",
          "high": 2,
          "low": 10,
          "medium": 5
        }
      },
      "RiskHistoryResponse": {
        "properties": {
          "data_points": {
            "items": {
              "$ref": "#/components/schemas/RiskHistoryDataPoint"
            },
            "type": "array",
            "title": "Data Points",
            "description": "Risk level counts aggregated by day"
          },
          "start_date": {
            "type": "string",
            "format": "date",
            "title": "Start Date",
            "description": "Start date of the date range"
          },
          "end_date": {
            "type": "string",
            "format": "date",
            "title": "End Date",
            "description": "End date of the date range"
          }
        },
        "type": "object",
        "required": ["data_points", "start_date", "end_date"],
        "title": "RiskHistoryResponse",
        "description": "Schema for risk score distribution over time.",
        "example": {
          "data_points": [
            {
              "critical": 1,
              "date": "2025-01-01",
              "high": 2,
              "low": 10,
              "medium": 5
            },
            {
              "critical": 0,
              "date": "2025-01-02",
              "high": 3,
              "low": 12,
              "medium": 4
            }
          ],
          "end_date": "2025-01-02",
          "start_date": "2025-01-01"
        }
      },
      "RuleTestEventResult": {
        "properties": {
          "event_id": {
            "type": "integer",
            "title": "Event Id",
            "description": "Event ID"
          },
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Score",
            "description": "Event risk score"
          },
          "object_types": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Object Types",
            "description": "Detected object types"
          },
          "matches": {
            "type": "boolean",
            "title": "Matches",
            "description": "Whether the rule matched this event"
          },
          "matched_conditions": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Matched Conditions",
            "description": "List of conditions that matched"
          },
          "started_at": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Started At",
            "description": "Event start timestamp"
          }
        },
        "type": "object",
        "required": ["event_id", "camera_id", "matches"],
        "title": "RuleTestEventResult",
        "description": "Schema for a single event's test result.",
        "example": {
          "camera_id": "front_door",
          "event_id": 123,
          "matched_conditions": ["risk_score >= 70", "object_type in ['person']"],
          "matches": true,
          "object_types": ["person"],
          "risk_score": 75,
          "started_at": "2025-12-28T22:15:00Z"
        }
      },
      "RuleTestRequest": {
        "properties": {
          "event_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "integer"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Event Ids",
            "description": "Specific event IDs to test against. If not provided, tests against recent events."
          },
          "limit": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Maximum number of recent events to test (if event_ids not provided)",
            "default": 10
          },
          "test_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Test Time",
            "description": "Override current time for schedule testing (ISO format)"
          }
        },
        "type": "object",
        "title": "RuleTestRequest",
        "description": "Schema for testing a rule against historical events.",
        "example": {
          "event_ids": [1, 2, 3, 4, 5],
          "test_time": "2025-12-28T22:30:00Z"
        }
      },
      "RuleTestResponse": {
        "properties": {
          "rule_id": {
            "type": "string",
            "title": "Rule Id",
            "description": "Rule ID that was tested"
          },
          "rule_name": {
            "type": "string",
            "title": "Rule Name",
            "description": "Rule name"
          },
          "events_tested": {
            "type": "integer",
            "title": "Events Tested",
            "description": "Number of events tested"
          },
          "events_matched": {
            "type": "integer",
            "title": "Events Matched",
            "description": "Number of events that matched the rule"
          },
          "match_rate": {
            "type": "number",
            "title": "Match Rate",
            "description": "Proportion of events that matched (0.0-1.0)"
          },
          "results": {
            "items": {
              "$ref": "#/components/schemas/RuleTestEventResult"
            },
            "type": "array",
            "title": "Results",
            "description": "Per-event test results"
          }
        },
        "type": "object",
        "required": [
          "rule_id",
          "rule_name",
          "events_tested",
          "events_matched",
          "match_rate",
          "results"
        ],
        "title": "RuleTestResponse",
        "description": "Schema for rule test response.",
        "example": {
          "events_matched": 3,
          "events_tested": 10,
          "match_rate": 0.3,
          "results": [
            {
              "camera_id": "front_door",
              "event_id": 123,
              "matched_conditions": ["risk_score >= 70", "object_type in ['person']"],
              "matches": true,
              "object_types": ["person"],
              "risk_score": 75,
              "started_at": "2025-12-28T22:15:00Z"
            }
          ],
          "rule_id": "550e8400-e29b-41d4-a716-446655440000",
          "rule_name": "Night Intruder Alert"
        }
      },
      "SceneChangeAcknowledgeResponse": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Scene change ID"
          },
          "acknowledged": {
            "type": "boolean",
            "title": "Acknowledged",
            "description": "Acknowledgement status (always True)",
            "default": true
          },
          "acknowledged_at": {
            "type": "string",
            "format": "date-time",
            "title": "Acknowledged At",
            "description": "When the change was acknowledged"
          }
        },
        "type": "object",
        "required": ["id", "acknowledged_at"],
        "title": "SceneChangeAcknowledgeResponse",
        "description": "Response schema for acknowledging a scene change.\n\nConfirms that a scene change has been acknowledged.",
        "example": {
          "acknowledged": true,
          "acknowledged_at": "2026-01-03T11:00:00Z",
          "id": 1
        }
      },
      "SceneChangeListResponse": {
        "properties": {
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "scene_changes": {
            "items": {
              "$ref": "#/components/schemas/SceneChangeResponse"
            },
            "type": "array",
            "title": "Scene Changes",
            "description": "List of scene changes"
          },
          "total_changes": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Changes",
            "description": "Number of scene changes returned",
            "default": 0
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Cursor",
            "description": "Cursor for fetching the next page (ISO 8601 timestamp)"
          },
          "has_more": {
            "type": "boolean",
            "title": "Has More",
            "description": "Whether there are more results available",
            "default": false
          }
        },
        "type": "object",
        "required": ["camera_id"],
        "title": "SceneChangeListResponse",
        "description": "Response schema for listing scene changes.\n\nReturns a list of scene changes for a camera with cursor-based pagination.",
        "example": {
          "camera_id": "front_door",
          "has_more": true,
          "next_cursor": "2026-01-03T09:30:00Z",
          "scene_changes": [
            {
              "acknowledged": false,
              "change_type": "view_blocked",
              "detected_at": "2026-01-03T10:30:00Z",
              "id": 1,
              "similarity_score": 0.23
            }
          ],
          "total_changes": 1
        }
      },
      "SceneChangeResponse": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Unique scene change ID"
          },
          "detected_at": {
            "type": "string",
            "format": "date-time",
            "title": "Detected At",
            "description": "When the scene change was detected"
          },
          "change_type": {
            "type": "string",
            "title": "Change Type",
            "description": "Type of change: view_blocked, angle_changed, view_tampered, unknown"
          },
          "similarity_score": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Similarity Score",
            "description": "SSIM similarity score (0-1, lower means more different)"
          },
          "acknowledged": {
            "type": "boolean",
            "title": "Acknowledged",
            "description": "Whether the change has been acknowledged",
            "default": false
          },
          "acknowledged_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Acknowledged At",
            "description": "When the change was acknowledged"
          },
          "file_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Path",
            "description": "Path to the image that triggered detection"
          }
        },
        "type": "object",
        "required": ["id", "detected_at", "change_type", "similarity_score"],
        "title": "SceneChangeResponse",
        "description": "Response schema for a single scene change.\n\nRepresents a detected camera view change that may indicate\ntampering, angle changes, or blocked views.",
        "example": {
          "acknowledged": false,
          "change_type": "view_blocked",
          "detected_at": "2026-01-03T10:30:00Z",
          "file_path": "/export/foscam/front_door/image.jpg",
          "id": 1,
          "similarity_score": 0.23
        }
      },
      "SearchResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/SearchResult"
            },
            "type": "array",
            "title": "Results",
            "description": "List of search results"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of matching events"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Maximum number of results returned"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Number of results skipped"
          }
        },
        "type": "object",
        "required": ["results", "total_count", "limit", "offset"],
        "title": "SearchResponse",
        "description": "Schema for search response with pagination.",
        "example": {
          "limit": 50,
          "offset": 0,
          "results": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_count": 5,
              "detection_ids": [1, 2, 3, 4, 5],
              "ended_at": "2025-12-23T12:02:30Z",
              "id": 1,
              "object_types": "person, vehicle",
              "reasoning": "Unknown individual approaching entrance during nighttime",
              "relevance_score": 0.85,
              "reviewed": false,
              "risk_level": "medium",
              "risk_score": 75,
              "started_at": "2025-12-23T12:00:00Z",
              "summary": "Suspicious person detected near front entrance"
            }
          ],
          "total_count": 42
        }
      },
      "SearchResult": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Event ID"
          },
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID"
          },
          "camera_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Camera Name",
            "description": "Camera display name"
          },
          "started_at": {
            "type": "string",
            "format": "date-time",
            "title": "Started At",
            "description": "Event start timestamp"
          },
          "ended_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ended At",
            "description": "Event end timestamp"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Score",
            "description": "Risk score (0-100)"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Level",
            "description": "Risk level (low, medium, high, critical)"
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Summary",
            "description": "LLM-generated event summary"
          },
          "reasoning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reasoning",
            "description": "LLM reasoning for risk score"
          },
          "reviewed": {
            "type": "boolean",
            "title": "Reviewed",
            "description": "Whether event has been reviewed",
            "default": false
          },
          "detection_count": {
            "type": "integer",
            "title": "Detection Count",
            "description": "Number of detections in this event",
            "default": 0
          },
          "detection_ids": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "title": "Detection Ids",
            "description": "List of detection IDs associated with this event"
          },
          "object_types": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Types",
            "description": "Comma-separated detected object types"
          },
          "relevance_score": {
            "type": "number",
            "title": "Relevance Score",
            "description": "Full-text search relevance score (higher is more relevant)",
            "default": 0.0
          }
        },
        "type": "object",
        "required": ["id", "camera_id", "started_at"],
        "title": "SearchResult",
        "description": "Schema for a single search result.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "detection_count": 5,
          "detection_ids": [1, 2, 3, 4, 5],
          "ended_at": "2025-12-23T12:02:30Z",
          "id": 1,
          "object_types": "person, vehicle",
          "reasoning": "Unknown individual approaching entrance during nighttime hours",
          "relevance_score": 0.85,
          "reviewed": false,
          "risk_level": "medium",
          "risk_score": 75,
          "started_at": "2025-12-23T12:00:00Z",
          "summary": "Suspicious person detected near front entrance"
        }
      },
      "SeedCamerasRequest": {
        "properties": {
          "count": {
            "type": "integer",
            "maximum": 6.0,
            "minimum": 1.0,
            "title": "Count",
            "description": "Number of cameras to create (1-6)",
            "default": 6
          },
          "clear_existing": {
            "type": "boolean",
            "title": "Clear Existing",
            "description": "Remove existing cameras first",
            "default": false
          },
          "create_folders": {
            "type": "boolean",
            "title": "Create Folders",
            "description": "Create camera folders on filesystem",
            "default": false
          }
        },
        "type": "object",
        "title": "SeedCamerasRequest",
        "description": "Request schema for seeding cameras."
      },
      "SeedCamerasResponse": {
        "properties": {
          "created": {
            "type": "integer",
            "title": "Created"
          },
          "cleared": {
            "type": "integer",
            "title": "Cleared"
          },
          "cameras": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Cameras"
          }
        },
        "type": "object",
        "required": ["created", "cleared", "cameras"],
        "title": "SeedCamerasResponse",
        "description": "Response schema for seed cameras endpoint."
      },
      "SeedEventsRequest": {
        "properties": {
          "count": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Count",
            "description": "Number of events to create (1-100)",
            "default": 15
          },
          "clear_existing": {
            "type": "boolean",
            "title": "Clear Existing",
            "description": "Remove existing events and detections",
            "default": false
          }
        },
        "type": "object",
        "title": "SeedEventsRequest",
        "description": "Request schema for seeding events."
      },
      "SeedEventsResponse": {
        "properties": {
          "events_created": {
            "type": "integer",
            "title": "Events Created"
          },
          "detections_created": {
            "type": "integer",
            "title": "Detections Created"
          },
          "events_cleared": {
            "type": "integer",
            "title": "Events Cleared"
          },
          "detections_cleared": {
            "type": "integer",
            "title": "Detections Cleared"
          }
        },
        "type": "object",
        "required": [
          "events_created",
          "detections_created",
          "events_cleared",
          "detections_cleared"
        ],
        "title": "SeedEventsResponse",
        "description": "Response schema for seed events endpoint."
      },
      "ServiceActionResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether the action completed successfully"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable result message"
          },
          "service": {
            "$ref": "#/components/schemas/ServiceInfo",
            "description": "Updated service information after the action"
          }
        },
        "type": "object",
        "required": ["success", "message", "service"],
        "title": "ServiceActionResponse",
        "description": "Response for service action endpoints (restart, enable, disable, start).\n\nReturned after POST /api/system/services/{name}/restart, enable, disable, or start.",
        "example": {
          "message": "Service restarted successfully",
          "service": {
            "category": "ai",
            "container_id": "abc123...",
            "display_name": "RT-DETRv2",
            "enabled": true,
            "failure_count": 0,
            "image": "ghcr.io/.../rtdetr:latest",
            "last_restart_at": "2026-01-05T15:50:00Z",
            "name": "ai-detector",
            "port": 8090,
            "restart_count": 3,
            "status": "starting"
          },
          "success": true
        }
      },
      "ServiceCategory": {
        "type": "string",
        "enum": ["infrastructure", "ai", "monitoring"],
        "title": "ServiceCategory",
        "description": "Service category for classification and restart policy.\n\nCategories determine restart behavior and priority:\n- INFRASTRUCTURE: Critical services (PostgreSQL, Redis) with aggressive restart\n- AI: AI/ML services with standard backoff\n- MONITORING: Optional monitoring services with lenient restart"
      },
      "ServiceHealthState": {
        "type": "string",
        "enum": ["healthy", "unhealthy", "degraded", "unknown"],
        "title": "ServiceHealthState",
        "description": "Health state for a service in the full health check.\n\nStates:\n- healthy: Service is fully operational\n- unhealthy: Service is down or experiencing critical issues\n- degraded: Service is partially operational\n- unknown: Service status cannot be determined"
      },
      "ServiceHealthStatusResponse": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Service name"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Health status (healthy, unhealthy, unknown)"
          },
          "last_check": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Check",
            "description": "Monotonic time of last health check"
          },
          "consecutive_failures": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Consecutive Failures",
            "description": "Count of consecutive health check failures"
          },
          "error_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error Message",
            "description": "Last error message if unhealthy"
          }
        },
        "type": "object",
        "required": ["name", "status", "consecutive_failures"],
        "title": "ServiceHealthStatusResponse",
        "description": "Health status of a registered service."
      },
      "ServiceInfo": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Service identifier (e.g., 'ai-detector', 'postgres', 'grafana')"
          },
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "Human-readable display name (e.g., 'RT-DETRv2', 'PostgreSQL')"
          },
          "category": {
            "$ref": "#/components/schemas/ServiceCategory",
            "description": "Service category: infrastructure, ai, or monitoring"
          },
          "status": {
            "$ref": "#/components/schemas/ContainerServiceStatus",
            "description": "Current service status: running, starting, unhealthy, stopped, disabled, not_found"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether auto-restart is enabled for this service",
            "default": true
          },
          "container_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Container Id",
            "description": "Docker container ID (short form)"
          },
          "image": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Image",
            "description": "Container image (e.g., 'postgres:16-alpine', 'ghcr.io/.../rtdetr:latest')"
          },
          "port": {
            "type": "integer",
            "maximum": 65535.0,
            "minimum": 1.0,
            "title": "Port",
            "description": "Primary service port"
          },
          "failure_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Failure Count",
            "description": "Consecutive health check failure count",
            "default": 0
          },
          "restart_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Restart Count",
            "description": "Total restarts since backend boot",
            "default": 0
          },
          "last_restart_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Restart At",
            "description": "Timestamp of last restart (null if never restarted)"
          },
          "uptime_seconds": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Uptime Seconds",
            "description": "Seconds since container started (null if not running)"
          }
        },
        "type": "object",
        "required": ["name", "display_name", "category", "status", "port"],
        "title": "ServiceInfo",
        "description": "Information about a single managed service.\n\nContains identity, configuration, and runtime status for a container\nmanaged by the orchestrator.",
        "example": {
          "category": "ai",
          "container_id": "abc123def456",
          "display_name": "RT-DETRv2",
          "enabled": true,
          "failure_count": 0,
          "image": "ghcr.io/.../rtdetr:latest",
          "last_restart_at": "2026-01-05T10:30:00Z",
          "name": "ai-detector",
          "port": 8090,
          "restart_count": 2,
          "status": "running",
          "uptime_seconds": 3600
        }
      },
      "ServicesResponse": {
        "properties": {
          "services": {
            "items": {
              "$ref": "#/components/schemas/ServiceInfo"
            },
            "type": "array",
            "title": "Services",
            "description": "List of all managed services with current status"
          },
          "by_category": {
            "additionalProperties": {
              "$ref": "#/components/schemas/CategorySummary"
            },
            "type": "object",
            "title": "By Category",
            "description": "Health summary by category (infrastructure, ai, monitoring)"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of status snapshot"
          }
        },
        "type": "object",
        "required": ["services", "by_category", "timestamp"],
        "title": "ServicesResponse",
        "description": "Response for GET /api/system/services.\n\nReturns a list of all managed services with their current status\nand category-level summaries.",
        "example": {
          "by_category": {
            "ai": {
              "healthy": 3,
              "total": 5,
              "unhealthy": 2
            },
            "infrastructure": {
              "healthy": 2,
              "total": 2,
              "unhealthy": 0
            },
            "monitoring": {
              "healthy": 4,
              "total": 4,
              "unhealthy": 0
            }
          },
          "services": [
            {
              "category": "infrastructure",
              "container_id": "def456...",
              "display_name": "PostgreSQL",
              "enabled": true,
              "failure_count": 0,
              "image": "postgres:16-alpine",
              "name": "postgres",
              "port": 5432,
              "restart_count": 0,
              "status": "running",
              "uptime_seconds": 86400
            },
            {
              "category": "ai",
              "container_id": "abc123...",
              "display_name": "RT-DETRv2",
              "enabled": true,
              "failure_count": 0,
              "image": "ghcr.io/.../rtdetr:latest",
              "last_restart_at": "2026-01-05T10:30:00Z",
              "name": "ai-detector",
              "port": 8090,
              "restart_count": 2,
              "status": "running",
              "uptime_seconds": 3600
            }
          ],
          "timestamp": "2026-01-05T15:45:00Z"
        }
      },
      "SeverityDefinitionResponse": {
        "properties": {
          "severity": {
            "$ref": "#/components/schemas/SeverityEnum",
            "description": "The severity level identifier"
          },
          "label": {
            "type": "string",
            "title": "Label",
            "description": "Human-readable label for the severity level"
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Description of when this severity applies"
          },
          "color": {
            "type": "string",
            "pattern": "^#[0-9a-fA-F]{6}$",
            "title": "Color",
            "description": "Hex color code for UI display (e.g., '#22c55e')"
          },
          "priority": {
            "type": "integer",
            "maximum": 3.0,
            "minimum": 0.0,
            "title": "Priority",
            "description": "Sort priority (0 = highest priority, 3 = lowest)"
          },
          "min_score": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Min Score",
            "description": "Minimum risk score for this severity (inclusive)"
          },
          "max_score": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Max Score",
            "description": "Maximum risk score for this severity (inclusive)"
          }
        },
        "type": "object",
        "required": [
          "severity",
          "label",
          "description",
          "color",
          "priority",
          "min_score",
          "max_score"
        ],
        "title": "SeverityDefinitionResponse",
        "description": "Definition of a single severity level.",
        "example": {
          "color": "#f97316",
          "description": "Concerning activity, review soon",
          "label": "High",
          "max_score": 84,
          "min_score": 60,
          "priority": 1,
          "severity": "high"
        }
      },
      "SeverityEnum": {
        "type": "string",
        "enum": ["low", "medium", "high", "critical"],
        "title": "SeverityEnum",
        "description": "Severity levels for API responses."
      },
      "SeverityMetadataResponse": {
        "properties": {
          "definitions": {
            "items": {
              "$ref": "#/components/schemas/SeverityDefinitionResponse"
            },
            "type": "array",
            "title": "Definitions",
            "description": "List of all severity level definitions"
          },
          "thresholds": {
            "$ref": "#/components/schemas/SeverityThresholds",
            "description": "Current severity threshold configuration"
          }
        },
        "type": "object",
        "required": ["definitions", "thresholds"],
        "title": "SeverityMetadataResponse",
        "description": "Response schema for severity metadata endpoint.\n\nProvides complete information about severity levels including:\n- All severity definitions with thresholds and colors\n- Current threshold configuration\n- Useful for frontend to display severity information consistently",
        "example": {
          "definitions": [
            {
              "color": "#22c55e",
              "description": "Routine activity, no concern",
              "label": "Low",
              "max_score": 29,
              "min_score": 0,
              "priority": 3,
              "severity": "low"
            },
            {
              "color": "#eab308",
              "description": "Notable activity, worth reviewing",
              "label": "Medium",
              "max_score": 59,
              "min_score": 30,
              "priority": 2,
              "severity": "medium"
            },
            {
              "color": "#f97316",
              "description": "Concerning activity, review soon",
              "label": "High",
              "max_score": 84,
              "min_score": 60,
              "priority": 1,
              "severity": "high"
            },
            {
              "color": "#ef4444",
              "description": "Immediate attention required",
              "label": "Critical",
              "max_score": 100,
              "min_score": 85,
              "priority": 0,
              "severity": "critical"
            }
          ],
          "thresholds": {
            "high_max": 84,
            "low_max": 29,
            "medium_max": 59
          }
        }
      },
      "SeverityThresholds": {
        "properties": {
          "low_max": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Low Max",
            "description": "Maximum risk score for LOW severity (0 to this value = LOW)"
          },
          "medium_max": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Medium Max",
            "description": "Maximum risk score for MEDIUM severity (low_max+1 to this value = MEDIUM)"
          },
          "high_max": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "High Max",
            "description": "Maximum risk score for HIGH severity (medium_max+1 to this value = HIGH)"
          }
        },
        "type": "object",
        "required": ["low_max", "medium_max", "high_max"],
        "title": "SeverityThresholds",
        "description": "Current severity threshold configuration.",
        "example": {
          "high_max": 84,
          "low_max": 29,
          "medium_max": 59
        }
      },
      "SeverityThresholdsUpdateRequest": {
        "properties": {
          "low_max": {
            "type": "integer",
            "maximum": 98.0,
            "minimum": 1.0,
            "title": "Low Max",
            "description": "Maximum risk score for LOW severity (1-98)"
          },
          "medium_max": {
            "type": "integer",
            "maximum": 99.0,
            "minimum": 2.0,
            "title": "Medium Max",
            "description": "Maximum risk score for MEDIUM severity (2-99)"
          },
          "high_max": {
            "type": "integer",
            "maximum": 99.0,
            "minimum": 3.0,
            "title": "High Max",
            "description": "Maximum risk score for HIGH severity (3-99)"
          }
        },
        "type": "object",
        "required": ["low_max", "medium_max", "high_max"],
        "title": "SeverityThresholdsUpdateRequest",
        "description": "Request schema for updating severity thresholds.\n\nThe thresholds must form contiguous ranges from 0-100:\n- LOW: 0 to low_max (inclusive)\n- MEDIUM: low_max+1 to medium_max (inclusive)\n- HIGH: medium_max+1 to high_max (inclusive)\n- CRITICAL: high_max+1 to 100 (inclusive)\n\nValidation rules:\n- 0 < low_max < medium_max < high_max < 100\n- This ensures all ranges are valid and cover 0-100 without gaps or overlaps",
        "example": {
          "high_max": 84,
          "low_max": 29,
          "medium_max": 59
        }
      },
      "StageLatency": {
        "properties": {
          "avg_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Ms",
            "description": "Average latency in milliseconds"
          },
          "min_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Ms",
            "description": "Minimum latency in milliseconds"
          },
          "max_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Ms",
            "description": "Maximum latency in milliseconds"
          },
          "p50_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "P50 Ms",
            "description": "50th percentile (median) latency in milliseconds"
          },
          "p95_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "P95 Ms",
            "description": "95th percentile latency in milliseconds"
          },
          "p99_ms": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "P99 Ms",
            "description": "99th percentile latency in milliseconds"
          },
          "sample_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Sample Count",
            "description": "Number of samples used to calculate statistics"
          }
        },
        "type": "object",
        "required": ["sample_count"],
        "title": "StageLatency",
        "description": "Latency statistics for a single pipeline stage.",
        "example": {
          "avg_ms": 150.5,
          "max_ms": 500.0,
          "min_ms": 50.0,
          "p50_ms": 120.0,
          "p95_ms": 400.0,
          "p99_ms": 480.0,
          "sample_count": 100
        }
      },
      "StorageCategoryStats": {
        "properties": {
          "file_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "File Count",
            "description": "Number of files in this category"
          },
          "size_bytes": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Size Bytes",
            "description": "Total size in bytes for this category"
          }
        },
        "type": "object",
        "required": ["file_count", "size_bytes"],
        "title": "StorageCategoryStats",
        "description": "Storage statistics for a single category."
      },
      "StorageStatsResponse": {
        "properties": {
          "disk_used_bytes": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Disk Used Bytes",
            "description": "Total disk space used in bytes"
          },
          "disk_total_bytes": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Disk Total Bytes",
            "description": "Total disk space available in bytes"
          },
          "disk_free_bytes": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Disk Free Bytes",
            "description": "Free disk space in bytes"
          },
          "disk_usage_percent": {
            "type": "number",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Disk Usage Percent",
            "description": "Disk usage percentage (0-100)"
          },
          "thumbnails": {
            "$ref": "#/components/schemas/StorageCategoryStats",
            "description": "Storage used by detection thumbnails"
          },
          "images": {
            "$ref": "#/components/schemas/StorageCategoryStats",
            "description": "Storage used by original camera images"
          },
          "clips": {
            "$ref": "#/components/schemas/StorageCategoryStats",
            "description": "Storage used by event video clips"
          },
          "events_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Events Count",
            "description": "Total number of events in database"
          },
          "detections_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Detections Count",
            "description": "Total number of detections in database"
          },
          "gpu_stats_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Gpu Stats Count",
            "description": "Total number of GPU stats records in database"
          },
          "logs_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Logs Count",
            "description": "Total number of log entries in database"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of storage stats snapshot"
          }
        },
        "type": "object",
        "required": [
          "disk_used_bytes",
          "disk_total_bytes",
          "disk_free_bytes",
          "disk_usage_percent",
          "thumbnails",
          "images",
          "clips",
          "events_count",
          "detections_count",
          "gpu_stats_count",
          "logs_count",
          "timestamp"
        ],
        "title": "StorageStatsResponse",
        "description": "Response schema for storage statistics endpoint.\n\nProvides detailed storage usage information including:\n- Disk usage for the storage volume\n- Breakdown by data category (thumbnails, images, clips)\n- Database record counts",
        "example": {
          "clips": {
            "file_count": 50,
            "size_bytes": 500000000
          },
          "detections_count": 892,
          "disk_free_bytes": 429496729600,
          "disk_total_bytes": 536870912000,
          "disk_usage_percent": 20.0,
          "disk_used_bytes": 107374182400,
          "events_count": 156,
          "gpu_stats_count": 2880,
          "images": {
            "file_count": 10000,
            "size_bytes": 5000000000
          },
          "logs_count": 5000,
          "thumbnails": {
            "file_count": 1500,
            "size_bytes": 75000000
          },
          "timestamp": "2025-12-30T10:30:00Z"
        }
      },
      "SystemStatsResponse": {
        "properties": {
          "total_cameras": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Cameras",
            "description": "Total number of cameras in the system"
          },
          "total_events": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Events",
            "description": "Total number of events recorded"
          },
          "total_detections": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Detections",
            "description": "Total number of detections recorded"
          },
          "uptime_seconds": {
            "type": "number",
            "minimum": 0.0,
            "title": "Uptime Seconds",
            "description": "Application uptime in seconds"
          }
        },
        "type": "object",
        "required": ["total_cameras", "total_events", "total_detections", "uptime_seconds"],
        "title": "SystemStatsResponse",
        "description": "Response schema for system statistics endpoint.",
        "example": {
          "total_cameras": 4,
          "total_detections": 892,
          "total_events": 156,
          "uptime_seconds": 86400.5
        }
      },
      "TelemetryResponse": {
        "properties": {
          "queues": {
            "$ref": "#/components/schemas/QueueDepths",
            "description": "Current queue depths for detection and analysis queues"
          },
          "latencies": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineLatencies"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency statistics for each pipeline stage"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of telemetry snapshot"
          }
        },
        "type": "object",
        "required": ["queues", "timestamp"],
        "title": "TelemetryResponse",
        "description": "Response schema for pipeline telemetry endpoint.\n\nProvides real-time visibility into:\n- Queue depths: How many items are waiting in detection/analysis queues\n- Stage latencies: How long each pipeline stage is taking\n\nThis helps operators:\n- Identify pipeline bottlenecks\n- Detect backlog situations\n- Monitor processing performance\n- Debug pipeline stalls",
        "example": {
          "latencies": {
            "detect": {
              "avg_ms": 200.0,
              "max_ms": 800.0,
              "min_ms": 100.0,
              "p50_ms": 180.0,
              "p95_ms": 600.0,
              "p99_ms": 750.0,
              "sample_count": 500
            },
            "watch": {
              "avg_ms": 10.0,
              "max_ms": 50.0,
              "min_ms": 5.0,
              "p50_ms": 8.0,
              "p95_ms": 40.0,
              "p99_ms": 48.0,
              "sample_count": 500
            }
          },
          "queues": {
            "analysis_queue": 2,
            "detection_queue": 5
          },
          "timestamp": "2025-12-27T10:30:00Z"
        }
      },
      "TestNotificationResponse": {
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "Channel that was tested"
          },
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether the test was successful"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Error message if test failed"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable result message"
          }
        },
        "type": "object",
        "required": ["channel", "success", "message"],
        "title": "TestNotificationResponse",
        "description": "Schema for test notification result.",
        "example": {
          "channel": "email",
          "message": "Test email sent successfully to test@example.com",
          "success": true
        }
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": ["loc", "msg", "type"],
        "title": "ValidationError"
      },
      "VehicleEnrichment": {
        "properties": {
          "type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Type",
            "description": "Vehicle type (sedan, suv, truck, etc.)"
          },
          "color": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Color",
            "description": "Vehicle color (if detected)"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Classification confidence"
          },
          "is_commercial": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Commercial",
            "description": "Whether vehicle is commercial/delivery"
          },
          "damage_detected": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Damage Detected",
            "description": "Whether vehicle damage was detected"
          },
          "damage_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Damage Types",
            "description": "Types of damage detected"
          }
        },
        "type": "object",
        "title": "VehicleEnrichment",
        "description": "Vehicle classification results.",
        "example": {
          "color": "silver",
          "confidence": 0.91,
          "is_commercial": false,
          "type": "sedan"
        }
      },
      "ViolenceEnrichment": {
        "properties": {
          "detected": {
            "type": "boolean",
            "title": "Detected",
            "description": "Whether violence was detected",
            "default": false
          },
          "score": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Score",
            "description": "Violence probability score",
            "default": 0.0
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Model confidence"
          }
        },
        "type": "object",
        "title": "ViolenceEnrichment",
        "description": "Violence detection results.",
        "example": {
          "confidence": 0.88,
          "detected": false,
          "score": 0.12
        }
      },
      "WeatherEnrichment": {
        "properties": {
          "condition": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Condition",
            "description": "Weather condition (clear, rain, fog, etc.)"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Confidence",
            "description": "Classification confidence"
          }
        },
        "type": "object",
        "title": "WeatherEnrichment",
        "description": "Weather classification results.",
        "example": {
          "condition": "clear",
          "confidence": 0.95
        }
      },
      "WebSocketBroadcasterStatus": {
        "properties": {
          "state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "Current circuit state: closed (normal), open (failing), half_open (testing), unavailable (not initialized)"
          },
          "failure_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Failure Count",
            "description": "Current consecutive failure count"
          },
          "is_degraded": {
            "type": "boolean",
            "title": "Is Degraded",
            "description": "Whether the broadcaster is in degraded mode"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Optional status message or error details"
          }
        },
        "type": "object",
        "required": ["state", "failure_count", "is_degraded"],
        "title": "WebSocketBroadcasterStatus",
        "description": "Status of a WebSocket broadcaster's circuit breaker."
      },
      "WebSocketConnectionsResponse": {
        "properties": {
          "event_broadcaster": {
            "$ref": "#/components/schemas/DebugWebSocketBroadcasterStatus",
            "description": "Event broadcaster status - handles security event streaming"
          },
          "system_broadcaster": {
            "$ref": "#/components/schemas/DebugWebSocketBroadcasterStatus",
            "description": "System broadcaster status - handles system metrics streaming"
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "ISO timestamp when WebSocket status was retrieved",
            "example": "2025-12-30T10:30:00Z"
          }
        },
        "type": "object",
        "required": ["event_broadcaster", "system_broadcaster", "timestamp"],
        "title": "WebSocketConnectionsResponse",
        "description": "Response for WebSocket connection states.\n\nProvides status information for both WebSocket broadcasters:\n- event_broadcaster: Streams security events to connected dashboards\n- system_broadcaster: Streams system status updates (GPU, health, etc.)"
      },
      "WebSocketHealthResponse": {
        "properties": {
          "event_broadcaster": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebSocketBroadcasterStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status of the event broadcaster circuit breaker"
          },
          "system_broadcaster": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebSocketBroadcasterStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status of the system broadcaster circuit breaker"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Timestamp of health check"
          }
        },
        "type": "object",
        "required": ["timestamp"],
        "title": "WebSocketHealthResponse",
        "description": "Response schema for WebSocket health endpoint.",
        "example": {
          "event_broadcaster": {
            "failure_count": 0,
            "is_degraded": false,
            "state": "closed"
          },
          "system_broadcaster": {
            "failure_count": 0,
            "is_degraded": false,
            "state": "closed"
          },
          "timestamp": "2025-12-30T10:30:00Z"
        }
      },
      "WebVitalMetric": {
        "properties": {
          "name": {
            "$ref": "#/components/schemas/WebVitalName",
            "description": "Core Web Vital metric name"
          },
          "value": {
            "type": "number",
            "title": "Value",
            "description": "Metric value (ms for most, dimensionless for CLS)"
          },
          "rating": {
            "type": "string",
            "enum": ["good", "needs-improvement", "poor"],
            "title": "Rating",
            "description": "Performance rating"
          },
          "delta": {
            "type": "number",
            "title": "Delta",
            "description": "Delta since last report"
          },
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique metric identifier from web-vitals"
          },
          "navigationType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Navigationtype",
            "description": "Navigation type (navigate, reload, back_forward, prerender)"
          },
          "path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Path",
            "description": "Page path where metric was measured"
          }
        },
        "type": "object",
        "required": ["name", "value", "rating", "delta", "id"],
        "title": "WebVitalMetric",
        "description": "A single Core Web Vital metric measurement from the frontend.\n\nThis schema matches the structure returned by the web-vitals library's\nonLCP, onFID, onINP, onCLS, onTTFB, and onFCP functions.\n\nAttributes:\n    name: The Core Web Vital metric name (LCP, FID, INP, CLS, TTFB, FCP)\n    value: The metric value (milliseconds for most, dimensionless for CLS)\n    rating: Performance rating based on thresholds (good, needs-improvement, poor)\n    delta: The delta since the last report (for CLS this accumulates)\n    id: Unique identifier for this metric instance\n    navigationType: The type of navigation (navigate, reload, back_forward, prerender)\n    path: The page path where the metric was measured",
        "example": {
          "delta": 2500.0,
          "id": "v1-1234567890123-1234567890123",
          "name": "LCP",
          "navigationType": "navigate",
          "path": "/dashboard",
          "rating": "good",
          "value": 2500.0
        }
      },
      "WebVitalName": {
        "type": "string",
        "enum": ["LCP", "FID", "INP", "CLS", "TTFB", "FCP"],
        "title": "WebVitalName",
        "description": "Supported Core Web Vitals metric names.\n\nThese correspond to the metrics collected by the web-vitals library."
      },
      "WebhookTestNotificationRequest": {
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "Channel to test"
          },
          "email_recipients": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email Recipients",
            "description": "Email recipients for email test"
          },
          "webhook_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Webhook Url",
            "description": "Webhook URL for webhook test. Must be HTTPS and not point to private IPs."
          }
        },
        "type": "object",
        "required": ["channel"],
        "title": "WebhookTestNotificationRequest",
        "description": "Schema for testing notification configuration.",
        "example": {
          "channel": "email",
          "email_recipients": ["test@example.com"]
        }
      },
      "WorkerHealthStatus": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Worker name (e.g., 'file_watcher')"
          },
          "running": {
            "type": "boolean",
            "title": "Running",
            "description": "Whether the worker is currently running"
          },
          "critical": {
            "type": "boolean",
            "title": "Critical",
            "description": "Whether this worker is critical for system operation"
          }
        },
        "type": "object",
        "required": ["name", "running", "critical"],
        "title": "WorkerHealthStatus",
        "description": "Health status for a background worker.\n\nWorkers are background processes that perform periodic or event-driven tasks.",
        "example": {
          "critical": true,
          "name": "file_watcher",
          "running": true
        }
      },
      "WorkerStatus": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Worker/service name"
          },
          "running": {
            "type": "boolean",
            "title": "Running",
            "description": "Whether the worker is currently running"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Optional status message or error details"
          }
        },
        "type": "object",
        "required": ["name", "running"],
        "title": "WorkerStatus",
        "description": "Status information for a background worker/service."
      },
      "ZoneCreate": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "description": "Zone name"
          },
          "zone_type": {
            "$ref": "#/components/schemas/ZoneType",
            "description": "Type of zone",
            "default": "other"
          },
          "coordinates": {
            "items": {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            "type": "array",
            "minItems": 3,
            "title": "Coordinates",
            "description": "Array of normalized [x, y] points (0-1 range)"
          },
          "shape": {
            "$ref": "#/components/schemas/ZoneShape",
            "description": "Shape of the zone",
            "default": "rectangle"
          },
          "color": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "title": "Color",
            "description": "Hex color for UI display",
            "default": "#3B82F6"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether zone is active",
            "default": true
          },
          "priority": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Priority",
            "description": "Priority for overlapping zones (higher = more important)",
            "default": 0
          }
        },
        "type": "object",
        "required": ["name", "coordinates"],
        "title": "ZoneCreate",
        "description": "Schema for creating a new zone.",
        "example": {
          "color": "#3B82F6",
          "coordinates": [
            [0.1, 0.2],
            [0.3, 0.2],
            [0.3, 0.8],
            [0.1, 0.8]
          ],
          "enabled": true,
          "name": "Front Door",
          "priority": 1,
          "shape": "rectangle",
          "zone_type": "entry_point"
        }
      },
      "ZoneListResponse": {
        "properties": {
          "zones": {
            "items": {
              "$ref": "#/components/schemas/ZoneResponse"
            },
            "type": "array",
            "title": "Zones",
            "description": "List of zones"
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Total number of zones"
          }
        },
        "type": "object",
        "required": ["zones", "count"],
        "title": "ZoneListResponse",
        "description": "Schema for zone list response.",
        "example": {
          "count": 1,
          "zones": [
            {
              "camera_id": "front_door",
              "color": "#3B82F6",
              "coordinates": [
                [0.1, 0.2],
                [0.3, 0.2],
                [0.3, 0.8],
                [0.1, 0.8]
              ],
              "created_at": "2025-12-23T10:00:00Z",
              "enabled": true,
              "id": "123e4567-e89b-12d3-a456-426614174000",
              "name": "Front Door",
              "priority": 1,
              "shape": "rectangle",
              "updated_at": "2025-12-23T12:00:00Z",
              "zone_type": "entry_point"
            }
          ]
        }
      },
      "ZoneResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Zone UUID"
          },
          "camera_id": {
            "type": "string",
            "title": "Camera Id",
            "description": "Camera ID this zone belongs to"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Zone name"
          },
          "zone_type": {
            "$ref": "#/components/schemas/ZoneType",
            "description": "Type of zone"
          },
          "coordinates": {
            "items": {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            "type": "array",
            "title": "Coordinates",
            "description": "Array of normalized [x, y] points (0-1 range)"
          },
          "shape": {
            "$ref": "#/components/schemas/ZoneShape",
            "description": "Shape of the zone"
          },
          "color": {
            "type": "string",
            "title": "Color",
            "description": "Hex color for UI display"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether zone is active"
          },
          "priority": {
            "type": "integer",
            "title": "Priority",
            "description": "Priority for overlapping zones"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp when zone was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Timestamp when zone was last updated"
          }
        },
        "type": "object",
        "required": [
          "id",
          "camera_id",
          "name",
          "zone_type",
          "coordinates",
          "shape",
          "color",
          "enabled",
          "priority",
          "created_at",
          "updated_at"
        ],
        "title": "ZoneResponse",
        "description": "Schema for zone response.",
        "example": {
          "camera_id": "front_door",
          "color": "#3B82F6",
          "coordinates": [
            [0.1, 0.2],
            [0.3, 0.2],
            [0.3, 0.8],
            [0.1, 0.8]
          ],
          "created_at": "2025-12-23T10:00:00Z",
          "enabled": true,
          "id": "123e4567-e89b-12d3-a456-426614174000",
          "name": "Front Door",
          "priority": 1,
          "shape": "rectangle",
          "updated_at": "2025-12-23T12:00:00Z",
          "zone_type": "entry_point"
        }
      },
      "ZoneShape": {
        "type": "string",
        "enum": ["rectangle", "polygon"],
        "title": "ZoneShape",
        "description": "Shape of the zone polygon."
      },
      "ZoneType": {
        "type": "string",
        "enum": ["entry_point", "driveway", "sidewalk", "yard", "other"],
        "title": "ZoneType",
        "description": "Type of zone for semantic categorization."
      },
      "ZoneUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Zone name"
          },
          "zone_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ZoneType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Type of zone"
          },
          "coordinates": {
            "anyOf": [
              {
                "items": {
                  "items": {
                    "type": "number"
                  },
                  "type": "array"
                },
                "type": "array",
                "minItems": 3
              },
              {
                "type": "null"
              }
            ],
            "title": "Coordinates",
            "description": "Array of normalized [x, y] points (0-1 range)"
          },
          "shape": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ZoneShape"
              },
              {
                "type": "null"
              }
            ],
            "description": "Shape of the zone"
          },
          "color": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^#[0-9A-Fa-f]{6}$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Color",
            "description": "Hex color for UI display"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enabled",
            "description": "Whether zone is active"
          },
          "priority": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 100.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Priority",
            "description": "Priority for overlapping zones (higher = more important)"
          }
        },
        "type": "object",
        "title": "ZoneUpdate",
        "description": "Schema for updating an existing zone.",
        "example": {
          "enabled": false,
          "name": "Front Door - Updated"
        }
      }
    }
  }
}
