{
  "components": {
    "schemas": {
      "AIModelEnum": {
        "description": "Supported AI models for prompt configuration.",
        "enum": [
          "nemotron",
          "florence2",
          "yolo_world",
          "xclip",
          "fashion_clip"
        ],
        "title": "AIModelEnum",
        "type": "string"
      },
      "AIServiceCircuitState": {
        "description": "Circuit breaker state for an AI service.\n\nStates:\n- closed: Normal operation, requests pass through\n- open: Service failing, requests fail immediately\n- half_open: Testing recovery, limited requests allowed",
        "enum": [
          "closed",
          "open",
          "half_open"
        ],
        "title": "AIServiceCircuitState",
        "type": "string"
      },
      "AIServiceHealthDetail": {
        "description": "Detailed health information for a single AI service.\n\nProvides comprehensive status including circuit breaker state,\nerror rates, and latency metrics for monitoring and alerting.",
        "example": {
          "circuit_state": "closed",
          "error_rate_1h": 0.02,
          "last_health_check": "2026-01-20T12:00:00Z",
          "latency_p99_ms": 450,
          "status": "healthy",
          "url": "http://ai-detector:8090"
        },
        "properties": {
          "circuit_state": {
            "$ref": "#/components/schemas/AIServiceCircuitState",
            "default": "closed",
            "description": "Circuit breaker state for this service"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if service is unhealthy",
            "title": "Error"
          },
          "error_rate_1h": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error rate over the last hour (0.0 to 1.0)",
            "title": "Error Rate 1H"
          },
          "last_health_check": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of the last successful health check",
            "title": "Last Health Check"
          },
          "latency_p99_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "99th percentile latency in milliseconds",
            "title": "Latency P99 Ms"
          },
          "status": {
            "$ref": "#/components/schemas/AIServiceStatus",
            "description": "Current health status of the service"
          },
          "url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Service URL if configured",
            "title": "Url"
          }
        },
        "required": [
          "status"
        ],
        "title": "AIServiceHealthDetail",
        "type": "object"
      },
      "AIServiceHealthStatus": {
        "description": "Health status for an AI service.\n\nIncludes service identification, health state, circuit breaker state,\nand response time metrics.",
        "example": {
          "circuit_state": "closed",
          "display_name": "YOLO26v2 Object Detection",
          "last_check": "2026-01-08T10:30:00Z",
          "name": "yolo26",
          "response_time_ms": 45.2,
          "status": "healthy",
          "url": "http://ai-detector:8090"
        },
        "properties": {
          "circuit_state": {
            "$ref": "#/components/schemas/CircuitState",
            "default": "closed",
            "description": "Circuit breaker state"
          },
          "display_name": {
            "description": "Human-readable service name",
            "title": "Display Name",
            "type": "string"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if unhealthy",
            "title": "Error"
          },
          "last_check": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of last health check",
            "title": "Last Check"
          },
          "name": {
            "description": "Service identifier (e.g., 'yolo26', 'nemotron')",
            "title": "Name",
            "type": "string"
          },
          "response_time_ms": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Health check response time in milliseconds",
            "title": "Response Time Ms"
          },
          "status": {
            "$ref": "#/components/schemas/ServiceHealthState",
            "description": "Current health state"
          },
          "url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Service URL if configured",
            "title": "Url"
          }
        },
        "required": [
          "name",
          "display_name",
          "status"
        ],
        "title": "AIServiceHealthStatus",
        "type": "object"
      },
      "AIServiceOverallStatus": {
        "description": "Overall status for the AI services subsystem.\n\nStatuses:\n- healthy: All services are operational\n- degraded: Some services are unhealthy but system is functional\n- critical: Critical services are down, system cannot process requests",
        "enum": [
          "healthy",
          "degraded",
          "critical"
        ],
        "title": "AIServiceOverallStatus",
        "type": "string"
      },
      "AIServiceStatus": {
        "description": "Health status for an individual AI service.\n\nStatuses:\n- healthy: Service is fully operational\n- unhealthy: Service is down or experiencing critical issues\n- degraded: Service is partially operational\n- unknown: Service status cannot be determined",
        "enum": [
          "healthy",
          "unhealthy",
          "degraded",
          "unknown"
        ],
        "title": "AIServiceStatus",
        "type": "string"
      },
      "AIServicesHealthResponse": {
        "description": "Response schema for GET /api/health/ai-services endpoint.\n\nProvides a unified view of all AI service health including:\n- Overall system status (healthy/degraded/critical)\n- Individual service health with circuit breaker states\n- Queue depths for detection and analysis pipelines\n\nHTTP Status Codes:\n- 200: System is healthy or degraded (can still serve traffic)\n- 503: Critical services are unhealthy (should not receive traffic)",
        "example": {
          "overall_status": "healthy",
          "queues": {
            "analysis_queue": {
              "depth": 2,
              "dlq_depth": 0
            },
            "detection_queue": {
              "depth": 5,
              "dlq_depth": 0
            }
          },
          "services": {
            "clip": {
              "circuit_state": "closed",
              "error_rate_1h": 0.0,
              "last_health_check": "2026-01-20T12:00:00Z",
              "latency_p99_ms": 200,
              "status": "healthy",
              "url": "http://clip-service:8092"
            },
            "enrichment": {
              "circuit_state": "half_open",
              "error": "Intermittent connection issues",
              "error_rate_1h": 0.15,
              "last_health_check": "2026-01-20T11:55:00Z",
              "latency_p99_ms": 1200,
              "status": "degraded",
              "url": "http://enrichment-service:8093"
            },
            "florence": {
              "circuit_state": "closed",
              "error_rate_1h": 0.0,
              "last_health_check": "2026-01-20T12:00:00Z",
              "latency_p99_ms": 350,
              "status": "healthy",
              "url": "http://florence-service:8091"
            },
            "nemotron": {
              "circuit_state": "closed",
              "error_rate_1h": 0.01,
              "last_health_check": "2026-01-20T12:00:00Z",
              "latency_p99_ms": 2500,
              "status": "healthy",
              "url": "http://llm-analyzer:8080"
            },
            "yolo26": {
              "circuit_state": "closed",
              "error_rate_1h": 0.02,
              "last_health_check": "2026-01-20T12:00:00Z",
              "latency_p99_ms": 450,
              "status": "healthy",
              "url": "http://ai-detector:8090"
            }
          },
          "timestamp": "2026-01-20T12:00:00Z"
        },
        "properties": {
          "overall_status": {
            "$ref": "#/components/schemas/AIServiceOverallStatus",
            "description": "Overall health status of the AI services subsystem"
          },
          "queues": {
            "additionalProperties": {
              "$ref": "#/components/schemas/QueueDepthInfo"
            },
            "description": "Queue depth information for processing queues",
            "title": "Queues",
            "type": "object"
          },
          "services": {
            "additionalProperties": {
              "$ref": "#/components/schemas/AIServiceHealthDetail"
            },
            "description": "Health details for each AI service keyed by service name",
            "title": "Services",
            "type": "object"
          },
          "timestamp": {
            "description": "Timestamp when this health check was performed",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "overall_status",
          "services",
          "queues",
          "timestamp"
        ],
        "title": "AIServicesHealthResponse",
        "type": "object"
      },
      "AccessSchedule": {
        "description": "Schema for time-based access schedule configuration.\n\nAllows defining when specific members have access to a zone using\ncron-style expressions for flexible scheduling.\n\nExample:\n    {\n        \"member_ids\": [1, 2, 3],\n        \"cron_expression\": \"0 9-17 * * 1-5\",  # Weekdays 9am-5pm\n        \"description\": \"Service workers during business hours\"\n    }",
        "example": {
          "cron_expression": "0 9-17 * * 1-5",
          "description": "Business hours access",
          "member_ids": [
            1,
            2
          ]
        },
        "properties": {
          "cron_expression": {
            "description": "Cron expression defining when access is granted (minute hour day month weekday)",
            "minLength": 1,
            "title": "Cron Expression",
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "maxLength": 255,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional human-readable description of the schedule",
            "title": "Description"
          },
          "member_ids": {
            "description": "List of household member IDs this schedule applies to",
            "items": {
              "type": "integer"
            },
            "minItems": 1,
            "title": "Member Ids",
            "type": "array"
          }
        },
        "required": [
          "member_ids",
          "cron_expression"
        ],
        "title": "AccessSchedule",
        "type": "object"
      },
      "ActionAnalyzeRequest": {
        "description": "Schema for action analysis request.\n\nUsed to trigger action recognition on a set of frames.",
        "example": {
          "camera_id": "front_door",
          "confidence_threshold": 0.5,
          "frame_paths": [
            "/export/foscam/front_door/frame_001.jpg",
            "/export/foscam/front_door/frame_002.jpg",
            "/export/foscam/front_door/frame_003.jpg",
            "/export/foscam/front_door/frame_004.jpg",
            "/export/foscam/front_door/frame_005.jpg",
            "/export/foscam/front_door/frame_006.jpg",
            "/export/foscam/front_door/frame_007.jpg",
            "/export/foscam/front_door/frame_008.jpg"
          ],
          "track_id": 42
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID for the frames",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence_threshold": {
            "default": 0.5,
            "description": "Minimum confidence threshold for creating an action event",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Confidence Threshold",
            "type": "number"
          },
          "frame_paths": {
            "description": "List of frame file paths to analyze (1-32 frames)",
            "items": {
              "type": "string"
            },
            "maxItems": 32,
            "minItems": 1,
            "title": "Frame Paths",
            "type": "array"
          },
          "save_event": {
            "default": true,
            "description": "Whether to save the action event to the database",
            "title": "Save Event",
            "type": "boolean"
          },
          "track_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional track ID to associate with the action",
            "title": "Track Id"
          }
        },
        "required": [
          "camera_id",
          "frame_paths"
        ],
        "title": "ActionAnalyzeRequest",
        "type": "object"
      },
      "ActionAnalyzeResponse": {
        "description": "Schema for action analysis response.\n\nReturns the detected action along with all scores and optional saved event.",
        "example": {
          "action": "walking normally",
          "all_scores": {
            "climbing": 0.02,
            "loitering": 0.04,
            "running": 0.05,
            "walking normally": 0.89
          },
          "confidence": 0.89,
          "event_id": 1,
          "frame_count": 8,
          "is_suspicious": false,
          "saved": true
        },
        "properties": {
          "action": {
            "description": "Detected action label",
            "title": "Action",
            "type": "string"
          },
          "all_scores": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "All action scores",
            "title": "All Scores",
            "type": "object"
          },
          "confidence": {
            "description": "Action classification confidence",
            "title": "Confidence",
            "type": "number"
          },
          "event_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Saved action event ID (if save_event=True)",
            "title": "Event Id"
          },
          "frame_count": {
            "description": "Number of frames analyzed",
            "title": "Frame Count",
            "type": "integer"
          },
          "is_suspicious": {
            "description": "Whether the action is security-relevant",
            "title": "Is Suspicious",
            "type": "boolean"
          },
          "saved": {
            "description": "Whether the event was saved to the database",
            "title": "Saved",
            "type": "boolean"
          }
        },
        "required": [
          "action",
          "confidence",
          "is_suspicious",
          "all_scores",
          "frame_count",
          "saved"
        ],
        "title": "ActionAnalyzeResponse",
        "type": "object"
      },
      "ActionEventCreate": {
        "description": "Schema for creating a new action event.\n\nInherits all fields from ActionEventBase. The timestamp will be\nauto-generated if not provided.",
        "example": {
          "action": "walking normally",
          "all_scores": {
            "climbing": 0.02,
            "loitering": 0.04,
            "running": 0.05,
            "walking normally": 0.89
          },
          "camera_id": "front_door",
          "confidence": 0.89,
          "frame_count": 8,
          "is_suspicious": false,
          "track_id": 42
        },
        "properties": {
          "action": {
            "description": "Detected action label (e.g., 'walking normally', 'climbing')",
            "title": "Action",
            "type": "string"
          },
          "all_scores": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "number"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Dictionary mapping all action classes to their confidence scores",
            "title": "All Scores"
          },
          "camera_id": {
            "description": "Camera ID where the action was detected",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence": {
            "description": "Action classification confidence (0.0 to 1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Confidence",
            "type": "number"
          },
          "frame_count": {
            "default": 8,
            "description": "Number of frames analyzed for this action",
            "minimum": 1.0,
            "title": "Frame Count",
            "type": "integer"
          },
          "is_suspicious": {
            "default": false,
            "description": "Whether the action is flagged as security-relevant",
            "title": "Is Suspicious",
            "type": "boolean"
          },
          "timestamp": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the action was detected (auto-generated if not provided)",
            "title": "Timestamp"
          },
          "track_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional track ID for the detected person",
            "title": "Track Id"
          }
        },
        "required": [
          "camera_id",
          "action",
          "confidence"
        ],
        "title": "ActionEventCreate",
        "type": "object"
      },
      "ActionEventListResponse": {
        "description": "Schema for action event list response with pagination.\n\nUses the standard pagination envelope pattern.",
        "example": {
          "items": [
            {
              "action": "walking normally",
              "camera_id": "front_door",
              "confidence": 0.89,
              "created_at": "2026-01-26T12:00:00Z",
              "frame_count": 8,
              "id": 1,
              "is_suspicious": false,
              "timestamp": "2026-01-26T12:00:00Z",
              "track_id": 42
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of action events",
            "items": {
              "$ref": "#/components/schemas/ActionEventResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "ActionEventListResponse",
        "type": "object"
      },
      "ActionEventResponse": {
        "description": "Schema for action event response.\n\nIncludes all base fields plus server-generated fields like id and timestamps.",
        "example": {
          "action": "walking normally",
          "all_scores": {
            "climbing": 0.02,
            "loitering": 0.04,
            "running": 0.05,
            "walking normally": 0.89
          },
          "camera_id": "front_door",
          "confidence": 0.89,
          "created_at": "2026-01-26T12:00:00Z",
          "frame_count": 8,
          "id": 1,
          "is_suspicious": false,
          "timestamp": "2026-01-26T12:00:00Z",
          "track_id": 42
        },
        "properties": {
          "action": {
            "description": "Detected action label (e.g., 'walking normally', 'climbing')",
            "title": "Action",
            "type": "string"
          },
          "all_scores": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "number"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Dictionary mapping all action classes to their confidence scores",
            "title": "All Scores"
          },
          "camera_id": {
            "description": "Camera ID where the action was detected",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence": {
            "description": "Action classification confidence (0.0 to 1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Confidence",
            "type": "number"
          },
          "created_at": {
            "description": "Record creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "frame_count": {
            "default": 8,
            "description": "Number of frames analyzed for this action",
            "minimum": 1.0,
            "title": "Frame Count",
            "type": "integer"
          },
          "id": {
            "description": "Action event ID",
            "title": "Id",
            "type": "integer"
          },
          "is_suspicious": {
            "default": false,
            "description": "Whether the action is flagged as security-relevant",
            "title": "Is Suspicious",
            "type": "boolean"
          },
          "timestamp": {
            "description": "When the action was detected",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "track_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional track ID for the detected person",
            "title": "Track Id"
          }
        },
        "required": [
          "camera_id",
          "action",
          "confidence",
          "id",
          "timestamp",
          "created_at"
        ],
        "title": "ActionEventResponse",
        "type": "object"
      },
      "ActiveDwellerResponse": {
        "description": "Response for an object currently dwelling in a zone.\n\nIncludes real-time dwell time calculation.",
        "example": {
          "camera_id": "front_door",
          "current_dwell_seconds": 150.3,
          "entry_time": "2026-01-26T12:00:00Z",
          "object_class": "person",
          "record_id": 1,
          "track_id": 42
        },
        "properties": {
          "camera_id": {
            "description": "ID of the camera",
            "title": "Camera Id",
            "type": "string"
          },
          "current_dwell_seconds": {
            "description": "Current dwell time in seconds (calculated at request time)",
            "minimum": 0.0,
            "title": "Current Dwell Seconds",
            "type": "number"
          },
          "entry_time": {
            "description": "When the object entered the zone",
            "format": "date-time",
            "title": "Entry Time",
            "type": "string"
          },
          "object_class": {
            "description": "Classification of the object",
            "title": "Object Class",
            "type": "string"
          },
          "record_id": {
            "description": "ID of the dwell time record",
            "title": "Record Id",
            "type": "integer"
          },
          "track_id": {
            "description": "Tracking ID of the object",
            "title": "Track Id",
            "type": "integer"
          }
        },
        "required": [
          "record_id",
          "track_id",
          "camera_id",
          "object_class",
          "entry_time",
          "current_dwell_seconds"
        ],
        "title": "ActiveDwellerResponse",
        "type": "object"
      },
      "ActiveDwellersListResponse": {
        "description": "List of objects currently dwelling in a zone.",
        "example": {
          "dwellers": [
            {
              "camera_id": "front_door",
              "current_dwell_seconds": 150.3,
              "entry_time": "2026-01-26T12:00:00Z",
              "object_class": "person",
              "record_id": 1,
              "track_id": 42
            }
          ],
          "total": 1,
          "zone_id": 1
        },
        "properties": {
          "dwellers": {
            "description": "List of objects currently in the zone",
            "items": {
              "$ref": "#/components/schemas/ActiveDwellerResponse"
            },
            "title": "Dwellers",
            "type": "array"
          },
          "total": {
            "description": "Total number of active dwellers",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          },
          "zone_id": {
            "description": "ID of the polygon zone",
            "title": "Zone Id",
            "type": "integer"
          }
        },
        "required": [
          "zone_id",
          "dwellers",
          "total"
        ],
        "title": "ActiveDwellersListResponse",
        "type": "object"
      },
      "ActivityBaselineEntry": {
        "description": "A single activity baseline entry for a specific hour and day combination.\n\nThis represents one cell in the 24x7 activity heatmap (168 total entries).",
        "example": {
          "avg_count": 5.2,
          "day_of_week": 0,
          "hour": 17,
          "is_peak": true,
          "sample_count": 30
        },
        "properties": {
          "avg_count": {
            "description": "Average activity count for this time slot",
            "minimum": 0.0,
            "title": "Avg Count",
            "type": "number"
          },
          "day_of_week": {
            "description": "Day of week (0=Monday, 6=Sunday)",
            "maximum": 6.0,
            "minimum": 0.0,
            "title": "Day Of Week",
            "type": "integer"
          },
          "hour": {
            "description": "Hour of day (0-23)",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Hour",
            "type": "integer"
          },
          "is_peak": {
            "default": false,
            "description": "Whether this time slot has above-average activity",
            "title": "Is Peak",
            "type": "boolean"
          },
          "sample_count": {
            "description": "Number of samples used to calculate this average",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "hour",
          "day_of_week",
          "avg_count",
          "sample_count"
        ],
        "title": "ActivityBaselineEntry",
        "type": "object"
      },
      "ActivityBaselineResponse": {
        "description": "Response for camera activity baseline endpoint.\n\nContains 168 entries (24 hours x 7 days) representing the full weekly\nactivity heatmap for a camera.",
        "example": {
          "camera_id": "front_door",
          "entries": [
            {
              "avg_count": 0.5,
              "day_of_week": 0,
              "hour": 0,
              "is_peak": false,
              "sample_count": 30
            },
            {
              "avg_count": 5.2,
              "day_of_week": 4,
              "hour": 17,
              "is_peak": true,
              "sample_count": 30
            }
          ],
          "learning_complete": true,
          "min_samples_required": 10,
          "peak_day": 4,
          "peak_hour": 17,
          "total_samples": 720
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "entries": {
            "description": "Activity baseline entries (up to 168 = 24h x 7 days)",
            "items": {
              "$ref": "#/components/schemas/ActivityBaselineEntry"
            },
            "title": "Entries",
            "type": "array"
          },
          "learning_complete": {
            "default": false,
            "description": "Whether baseline has sufficient samples for reliable anomaly detection",
            "title": "Learning Complete",
            "type": "boolean"
          },
          "min_samples_required": {
            "default": 10,
            "description": "Minimum samples required per time slot for learning completion",
            "minimum": 1.0,
            "title": "Min Samples Required",
            "type": "integer"
          },
          "peak_day": {
            "anyOf": [
              {
                "maximum": 6.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Day with highest average activity (0=Monday, 6=Sunday)",
            "title": "Peak Day"
          },
          "peak_hour": {
            "anyOf": [
              {
                "maximum": 23.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Hour with highest average activity (0-23)",
            "title": "Peak Hour"
          },
          "total_samples": {
            "description": "Total number of samples across all entries",
            "minimum": 0.0,
            "title": "Total Samples",
            "type": "integer"
          }
        },
        "required": [
          "camera_id",
          "total_samples"
        ],
        "title": "ActivityBaselineResponse",
        "type": "object"
      },
      "ActualThreatLevel": {
        "description": "User's assessment of the actual threat level.\n\nValues:\n    NO_THREAT: No threat at all (e.g., household member, pet)\n    MINOR_CONCERN: Worth noting but not alarming\n    GENUINE_THREAT: Real security concern",
        "enum": [
          "no_threat",
          "minor_concern",
          "genuine_threat"
        ],
        "title": "ActualThreatLevel",
        "type": "string"
      },
      "AddEmbeddingRequest": {
        "description": "Schema for adding a person embedding from an event.",
        "example": {
          "confidence": 0.95,
          "event_id": 100
        },
        "properties": {
          "confidence": {
            "default": 1.0,
            "description": "Reliability score for this embedding (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Confidence",
            "type": "number"
          },
          "event_id": {
            "description": "ID of the event to extract embedding from",
            "title": "Event Id",
            "type": "integer"
          }
        },
        "required": [
          "event_id"
        ],
        "title": "AddEmbeddingRequest",
        "type": "object"
      },
      "AiModelMetrics": {
        "description": "Metrics for YOLO26v2 model.",
        "example": {
          "device": "cuda:0",
          "model": "yolo26_r50vd_coco_o365",
          "status": "healthy",
          "vram_gb": 0.17
        },
        "properties": {
          "device": {
            "description": "Device (e.g., 'cuda:0')",
            "title": "Device",
            "type": "string"
          },
          "model": {
            "description": "Model name",
            "title": "Model",
            "type": "string"
          },
          "status": {
            "description": "Health status: healthy, unhealthy, unreachable",
            "title": "Status",
            "type": "string"
          },
          "vram_gb": {
            "description": "VRAM used by the model in GB",
            "minimum": 0.0,
            "title": "Vram Gb",
            "type": "number"
          }
        },
        "required": [
          "status",
          "vram_gb",
          "model",
          "device"
        ],
        "title": "AiModelMetrics",
        "type": "object"
      },
      "AiServiceInfo": {
        "description": "Information about an AI service for GPU assignment.\n\nProvides service metadata including VRAM requirements, enabling\nthe frontend to dynamically build the assignment UI.",
        "example": {
          "description": "Nemotron LLM for risk analysis and enrichment",
          "display_name": "LLM (Nemotron)",
          "name": "ai-llm",
          "vram_required_gb": 8.0,
          "vram_required_mb": 8192
        },
        "properties": {
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Service description",
            "title": "Description"
          },
          "display_name": {
            "description": "Human-readable display name",
            "title": "Display Name",
            "type": "string"
          },
          "name": {
            "description": "Service name (e.g., 'ai-llm')",
            "title": "Name",
            "type": "string"
          },
          "vram_required_gb": {
            "description": "VRAM requirement in gigabytes",
            "minimum": 0.0,
            "title": "Vram Required Gb",
            "type": "number"
          },
          "vram_required_mb": {
            "description": "VRAM requirement in megabytes",
            "minimum": 0.0,
            "title": "Vram Required Mb",
            "type": "integer"
          }
        },
        "required": [
          "name",
          "display_name",
          "vram_required_mb",
          "vram_required_gb"
        ],
        "title": "AiServiceInfo",
        "type": "object"
      },
      "AiServicesResponse": {
        "description": "Response schema for listing available AI services.\n\nReturns all AI services with their VRAM requirements for GPU assignment.",
        "example": {
          "services": [
            {
              "description": "Nemotron LLM for risk analysis and enrichment",
              "display_name": "LLM (Nemotron)",
              "name": "ai-llm",
              "vram_required_gb": 8.0,
              "vram_required_mb": 8192
            },
            {
              "description": "YOLO26 real-time object detection",
              "display_name": "Object Detector",
              "name": "ai-detector",
              "vram_required_gb": 2.0,
              "vram_required_mb": 2048
            }
          ]
        },
        "properties": {
          "services": {
            "description": "List of available AI services",
            "items": {
              "$ref": "#/components/schemas/AiServiceInfo"
            },
            "title": "Services",
            "type": "array"
          }
        },
        "required": [
          "services"
        ],
        "title": "AiServicesResponse",
        "type": "object"
      },
      "AlertResponse": {
        "description": "Schema for alert response.",
        "example": {
          "channels": [
            "pushover"
          ],
          "created_at": "2025-12-28T12:00:00Z",
          "dedup_key": "front_door:person:entry_zone",
          "delivered_at": "2025-12-28T12:00:30Z",
          "event_id": 123,
          "id": "550e8400-e29b-41d4-a716-446655440001",
          "metadata": {
            "camera_name": "Front Door"
          },
          "rule_id": "550e8400-e29b-41d4-a716-446655440000",
          "severity": "high",
          "status": "delivered",
          "updated_at": "2025-12-28T12:01:00Z"
        },
        "properties": {
          "channels": {
            "description": "Notification channels",
            "items": {
              "type": "string"
            },
            "title": "Channels",
            "type": "array"
          },
          "created_at": {
            "description": "Creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "dedup_key": {
            "description": "Deduplication key",
            "title": "Dedup Key",
            "type": "string"
          },
          "delivered_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Delivery timestamp",
            "title": "Delivered At"
          },
          "event_id": {
            "description": "Event ID that triggered this alert",
            "title": "Event Id",
            "type": "integer"
          },
          "id": {
            "description": "Alert UUID",
            "title": "Id",
            "type": "string"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional context",
            "title": "Metadata"
          },
          "rule_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Alert rule UUID that matched",
            "title": "Rule Id"
          },
          "severity": {
            "$ref": "#/components/schemas/AlertSeverity",
            "description": "Alert severity level"
          },
          "status": {
            "$ref": "#/components/schemas/AlertStatus",
            "description": "Alert status"
          },
          "updated_at": {
            "description": "Last update timestamp",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          }
        },
        "required": [
          "id",
          "event_id",
          "severity",
          "status",
          "created_at",
          "updated_at",
          "dedup_key"
        ],
        "title": "AlertResponse",
        "type": "object"
      },
      "AlertRuleConditions": {
        "description": "Schema for legacy alert rule conditions (backward compatibility).\n\nNew rules should use explicit fields on AlertRuleCreate/AlertRuleUpdate.\nThis schema is kept for backward compatibility with existing rules.",
        "example": {
          "camera_ids": [
            "front_door",
            "backyard"
          ],
          "object_types": [
            "person",
            "vehicle"
          ],
          "risk_threshold": 70,
          "time_ranges": [
            {
              "end": "06:00",
              "start": "22:00"
            }
          ]
        },
        "properties": {
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Specific camera IDs that trigger alerts",
            "title": "Camera Ids"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object types that trigger alerts (e.g., person, vehicle)",
            "title": "Object Types"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum risk score to trigger alert",
            "title": "Risk Threshold"
          },
          "time_ranges": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time ranges when alerts are active (start/end in HH:MM format)",
            "title": "Time Ranges"
          }
        },
        "title": "AlertRuleConditions",
        "type": "object"
      },
      "AlertRuleCreate": {
        "description": "Schema for creating an alert rule.\n\nAll conditions use AND logic - all specified conditions must match for the rule to trigger.\nLeave a condition as null/empty to not filter on that criterion.",
        "example": {
          "camera_ids": [
            "front_door",
            "backyard"
          ],
          "channels": [
            "pushover",
            "webhook"
          ],
          "cooldown_seconds": 300,
          "dedup_key_template": "{camera_id}:{rule_id}",
          "description": "High-priority alert for person detection at night",
          "enabled": true,
          "min_confidence": 0.8,
          "name": "Night Intruder Alert",
          "object_types": [
            "person"
          ],
          "risk_threshold": 70,
          "schedule": {
            "days": [
              "monday",
              "tuesday",
              "wednesday",
              "thursday",
              "friday"
            ],
            "end_time": "06:00",
            "start_time": "22:00",
            "timezone": "America/New_York"
          },
          "severity": "critical"
        },
        "properties": {
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera IDs to apply rule to (empty = all cameras)",
            "title": "Camera Ids"
          },
          "channels": {
            "description": "Notification channels for this rule",
            "items": {
              "type": "string"
            },
            "title": "Channels",
            "type": "array"
          },
          "conditions": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleConditions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Legacy conditions (use explicit fields instead)"
          },
          "cooldown_seconds": {
            "default": 300,
            "description": "Minimum seconds between duplicate alerts",
            "minimum": 0.0,
            "title": "Cooldown Seconds",
            "type": "integer"
          },
          "dedup_key_template": {
            "default": "{camera_id}:{rule_id}",
            "description": "Template for dedup key. Variables: {camera_id}, {rule_id}, {object_type}",
            "maxLength": 255,
            "title": "Dedup Key Template",
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Rule description",
            "title": "Description"
          },
          "enabled": {
            "default": true,
            "description": "Whether the rule is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "min_confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum detection confidence (0.0-1.0)",
            "title": "Min Confidence"
          },
          "name": {
            "description": "Rule name",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object types to match (e.g., ['person', 'vehicle'])",
            "title": "Object Types"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Alert when risk_score >= threshold",
            "title": "Risk Threshold"
          },
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleSchedule"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based conditions (null = always active)"
          },
          "severity": {
            "$ref": "#/components/schemas/AlertSeverity",
            "default": "medium",
            "description": "Severity level for triggered alerts"
          },
          "zone_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Zone IDs to match (empty = any zone)",
            "title": "Zone Ids"
          }
        },
        "required": [
          "name"
        ],
        "title": "AlertRuleCreate",
        "type": "object"
      },
      "AlertRuleListResponse": {
        "description": "Schema for alert rule list response with pagination.",
        "example": {
          "items": [
            {
              "channels": [
                "pushover"
              ],
              "conditions": {
                "risk_threshold": 70
              },
              "cooldown_seconds": 300,
              "created_at": "2025-12-28T12:00:00Z",
              "enabled": true,
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "name": "High Risk Alert",
              "updated_at": "2025-12-28T12:00:00Z"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of alert rules",
            "items": {
              "$ref": "#/components/schemas/AlertRuleResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "AlertRuleListResponse",
        "type": "object"
      },
      "AlertRuleResponse": {
        "description": "Schema for alert rule response.",
        "example": {
          "camera_ids": [
            "front_door",
            "backyard"
          ],
          "channels": [
            "pushover",
            "webhook"
          ],
          "cooldown_seconds": 300,
          "created_at": "2025-12-28T12:00:00Z",
          "dedup_key_template": "{camera_id}:{rule_id}",
          "description": "High-priority alert for person detection at night",
          "enabled": true,
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "min_confidence": 0.8,
          "name": "Night Intruder Alert",
          "object_types": [
            "person"
          ],
          "risk_threshold": 70,
          "schedule": {
            "days": [
              "monday",
              "tuesday",
              "wednesday",
              "thursday",
              "friday"
            ],
            "end_time": "06:00",
            "start_time": "22:00",
            "timezone": "America/New_York"
          },
          "severity": "critical",
          "updated_at": "2025-12-28T12:00:00Z"
        },
        "properties": {
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera IDs to apply to",
            "title": "Camera Ids"
          },
          "channels": {
            "description": "Notification channels",
            "items": {
              "type": "string"
            },
            "title": "Channels",
            "type": "array"
          },
          "conditions": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleConditions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Legacy conditions"
          },
          "cooldown_seconds": {
            "description": "Minimum seconds between duplicate alerts",
            "title": "Cooldown Seconds",
            "type": "integer"
          },
          "created_at": {
            "description": "Creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "dedup_key_template": {
            "description": "Template for dedup key",
            "title": "Dedup Key Template",
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Rule description",
            "title": "Description"
          },
          "enabled": {
            "description": "Whether the rule is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "id": {
            "description": "Alert rule UUID",
            "title": "Id",
            "type": "string"
          },
          "min_confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum confidence",
            "title": "Min Confidence"
          },
          "name": {
            "description": "Rule name",
            "title": "Name",
            "type": "string"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object types to match",
            "title": "Object Types"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk score threshold",
            "title": "Risk Threshold"
          },
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleSchedule"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based conditions"
          },
          "severity": {
            "$ref": "#/components/schemas/AlertSeverity",
            "description": "Severity level"
          },
          "updated_at": {
            "description": "Last update timestamp",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "zone_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Zone IDs to match",
            "title": "Zone Ids"
          }
        },
        "required": [
          "id",
          "name",
          "enabled",
          "severity",
          "dedup_key_template",
          "cooldown_seconds",
          "created_at",
          "updated_at"
        ],
        "title": "AlertRuleResponse",
        "type": "object"
      },
      "AlertRuleSchedule": {
        "description": "Schema for alert rule schedule (time-based conditions).\n\nIf start_time > end_time, the schedule spans midnight (e.g., 22:00-06:00).\nEmpty days array means all days. No schedule = always active (vacation mode).\n\nValidation:\n- Days must be valid day names (monday-sunday)\n- Times must be valid HH:MM format with hours 00-23, minutes 00-59\n- Start and end times are validated but can span midnight",
        "example": {
          "days": [
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday"
          ],
          "end_time": "06:00",
          "start_time": "22:00",
          "timezone": "America/New_York"
        },
        "properties": {
          "days": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Days of week when rule is active (empty = all days). Values: monday, tuesday, wednesday, thursday, friday, saturday, sunday",
            "title": "Days"
          },
          "end_time": {
            "anyOf": [
              {
                "pattern": "^\\d{2}:\\d{2}$",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "End time in HH:MM format (00:00-23:59)",
            "title": "End Time"
          },
          "start_time": {
            "anyOf": [
              {
                "pattern": "^\\d{2}:\\d{2}$",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Start time in HH:MM format (00:00-23:59)",
            "title": "Start Time"
          },
          "timezone": {
            "default": "UTC",
            "description": "Timezone for time evaluation",
            "title": "Timezone",
            "type": "string"
          }
        },
        "title": "AlertRuleSchedule",
        "type": "object"
      },
      "AlertRuleUpdate": {
        "description": "Schema for updating an alert rule (PATCH).\n\nOnly provided fields will be updated. Null values clear the field.",
        "example": {
          "cooldown_seconds": 600,
          "enabled": false,
          "risk_threshold": 80
        },
        "properties": {
          "camera_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera IDs to apply rule to",
            "title": "Camera Ids"
          },
          "channels": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Notification channels for this rule",
            "title": "Channels"
          },
          "conditions": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleConditions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Legacy conditions"
          },
          "cooldown_seconds": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum seconds between duplicate alerts",
            "title": "Cooldown Seconds"
          },
          "dedup_key_template": {
            "anyOf": [
              {
                "maxLength": 255,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Template for dedup key",
            "title": "Dedup Key Template"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Rule description",
            "title": "Description"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether the rule is active",
            "title": "Enabled"
          },
          "min_confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum detection confidence",
            "title": "Min Confidence"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 255,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Rule name",
            "title": "Name"
          },
          "object_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object types to match",
            "title": "Object Types"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Alert when risk_score >= threshold",
            "title": "Risk Threshold"
          },
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertRuleSchedule"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based conditions"
          },
          "severity": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AlertSeverity"
              },
              {
                "type": "null"
              }
            ],
            "description": "Severity level"
          },
          "zone_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Zone IDs to match",
            "title": "Zone Ids"
          }
        },
        "title": "AlertRuleUpdate",
        "type": "object"
      },
      "AlertSeverity": {
        "description": "Alert severity levels.",
        "enum": [
          "low",
          "medium",
          "high",
          "critical"
        ],
        "title": "AlertSeverity",
        "type": "string"
      },
      "AlertStatus": {
        "description": "Alert status values.",
        "enum": [
          "pending",
          "delivered",
          "acknowledged",
          "dismissed"
        ],
        "title": "AlertStatus",
        "type": "string"
      },
      "AlertmanagerAlert": {
        "description": "Schema for a single alert in Alertmanager webhook payload.\n\nRepresents one alert instance with its labels, annotations, and timing.\nThis schema matches the Alertmanager webhook format.",
        "example": {
          "annotations": {
            "description": "CPU usage is above 80% for 5 minutes",
            "summary": "CPU usage is high"
          },
          "endsAt": "0001-01-01T00:00:00Z",
          "fingerprint": "abc123def456",
          "generatorURL": "http://prometheus:9090/graph?...",
          "labels": {
            "alertname": "HighCPU",
            "instance": "localhost:9090",
            "severity": "warning"
          },
          "startsAt": "2026-01-20T12:00:00Z",
          "status": "firing"
        },
        "properties": {
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Alert annotations (summary, description)",
            "title": "Annotations",
            "type": "object"
          },
          "endsAt": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the alert was resolved",
            "title": "Endsat"
          },
          "fingerprint": {
            "description": "Unique identifier for alert deduplication",
            "title": "Fingerprint",
            "type": "string"
          },
          "generatorURL": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to the Prometheus graph",
            "title": "Generatorurl"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Alert labels (alertname, severity, etc.)",
            "title": "Labels",
            "type": "object"
          },
          "startsAt": {
            "description": "When the alert started firing",
            "format": "date-time",
            "title": "Startsat",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/PrometheusAlertStatus",
            "description": "Alert status (firing or resolved)"
          }
        },
        "required": [
          "fingerprint",
          "status",
          "startsAt"
        ],
        "title": "AlertmanagerAlert",
        "type": "object"
      },
      "AlertmanagerStatus": {
        "description": "Alertmanager alert status values.",
        "enum": [
          "firing",
          "resolved"
        ],
        "title": "AlertmanagerStatus",
        "type": "string"
      },
      "AlertmanagerWebhook": {
        "description": "Schema for Alertmanager webhook payload.\n\nThis is the format Alertmanager sends when configured with a webhook receiver.\nSee: https://prometheus.io/docs/alerting/latest/configuration/#webhook_config",
        "example": {
          "alerts": [
            {
              "annotations": {
                "description": "CPU at 85%"
              },
              "endsAt": "0001-01-01T00:00:00Z",
              "fingerprint": "abc123",
              "labels": {
                "alertname": "HighCPU",
                "severity": "warning"
              },
              "startsAt": "2026-01-20T12:00:00Z",
              "status": "firing"
            }
          ],
          "commonAnnotations": {
            "summary": "CPU usage is high"
          },
          "commonLabels": {
            "alertname": "HighCPU",
            "severity": "warning"
          },
          "externalURL": "http://alertmanager:9093",
          "groupKey": "{}:{alertname=\"HighCPU\"}",
          "groupLabels": {
            "alertname": "HighCPU"
          },
          "receiver": "webhook-receiver",
          "status": "firing",
          "truncatedAlerts": 0,
          "version": "4"
        },
        "properties": {
          "alerts": {
            "description": "List of alerts in this group",
            "items": {
              "$ref": "#/components/schemas/AlertmanagerAlert"
            },
            "title": "Alerts",
            "type": "array"
          },
          "commonAnnotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Annotations common to all alerts",
            "title": "Commonannotations",
            "type": "object"
          },
          "commonLabels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels common to all alerts",
            "title": "Commonlabels",
            "type": "object"
          },
          "externalURL": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Alertmanager external URL",
            "title": "Externalurl"
          },
          "groupKey": {
            "description": "Key identifying the alert group",
            "title": "Groupkey",
            "type": "string"
          },
          "groupLabels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels used for grouping",
            "title": "Grouplabels",
            "type": "object"
          },
          "receiver": {
            "description": "Name of the receiver that matched",
            "title": "Receiver",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/PrometheusAlertStatus",
            "description": "Overall group status"
          },
          "truncatedAlerts": {
            "default": 0,
            "description": "Number of truncated alerts",
            "title": "Truncatedalerts",
            "type": "integer"
          },
          "version": {
            "default": "4",
            "description": "Alertmanager webhook version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "groupKey",
          "status",
          "receiver",
          "alerts"
        ],
        "title": "AlertmanagerWebhook",
        "type": "object"
      },
      "AlertmanagerWebhookPayload": {
        "description": "Schema for Alertmanager webhook payload.\n\nThis is the format Alertmanager sends when configured with a webhook receiver.\nSee: https://prometheus.io/docs/alerting/latest/configuration/#webhook_config",
        "example": {
          "alerts": [
            {
              "annotations": {
                "description": "GPU memory at 96%"
              },
              "endsAt": "0001-01-01T00:00:00Z",
              "fingerprint": "abc123",
              "labels": {
                "alertname": "HSIGPUMemoryHigh",
                "severity": "warning"
              },
              "startsAt": "2026-01-17T12:22:56.068Z",
              "status": "firing"
            }
          ],
          "commonAnnotations": {
            "summary": "GPU memory usage is high"
          },
          "commonLabels": {
            "alertname": "HSIGPUMemoryHigh",
            "severity": "warning"
          },
          "externalURL": "http://alertmanager:9093",
          "groupKey": "{}:{alertname=\"HSIGPUMemoryHigh\"}",
          "groupLabels": {
            "alertname": "HSIGPUMemoryHigh"
          },
          "receiver": "critical-receiver",
          "status": "firing",
          "truncatedAlerts": 0,
          "version": "4"
        },
        "properties": {
          "alerts": {
            "description": "List of alerts in this group",
            "items": {
              "$ref": "#/components/schemas/WebhookAlert"
            },
            "title": "Alerts",
            "type": "array"
          },
          "commonAnnotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Annotations common to all alerts",
            "title": "Commonannotations",
            "type": "object"
          },
          "commonLabels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels common to all alerts",
            "title": "Commonlabels",
            "type": "object"
          },
          "externalURL": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Alertmanager external URL",
            "title": "Externalurl"
          },
          "groupKey": {
            "description": "Key identifying the alert group",
            "title": "Groupkey",
            "type": "string"
          },
          "groupLabels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels used for grouping",
            "title": "Grouplabels",
            "type": "object"
          },
          "receiver": {
            "description": "Name of the receiver that matched",
            "title": "Receiver",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/AlertmanagerStatus",
            "description": "Overall group status"
          },
          "truncatedAlerts": {
            "default": 0,
            "description": "Number of truncated alerts",
            "title": "Truncatedalerts",
            "type": "integer"
          },
          "version": {
            "default": "4",
            "description": "Alertmanager webhook version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "groupKey",
          "status",
          "receiver",
          "alerts"
        ],
        "title": "AlertmanagerWebhookPayload",
        "type": "object"
      },
      "AlertmanagerWebhookResponse": {
        "description": "Response schema for the alertmanager webhook endpoint.",
        "example": {
          "broadcast": 2,
          "message": "Processed 2 alert(s)",
          "received": 2,
          "status": "ok",
          "stored": 2
        },
        "properties": {
          "broadcast": {
            "description": "Number of alerts broadcast via WebSocket",
            "title": "Broadcast",
            "type": "integer"
          },
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "received": {
            "description": "Number of alerts received",
            "title": "Received",
            "type": "integer"
          },
          "status": {
            "description": "Processing status (ok or error)",
            "title": "Status",
            "type": "string"
          },
          "stored": {
            "description": "Number of alerts stored in database",
            "title": "Stored",
            "type": "integer"
          }
        },
        "required": [
          "status",
          "received",
          "stored",
          "broadcast",
          "message"
        ],
        "title": "AlertmanagerWebhookResponse",
        "type": "object"
      },
      "AllPromptsResponse": {
        "description": "Response containing prompts for all configurable models.",
        "example": {
          "exported_at": "2026-01-03T10:30:00Z",
          "prompts": {
            "florence2": {
              "vqa_queries": [
                "What is this person wearing?",
                "Is this person carrying anything?"
              ]
            },
            "nemotron": {
              "max_tokens": 2048,
              "system_prompt": "You are a home security AI assistant...",
              "temperature": 0.7
            }
          },
          "version": "1.0"
        },
        "properties": {
          "exported_at": {
            "description": "Export timestamp",
            "format": "date-time",
            "title": "Exported At",
            "type": "string"
          },
          "prompts": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "description": "Configuration for each model",
            "title": "Prompts",
            "type": "object"
          },
          "version": {
            "default": "1.0",
            "description": "Export format version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "exported_at",
          "prompts"
        ],
        "title": "AllPromptsResponse",
        "type": "object"
      },
      "AnomalyConfig": {
        "description": "Current anomaly detection configuration.",
        "example": {
          "decay_factor": 0.1,
          "min_samples": 10,
          "threshold_stdev": 2.0,
          "window_days": 30
        },
        "properties": {
          "decay_factor": {
            "description": "Exponential decay factor for EWMA (0 < factor <= 1)",
            "exclusiveMinimum": 0.0,
            "maximum": 1.0,
            "title": "Decay Factor",
            "type": "number"
          },
          "min_samples": {
            "description": "Minimum samples required before anomaly detection is reliable",
            "minimum": 1.0,
            "title": "Min Samples",
            "type": "integer"
          },
          "threshold_stdev": {
            "description": "Number of standard deviations from mean for anomaly detection",
            "exclusiveMinimum": 0.0,
            "title": "Threshold Stdev",
            "type": "number"
          },
          "window_days": {
            "description": "Rolling window size in days for baseline calculations",
            "minimum": 1.0,
            "title": "Window Days",
            "type": "integer"
          }
        },
        "required": [
          "threshold_stdev",
          "min_samples",
          "decay_factor",
          "window_days"
        ],
        "title": "AnomalyConfig",
        "type": "object"
      },
      "AnomalyConfigUpdate": {
        "description": "Request to update anomaly detection configuration.",
        "example": {
          "min_samples": 15,
          "threshold_stdev": 2.5
        },
        "properties": {
          "min_samples": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum samples required before anomaly detection is reliable",
            "title": "Min Samples"
          },
          "threshold_stdev": {
            "anyOf": [
              {
                "exclusiveMinimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of standard deviations from mean for anomaly detection",
            "title": "Threshold Stdev"
          }
        },
        "title": "AnomalyConfigUpdate",
        "type": "object"
      },
      "AnomalyEvent": {
        "description": "A single anomaly event detected for a camera.",
        "example": {
          "anomaly_score": 0.95,
          "detection_class": "vehicle",
          "expected_frequency": 0.1,
          "observed_frequency": 5.0,
          "reason": "Vehicle detected at 2:30 AM when rarely seen at this hour",
          "timestamp": "2026-01-03T02:30:00Z"
        },
        "properties": {
          "anomaly_score": {
            "description": "Anomaly score (0.0-1.0, higher is more anomalous)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Anomaly Score",
            "type": "number"
          },
          "detection_class": {
            "description": "Object class that triggered the anomaly",
            "title": "Detection Class",
            "type": "string"
          },
          "expected_frequency": {
            "description": "Expected frequency for this class at this time",
            "minimum": 0.0,
            "title": "Expected Frequency",
            "type": "number"
          },
          "observed_frequency": {
            "description": "Observed frequency that triggered the anomaly",
            "minimum": 0.0,
            "title": "Observed Frequency",
            "type": "number"
          },
          "reason": {
            "description": "Human-readable explanation of why this is anomalous",
            "title": "Reason",
            "type": "string"
          },
          "timestamp": {
            "description": "When the anomaly was detected",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "detection_class",
          "anomaly_score",
          "expected_frequency",
          "observed_frequency",
          "reason"
        ],
        "title": "AnomalyEvent",
        "type": "object"
      },
      "AnomalyListResponse": {
        "description": "Response schema for camera anomaly list endpoint.",
        "example": {
          "anomalies": [
            {
              "anomaly_score": 0.95,
              "detection_class": "vehicle",
              "expected_frequency": 0.1,
              "observed_frequency": 5.0,
              "reason": "Vehicle detected at 2:30 AM when rarely seen",
              "timestamp": "2026-01-03T02:30:00Z"
            }
          ],
          "camera_id": "front_door",
          "count": 1,
          "period_days": 7
        },
        "properties": {
          "anomalies": {
            "description": "List of recent anomaly events",
            "items": {
              "$ref": "#/components/schemas/AnomalyEvent"
            },
            "title": "Anomalies",
            "type": "array"
          },
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "count": {
            "description": "Total number of anomalies returned",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "period_days": {
            "description": "Number of days covered by this query",
            "minimum": 1.0,
            "title": "Period Days",
            "type": "integer"
          }
        },
        "required": [
          "camera_id",
          "count",
          "period_days"
        ],
        "title": "AnomalyListResponse",
        "type": "object"
      },
      "AreaBasic": {
        "description": "Minimal area schema for embedding in CameraResponse.\n\nNEM-3597: Basic area information for API responses that include\ncamera-area relationships without full area details.",
        "example": {
          "id": 1,
          "name": "Front Yard"
        },
        "properties": {
          "id": {
            "description": "Unique area identifier",
            "title": "Id",
            "type": "integer"
          },
          "name": {
            "description": "Area name",
            "title": "Name",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ],
        "title": "AreaBasic",
        "type": "object"
      },
      "AreaCameraResponse": {
        "description": "Schema for camera info in area context (minimal camera info).",
        "example": {
          "id": "front_door",
          "name": "Front Door Camera",
          "status": "online"
        },
        "properties": {
          "id": {
            "description": "Camera ID",
            "title": "Id",
            "type": "string"
          },
          "name": {
            "description": "Camera name",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "description": "Camera status (online, offline, error, unknown)",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "status"
        ],
        "title": "AreaCameraResponse",
        "type": "object"
      },
      "AreaCamerasResponse": {
        "description": "Schema for listing cameras in an area.",
        "example": {
          "area_id": 1,
          "area_name": "Front Yard",
          "cameras": [
            {
              "id": "front_door",
              "name": "Front Door Camera",
              "status": "online"
            }
          ],
          "count": 1
        },
        "properties": {
          "area_id": {
            "description": "ID of the area",
            "title": "Area Id",
            "type": "integer"
          },
          "area_name": {
            "description": "Name of the area",
            "title": "Area Name",
            "type": "string"
          },
          "cameras": {
            "description": "List of cameras in this area",
            "items": {
              "$ref": "#/components/schemas/AreaCameraResponse"
            },
            "title": "Cameras",
            "type": "array"
          },
          "count": {
            "description": "Number of cameras in this area",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          }
        },
        "required": [
          "area_id",
          "area_name",
          "cameras",
          "count"
        ],
        "title": "AreaCamerasResponse",
        "type": "object"
      },
      "AreaCreate": {
        "description": "Schema for creating a new area.\n\nAn area represents a logical zone within a property\n(e.g., front yard, garage, pool area).",
        "example": {
          "color": "#10B981",
          "description": "Main entrance and lawn area",
          "name": "Front Yard"
        },
        "properties": {
          "color": {
            "default": "#76B900",
            "description": "Hex color code for UI display",
            "maxLength": 7,
            "title": "Color",
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "maxLength": 1000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional longer description",
            "title": "Description"
          },
          "name": {
            "description": "Area name (e.g., 'Front Yard')",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "title": "AreaCreate",
        "type": "object"
      },
      "AreaListResponse": {
        "description": "Schema for listing areas.",
        "example": {
          "items": [
            {
              "color": "#10B981",
              "created_at": "2026-01-20T10:00:00Z",
              "description": "Main entrance",
              "id": 1,
              "name": "Front Yard",
              "property_id": 1
            }
          ],
          "total": 1
        },
        "properties": {
          "items": {
            "description": "List of areas",
            "items": {
              "$ref": "#/components/schemas/AreaResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "total": {
            "description": "Total number of areas",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "items",
          "total"
        ],
        "title": "AreaListResponse",
        "type": "object"
      },
      "AreaResponse": {
        "description": "Schema for area response.",
        "example": {
          "color": "#10B981",
          "created_at": "2026-01-20T10:00:00Z",
          "description": "Main entrance and lawn area",
          "id": 1,
          "name": "Front Yard",
          "property_id": 1
        },
        "properties": {
          "color": {
            "description": "Hex color code for UI",
            "title": "Color",
            "type": "string"
          },
          "created_at": {
            "description": "Timestamp when area was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Description",
            "title": "Description"
          },
          "id": {
            "description": "Unique area identifier",
            "title": "Id",
            "type": "integer"
          },
          "name": {
            "description": "Area name",
            "title": "Name",
            "type": "string"
          },
          "property_id": {
            "description": "ID of the parent property",
            "title": "Property Id",
            "type": "integer"
          }
        },
        "required": [
          "id",
          "property_id",
          "name",
          "color",
          "created_at"
        ],
        "title": "AreaResponse",
        "type": "object"
      },
      "AreaUpdate": {
        "description": "Schema for updating an existing area.\n\nAll fields are optional; only provided fields will be updated.",
        "example": {
          "color": "#3B82F6",
          "name": "Main Entrance"
        },
        "properties": {
          "color": {
            "anyOf": [
              {
                "maxLength": 7,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Hex color code",
            "title": "Color"
          },
          "description": {
            "anyOf": [
              {
                "maxLength": 1000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Description",
            "title": "Description"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Area name",
            "title": "Name"
          }
        },
        "title": "AreaUpdate",
        "type": "object"
      },
      "AuditLogListResponse": {
        "description": "Schema for paginated audit log response.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.",
        "example": {
          "items": [
            {
              "action": "acknowledge",
              "actor": "admin@example.com",
              "id": 1,
              "ip_address": "192.168.1.100",
              "resource_id": "123",
              "resource_type": "event",
              "status": "success",
              "timestamp": "2026-01-03T10:30:00Z"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjYtMDEtMDNUMTA6MzA6MDBaIn0=",
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Warning when using deprecated offset pagination",
            "title": "Deprecation Warning"
          },
          "items": {
            "description": "List of audit log entries",
            "items": {
              "$ref": "#/components/schemas/AuditLogResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "AuditLogListResponse",
        "type": "object"
      },
      "AuditLogResponse": {
        "description": "Schema for a single audit log entry.",
        "example": {
          "action": "acknowledge",
          "actor": "admin@example.com",
          "details": {
            "new_status": "acknowledged",
            "previous_status": "unacknowledged"
          },
          "id": 1,
          "ip_address": "192.168.1.100",
          "resource_id": "123",
          "resource_type": "event",
          "status": "success",
          "timestamp": "2026-01-03T10:30:00Z",
          "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0"
        },
        "properties": {
          "action": {
            "description": "The action performed (e.g., 'create', 'update', 'delete', 'acknowledge')",
            "maxLength": 50,
            "minLength": 1,
            "title": "Action",
            "type": "string"
          },
          "actor": {
            "description": "User or system that performed the action",
            "maxLength": 200,
            "minLength": 1,
            "title": "Actor",
            "type": "string"
          },
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Action-specific details (JSON-serializable)",
            "title": "Details"
          },
          "id": {
            "description": "Audit log entry ID",
            "minimum": 1.0,
            "title": "Id",
            "type": "integer"
          },
          "ip_address": {
            "anyOf": [
              {
                "maxLength": 45,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "IP address of the client (IPv4 or IPv6)",
            "title": "Ip Address"
          },
          "resource_id": {
            "anyOf": [
              {
                "maxLength": 128,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the specific resource",
            "title": "Resource Id"
          },
          "resource_type": {
            "description": "Type of resource (event, alert, rule, camera, settings)",
            "maxLength": 50,
            "minLength": 1,
            "title": "Resource Type",
            "type": "string"
          },
          "status": {
            "description": "Status of the action (success/failure)",
            "pattern": "^(success|failure)$",
            "title": "Status",
            "type": "string"
          },
          "timestamp": {
            "description": "When the action occurred (UTC)",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "user_agent": {
            "anyOf": [
              {
                "maxLength": 500,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "User agent string of the client",
            "title": "User Agent"
          }
        },
        "required": [
          "id",
          "timestamp",
          "action",
          "resource_type",
          "actor",
          "status"
        ],
        "title": "AuditLogResponse",
        "type": "object"
      },
      "AuditLogStats": {
        "description": "Schema for audit log statistics.",
        "example": {
          "by_action": {
            "acknowledge": 50,
            "create": 30,
            "delete": 25,
            "update": 45
          },
          "by_resource_type": {
            "alert": 40,
            "camera": 20,
            "event": 80,
            "settings": 10
          },
          "by_status": {
            "failure": 5,
            "success": 145
          },
          "logs_today": 150,
          "recent_actors": [
            "admin@example.com",
            "system",
            "scheduler"
          ],
          "total_logs": 5000
        },
        "properties": {
          "by_action": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Counts by action type",
            "title": "By Action",
            "type": "object"
          },
          "by_resource_type": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Counts by resource type",
            "title": "By Resource Type",
            "type": "object"
          },
          "by_status": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Counts by status",
            "title": "By Status",
            "type": "object"
          },
          "logs_today": {
            "description": "Number of logs today",
            "minimum": 0.0,
            "title": "Logs Today",
            "type": "integer"
          },
          "recent_actors": {
            "description": "Recently active actors",
            "items": {
              "type": "string"
            },
            "title": "Recent Actors",
            "type": "array"
          },
          "total_logs": {
            "description": "Total number of audit logs",
            "minimum": 0.0,
            "title": "Total Logs",
            "type": "integer"
          }
        },
        "required": [
          "total_logs",
          "logs_today",
          "by_action",
          "by_resource_type",
          "by_status",
          "recent_actors"
        ],
        "title": "AuditLogStats",
        "type": "object"
      },
      "AuditStatsResponse": {
        "description": "Aggregate audit statistics.",
        "example": {
          "audited_events": 1100,
          "audits_by_day": [
            {
              "avg_enrichment_utilization": 0.78,
              "avg_quality_score": 4.2,
              "count": 45,
              "date": "2026-01-01",
              "day_of_week": "Wednesday",
              "model_contributions": {
                "florence": 38,
                "yolo26": 45
              }
            },
            {
              "avg_enrichment_utilization": 0.8,
              "avg_quality_score": 4.0,
              "count": 52,
              "date": "2026-01-02",
              "day_of_week": "Thursday",
              "model_contributions": {
                "florence": 45,
                "yolo26": 52
              }
            },
            {
              "avg_enrichment_utilization": 0.75,
              "avg_quality_score": 4.3,
              "count": 38,
              "date": "2026-01-03",
              "day_of_week": "Friday",
              "model_contributions": {
                "florence": 30,
                "yolo26": 38
              }
            }
          ],
          "avg_consistency_rate": 0.92,
          "avg_enrichment_utilization": 0.78,
          "avg_quality_score": 4.1,
          "fully_evaluated_events": 950,
          "model_contribution_rates": {
            "clothing": 0.72,
            "florence": 0.85,
            "weather": 0.95,
            "yolo26": 0.98
          },
          "total_events": 1250
        },
        "properties": {
          "audited_events": {
            "title": "Audited Events",
            "type": "integer"
          },
          "audits_by_day": {
            "items": {
              "$ref": "#/components/schemas/DailyAuditStats"
            },
            "title": "Audits By Day",
            "type": "array"
          },
          "avg_consistency_rate": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Consistency Rate"
          },
          "avg_enrichment_utilization": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Enrichment Utilization"
          },
          "avg_quality_score": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avg Quality Score"
          },
          "fully_evaluated_events": {
            "title": "Fully Evaluated Events",
            "type": "integer"
          },
          "model_contribution_rates": {
            "additionalProperties": {
              "type": "number"
            },
            "title": "Model Contribution Rates",
            "type": "object"
          },
          "total_events": {
            "title": "Total Events",
            "type": "integer"
          }
        },
        "required": [
          "total_events",
          "audited_events",
          "fully_evaluated_events",
          "avg_quality_score",
          "avg_consistency_rate",
          "avg_enrichment_utilization",
          "model_contribution_rates",
          "audits_by_day"
        ],
        "title": "AuditStatsResponse",
        "type": "object"
      },
      "BaselineSummaryResponse": {
        "description": "Response schema for camera baseline summary endpoint.\n\nProvides comprehensive baseline data for a camera including:\n- Hourly activity patterns (0-23 hours)\n- Daily patterns (by day of week)\n- Object-specific baselines\n- Current deviation from baseline",
        "example": {
          "baseline_established": "2026-01-01T00:00:00Z",
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "current_deviation": {
            "contributing_factors": [
              "person_count_elevated"
            ],
            "interpretation": "slightly_above_normal",
            "score": 1.8
          },
          "daily_patterns": {
            "monday": {
              "avg_detections": 45,
              "peak_hour": 17,
              "total_samples": 24
            }
          },
          "data_points": 720,
          "hourly_patterns": {
            "0": {
              "avg_detections": 0.5,
              "sample_count": 30,
              "std_dev": 0.3
            },
            "17": {
              "avg_detections": 5.2,
              "sample_count": 30,
              "std_dev": 1.1
            }
          },
          "object_baselines": {
            "person": {
              "avg_hourly": 2.3,
              "peak_hour": 17,
              "total_detections": 550
            }
          }
        },
        "properties": {
          "baseline_established": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When baseline data collection started (null if no data)",
            "title": "Baseline Established"
          },
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "description": "Human-readable camera name",
            "title": "Camera Name",
            "type": "string"
          },
          "current_deviation": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CurrentDeviation"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current deviation from baseline (null if insufficient data)"
          },
          "daily_patterns": {
            "additionalProperties": {
              "$ref": "#/components/schemas/DailyPattern"
            },
            "description": "Activity patterns by day of week (monday-sunday)",
            "title": "Daily Patterns",
            "type": "object"
          },
          "data_points": {
            "description": "Total number of data points in baseline",
            "minimum": 0.0,
            "title": "Data Points",
            "type": "integer"
          },
          "hourly_patterns": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HourlyPattern"
            },
            "description": "Activity patterns by hour (0-23)",
            "title": "Hourly Patterns",
            "type": "object"
          },
          "object_baselines": {
            "additionalProperties": {
              "$ref": "#/components/schemas/ObjectBaseline"
            },
            "description": "Baseline statistics by object type",
            "title": "Object Baselines",
            "type": "object"
          }
        },
        "required": [
          "camera_id",
          "camera_name",
          "data_points"
        ],
        "title": "BaselineSummaryResponse",
        "type": "object"
      },
      "BatchAggregatorStatusResponse": {
        "description": "Status information for the BatchAggregator service.",
        "example": {
          "active_batches": 2,
          "batch_window_seconds": 90,
          "batches": [
            {
              "age_seconds": 45.5,
              "batch_id": "abc123",
              "camera_id": "front_door",
              "detection_count": 5,
              "last_activity_seconds": 10.2,
              "started_at": 1735500000.0
            }
          ],
          "idle_timeout_seconds": 30
        },
        "properties": {
          "active_batches": {
            "description": "Number of active batches being aggregated",
            "minimum": 0.0,
            "title": "Active Batches",
            "type": "integer"
          },
          "batch_window_seconds": {
            "description": "Configured batch window timeout in seconds",
            "minimum": 1.0,
            "title": "Batch Window Seconds",
            "type": "integer"
          },
          "batches": {
            "description": "Details of active batches",
            "items": {
              "$ref": "#/components/schemas/BatchInfoResponse"
            },
            "title": "Batches",
            "type": "array"
          },
          "idle_timeout_seconds": {
            "description": "Configured idle timeout in seconds",
            "minimum": 1.0,
            "title": "Idle Timeout Seconds",
            "type": "integer"
          }
        },
        "required": [
          "active_batches",
          "batch_window_seconds",
          "idle_timeout_seconds"
        ],
        "title": "BatchAggregatorStatusResponse",
        "type": "object"
      },
      "BatchAuditJobResponse": {
        "description": "Response for async batch audit job creation.\n\nReturned immediately when triggering a batch audit, containing\nthe job ID for progress tracking via GET /api/ai-audit/batch/{job_id}.",
        "example": {
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "message": "Batch audit job created. Use GET /api/ai-audit/batch/550e8400-e29b-41d4-a716-446655440000 to track progress.",
          "status": "pending",
          "total_events": 75
        },
        "properties": {
          "job_id": {
            "description": "Unique job ID for tracking progress",
            "title": "Job Id",
            "type": "string"
          },
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "status": {
            "description": "Initial job status (pending)",
            "title": "Status",
            "type": "string"
          },
          "total_events": {
            "description": "Number of events queued for processing",
            "minimum": 0.0,
            "title": "Total Events",
            "type": "integer"
          }
        },
        "required": [
          "job_id",
          "status",
          "message",
          "total_events"
        ],
        "title": "BatchAuditJobResponse",
        "type": "object"
      },
      "BatchAuditJobStatusResponse": {
        "description": "Response for batch audit job status query.\n\nProvides detailed progress information for an ongoing or completed\nbatch audit job.",
        "example": {
          "created_at": "2026-01-03T10:30:00Z",
          "failed_events": 2,
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "message": "Processing event 45 of 100",
          "processed_events": 45,
          "progress": 45,
          "started_at": "2026-01-03T10:30:01Z",
          "status": "running",
          "total_events": 100
        },
        "properties": {
          "completed_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When processing completed",
            "title": "Completed At"
          },
          "created_at": {
            "description": "When the job was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if job failed",
            "title": "Error"
          },
          "failed_events": {
            "default": 0,
            "description": "Events that failed processing",
            "minimum": 0.0,
            "title": "Failed Events",
            "type": "integer"
          },
          "job_id": {
            "description": "Unique job ID",
            "title": "Job Id",
            "type": "string"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current status message",
            "title": "Message"
          },
          "processed_events": {
            "description": "Events successfully processed",
            "minimum": 0.0,
            "title": "Processed Events",
            "type": "integer"
          },
          "progress": {
            "description": "Progress percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Progress",
            "type": "integer"
          },
          "started_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When processing started",
            "title": "Started At"
          },
          "status": {
            "description": "Current job status (pending, running, completed, failed)",
            "title": "Status",
            "type": "string"
          },
          "total_events": {
            "description": "Total events to process",
            "minimum": 0.0,
            "title": "Total Events",
            "type": "integer"
          }
        },
        "required": [
          "job_id",
          "status",
          "progress",
          "total_events",
          "processed_events",
          "created_at"
        ],
        "title": "BatchAuditJobStatusResponse",
        "type": "object"
      },
      "BatchAuditRequest": {
        "description": "Request for batch audit processing.",
        "example": {
          "force_reevaluate": false,
          "limit": 100,
          "min_risk_score": 50
        },
        "properties": {
          "force_reevaluate": {
            "default": false,
            "title": "Force Reevaluate",
            "type": "boolean"
          },
          "limit": {
            "default": 100,
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "type": "integer"
          },
          "min_risk_score": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Risk Score"
          }
        },
        "title": "BatchAuditRequest",
        "type": "object"
      },
      "BatchInfoResponse": {
        "description": "Information about an active batch.",
        "properties": {
          "age_seconds": {
            "description": "Time since batch started in seconds",
            "minimum": 0.0,
            "title": "Age Seconds",
            "type": "number"
          },
          "batch_id": {
            "description": "Unique batch identifier",
            "title": "Batch Id",
            "type": "string"
          },
          "camera_id": {
            "description": "Camera ID this batch belongs to",
            "title": "Camera Id",
            "type": "string"
          },
          "detection_count": {
            "description": "Number of detections in this batch",
            "minimum": 0.0,
            "title": "Detection Count",
            "type": "integer"
          },
          "last_activity_seconds": {
            "description": "Time since last activity in seconds",
            "minimum": 0.0,
            "title": "Last Activity Seconds",
            "type": "number"
          },
          "started_at": {
            "description": "Batch start time (Unix timestamp)",
            "title": "Started At",
            "type": "number"
          }
        },
        "required": [
          "batch_id",
          "camera_id",
          "detection_count",
          "started_at",
          "age_seconds",
          "last_activity_seconds"
        ],
        "title": "BatchInfoResponse",
        "type": "object"
      },
      "BatchSettings": {
        "description": "Batch processing settings for detection grouping.\n\nControls how detections are batched together before being sent to\nthe Nemotron LLM for risk analysis.",
        "example": {
          "idle_timeout_seconds": 30,
          "window_seconds": 90
        },
        "properties": {
          "idle_timeout_seconds": {
            "description": "Idle timeout in seconds before processing incomplete batch",
            "exclusiveMinimum": 0.0,
            "title": "Idle Timeout Seconds",
            "type": "integer"
          },
          "window_seconds": {
            "description": "Time window in seconds for batch processing detections",
            "exclusiveMinimum": 0.0,
            "title": "Window Seconds",
            "type": "integer"
          }
        },
        "required": [
          "window_seconds",
          "idle_timeout_seconds"
        ],
        "title": "BatchSettings",
        "type": "object"
      },
      "BatchSettingsUpdate": {
        "description": "Batch settings update schema (all fields optional).\n\nUsed for PATCH /api/v1/settings to partially update batch processing settings.\nValidates that idle_timeout_seconds < window_seconds when both are provided.",
        "example": {
          "window_seconds": 120
        },
        "properties": {
          "idle_timeout_seconds": {
            "anyOf": [
              {
                "exclusiveMinimum": 0.0,
                "maximum": 300.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Idle timeout in seconds before processing incomplete batch (max 300)",
            "title": "Idle Timeout Seconds"
          },
          "window_seconds": {
            "anyOf": [
              {
                "exclusiveMinimum": 0.0,
                "maximum": 600.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time window in seconds for batch processing detections (max 600)",
            "title": "Window Seconds"
          }
        },
        "title": "BatchSettingsUpdate",
        "type": "object"
      },
      "BulkCancelError": {
        "description": "Error details for a single job in bulk cancellation.",
        "example": {
          "error": "Job not found",
          "job_id": "550e8400-e29b-41d4-a716-446655440000"
        },
        "properties": {
          "error": {
            "description": "Error message",
            "title": "Error",
            "type": "string"
          },
          "job_id": {
            "description": "Job ID that failed to cancel",
            "title": "Job Id",
            "type": "string"
          }
        },
        "required": [
          "job_id",
          "error"
        ],
        "title": "BulkCancelError",
        "type": "object"
      },
      "BulkCancelRequest": {
        "description": "Request model for bulk job cancellation.",
        "example": {
          "job_ids": [
            "550e8400-e29b-41d4-a716-446655440000",
            "550e8400-e29b-41d4-a716-446655440001"
          ]
        },
        "properties": {
          "job_ids": {
            "description": "List of job IDs to cancel (1-100 jobs)",
            "items": {
              "type": "string"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Job Ids",
            "type": "array"
          }
        },
        "required": [
          "job_ids"
        ],
        "title": "BulkCancelRequest",
        "type": "object"
      },
      "BulkCancelResponse": {
        "description": "Response model for bulk job cancellation.",
        "example": {
          "cancelled": 5,
          "errors": [
            {
              "error": "Job already completed",
              "job_id": "550e8400-e29b-41d4-a716-446655440005"
            }
          ],
          "failed": 1
        },
        "properties": {
          "cancelled": {
            "description": "Number of jobs successfully cancelled",
            "minimum": 0.0,
            "title": "Cancelled",
            "type": "integer"
          },
          "errors": {
            "description": "Details of cancellation failures",
            "items": {
              "$ref": "#/components/schemas/BulkCancelError"
            },
            "title": "Errors",
            "type": "array"
          },
          "failed": {
            "description": "Number of jobs that failed to cancel",
            "minimum": 0.0,
            "title": "Failed",
            "type": "integer"
          }
        },
        "required": [
          "cancelled",
          "failed"
        ],
        "title": "BulkCancelResponse",
        "type": "object"
      },
      "BulkItemResult": {
        "description": "Result for a single item in a bulk operation.\n\nAttributes:\n    index: Zero-based index of the item in the request array\n    status: Operation status (success, failed, skipped)\n    id: ID of the created/updated resource (for successful operations)\n    error: Error message (for failed operations)",
        "properties": {
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message for failed operations",
            "title": "Error"
          },
          "id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the created/updated resource",
            "title": "Id"
          },
          "index": {
            "description": "Zero-based index of the item in the request",
            "minimum": 0.0,
            "title": "Index",
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/BulkOperationStatus",
            "description": "Operation status"
          }
        },
        "required": [
          "index",
          "status"
        ],
        "title": "BulkItemResult",
        "type": "object"
      },
      "BulkOperationResponse": {
        "description": "Base response for bulk operations with partial success support.\n\nUses HTTP 207 Multi-Status when some operations succeed and others fail.\n\nAttributes:\n    total: Total number of items in the request\n    succeeded: Number of successful operations\n    failed: Number of failed operations\n    skipped: Number of skipped operations\n    results: Per-item results with status and error details",
        "properties": {
          "failed": {
            "description": "Number of failed operations",
            "minimum": 0.0,
            "title": "Failed",
            "type": "integer"
          },
          "results": {
            "description": "Per-item results",
            "items": {
              "$ref": "#/components/schemas/BulkItemResult"
            },
            "title": "Results",
            "type": "array"
          },
          "skipped": {
            "default": 0,
            "description": "Number of skipped operations",
            "minimum": 0.0,
            "title": "Skipped",
            "type": "integer"
          },
          "succeeded": {
            "description": "Number of successful operations",
            "minimum": 0.0,
            "title": "Succeeded",
            "type": "integer"
          },
          "total": {
            "description": "Total number of items in the request",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "succeeded",
          "failed"
        ],
        "title": "BulkOperationResponse",
        "type": "object"
      },
      "BulkOperationStatus": {
        "description": "Status of individual items in a bulk operation.",
        "enum": [
          "success",
          "failed",
          "skipped"
        ],
        "title": "BulkOperationStatus",
        "type": "string"
      },
      "BulletPointSchema": {
        "description": "Schema for a single bullet point in a structured summary.\n\nRepresents a visual bullet point for display in the dashboard UI,\nwith an icon, text content, and optional severity level.",
        "example": {
          "icon": "camera",
          "severity": "high",
          "text": "Activity at Beach Front Left: person detected"
        },
        "properties": {
          "icon": {
            "description": "Icon identifier (e.g., 'camera', 'alert-triangle')",
            "title": "Icon",
            "type": "string"
          },
          "severity": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Severity level ('low', 'medium', 'high', 'critical')",
            "title": "Severity"
          },
          "text": {
            "description": "Text content of the bullet point",
            "title": "Text",
            "type": "string"
          }
        },
        "required": [
          "icon",
          "text"
        ],
        "title": "BulletPointSchema",
        "type": "object"
      },
      "CalibrationDefaultsResponse": {
        "description": "Schema for calibration defaults response.\n\nReturns the system default threshold values.",
        "example": {
          "decay_factor": 0.1,
          "high_threshold": 85,
          "low_threshold": 30,
          "medium_threshold": 60
        },
        "properties": {
          "decay_factor": {
            "default": 0.1,
            "description": "Default decay factor value",
            "title": "Decay Factor",
            "type": "number"
          },
          "high_threshold": {
            "default": 85,
            "description": "Default high threshold value",
            "title": "High Threshold",
            "type": "integer"
          },
          "low_threshold": {
            "default": 30,
            "description": "Default low threshold value",
            "title": "Low Threshold",
            "type": "integer"
          },
          "medium_threshold": {
            "default": 60,
            "description": "Default medium threshold value",
            "title": "Medium Threshold",
            "type": "integer"
          }
        },
        "title": "CalibrationDefaultsResponse",
        "type": "object"
      },
      "CalibrationResetResponse": {
        "description": "Schema for calibration reset response.\n\nReturned after resetting calibration to default values.",
        "example": {
          "calibration": {
            "created_at": "2025-01-01T12:00:00Z",
            "decay_factor": 0.1,
            "false_positive_count": 5,
            "high_threshold": 85,
            "id": 1,
            "low_threshold": 30,
            "medium_threshold": 60,
            "missed_threat_count": 3,
            "updated_at": "2025-01-01T12:00:00Z",
            "user_id": "default"
          },
          "message": "Calibration reset to default values"
        },
        "properties": {
          "calibration": {
            "$ref": "#/components/schemas/UserCalibrationResponse",
            "description": "Reset calibration data"
          },
          "message": {
            "description": "Success message",
            "title": "Message",
            "type": "string"
          }
        },
        "required": [
          "message",
          "calibration"
        ],
        "title": "CalibrationResetResponse",
        "type": "object"
      },
      "CameraCreate": {
        "description": "Schema for creating a new camera.\n\nNEM-2569: Enhanced with explicit Pydantic validators for:\n- Name: Control character rejection, whitespace stripping, empty validation\n- Folder path: Path traversal prevention, forbidden character rejection",
        "example": {
          "folder_path": "/export/foscam/front_door",
          "name": "Front Door Camera",
          "status": "online"
        },
        "properties": {
          "folder_path": {
            "description": "File system path for camera uploads",
            "maxLength": 500,
            "minLength": 1,
            "title": "Folder Path",
            "type": "string"
          },
          "name": {
            "description": "Camera name",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/CameraStatus",
            "default": "online",
            "description": "Camera status (online, offline, error, unknown)"
          }
        },
        "required": [
          "name",
          "folder_path"
        ],
        "title": "CameraCreate",
        "type": "object"
      },
      "CameraLinkRequest": {
        "description": "Schema for linking a camera to an area.\n\nUsed to establish the many-to-many relationship between areas and cameras.\nA camera can be linked to multiple areas, and an area can have multiple cameras.",
        "example": {
          "camera_id": "front_door"
        },
        "properties": {
          "camera_id": {
            "description": "ID of the camera to link to this area",
            "maxLength": 255,
            "minLength": 1,
            "title": "Camera Id",
            "type": "string"
          }
        },
        "required": [
          "camera_id"
        ],
        "title": "CameraLinkRequest",
        "type": "object"
      },
      "CameraLinkResponse": {
        "description": "Schema for camera link/unlink response.",
        "example": {
          "area_id": 1,
          "camera_id": "front_door",
          "linked": true
        },
        "properties": {
          "area_id": {
            "description": "ID of the area",
            "title": "Area Id",
            "type": "integer"
          },
          "camera_id": {
            "description": "ID of the camera",
            "title": "Camera Id",
            "type": "string"
          },
          "linked": {
            "description": "Whether the camera is now linked (True) or unlinked (False)",
            "title": "Linked",
            "type": "boolean"
          }
        },
        "required": [
          "area_id",
          "camera_id",
          "linked"
        ],
        "title": "CameraLinkResponse",
        "type": "object"
      },
      "CameraListResponse": {
        "description": "Schema for camera list response.\n\nNEM-2075: Standardized pagination envelope with items + pagination structure.",
        "example": {
          "items": [
            {
              "created_at": "2025-12-23T10:00:00Z",
              "folder_path": "/export/foscam/front_door",
              "id": "front_door",
              "last_seen_at": "2025-12-23T12:00:00Z",
              "name": "Front Door Camera",
              "status": "online"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of cameras",
            "items": {
              "$ref": "#/components/schemas/CameraResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "CameraListResponse",
        "type": "object"
      },
      "CameraNotificationSettingResponse": {
        "description": "Schema for camera notification setting response.",
        "example": {
          "camera_id": "front_door",
          "enabled": true,
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "risk_threshold": 50
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "enabled": {
            "description": "Whether notifications are enabled for this camera",
            "title": "Enabled",
            "type": "boolean"
          },
          "id": {
            "description": "Setting UUID",
            "title": "Id",
            "type": "string"
          },
          "risk_threshold": {
            "description": "Minimum risk score to trigger notifications (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Risk Threshold",
            "type": "integer"
          }
        },
        "required": [
          "id",
          "camera_id",
          "enabled",
          "risk_threshold"
        ],
        "title": "CameraNotificationSettingResponse",
        "type": "object"
      },
      "CameraNotificationSettingUpdate": {
        "description": "Schema for updating camera notification setting.",
        "example": {
          "enabled": false,
          "risk_threshold": 70
        },
        "properties": {
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether notifications are enabled for this camera",
            "title": "Enabled"
          },
          "risk_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum risk score to trigger notifications (0-100)",
            "title": "Risk Threshold"
          }
        },
        "title": "CameraNotificationSettingUpdate",
        "type": "object"
      },
      "CameraNotificationSettingsListResponse": {
        "description": "Schema for camera notification settings list response with pagination.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "enabled": true,
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "risk_threshold": 50
            },
            {
              "camera_id": "back_yard",
              "enabled": false,
              "id": "550e8400-e29b-41d4-a716-446655440001",
              "risk_threshold": 70
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 2
          }
        },
        "properties": {
          "items": {
            "description": "List of camera notification settings",
            "items": {
              "$ref": "#/components/schemas/CameraNotificationSettingResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "CameraNotificationSettingsListResponse",
        "type": "object"
      },
      "CameraPathValidationResponse": {
        "description": "Schema for camera path validation response.\n\nNEM-2063: Response model for the /api/cameras/validation/paths endpoint.\nValidates all camera folder paths against the configured base path.",
        "example": {
          "base_path": "/export/foscam",
          "invalid_cameras": [
            {
              "folder_path": "/export/foscam/garage",
              "id": "garage",
              "issues": [
                "directory does not exist"
              ],
              "name": "Garage Camera",
              "status": "offline"
            }
          ],
          "invalid_count": 2,
          "total_cameras": 6,
          "valid_cameras": [
            {
              "folder_path": "/export/foscam/front_door",
              "id": "front_door",
              "name": "Front Door Camera",
              "status": "online"
            }
          ],
          "valid_count": 4
        },
        "properties": {
          "base_path": {
            "description": "Configured base path for camera folders",
            "title": "Base Path",
            "type": "string"
          },
          "invalid_cameras": {
            "description": "Cameras with validation issues",
            "items": {
              "$ref": "#/components/schemas/CameraValidationInfo"
            },
            "title": "Invalid Cameras",
            "type": "array"
          },
          "invalid_count": {
            "description": "Number of cameras with invalid paths",
            "title": "Invalid Count",
            "type": "integer"
          },
          "total_cameras": {
            "description": "Total number of cameras validated",
            "title": "Total Cameras",
            "type": "integer"
          },
          "valid_cameras": {
            "description": "Cameras with valid paths",
            "items": {
              "$ref": "#/components/schemas/CameraValidationInfo"
            },
            "title": "Valid Cameras",
            "type": "array"
          },
          "valid_count": {
            "description": "Number of cameras with valid paths",
            "title": "Valid Count",
            "type": "integer"
          }
        },
        "required": [
          "base_path",
          "total_cameras",
          "valid_count",
          "invalid_count",
          "valid_cameras",
          "invalid_cameras"
        ],
        "title": "CameraPathValidationResponse",
        "type": "object"
      },
      "CameraResponse": {
        "description": "Schema for camera response.\n\nNEM-3597: Added property_id and areas fields to expose camera relationships.",
        "example": {
          "areas": [
            {
              "id": 1,
              "name": "Front Yard"
            }
          ],
          "created_at": "2025-12-23T10:00:00Z",
          "folder_path": "/export/foscam/front_door",
          "id": "front_door",
          "last_seen_at": "2025-12-23T12:00:00Z",
          "name": "Front Door Camera",
          "property_id": 1,
          "status": "online"
        },
        "properties": {
          "areas": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/AreaBasic"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of areas this camera is assigned to",
            "title": "Areas"
          },
          "created_at": {
            "description": "Timestamp when camera was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "folder_path": {
            "description": "File system path for camera uploads",
            "title": "Folder Path",
            "type": "string"
          },
          "id": {
            "description": "Normalized camera ID derived from folder name (e.g., 'front_door')",
            "title": "Id",
            "type": "string"
          },
          "last_seen_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Last time camera was active",
            "title": "Last Seen At"
          },
          "name": {
            "description": "Camera name",
            "title": "Name",
            "type": "string"
          },
          "property_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the property this camera belongs to",
            "title": "Property Id"
          },
          "status": {
            "$ref": "#/components/schemas/CameraStatus",
            "description": "Camera status (online, offline, error, unknown)"
          }
        },
        "required": [
          "id",
          "name",
          "folder_path",
          "status",
          "created_at"
        ],
        "title": "CameraResponse",
        "type": "object"
      },
      "CameraStatus": {
        "description": "Camera status values.\n\nIndicates the operational state of a camera:\n- ONLINE: Camera is active and receiving images\n- OFFLINE: Camera is not currently active (e.g., disconnected)\n- ERROR: Camera is experiencing an error condition\n- UNKNOWN: Camera status cannot be determined",
        "enum": [
          "online",
          "offline",
          "error",
          "unknown"
        ],
        "title": "CameraStatus",
        "type": "string"
      },
      "CameraUpdate": {
        "description": "Schema for updating an existing camera.\n\nNEM-2569: Enhanced with explicit Pydantic validators for partial updates.\nAll fields are optional; only provided fields are validated.",
        "example": {
          "name": "Front Door Camera - Updated",
          "status": "offline"
        },
        "properties": {
          "folder_path": {
            "anyOf": [
              {
                "maxLength": 500,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "File system path for camera uploads",
            "title": "Folder Path"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 255,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera name",
            "title": "Name"
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CameraStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera status (online, offline, error, unknown)"
          }
        },
        "title": "CameraUpdate",
        "type": "object"
      },
      "CameraUptimeDataPoint": {
        "description": "Schema for a single camera uptime data point.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "detection_count": 150,
          "uptime_percentage": 98.5
        },
        "properties": {
          "camera_id": {
            "description": "Normalized camera ID (e.g., 'front_door')",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "description": "Camera name",
            "title": "Camera Name",
            "type": "string"
          },
          "detection_count": {
            "description": "Total detections in date range",
            "minimum": 0.0,
            "title": "Detection Count",
            "type": "integer"
          },
          "uptime_percentage": {
            "description": "Uptime percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Uptime Percentage",
            "type": "number"
          }
        },
        "required": [
          "camera_id",
          "camera_name",
          "uptime_percentage",
          "detection_count"
        ],
        "title": "CameraUptimeDataPoint",
        "type": "object"
      },
      "CameraUptimeResponse": {
        "description": "Schema for camera uptime percentage per camera.",
        "example": {
          "cameras": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_count": 150,
              "uptime_percentage": 98.5
            },
            {
              "camera_id": "back_door",
              "camera_name": "Back Door",
              "detection_count": 120,
              "uptime_percentage": 95.2
            }
          ],
          "end_date": "2025-01-07",
          "start_date": "2025-01-01"
        },
        "properties": {
          "cameras": {
            "description": "Uptime data per camera",
            "items": {
              "$ref": "#/components/schemas/CameraUptimeDataPoint"
            },
            "title": "Cameras",
            "type": "array"
          },
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          }
        },
        "required": [
          "cameras",
          "start_date",
          "end_date"
        ],
        "title": "CameraUptimeResponse",
        "type": "object"
      },
      "CameraValidationInfo": {
        "description": "Schema for individual camera validation result.\n\nNEM-2063: Response model for camera path validation details.",
        "example": {
          "folder_path": "/export/foscam/front_door",
          "id": "front_door",
          "issues": [
            "directory does not exist"
          ],
          "name": "Front Door Camera",
          "resolved_path": "/export/foscam/front_door",
          "status": "online"
        },
        "properties": {
          "folder_path": {
            "description": "Configured folder path",
            "title": "Folder Path",
            "type": "string"
          },
          "id": {
            "description": "Camera ID",
            "title": "Id",
            "type": "string"
          },
          "issues": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of validation issues (only for invalid cameras)",
            "title": "Issues"
          },
          "name": {
            "description": "Camera name",
            "title": "Name",
            "type": "string"
          },
          "resolved_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Resolved absolute path (included if path is outside base_path)",
            "title": "Resolved Path"
          },
          "status": {
            "$ref": "#/components/schemas/CameraStatus",
            "description": "Camera status"
          }
        },
        "required": [
          "id",
          "name",
          "folder_path",
          "status"
        ],
        "title": "CameraValidationInfo",
        "type": "object"
      },
      "CameraZoneShape": {
        "description": "Shape of the camera zone polygon.",
        "enum": [
          "rectangle",
          "polygon"
        ],
        "title": "CameraZoneShape",
        "type": "string"
      },
      "CameraZoneType": {
        "description": "Type of camera zone for semantic categorization.",
        "enum": [
          "entry_point",
          "driveway",
          "sidewalk",
          "yard",
          "other"
        ],
        "title": "CameraZoneType",
        "type": "string"
      },
      "CategorySummary": {
        "description": "Summary of services in a category.\n\nProvides a quick overview of service health within a category\nfor dashboard displays.",
        "example": {
          "healthy": 3,
          "total": 5,
          "unhealthy": 2
        },
        "properties": {
          "healthy": {
            "description": "Number of healthy (running) services",
            "minimum": 0.0,
            "title": "Healthy",
            "type": "integer"
          },
          "total": {
            "description": "Total number of services in this category",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          },
          "unhealthy": {
            "description": "Number of unhealthy/stopped/disabled services",
            "minimum": 0.0,
            "title": "Unhealthy",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "healthy",
          "unhealthy"
        ],
        "title": "CategorySummary",
        "type": "object"
      },
      "CircuitBreakerConfigResponse": {
        "description": "Configuration for a circuit breaker.",
        "properties": {
          "failure_threshold": {
            "description": "Number of failures before opening circuit",
            "minimum": 1.0,
            "title": "Failure Threshold",
            "type": "integer"
          },
          "half_open_max_calls": {
            "description": "Maximum calls allowed in half-open state",
            "minimum": 1.0,
            "title": "Half Open Max Calls",
            "type": "integer"
          },
          "recovery_timeout": {
            "description": "Seconds to wait before transitioning to half-open",
            "minimum": 0.0,
            "title": "Recovery Timeout",
            "type": "number"
          },
          "success_threshold": {
            "description": "Successes needed in half-open to close circuit",
            "minimum": 1.0,
            "title": "Success Threshold",
            "type": "integer"
          }
        },
        "required": [
          "failure_threshold",
          "recovery_timeout",
          "half_open_max_calls",
          "success_threshold"
        ],
        "title": "CircuitBreakerConfigResponse",
        "type": "object"
      },
      "CircuitBreakerResetResponse": {
        "description": "Response for circuit breaker reset operation.",
        "properties": {
          "message": {
            "description": "Human-readable result message",
            "title": "Message",
            "type": "string"
          },
          "name": {
            "description": "Name of the circuit breaker that was reset",
            "title": "Name",
            "type": "string"
          },
          "new_state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "State after reset (should be closed)"
          },
          "previous_state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "State before reset"
          }
        },
        "required": [
          "name",
          "previous_state",
          "new_state",
          "message"
        ],
        "title": "CircuitBreakerResetResponse",
        "type": "object"
      },
      "CircuitBreakerStateEnum": {
        "description": "Circuit breaker states.",
        "enum": [
          "closed",
          "open",
          "half_open",
          "unavailable"
        ],
        "title": "CircuitBreakerStateEnum",
        "type": "string"
      },
      "CircuitBreakerStatusResponse": {
        "description": "Status of a single circuit breaker.",
        "example": {
          "config": {
            "failure_threshold": 5,
            "half_open_max_calls": 3,
            "recovery_timeout": 30.0,
            "success_threshold": 2
          },
          "failure_count": 0,
          "name": "ai_service",
          "rejected_calls": 0,
          "state": "closed",
          "success_count": 0,
          "total_calls": 150
        },
        "properties": {
          "config": {
            "$ref": "#/components/schemas/CircuitBreakerConfigResponse",
            "description": "Circuit breaker configuration"
          },
          "failure_count": {
            "description": "Current consecutive failure count",
            "minimum": 0.0,
            "title": "Failure Count",
            "type": "integer"
          },
          "last_failure_time": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Monotonic time of last failure (seconds)",
            "title": "Last Failure Time"
          },
          "name": {
            "description": "Circuit breaker name",
            "title": "Name",
            "type": "string"
          },
          "opened_at": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Monotonic time when circuit opened (seconds)",
            "title": "Opened At"
          },
          "rejected_calls": {
            "description": "Calls rejected due to open circuit",
            "minimum": 0.0,
            "title": "Rejected Calls",
            "type": "integer"
          },
          "state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "Current circuit state: closed (normal), open (failing), half_open (testing)"
          },
          "success_count": {
            "description": "Current consecutive success count (relevant in half-open)",
            "minimum": 0.0,
            "title": "Success Count",
            "type": "integer"
          },
          "total_calls": {
            "description": "Total calls attempted through this circuit",
            "minimum": 0.0,
            "title": "Total Calls",
            "type": "integer"
          }
        },
        "required": [
          "name",
          "state",
          "failure_count",
          "success_count",
          "total_calls",
          "rejected_calls",
          "config"
        ],
        "title": "CircuitBreakerStatusResponse",
        "type": "object"
      },
      "CircuitBreakerSummary": {
        "description": "Summary of all circuit breakers in the system.\n\nProvides counts by state and individual breaker states for monitoring.",
        "example": {
          "breakers": {
            "clip": "closed",
            "enrichment": "closed",
            "florence": "open",
            "nemotron": "closed",
            "yolo26": "closed"
          },
          "closed": 4,
          "half_open": 0,
          "open": 1,
          "total": 5
        },
        "properties": {
          "breakers": {
            "additionalProperties": {
              "$ref": "#/components/schemas/CircuitState"
            },
            "description": "Individual circuit breaker states keyed by service name",
            "title": "Breakers",
            "type": "object"
          },
          "closed": {
            "description": "Number of breakers in closed state",
            "title": "Closed",
            "type": "integer"
          },
          "half_open": {
            "description": "Number of breakers in half-open state",
            "title": "Half Open",
            "type": "integer"
          },
          "open": {
            "description": "Number of breakers in open state",
            "title": "Open",
            "type": "integer"
          },
          "total": {
            "description": "Total number of circuit breakers",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "closed",
          "open",
          "half_open",
          "breakers"
        ],
        "title": "CircuitBreakerSummary",
        "type": "object"
      },
      "CircuitBreakersResponse": {
        "description": "Response schema for circuit breakers status endpoint.",
        "example": {
          "circuit_breakers": {
            "yolo26": {
              "config": {
                "failure_threshold": 5,
                "half_open_max_calls": 3,
                "recovery_timeout": 30.0,
                "success_threshold": 2
              },
              "failure_count": 0,
              "name": "yolo26",
              "rejected_calls": 0,
              "state": "closed",
              "success_count": 0,
              "total_calls": 100
            }
          },
          "open_count": 0,
          "timestamp": "2025-12-30T10:30:00Z",
          "total_count": 2
        },
        "properties": {
          "circuit_breakers": {
            "additionalProperties": {
              "$ref": "#/components/schemas/CircuitBreakerStatusResponse"
            },
            "description": "Status of all circuit breakers keyed by name",
            "title": "Circuit Breakers",
            "type": "object"
          },
          "open_count": {
            "description": "Number of circuit breakers currently open",
            "minimum": 0.0,
            "title": "Open Count",
            "type": "integer"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "total_count": {
            "description": "Total number of circuit breakers",
            "minimum": 0.0,
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "circuit_breakers",
          "total_count",
          "open_count",
          "timestamp"
        ],
        "title": "CircuitBreakersResponse",
        "type": "object"
      },
      "CircuitState": {
        "description": "Circuit breaker state for a service.\n\nStates:\n- closed: Normal operation, requests pass through\n- open: Service failing, requests fail immediately\n- half_open: Testing recovery, limited requests allowed",
        "enum": [
          "closed",
          "open",
          "half_open"
        ],
        "title": "CircuitState",
        "type": "string"
      },
      "ClassBaselineEntry": {
        "description": "Baseline entry for a specific object class at a specific hour.",
        "example": {
          "frequency": 3.5,
          "hour": 17,
          "object_class": "person",
          "sample_count": 45
        },
        "properties": {
          "frequency": {
            "description": "Frequency of this class at this hour",
            "minimum": 0.0,
            "title": "Frequency",
            "type": "number"
          },
          "hour": {
            "description": "Hour of day (0-23)",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Hour",
            "type": "integer"
          },
          "object_class": {
            "description": "Object class (e.g., person, vehicle, animal)",
            "title": "Object Class",
            "type": "string"
          },
          "sample_count": {
            "description": "Number of samples for this class/hour combination",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "object_class",
          "hour",
          "frequency",
          "sample_count"
        ],
        "title": "ClassBaselineEntry",
        "type": "object"
      },
      "ClassBaselineResponse": {
        "description": "Response for camera class frequency baseline endpoint.",
        "example": {
          "camera_id": "front_door",
          "entries": [
            {
              "frequency": 3.5,
              "hour": 17,
              "object_class": "person",
              "sample_count": 45
            },
            {
              "frequency": 2.1,
              "hour": 8,
              "object_class": "vehicle",
              "sample_count": 30
            }
          ],
          "most_common_class": "person",
          "total_samples": 150,
          "unique_classes": [
            "person",
            "vehicle",
            "animal"
          ]
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "entries": {
            "description": "Class baseline entries grouped by class and hour",
            "items": {
              "$ref": "#/components/schemas/ClassBaselineEntry"
            },
            "title": "Entries",
            "type": "array"
          },
          "most_common_class": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Most frequently detected object class",
            "title": "Most Common Class"
          },
          "total_samples": {
            "description": "Total number of samples across all entries",
            "minimum": 0.0,
            "title": "Total Samples",
            "type": "integer"
          },
          "unique_classes": {
            "description": "List of unique object classes detected for this camera",
            "items": {
              "type": "string"
            },
            "title": "Unique Classes",
            "type": "array"
          }
        },
        "required": [
          "camera_id",
          "total_samples"
        ],
        "title": "ClassBaselineResponse",
        "type": "object"
      },
      "CleanupResponse": {
        "description": "Response schema for data cleanup endpoint.\n\nReturns statistics about the cleanup operation including counts of\ndeleted records and files. When dry_run is True, the counts represent\nwhat would be deleted without actually deleting.",
        "example": {
          "detections_deleted": 89,
          "dry_run": false,
          "events_deleted": 15,
          "gpu_stats_deleted": 2880,
          "images_deleted": 0,
          "logs_deleted": 150,
          "retention_days": 30,
          "space_reclaimed": 524288000,
          "thumbnails_deleted": 89,
          "timestamp": "2025-12-27T10:30:00Z"
        },
        "properties": {
          "detections_deleted": {
            "description": "Number of detections deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Detections Deleted",
            "type": "integer"
          },
          "dry_run": {
            "default": false,
            "description": "Whether this was a dry run (no actual deletion performed)",
            "title": "Dry Run",
            "type": "boolean"
          },
          "events_deleted": {
            "description": "Number of events deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Events Deleted",
            "type": "integer"
          },
          "gpu_stats_deleted": {
            "description": "Number of GPU stat records deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Gpu Stats Deleted",
            "type": "integer"
          },
          "images_deleted": {
            "description": "Number of original image files deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Images Deleted",
            "type": "integer"
          },
          "logs_deleted": {
            "description": "Number of log records deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Logs Deleted",
            "type": "integer"
          },
          "retention_days": {
            "description": "Retention period used for cleanup",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Retention Days",
            "type": "integer"
          },
          "space_reclaimed": {
            "description": "Estimated disk space freed in bytes (or would be freed in dry run)",
            "minimum": 0.0,
            "title": "Space Reclaimed",
            "type": "integer"
          },
          "thumbnails_deleted": {
            "description": "Number of thumbnail files deleted (or would be deleted in dry run)",
            "minimum": 0.0,
            "title": "Thumbnails Deleted",
            "type": "integer"
          },
          "timestamp": {
            "description": "Timestamp of cleanup operation",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "events_deleted",
          "detections_deleted",
          "gpu_stats_deleted",
          "logs_deleted",
          "thumbnails_deleted",
          "images_deleted",
          "space_reclaimed",
          "retention_days",
          "timestamp"
        ],
        "title": "CleanupResponse",
        "type": "object"
      },
      "CleanupStatusResponse": {
        "description": "Response schema for cleanup service status endpoint.",
        "example": {
          "cleanup_time": "03:00",
          "delete_images": false,
          "next_cleanup": "2025-12-31T03:00:00Z",
          "retention_days": 30,
          "running": true,
          "timestamp": "2025-12-30T10:30:00Z"
        },
        "properties": {
          "cleanup_time": {
            "description": "Scheduled daily cleanup time in HH:MM format",
            "title": "Cleanup Time",
            "type": "string"
          },
          "delete_images": {
            "description": "Whether original images are deleted during cleanup",
            "title": "Delete Images",
            "type": "boolean"
          },
          "next_cleanup": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ISO timestamp of next scheduled cleanup (null if not running)",
            "title": "Next Cleanup"
          },
          "retention_days": {
            "description": "Current retention period in days",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Retention Days",
            "type": "integer"
          },
          "running": {
            "description": "Whether the cleanup service is currently running",
            "title": "Running",
            "type": "boolean"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "running",
          "retention_days",
          "cleanup_time",
          "delete_images",
          "timestamp"
        ],
        "title": "CleanupStatusResponse",
        "type": "object"
      },
      "ClearCacheResponse": {
        "description": "Response schema for cache clear endpoint.",
        "properties": {
          "cache_types": {
            "items": {
              "type": "string"
            },
            "title": "Cache Types",
            "type": "array"
          },
          "duration_seconds": {
            "title": "Duration Seconds",
            "type": "number"
          },
          "keys_cleared": {
            "title": "Keys Cleared",
            "type": "integer"
          },
          "message": {
            "title": "Message",
            "type": "string"
          }
        },
        "required": [
          "keys_cleared",
          "cache_types",
          "duration_seconds",
          "message"
        ],
        "title": "ClearCacheResponse",
        "type": "object"
      },
      "ClearDataRequest": {
        "description": "Request schema for clearing data - requires confirmation.",
        "properties": {
          "confirm": {
            "description": "Must be exactly 'DELETE_ALL_DATA' to confirm deletion",
            "title": "Confirm",
            "type": "string"
          }
        },
        "required": [
          "confirm"
        ],
        "title": "ClearDataRequest",
        "type": "object"
      },
      "ClearDataResponse": {
        "description": "Response schema for clear data endpoint.",
        "properties": {
          "cameras_cleared": {
            "title": "Cameras Cleared",
            "type": "integer"
          },
          "detections_cleared": {
            "title": "Detections Cleared",
            "type": "integer"
          },
          "events_cleared": {
            "title": "Events Cleared",
            "type": "integer"
          }
        },
        "required": [
          "cameras_cleared",
          "events_cleared",
          "detections_cleared"
        ],
        "title": "ClearDataResponse",
        "type": "object"
      },
      "ClipGenerateRequest": {
        "description": "Schema for clip generation request (POST /api/events/{event_id}/clip/generate).\n\nOffset validation (NEM-1355):\n- start_offset_seconds: -30 to 3600 seconds\n- end_offset_seconds: -30 to 3600 seconds\n- end_offset_seconds must be >= start_offset_seconds",
        "example": {
          "end_offset_seconds": 30,
          "force": false,
          "start_offset_seconds": -15
        },
        "properties": {
          "end_offset_seconds": {
            "default": 30,
            "description": "Seconds relative to event start to end clip (range: -30 to 3600, must be >= start_offset_seconds)",
            "maximum": 3600.0,
            "minimum": -30.0,
            "title": "End Offset Seconds",
            "type": "integer"
          },
          "force": {
            "default": false,
            "description": "Force regeneration even if clip already exists",
            "title": "Force",
            "type": "boolean"
          },
          "start_offset_seconds": {
            "default": -15,
            "description": "Seconds relative to event start to begin clip (negative = before event, range: -30 to 3600)",
            "maximum": 3600.0,
            "minimum": -30.0,
            "title": "Start Offset Seconds",
            "type": "integer"
          }
        },
        "title": "ClipGenerateRequest",
        "type": "object"
      },
      "ClipGenerateResponse": {
        "description": "Schema for clip generation response.",
        "example": {
          "clip_url": "/api/media/clips/123_clip.mp4",
          "event_id": 123,
          "generated_at": "2026-01-03T10:30:00Z",
          "message": "Clip generated successfully",
          "status": "completed"
        },
        "properties": {
          "clip_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to access the clip (if completed)",
            "title": "Clip Url"
          },
          "event_id": {
            "description": "Event ID",
            "title": "Event Id",
            "type": "integer"
          },
          "generated_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when the clip was generated",
            "title": "Generated At"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status message or error details",
            "title": "Message"
          },
          "status": {
            "$ref": "#/components/schemas/ClipStatus",
            "description": "Status of clip generation"
          }
        },
        "required": [
          "event_id",
          "status"
        ],
        "title": "ClipGenerateResponse",
        "type": "object"
      },
      "ClipInfoResponse": {
        "description": "Schema for clip info response (GET /api/events/{event_id}/clip).",
        "example": {
          "clip_available": true,
          "clip_url": "/api/media/clips/123_clip.mp4",
          "duration_seconds": 30,
          "event_id": 123,
          "file_size_bytes": 5242880,
          "generated_at": "2026-01-03T10:30:00Z"
        },
        "properties": {
          "clip_available": {
            "description": "Whether a clip is available for this event",
            "title": "Clip Available",
            "type": "boolean"
          },
          "clip_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to access the clip (if available)",
            "title": "Clip Url"
          },
          "duration_seconds": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Duration of the clip in seconds",
            "title": "Duration Seconds"
          },
          "event_id": {
            "description": "Event ID",
            "title": "Event Id",
            "type": "integer"
          },
          "file_size_bytes": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "File size of the clip in bytes",
            "title": "File Size Bytes"
          },
          "generated_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when the clip was generated",
            "title": "Generated At"
          }
        },
        "required": [
          "event_id",
          "clip_available"
        ],
        "title": "ClipInfoResponse",
        "type": "object"
      },
      "ClipStatus": {
        "description": "Status of clip generation.",
        "enum": [
          "pending",
          "completed",
          "failed"
        ],
        "title": "ClipStatus",
        "type": "string"
      },
      "ClothingEnrichment": {
        "description": "Clothing classification and segmentation results.",
        "example": {
          "has_bag": true,
          "has_face_covered": false,
          "is_service_uniform": false,
          "is_suspicious": false,
          "lower": "blue jeans",
          "upper": "red t-shirt"
        },
        "properties": {
          "clothing_items": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of detected clothing items",
            "title": "Clothing Items"
          },
          "has_bag": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether person is carrying a bag",
            "title": "Has Bag"
          },
          "has_face_covered": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether face is covered (hat/sunglasses/mask)",
            "title": "Has Face Covered"
          },
          "is_service_uniform": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether wearing service uniform",
            "title": "Is Service Uniform"
          },
          "is_suspicious": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether clothing is flagged as suspicious",
            "title": "Is Suspicious"
          },
          "lower": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Lower body clothing description",
            "title": "Lower"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          },
          "upper": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Upper body clothing description",
            "title": "Upper"
          }
        },
        "title": "ClothingEnrichment",
        "type": "object"
      },
      "ClusterEventSummary": {
        "description": "Abbreviated event object for cluster response.",
        "example": {
          "camera_id": "front_door",
          "id": 1,
          "risk_level": "high",
          "risk_score": 75,
          "started_at": "2026-01-25T10:00:00Z",
          "summary": "Person detected at front entrance"
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID that captured this event",
            "title": "Camera Id",
            "type": "string"
          },
          "id": {
            "description": "Event ID",
            "title": "Id",
            "type": "integer"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk level (low, medium, high, critical)",
            "title": "Risk Level"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk score (0-100)",
            "title": "Risk Score"
          },
          "started_at": {
            "description": "Event start timestamp",
            "format": "date-time",
            "title": "Started At",
            "type": "string"
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Brief event summary",
            "title": "Summary"
          }
        },
        "required": [
          "id",
          "camera_id",
          "started_at"
        ],
        "title": "ClusterEventSummary",
        "type": "object"
      },
      "ClusterRiskLevels": {
        "description": "Schema for aggregated risk levels within a cluster.",
        "example": {
          "critical": 1,
          "high": 2,
          "low": 0,
          "medium": 2
        },
        "properties": {
          "critical": {
            "default": 0,
            "description": "Number of critical risk events in the cluster",
            "minimum": 0.0,
            "title": "Critical",
            "type": "integer"
          },
          "high": {
            "default": 0,
            "description": "Number of high risk events in the cluster",
            "minimum": 0.0,
            "title": "High",
            "type": "integer"
          },
          "low": {
            "default": 0,
            "description": "Number of low risk events in the cluster",
            "minimum": 0.0,
            "title": "Low",
            "type": "integer"
          },
          "medium": {
            "default": 0,
            "description": "Number of medium risk events in the cluster",
            "minimum": 0.0,
            "title": "Medium",
            "type": "integer"
          }
        },
        "title": "ClusterRiskLevels",
        "type": "object"
      },
      "ConfidenceFactors": {
        "description": "Factors affecting confidence in the risk analysis.\n\nThese factors help explain the reliability of the risk assessment\nand can be used to understand when additional review may be needed.\n\nAttributes:\n    detection_quality: Quality of the detection data (good, fair, poor)\n    weather_impact: Impact of weather on detection accuracy\n    enrichment_coverage: Completeness of enrichment data used",
        "example": {
          "detection_quality": "good",
          "enrichment_coverage": "full",
          "weather_impact": "none"
        },
        "properties": {
          "detection_quality": {
            "default": "good",
            "description": "Quality of the detection data",
            "enum": [
              "good",
              "fair",
              "poor"
            ],
            "title": "Detection Quality",
            "type": "string"
          },
          "enrichment_coverage": {
            "default": "full",
            "description": "Completeness of enrichment data available",
            "enum": [
              "full",
              "partial",
              "minimal"
            ],
            "title": "Enrichment Coverage",
            "type": "string"
          },
          "weather_impact": {
            "default": "none",
            "description": "Impact of weather conditions on detection accuracy",
            "enum": [
              "none",
              "minor",
              "significant"
            ],
            "title": "Weather Impact",
            "type": "string"
          }
        },
        "title": "ConfidenceFactors",
        "type": "object"
      },
      "ConfigResponse": {
        "description": "Response schema for configuration endpoint.\n\nOnly includes public, non-sensitive configuration values.",
        "example": {
          "app_name": "Home Security Intelligence",
          "batch_idle_timeout_seconds": 30,
          "batch_window_seconds": 90,
          "debug": false,
          "detection_confidence_threshold": 0.5,
          "fast_path_confidence_threshold": 0.9,
          "grafana_url": "/grafana",
          "log_retention_days": 7,
          "retention_days": 30,
          "version": "0.1.0"
        },
        "properties": {
          "app_name": {
            "description": "Application name",
            "title": "App Name",
            "type": "string"
          },
          "batch_idle_timeout_seconds": {
            "description": "Idle timeout before processing incomplete batch",
            "minimum": 1.0,
            "title": "Batch Idle Timeout Seconds",
            "type": "integer"
          },
          "batch_window_seconds": {
            "description": "Time window for batch processing detections",
            "minimum": 1.0,
            "title": "Batch Window Seconds",
            "type": "integer"
          },
          "debug": {
            "description": "Whether debug mode is enabled (enables developer tools)",
            "title": "Debug",
            "type": "boolean"
          },
          "detection_confidence_threshold": {
            "deprecated": true,
            "description": "DEPRECATED: Use /api/v1/settings detection.confidence_threshold instead. Minimum confidence threshold for detections (0.0-1.0). This field will be removed in a future version.",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Detection Confidence Threshold",
            "type": "number"
          },
          "fast_path_confidence_threshold": {
            "description": "Confidence threshold for fast-path high-priority analysis (0.0-1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Fast Path Confidence Threshold",
            "type": "number"
          },
          "grafana_url": {
            "description": "Grafana dashboard URL for frontend link",
            "title": "Grafana Url",
            "type": "string"
          },
          "log_retention_days": {
            "description": "Number of days to retain logs (separate from event retention)",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Log Retention Days",
            "type": "integer"
          },
          "retention_days": {
            "description": "Number of days to retain events and detections",
            "maximum": 365.0,
            "minimum": 1.0,
            "title": "Retention Days",
            "type": "integer"
          },
          "version": {
            "description": "Application version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "app_name",
          "version",
          "retention_days",
          "log_retention_days",
          "batch_window_seconds",
          "batch_idle_timeout_seconds",
          "detection_confidence_threshold",
          "fast_path_confidence_threshold",
          "grafana_url",
          "debug"
        ],
        "title": "ConfigResponse",
        "type": "object"
      },
      "ConfigUpdateRequest": {
        "description": "Request schema for PATCH /api/system/config.\n\nOnly supports a subset of processing-related settings.",
        "properties": {
          "batch_idle_timeout_seconds": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Idle timeout before processing incomplete batch",
            "title": "Batch Idle Timeout Seconds"
          },
          "batch_window_seconds": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time window for batch processing detections",
            "title": "Batch Window Seconds"
          },
          "detection_confidence_threshold": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "deprecated": true,
            "description": "DEPRECATED: Use /api/v1/settings detection.confidence_threshold instead. Minimum confidence threshold for detections (0.0-1.0). This field will be removed in a future version.",
            "title": "Detection Confidence Threshold"
          },
          "fast_path_confidence_threshold": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Confidence threshold for fast-path high-priority analysis (0.0-1.0)",
            "title": "Fast Path Confidence Threshold"
          },
          "log_retention_days": {
            "anyOf": [
              {
                "maximum": 365.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of days to retain logs",
            "title": "Log Retention Days"
          },
          "retention_days": {
            "anyOf": [
              {
                "maximum": 365.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of days to retain events and detections",
            "title": "Retention Days"
          }
        },
        "title": "ConfigUpdateRequest",
        "type": "object"
      },
      "ContainerMetrics": {
        "description": "Container health status.",
        "example": {
          "health": "healthy",
          "name": "backend",
          "status": "running"
        },
        "properties": {
          "health": {
            "description": "Health status (healthy, unhealthy, starting)",
            "title": "Health",
            "type": "string"
          },
          "name": {
            "description": "Container name",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "description": "Container status (running, stopped, restarting, etc.)",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "name",
          "status",
          "health"
        ],
        "title": "ContainerMetrics",
        "type": "object"
      },
      "ContainerServiceStatus": {
        "description": "Current status of a managed container service.\n\nStatus values:\n- RUNNING: Container is up and passing health checks\n- STARTING: Container is starting, not yet healthy\n- UNHEALTHY: Running but failing health checks\n- STOPPED: Container is not running\n- DISABLED: Exceeded failure limit, requires manual reset\n- NOT_FOUND: Container doesn't exist yet",
        "enum": [
          "running",
          "starting",
          "unhealthy",
          "stopped",
          "disabled",
          "not_found"
        ],
        "title": "ContainerServiceStatus",
        "type": "string"
      },
      "CurrentDeviation": {
        "description": "Current activity deviation from established baseline.",
        "example": {
          "contributing_factors": [
            "person_count_elevated",
            "unusual_hour"
          ],
          "interpretation": "slightly_above_normal",
          "score": 1.8
        },
        "properties": {
          "contributing_factors": {
            "description": "Factors contributing to current deviation",
            "items": {
              "type": "string"
            },
            "title": "Contributing Factors",
            "type": "array"
          },
          "interpretation": {
            "$ref": "#/components/schemas/DeviationInterpretation",
            "description": "Human-readable interpretation of the deviation"
          },
          "score": {
            "description": "Deviation score (standard deviations from mean, can be negative)",
            "title": "Score",
            "type": "number"
          }
        },
        "required": [
          "score",
          "interpretation"
        ],
        "title": "CurrentDeviation",
        "type": "object"
      },
      "CustomTestPromptRequest": {
        "description": "Request to test a custom prompt against an existing event.\n\nThis is used for A/B testing in the Prompt Playground - testing a\nmodified prompt without persisting results to the database.",
        "example": {
          "custom_prompt": "You are a home security AI with enhanced context...",
          "event_id": 12345,
          "max_tokens": 2048,
          "model": "nemotron",
          "temperature": 0.7
        },
        "properties": {
          "custom_prompt": {
            "description": "Custom prompt text to test",
            "minLength": 1,
            "title": "Custom Prompt",
            "type": "string"
          },
          "event_id": {
            "description": "Event ID to test the prompt against",
            "minimum": 1.0,
            "title": "Event Id",
            "type": "integer"
          },
          "max_tokens": {
            "default": 2048,
            "description": "Maximum tokens for LLM response (100-8192)",
            "maximum": 8192.0,
            "minimum": 100.0,
            "title": "Max Tokens",
            "type": "integer"
          },
          "model": {
            "default": "nemotron",
            "description": "Model to use for testing (default: nemotron)",
            "title": "Model",
            "type": "string"
          },
          "temperature": {
            "default": 0.7,
            "description": "Temperature for LLM generation (0-2)",
            "maximum": 2.0,
            "minimum": 0.0,
            "title": "Temperature",
            "type": "number"
          }
        },
        "required": [
          "event_id",
          "custom_prompt"
        ],
        "title": "CustomTestPromptRequest",
        "type": "object"
      },
      "CustomTestPromptResponse": {
        "description": "Response from testing a custom prompt against an event.\n\nResults are NOT persisted - this is for A/B testing only.",
        "example": {
          "entities": [
            {
              "confidence": 0.95,
              "type": "person"
            }
          ],
          "flags": [],
          "processing_time_ms": 1250,
          "reasoning": "The detected person matches the expected delivery pattern based on time and approach direction.",
          "recommended_action": "No action required",
          "risk_level": "low",
          "risk_score": 45,
          "summary": "Delivery person detected at front door during expected hours",
          "tokens_used": 512
        },
        "properties": {
          "entities": {
            "description": "Entities detected in the analysis",
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "title": "Entities",
            "type": "array"
          },
          "flags": {
            "description": "Any flags raised during analysis",
            "items": {
              "type": "string"
            },
            "title": "Flags",
            "type": "array"
          },
          "processing_time_ms": {
            "description": "Processing time in milliseconds",
            "minimum": 0.0,
            "title": "Processing Time Ms",
            "type": "integer"
          },
          "reasoning": {
            "description": "Detailed reasoning for the risk assessment",
            "title": "Reasoning",
            "type": "string"
          },
          "recommended_action": {
            "description": "Recommended action based on risk level",
            "title": "Recommended Action",
            "type": "string"
          },
          "risk_level": {
            "description": "Risk level: low, medium, high, or critical",
            "title": "Risk Level",
            "type": "string"
          },
          "risk_score": {
            "description": "Risk score from 0 (no risk) to 100 (critical)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Risk Score",
            "type": "integer"
          },
          "summary": {
            "description": "Brief summary of the analysis",
            "title": "Summary",
            "type": "string"
          },
          "tokens_used": {
            "description": "Estimated tokens used for the analysis",
            "minimum": 0.0,
            "title": "Tokens Used",
            "type": "integer"
          }
        },
        "required": [
          "risk_score",
          "risk_level",
          "reasoning",
          "summary",
          "recommended_action",
          "processing_time_ms",
          "tokens_used"
        ],
        "title": "CustomTestPromptResponse",
        "type": "object"
      },
      "DLQClearResponse": {
        "description": "Response schema for clearing a DLQ.",
        "example": {
          "message": "Cleared 5 jobs from dlq:detection_queue",
          "queue_name": "dlq:detection_queue",
          "success": true
        },
        "properties": {
          "message": {
            "description": "Status message",
            "title": "Message",
            "type": "string"
          },
          "queue_name": {
            "description": "Name of the cleared queue",
            "title": "Queue Name",
            "type": "string"
          },
          "success": {
            "description": "Whether the clear operation succeeded",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success",
          "message",
          "queue_name"
        ],
        "title": "DLQClearResponse",
        "type": "object"
      },
      "DLQJobResponse": {
        "description": "Response schema for a single job in the dead-letter queue.\n\nIncludes enriched error context (NEM-1474) for faster debugging:\n- error_type: Exception class name for categorization\n- stack_trace: Truncated stack trace for debugging\n- http_status: HTTP status code (for network errors)\n- response_body: Truncated AI service response (for debugging)\n- retry_delays: Delays applied between retry attempts\n- context: System state snapshot at failure time",
        "example": {
          "attempt_count": 3,
          "context": {
            "analysis_queue_depth": 25,
            "detection_queue_depth": 150,
            "dlq_circuit_breaker_state": "closed"
          },
          "error": "Connection refused: detector service unavailable",
          "error_type": "ConnectionRefusedError",
          "first_failed_at": "2025-12-23T10:30:05.000000",
          "last_failed_at": "2025-12-23T10:30:15.000000",
          "original_job": {
            "camera_id": "front_door",
            "file_path": "/export/foscam/front_door/image_001.jpg",
            "timestamp": "2025-12-23T10:30:00.000000"
          },
          "queue_name": "detection_queue",
          "retry_delays": [
            1.0,
            2.0
          ],
          "stack_trace": "Traceback (most recent call last):\n  ..."
        },
        "properties": {
          "attempt_count": {
            "description": "Number of processing attempts made",
            "minimum": 1.0,
            "title": "Attempt Count",
            "type": "integer"
          },
          "context": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "System state snapshot at failure time (queue depths, circuit breaker states)",
            "title": "Context"
          },
          "error": {
            "description": "Error message from the last failure attempt",
            "title": "Error",
            "type": "string"
          },
          "error_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Exception class name (e.g., 'ConnectionRefusedError')",
            "title": "Error Type"
          },
          "first_failed_at": {
            "description": "ISO timestamp of the first failure",
            "title": "First Failed At",
            "type": "string"
          },
          "http_status": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "HTTP status code if the error was from a network request",
            "title": "Http Status"
          },
          "last_failed_at": {
            "description": "ISO timestamp of the last failure",
            "title": "Last Failed At",
            "type": "string"
          },
          "original_job": {
            "additionalProperties": true,
            "description": "Original job payload that failed",
            "title": "Original Job",
            "type": "object"
          },
          "queue_name": {
            "description": "Name of the original queue where the job came from",
            "title": "Queue Name",
            "type": "string"
          },
          "response_body": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Truncated response body (max 2KB) from AI service",
            "title": "Response Body"
          },
          "retry_delays": {
            "anyOf": [
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Delays (in seconds) applied between retry attempts",
            "title": "Retry Delays"
          },
          "stack_trace": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Truncated stack trace (max 4KB) for debugging",
            "title": "Stack Trace"
          }
        },
        "required": [
          "original_job",
          "error",
          "attempt_count",
          "first_failed_at",
          "last_failed_at",
          "queue_name"
        ],
        "title": "DLQJobResponse",
        "type": "object"
      },
      "DLQJobsResponse": {
        "description": "Response schema for listing jobs in a DLQ.\n\nUses standard pagination envelope format (NEM-2178):\n- items: List of DLQ jobs (renamed from 'jobs')\n- pagination: Standard pagination metadata\n- queue_name: Name of the dead-letter queue",
        "example": {
          "items": [
            {
              "attempt_count": 3,
              "error": "Connection refused",
              "first_failed_at": "2025-12-23T10:30:05.000000",
              "last_failed_at": "2025-12-23T10:30:15.000000",
              "original_job": {
                "camera_id": "front_door",
                "file_path": "/export/foscam/front_door/image_001.jpg",
                "timestamp": "2025-12-23T10:30:00.000000"
              },
              "queue_name": "detection_queue"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 100,
            "offset": 0,
            "total": 1
          },
          "queue_name": "dlq:detection_queue"
        },
        "properties": {
          "items": {
            "description": "List of jobs in the queue",
            "items": {
              "$ref": "#/components/schemas/DLQJobResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          },
          "queue_name": {
            "description": "Name of the dead-letter queue",
            "title": "Queue Name",
            "type": "string"
          }
        },
        "required": [
          "queue_name",
          "items",
          "pagination"
        ],
        "title": "DLQJobsResponse",
        "type": "object"
      },
      "DLQName": {
        "description": "Available dead-letter queue names.",
        "enum": [
          "dlq:detection_queue",
          "dlq:analysis_queue"
        ],
        "title": "DLQName",
        "type": "string"
      },
      "DLQRequeueResponse": {
        "description": "Response schema for requeuing a job from DLQ.",
        "example": {
          "job": {
            "camera_id": "front_door",
            "file_path": "/export/foscam/front_door/image_001.jpg",
            "timestamp": "2025-12-23T10:30:00.000000"
          },
          "message": "Job requeued from dlq:detection_queue to detection_queue",
          "success": true
        },
        "properties": {
          "job": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "The requeued job data (if successful)",
            "title": "Job"
          },
          "message": {
            "description": "Status message",
            "title": "Message",
            "type": "string"
          },
          "success": {
            "description": "Whether the requeue operation succeeded",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success",
          "message"
        ],
        "title": "DLQRequeueResponse",
        "type": "object"
      },
      "DLQStatsResponse": {
        "description": "Response schema for DLQ statistics.",
        "example": {
          "analysis_queue_count": 1,
          "detection_queue_count": 2,
          "total_count": 3
        },
        "properties": {
          "analysis_queue_count": {
            "description": "Number of jobs in the analysis DLQ",
            "minimum": 0.0,
            "title": "Analysis Queue Count",
            "type": "integer"
          },
          "detection_queue_count": {
            "description": "Number of jobs in the detection DLQ",
            "minimum": 0.0,
            "title": "Detection Queue Count",
            "type": "integer"
          },
          "total_count": {
            "description": "Total number of jobs across all DLQs",
            "minimum": 0.0,
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "detection_queue_count",
          "analysis_queue_count",
          "total_count"
        ],
        "title": "DLQStatsResponse",
        "type": "object"
      },
      "DailyAuditStats": {
        "description": "Daily breakdown of audit statistics.\n\nProvides a detailed view of audit activity for a single day,\nincluding quality metrics and model contribution counts.",
        "example": {
          "avg_enrichment_utilization": 0.78,
          "avg_quality_score": 4.2,
          "count": 45,
          "date": "2026-01-01",
          "day_of_week": "Wednesday",
          "model_contributions": {
            "baseline": 25,
            "clip": 12,
            "clothing": 32,
            "cross_camera": 10,
            "florence": 38,
            "image_quality": 40,
            "pet": 3,
            "vehicle": 8,
            "violence": 5,
            "weather": 42,
            "yolo26": 45,
            "zones": 30
          }
        },
        "properties": {
          "avg_enrichment_utilization": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Average enrichment utilization for this day (0-1)",
            "title": "Avg Enrichment Utilization"
          },
          "avg_quality_score": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Average quality score for this day (1-5 scale)",
            "title": "Avg Quality Score"
          },
          "count": {
            "description": "Number of audits on this day",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "date": {
            "description": "ISO date string (YYYY-MM-DD)",
            "title": "Date",
            "type": "string"
          },
          "day_of_week": {
            "description": "Day name (e.g., Monday, Tuesday)",
            "title": "Day Of Week",
            "type": "string"
          },
          "model_contributions": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of audits where each model contributed on this day",
            "title": "Model Contributions",
            "type": "object"
          }
        },
        "required": [
          "date",
          "day_of_week",
          "count"
        ],
        "title": "DailyAuditStats",
        "type": "object"
      },
      "DailyPattern": {
        "description": "Activity pattern for a specific day of the week.",
        "example": {
          "avg_detections": 45.0,
          "peak_hour": 17,
          "total_samples": 168
        },
        "properties": {
          "avg_detections": {
            "description": "Average number of detections for this day",
            "minimum": 0.0,
            "title": "Avg Detections",
            "type": "number"
          },
          "peak_hour": {
            "description": "Hour with most activity (0-23)",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Peak Hour",
            "type": "integer"
          },
          "total_samples": {
            "description": "Total samples for this day",
            "minimum": 0.0,
            "title": "Total Samples",
            "type": "integer"
          }
        },
        "required": [
          "avg_detections",
          "peak_hour",
          "total_samples"
        ],
        "title": "DailyPattern",
        "type": "object"
      },
      "DatabaseMetrics": {
        "description": "PostgreSQL database metrics.",
        "example": {
          "cache_hit_ratio": 98.2,
          "connections_active": 5,
          "connections_max": 30,
          "status": "healthy",
          "transactions_per_min": 1200
        },
        "properties": {
          "cache_hit_ratio": {
            "description": "Buffer cache hit ratio percentage",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Cache Hit Ratio",
            "type": "number"
          },
          "connections_active": {
            "description": "Active connections",
            "minimum": 0.0,
            "title": "Connections Active",
            "type": "integer"
          },
          "connections_max": {
            "description": "Maximum allowed connections",
            "minimum": 0.0,
            "title": "Connections Max",
            "type": "integer"
          },
          "status": {
            "description": "Health status: healthy, unhealthy, unreachable",
            "title": "Status",
            "type": "string"
          },
          "transactions_per_min": {
            "description": "Transaction rate per minute",
            "minimum": 0.0,
            "title": "Transactions Per Min",
            "type": "number"
          }
        },
        "required": [
          "status",
          "connections_active",
          "connections_max",
          "cache_hit_ratio",
          "transactions_per_min"
        ],
        "title": "DatabaseMetrics",
        "type": "object"
      },
      "DebugCircuitBreakersResponse": {
        "description": "Response for circuit breaker states.",
        "properties": {
          "circuit_breakers": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "description": "All circuit breaker states keyed by name",
            "title": "Circuit Breakers",
            "type": "object"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "circuit_breakers",
          "timestamp"
        ],
        "title": "DebugCircuitBreakersResponse",
        "type": "object"
      },
      "DebugConfigResponse": {
        "description": "Response for configuration inspection.",
        "properties": {
          "config": {
            "additionalProperties": true,
            "description": "Current configuration with sensitive values redacted",
            "title": "Config",
            "type": "object"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "config",
          "timestamp"
        ],
        "title": "DebugConfigResponse",
        "type": "object"
      },
      "DebugWebSocketBroadcasterStatus": {
        "description": "Status of a WebSocket broadcaster.",
        "properties": {
          "channel_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Redis channel being listened to",
            "title": "Channel Name"
          },
          "circuit_state": {
            "description": "Circuit breaker state (CLOSED, OPEN, HALF_OPEN)",
            "title": "Circuit State",
            "type": "string"
          },
          "connection_count": {
            "description": "Number of active connections",
            "title": "Connection Count",
            "type": "integer"
          },
          "is_degraded": {
            "description": "Whether the broadcaster is in degraded mode",
            "title": "Is Degraded",
            "type": "boolean"
          },
          "is_listening": {
            "description": "Whether the broadcaster is listening for events",
            "title": "Is Listening",
            "type": "boolean"
          }
        },
        "required": [
          "connection_count",
          "is_listening",
          "is_degraded",
          "circuit_state"
        ],
        "title": "DebugWebSocketBroadcasterStatus",
        "type": "object"
      },
      "DegradationModeEnum": {
        "description": "System degradation modes.",
        "enum": [
          "normal",
          "degraded",
          "minimal",
          "offline"
        ],
        "title": "DegradationModeEnum",
        "type": "string"
      },
      "DegradationStatusResponse": {
        "description": "Status information for the DegradationManager service.",
        "example": {
          "available_features": [
            "detection",
            "analysis",
            "events",
            "media"
          ],
          "fallback_queues": {},
          "is_degraded": false,
          "memory_queue_size": 0,
          "mode": "normal",
          "redis_healthy": true,
          "services": [
            {
              "consecutive_failures": 0,
              "last_check": 1735500000.0,
              "name": "yolo26",
              "status": "healthy"
            }
          ]
        },
        "properties": {
          "available_features": {
            "description": "Features available in current degradation mode",
            "items": {
              "type": "string"
            },
            "title": "Available Features",
            "type": "array"
          },
          "fallback_queues": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of items in disk-based fallback queues by name",
            "title": "Fallback Queues",
            "type": "object"
          },
          "is_degraded": {
            "description": "Whether system is in any degraded state",
            "title": "Is Degraded",
            "type": "boolean"
          },
          "memory_queue_size": {
            "description": "Number of jobs in in-memory fallback queue",
            "minimum": 0.0,
            "title": "Memory Queue Size",
            "type": "integer"
          },
          "mode": {
            "$ref": "#/components/schemas/DegradationModeEnum",
            "description": "Current degradation mode"
          },
          "redis_healthy": {
            "description": "Whether Redis is healthy",
            "title": "Redis Healthy",
            "type": "boolean"
          },
          "services": {
            "description": "Health status of registered services",
            "items": {
              "$ref": "#/components/schemas/ServiceHealthStatusResponse"
            },
            "title": "Services",
            "type": "array"
          }
        },
        "required": [
          "mode",
          "is_degraded",
          "redis_healthy",
          "memory_queue_size"
        ],
        "title": "DegradationStatusResponse",
        "type": "object"
      },
      "DeletedCamerasListResponse": {
        "description": "Schema for listing soft-deleted cameras (trash view).\n\nNEM-1955: Provides a trash view of soft-deleted cameras that can be restored.\nCameras are ordered by deleted_at descending (most recently deleted first).\nNEM-2075: Standardized pagination envelope with items + pagination structure.",
        "example": {
          "items": [
            {
              "created_at": "2025-12-23T10:00:00Z",
              "folder_path": "/export/foscam/front_door",
              "id": "front_door",
              "last_seen_at": "2025-12-23T12:00:00Z",
              "name": "Front Door Camera",
              "status": "offline"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of soft-deleted cameras",
            "items": {
              "$ref": "#/components/schemas/CameraResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "DeletedCamerasListResponse",
        "type": "object"
      },
      "DeletedEventsListResponse": {
        "description": "Schema for listing soft-deleted events (trash view).\n\nNEM-1955: Provides a trash view of soft-deleted events that can be restored.\nEvents are ordered by deleted_at descending (most recently deleted first).\nNEM-2075: Standardized pagination envelope with items + pagination structure.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "detection_count": 5,
              "detection_ids": [
                1,
                2,
                3,
                4,
                5
              ],
              "ended_at": "2025-12-23T12:02:30Z",
              "id": 1,
              "reasoning": "Analysis details",
              "reviewed": false,
              "risk_level": "medium",
              "risk_score": 75,
              "started_at": "2025-12-23T12:00:00Z",
              "summary": "Person detected near front entrance",
              "thumbnail_url": "/api/detections/1/image"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of soft-deleted events",
            "items": {
              "$ref": "#/components/schemas/EventResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "DeletedEventsListResponse",
        "type": "object"
      },
      "DepthEnrichment": {
        "description": "Depth estimation results (placeholder for future Depth Anything V2).",
        "example": {
          "confidence": 0.78,
          "estimated_distance_m": 4.2
        },
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimation confidence",
            "title": "Confidence"
          },
          "estimated_distance_m": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimated distance in meters",
            "title": "Estimated Distance M"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          }
        },
        "title": "DepthEnrichment",
        "type": "object"
      },
      "DetectionBulkCreateItem": {
        "description": "Schema for a single detection in a bulk create request.\n\nAttributes:\n    camera_id: Camera ID that captured this detection\n    object_type: Type of detected object (person, vehicle, etc.)\n    confidence: Detection confidence score (0.0-1.0)\n    detected_at: Detection timestamp\n    file_path: Path to the detection image\n    bbox_x: Bounding box X coordinate\n    bbox_y: Bounding box Y coordinate\n    bbox_width: Bounding box width\n    bbox_height: Bounding box height\n    enrichment_data: Optional enrichment pipeline results",
        "properties": {
          "bbox_height": {
            "description": "Bounding box height",
            "exclusiveMinimum": 0.0,
            "title": "Bbox Height",
            "type": "integer"
          },
          "bbox_width": {
            "description": "Bounding box width",
            "exclusiveMinimum": 0.0,
            "title": "Bbox Width",
            "type": "integer"
          },
          "bbox_x": {
            "description": "Bounding box X coordinate",
            "minimum": 0.0,
            "title": "Bbox X",
            "type": "integer"
          },
          "bbox_y": {
            "description": "Bounding box Y coordinate",
            "minimum": 0.0,
            "title": "Bbox Y",
            "type": "integer"
          },
          "camera_id": {
            "description": "Camera ID",
            "maxLength": 255,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_-]+$",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence": {
            "description": "Confidence score (0.0-1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Confidence",
            "type": "number"
          },
          "detected_at": {
            "description": "Detection timestamp",
            "format": "date-time",
            "title": "Detected At",
            "type": "string"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enrichment pipeline results",
            "title": "Enrichment Data"
          },
          "file_path": {
            "description": "Image file path",
            "maxLength": 1000,
            "minLength": 1,
            "title": "File Path",
            "type": "string"
          },
          "object_type": {
            "description": "Object type (person, vehicle, etc.)",
            "maxLength": 100,
            "minLength": 1,
            "title": "Object Type",
            "type": "string"
          }
        },
        "required": [
          "camera_id",
          "object_type",
          "confidence",
          "detected_at",
          "file_path",
          "bbox_x",
          "bbox_y",
          "bbox_width",
          "bbox_height"
        ],
        "title": "DetectionBulkCreateItem",
        "type": "object"
      },
      "DetectionBulkCreateRequest": {
        "description": "Request schema for bulk detection creation.\n\nAttributes:\n    detections: List of detections to create (max 100 per request)",
        "properties": {
          "detections": {
            "description": "Detections to create (max 100)",
            "items": {
              "$ref": "#/components/schemas/DetectionBulkCreateItem"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Detections",
            "type": "array"
          }
        },
        "required": [
          "detections"
        ],
        "title": "DetectionBulkCreateRequest",
        "type": "object"
      },
      "DetectionBulkCreateResponse": {
        "description": "Response schema for bulk detection creation.\n\nExtends BulkOperationResponse with created detection IDs.",
        "properties": {
          "failed": {
            "description": "Number of failed operations",
            "minimum": 0.0,
            "title": "Failed",
            "type": "integer"
          },
          "results": {
            "description": "Per-item results",
            "items": {
              "$ref": "#/components/schemas/BulkItemResult"
            },
            "title": "Results",
            "type": "array"
          },
          "skipped": {
            "default": 0,
            "description": "Number of skipped operations",
            "minimum": 0.0,
            "title": "Skipped",
            "type": "integer"
          },
          "succeeded": {
            "description": "Number of successful operations",
            "minimum": 0.0,
            "title": "Succeeded",
            "type": "integer"
          },
          "total": {
            "description": "Total number of items in the request",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "succeeded",
          "failed"
        ],
        "title": "DetectionBulkCreateResponse",
        "type": "object"
      },
      "DetectionBulkDeleteRequest": {
        "description": "Request schema for bulk detection deletion.\n\nNote: Detection deletion is always hard delete as detections\nare raw data and soft-delete is not supported.\n\nAttributes:\n    detection_ids: List of detection IDs to delete (max 100 per request)",
        "properties": {
          "detection_ids": {
            "description": "Detection IDs to delete (max 100)",
            "items": {
              "type": "integer"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Detection Ids",
            "type": "array"
          }
        },
        "required": [
          "detection_ids"
        ],
        "title": "DetectionBulkDeleteRequest",
        "type": "object"
      },
      "DetectionBulkUpdateItem": {
        "description": "Schema for a single detection update in a bulk update request.\n\nAttributes:\n    id: Detection ID to update\n    object_type: Updated object type\n    confidence: Updated confidence score\n    enrichment_data: Updated enrichment data",
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Confidence score",
            "title": "Confidence"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enrichment pipeline results",
            "title": "Enrichment Data"
          },
          "id": {
            "description": "Detection ID to update",
            "exclusiveMinimum": 0.0,
            "title": "Id",
            "type": "integer"
          },
          "object_type": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object type",
            "title": "Object Type"
          }
        },
        "required": [
          "id"
        ],
        "title": "DetectionBulkUpdateItem",
        "type": "object"
      },
      "DetectionBulkUpdateRequest": {
        "description": "Request schema for bulk detection updates.\n\nAttributes:\n    detections: List of detection updates (max 100 per request)",
        "properties": {
          "detections": {
            "description": "Detection updates (max 100)",
            "items": {
              "$ref": "#/components/schemas/DetectionBulkUpdateItem"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Detections",
            "type": "array"
          }
        },
        "required": [
          "detections"
        ],
        "title": "DetectionBulkUpdateRequest",
        "type": "object"
      },
      "DetectionLabelCount": {
        "description": "Schema for a label with count.",
        "properties": {
          "count": {
            "title": "Count",
            "type": "integer"
          },
          "label": {
            "title": "Label",
            "type": "string"
          }
        },
        "required": [
          "label",
          "count"
        ],
        "title": "DetectionLabelCount",
        "type": "object"
      },
      "DetectionLabelsResponse": {
        "description": "Schema for detection labels response.",
        "properties": {
          "labels": {
            "items": {
              "$ref": "#/components/schemas/DetectionLabelCount"
            },
            "title": "Labels",
            "type": "array"
          }
        },
        "required": [
          "labels"
        ],
        "title": "DetectionLabelsResponse",
        "type": "object"
      },
      "DetectionListResponse": {
        "description": "Schema for detection list response with standardized pagination envelope.\n\nUses the standard pagination envelope: {\"items\": [...], \"pagination\": {...}}\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).",
        "example": {
          "items": [
            {
              "bbox_height": 400,
              "bbox_width": 200,
              "bbox_x": 100,
              "bbox_y": 150,
              "camera_id": "front_door",
              "confidence": 0.95,
              "detected_at": "2025-12-23T12:00:00Z",
              "file_path": "/export/foscam/front_door/20251223_120000.jpg",
              "file_type": "image/jpeg",
              "id": 1,
              "object_type": "person",
              "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=",
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Warning message when using deprecated offset pagination",
            "title": "Deprecation Warning"
          },
          "items": {
            "description": "List of detections",
            "items": {
              "$ref": "#/components/schemas/DetectionResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "DetectionListResponse",
        "type": "object"
      },
      "DetectionResponse": {
        "description": "Schema for detection response.",
        "example": {
          "bbox_height": 400,
          "bbox_width": 200,
          "bbox_x": 100,
          "bbox_y": 150,
          "camera_id": "front_door",
          "confidence": 0.95,
          "detected_at": "2025-12-23T12:00:00Z",
          "enrichment_data": {
            "errors": [],
            "person": {
              "action": "walking",
              "carrying": [
                "backpack"
              ],
              "clothing_description": "dark jacket",
              "is_suspicious": false
            },
            "vehicle": {
              "has_damage": false,
              "is_commercial": false,
              "vehicle_color": "blue",
              "vehicle_type": "sedan"
            },
            "weather": "sunny"
          },
          "file_path": "/export/foscam/front_door/20251223_120000.jpg",
          "file_type": "image/jpeg",
          "id": 1,
          "media_type": "image",
          "object_type": "person",
          "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
        },
        "properties": {
          "association_created_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when detection was associated with the event (NEM-3629). Only populated when fetching detections for an event with order_detections_by=created_at.",
            "title": "Association Created At"
          },
          "bbox_height": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box height",
            "title": "Bbox Height"
          },
          "bbox_width": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box width",
            "title": "Bbox Width"
          },
          "bbox_x": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box X coordinate",
            "title": "Bbox X"
          },
          "bbox_y": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box Y coordinate",
            "title": "Bbox Y"
          },
          "camera_id": {
            "description": "Normalized camera ID (e.g., 'front_door')",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detection confidence score (0-1)",
            "title": "Confidence"
          },
          "detected_at": {
            "description": "Timestamp when detection was made",
            "format": "date-time",
            "title": "Detected At",
            "type": "string"
          },
          "duration": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video duration in seconds (video only)",
            "title": "Duration"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "AI enrichment data including vehicle classification, pet identification, person attributes, license plates, weather, and image quality scores",
            "title": "Enrichment Data"
          },
          "file_path": {
            "description": "Path to source image or video file",
            "title": "File Path",
            "type": "string"
          },
          "file_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "MIME type of source file",
            "title": "File Type"
          },
          "id": {
            "description": "Detection ID",
            "title": "Id",
            "type": "integer"
          },
          "media_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "default": "image",
            "description": "Media type: 'image' or 'video'",
            "title": "Media Type"
          },
          "object_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Type of detected object (person, car, etc.)",
            "title": "Object Type"
          },
          "thumbnail_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to thumbnail image with bbox overlay",
            "title": "Thumbnail Path"
          },
          "track_confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Confidence score for the track assignment (0-1)",
            "title": "Track Confidence"
          },
          "track_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Unique track ID for tracking objects across frames",
            "title": "Track Id"
          },
          "video_codec": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video codec (e.g., h264, hevc)",
            "title": "Video Codec"
          },
          "video_height": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video resolution height",
            "title": "Video Height"
          },
          "video_width": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video resolution width",
            "title": "Video Width"
          }
        },
        "required": [
          "id",
          "camera_id",
          "file_path",
          "detected_at"
        ],
        "title": "DetectionResponse",
        "type": "object"
      },
      "DetectionSearchResponse": {
        "description": "Schema for detection search response.",
        "properties": {
          "limit": {
            "title": "Limit",
            "type": "integer"
          },
          "offset": {
            "title": "Offset",
            "type": "integer"
          },
          "results": {
            "description": "Search results",
            "items": {
              "$ref": "#/components/schemas/DetectionSearchResult"
            },
            "title": "Results",
            "type": "array"
          },
          "total_count": {
            "description": "Total matching detections",
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "results",
          "total_count",
          "limit",
          "offset"
        ],
        "title": "DetectionSearchResponse",
        "type": "object"
      },
      "DetectionSearchResult": {
        "description": "Schema for a single detection search result.",
        "properties": {
          "bbox_height": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox Height"
          },
          "bbox_width": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox Width"
          },
          "bbox_x": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox X"
          },
          "bbox_y": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bbox Y"
          },
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detection confidence score",
            "title": "Confidence"
          },
          "detected_at": {
            "description": "Detection timestamp",
            "format": "date-time",
            "title": "Detected At",
            "type": "string"
          },
          "enrichment_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enrichment Data"
          },
          "file_path": {
            "description": "Path to source file",
            "title": "File Path",
            "type": "string"
          },
          "id": {
            "description": "Detection ID",
            "title": "Id",
            "type": "integer"
          },
          "labels": {
            "description": "Searchable labels",
            "items": {
              "type": "string"
            },
            "title": "Labels",
            "type": "array"
          },
          "object_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detected object type",
            "title": "Object Type"
          },
          "relevance_score": {
            "default": 0.0,
            "description": "Search relevance score",
            "title": "Relevance Score",
            "type": "number"
          },
          "thumbnail_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to thumbnail",
            "title": "Thumbnail Path"
          },
          "track_confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Confidence score for the track assignment (0-1)",
            "title": "Track Confidence"
          },
          "track_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Unique track ID for tracking objects across frames",
            "title": "Track Id"
          }
        },
        "required": [
          "id",
          "camera_id",
          "detected_at",
          "file_path"
        ],
        "title": "DetectionSearchResult",
        "type": "object"
      },
      "DetectionSettings": {
        "description": "Detection-related settings for object detection thresholds.\n\nControls the confidence thresholds used by YOLO26v2 for object detection\nand fast-path processing for high-priority alerts.",
        "example": {
          "confidence_threshold": 0.5,
          "fast_path_threshold": 0.9
        },
        "properties": {
          "confidence_threshold": {
            "description": "Minimum confidence threshold for object detections (0.0-1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Confidence Threshold",
            "type": "number"
          },
          "fast_path_threshold": {
            "description": "Confidence threshold for fast-path high-priority analysis (0.0-1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Fast Path Threshold",
            "type": "number"
          }
        },
        "required": [
          "confidence_threshold",
          "fast_path_threshold"
        ],
        "title": "DetectionSettings",
        "type": "object"
      },
      "DetectionSettingsUpdate": {
        "description": "Detection settings update schema (all fields optional).\n\nUsed for PATCH /api/v1/settings to partially update detection settings.",
        "example": {
          "confidence_threshold": 0.6
        },
        "properties": {
          "confidence_threshold": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum confidence threshold for object detections (0.0-1.0)",
            "title": "Confidence Threshold"
          },
          "fast_path_threshold": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Confidence threshold for fast-path high-priority analysis (0.0-1.0)",
            "title": "Fast Path Threshold"
          }
        },
        "title": "DetectionSettingsUpdate",
        "type": "object"
      },
      "DetectionStatsResponse": {
        "description": "Schema for detection statistics response.\n\nReturns aggregate statistics about detections including counts by object class\nand detection trends over time. Used by the AI Performance page and Grafana\nAnalytics dashboard.",
        "example": {
          "average_confidence": 0.87,
          "detections_by_class": {
            "bicycle": 1,
            "car": 20,
            "person": 23,
            "truck": 6
          },
          "object_class_distribution": [
            {
              "count": 23,
              "object_class": "person"
            },
            {
              "count": 20,
              "object_class": "car"
            },
            {
              "count": 6,
              "object_class": "truck"
            },
            {
              "count": 1,
              "object_class": "bicycle"
            }
          ],
          "total_detections": 107,
          "trends": [
            {
              "detection_count": 10,
              "timestamp": "2026-01-16T00:00:00Z"
            },
            {
              "detection_count": 15,
              "timestamp": "2026-01-17T00:00:00Z"
            },
            {
              "detection_count": 12,
              "timestamp": "2026-01-18T00:00:00Z"
            },
            {
              "detection_count": 8,
              "timestamp": "2026-01-19T00:00:00Z"
            },
            {
              "detection_count": 20,
              "timestamp": "2026-01-20T00:00:00Z"
            },
            {
              "detection_count": 25,
              "timestamp": "2026-01-21T00:00:00Z"
            },
            {
              "detection_count": 50,
              "timestamp": "2026-01-22T00:00:00Z"
            }
          ]
        },
        "properties": {
          "average_confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Average confidence score across all detections",
            "title": "Average Confidence"
          },
          "detections_by_class": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Detection counts grouped by object class (e.g., person, car, truck)",
            "title": "Detections By Class",
            "type": "object"
          },
          "object_class_distribution": {
            "description": "Detections by class as array (for Grafana compatibility)",
            "items": {
              "$ref": "#/components/schemas/ObjectClassDistributionItem"
            },
            "title": "Object Class Distribution",
            "type": "array"
          },
          "total_detections": {
            "description": "Total number of detections",
            "title": "Total Detections",
            "type": "integer"
          },
          "trends": {
            "description": "Detection counts by day for the last 7 days (for Grafana time series)",
            "items": {
              "$ref": "#/components/schemas/DetectionTrendItem"
            },
            "title": "Trends",
            "type": "array"
          }
        },
        "required": [
          "total_detections",
          "detections_by_class"
        ],
        "title": "DetectionStatsResponse",
        "type": "object"
      },
      "DetectionSummary": {
        "description": "Summary of a detection linked to an entity.\n\nRepresents a single detection occurrence for an entity, used in\nthe entity detections list endpoint.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "confidence": 0.95,
          "detection_id": 123,
          "object_type": "person",
          "thumbnail_url": "/api/detections/123/image",
          "timestamp": "2025-12-23T10:00:00Z"
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID where detection occurred",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable camera name",
            "title": "Camera Name"
          },
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detection confidence score",
            "title": "Confidence"
          },
          "detection_id": {
            "description": "Detection database ID",
            "title": "Detection Id",
            "type": "integer"
          },
          "object_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detected object type",
            "title": "Object Type"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to detection thumbnail",
            "title": "Thumbnail Url"
          },
          "timestamp": {
            "description": "When the detection occurred",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "detection_id",
          "camera_id",
          "timestamp"
        ],
        "title": "DetectionSummary",
        "type": "object"
      },
      "DetectionTrendDataPoint": {
        "description": "Schema for a single detection trend data point.",
        "example": {
          "count": 25,
          "date": "2025-01-07"
        },
        "properties": {
          "count": {
            "description": "Number of detections on this date",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "date": {
            "description": "Date of the data point",
            "format": "date",
            "title": "Date",
            "type": "string"
          }
        },
        "required": [
          "date",
          "count"
        ],
        "title": "DetectionTrendDataPoint",
        "type": "object"
      },
      "DetectionTrendItem": {
        "description": "Schema for a single detection trend data point (for Grafana time series).\n\nUsed by the Grafana Analytics dashboard to display detection trends over time.\nThe timestamp field is Unix epoch milliseconds for Grafana JSON datasource compatibility.",
        "example": {
          "detection_count": 50,
          "timestamp": 1737504000000
        },
        "properties": {
          "detection_count": {
            "description": "Number of detections on this date",
            "title": "Detection Count",
            "type": "integer"
          },
          "timestamp": {
            "description": "Unix epoch milliseconds for the trend data point (start of day)",
            "title": "Timestamp",
            "type": "integer"
          }
        },
        "required": [
          "timestamp",
          "detection_count"
        ],
        "title": "DetectionTrendItem",
        "type": "object"
      },
      "DetectionTrendsResponse": {
        "description": "Schema for detection trends aggregated by day.",
        "example": {
          "data_points": [
            {
              "count": 20,
              "date": "2025-01-01"
            },
            {
              "count": 25,
              "date": "2025-01-02"
            },
            {
              "count": 18,
              "date": "2025-01-03"
            }
          ],
          "end_date": "2025-01-03",
          "start_date": "2025-01-01",
          "total_detections": 63
        },
        "properties": {
          "data_points": {
            "description": "Detection counts aggregated by day",
            "items": {
              "$ref": "#/components/schemas/DetectionTrendDataPoint"
            },
            "title": "Data Points",
            "type": "array"
          },
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          },
          "total_detections": {
            "description": "Total detections in date range",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          }
        },
        "required": [
          "data_points",
          "total_detections",
          "start_date",
          "end_date"
        ],
        "title": "DetectionTrendsResponse",
        "type": "object"
      },
      "DeviationInterpretation": {
        "description": "Interpretation of current deviation from baseline.",
        "enum": [
          "far_below_normal",
          "below_normal",
          "normal",
          "slightly_above_normal",
          "above_normal",
          "far_above_normal"
        ],
        "title": "DeviationInterpretation",
        "type": "string"
      },
      "DwellHistoryResponse": {
        "description": "Historical dwell time records for a zone.",
        "example": {
          "end_time": "2026-01-26T13:00:00Z",
          "records": [
            {
              "camera_id": "front_door",
              "entry_time": "2026-01-26T12:00:00Z",
              "exit_time": "2026-01-26T12:05:30Z",
              "id": 1,
              "is_active": false,
              "object_class": "person",
              "total_seconds": 330.0,
              "track_id": 42,
              "triggered_alert": true,
              "zone_id": 1
            }
          ],
          "start_time": "2026-01-26T11:00:00Z",
          "total": 1,
          "zone_id": 1
        },
        "properties": {
          "end_time": {
            "description": "End of the query time window",
            "format": "date-time",
            "title": "End Time",
            "type": "string"
          },
          "records": {
            "description": "Dwell time records in the time window",
            "items": {
              "$ref": "#/components/schemas/DwellTimeRecordResponse"
            },
            "title": "Records",
            "type": "array"
          },
          "start_time": {
            "description": "Start of the query time window",
            "format": "date-time",
            "title": "Start Time",
            "type": "string"
          },
          "total": {
            "description": "Total number of records",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          },
          "zone_id": {
            "description": "ID of the polygon zone",
            "title": "Zone Id",
            "type": "integer"
          }
        },
        "required": [
          "zone_id",
          "records",
          "total",
          "start_time",
          "end_time"
        ],
        "title": "DwellHistoryResponse",
        "type": "object"
      },
      "DwellStatisticsResponse": {
        "description": "Statistics for dwell time in a zone.",
        "example": {
          "alerts_triggered": 3,
          "avg_dwell_seconds": 120.5,
          "end_time": "2026-01-26T23:59:59Z",
          "max_dwell_seconds": 600.0,
          "min_dwell_seconds": 5.0,
          "start_time": "2026-01-26T00:00:00Z",
          "total_records": 50,
          "zone_id": 1
        },
        "properties": {
          "alerts_triggered": {
            "description": "Number of loitering alerts triggered",
            "minimum": 0.0,
            "title": "Alerts Triggered",
            "type": "integer"
          },
          "avg_dwell_seconds": {
            "description": "Average dwell time in seconds",
            "minimum": 0.0,
            "title": "Avg Dwell Seconds",
            "type": "number"
          },
          "end_time": {
            "description": "End of the statistics time window",
            "format": "date-time",
            "title": "End Time",
            "type": "string"
          },
          "max_dwell_seconds": {
            "description": "Maximum dwell time in seconds",
            "minimum": 0.0,
            "title": "Max Dwell Seconds",
            "type": "number"
          },
          "min_dwell_seconds": {
            "description": "Minimum dwell time in seconds",
            "minimum": 0.0,
            "title": "Min Dwell Seconds",
            "type": "number"
          },
          "start_time": {
            "description": "Start of the statistics time window",
            "format": "date-time",
            "title": "Start Time",
            "type": "string"
          },
          "total_records": {
            "description": "Total number of completed dwell records",
            "minimum": 0.0,
            "title": "Total Records",
            "type": "integer"
          },
          "zone_id": {
            "description": "ID of the polygon zone",
            "title": "Zone Id",
            "type": "integer"
          }
        },
        "required": [
          "zone_id",
          "total_records",
          "avg_dwell_seconds",
          "max_dwell_seconds",
          "min_dwell_seconds",
          "alerts_triggered",
          "start_time",
          "end_time"
        ],
        "title": "DwellStatisticsResponse",
        "type": "object"
      },
      "DwellTimeRecordResponse": {
        "description": "Response schema for a dwell time record.\n\nIncludes computed fields and database identifiers.",
        "example": {
          "camera_id": "front_door",
          "entry_time": "2026-01-26T12:00:00Z",
          "exit_time": "2026-01-26T12:05:30Z",
          "id": 1,
          "is_active": false,
          "object_class": "person",
          "total_seconds": 330.0,
          "track_id": 42,
          "triggered_alert": true,
          "zone_id": 1
        },
        "properties": {
          "camera_id": {
            "description": "ID of the camera where detection occurred",
            "title": "Camera Id",
            "type": "string"
          },
          "entry_time": {
            "description": "Timestamp when object entered the zone",
            "format": "date-time",
            "title": "Entry Time",
            "type": "string"
          },
          "exit_time": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when object exited the zone (null if still present)",
            "title": "Exit Time"
          },
          "id": {
            "description": "Unique dwell time record identifier",
            "title": "Id",
            "type": "integer"
          },
          "is_active": {
            "default": false,
            "description": "Whether the object is still in the zone (no exit time)",
            "title": "Is Active",
            "type": "boolean"
          },
          "object_class": {
            "description": "Classification of the object (e.g., person)",
            "title": "Object Class",
            "type": "string"
          },
          "total_seconds": {
            "description": "Total dwell time in seconds",
            "minimum": 0.0,
            "title": "Total Seconds",
            "type": "number"
          },
          "track_id": {
            "description": "Tracking ID of the detected object",
            "title": "Track Id",
            "type": "integer"
          },
          "triggered_alert": {
            "description": "Whether this dwell time triggered a loitering alert",
            "title": "Triggered Alert",
            "type": "boolean"
          },
          "zone_id": {
            "description": "ID of the polygon zone",
            "title": "Zone Id",
            "type": "integer"
          }
        },
        "required": [
          "zone_id",
          "track_id",
          "camera_id",
          "object_class",
          "id",
          "entry_time",
          "total_seconds",
          "triggered_alert"
        ],
        "title": "DwellTimeRecordResponse",
        "type": "object"
      },
      "EnrichmentModelInfo": {
        "description": "Information about the AI model that produced an enrichment result (NEM-3535).\n\nExposes which model processed each enrichment, enabling model performance\ntracking and debugging.",
        "example": {
          "inference_time_ms": 25.3,
          "model_name": "yolov11-face",
          "model_version": "1.0.0"
        },
        "properties": {
          "inference_time_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time taken for model inference in milliseconds",
            "title": "Inference Time Ms"
          },
          "model_name": {
            "description": "Name of the AI model that produced this enrichment",
            "title": "Model Name",
            "type": "string"
          },
          "model_version": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Version of the model (if available)",
            "title": "Model Version"
          }
        },
        "required": [
          "model_name"
        ],
        "title": "EnrichmentModelInfo",
        "type": "object"
      },
      "EnrichmentResponse": {
        "description": "Structured enrichment data for a single detection.\n\nContains results from all vision models run during the enrichment pipeline.",
        "example": {
          "clothing": {
            "lower": "blue jeans",
            "upper": "red t-shirt"
          },
          "detection_id": 12345,
          "enriched_at": "2026-01-03T10:30:00Z",
          "errors": [],
          "face": {
            "confidence": 0.88,
            "count": 1,
            "detected": true
          },
          "image_quality": {
            "is_blurry": false,
            "score": 0.85
          },
          "license_plate": {
            "confidence": 0.92,
            "detected": true,
            "text": "ABC-1234"
          },
          "processing_time_ms": 125.5,
          "vehicle": {
            "color": "silver",
            "confidence": 0.91,
            "type": "sedan"
          },
          "violence": {
            "detected": false,
            "score": 0.12
          },
          "weather": {
            "condition": "clear",
            "confidence": 0.95
          }
        },
        "properties": {
          "clothing": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ClothingEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Clothing analysis results",
            "title": "Clothing"
          },
          "depth": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DepthEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Depth estimation results",
            "title": "Depth"
          },
          "detection_id": {
            "description": "Detection ID",
            "title": "Detection Id",
            "type": "integer"
          },
          "enriched_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when enrichment was performed",
            "title": "Enriched At"
          },
          "errors": {
            "description": "Errors encountered during enrichment",
            "items": {
              "type": "string"
            },
            "title": "Errors",
            "type": "array"
          },
          "face": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FaceEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "description": "Face detection results",
            "title": "Face"
          },
          "image_quality": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ImageQualityEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Image quality assessment",
            "title": "Image Quality"
          },
          "license_plate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LicensePlateEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "description": "License plate detection results",
            "title": "License Plate"
          },
          "pet": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PetEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Pet classification results",
            "title": "Pet"
          },
          "pose": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PoseEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Pose estimation results",
            "title": "Pose"
          },
          "processing_time_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enrichment processing time in milliseconds",
            "title": "Processing Time Ms"
          },
          "vehicle": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VehicleEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Vehicle classification results",
            "title": "Vehicle"
          },
          "violence": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ViolenceEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "description": "Violence detection results",
            "title": "Violence"
          },
          "weather": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WeatherEnrichment"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Weather classification results",
            "title": "Weather"
          }
        },
        "required": [
          "detection_id"
        ],
        "title": "EnrichmentResponse",
        "type": "object"
      },
      "EnrichmentStatusEnum": {
        "description": "Status of enrichment pipeline execution for an event.\n\nValues:\n    full: All enrichment models succeeded\n    partial: Some models succeeded, some failed\n    failed: All models failed (no enrichment data)\n    skipped: Enrichment was not attempted",
        "enum": [
          "full",
          "partial",
          "failed",
          "skipped"
        ],
        "title": "EnrichmentStatusEnum",
        "type": "string"
      },
      "EnrichmentStatusResponse": {
        "description": "Schema for enrichment status in event responses (NEM-1672).\n\nProvides visibility into which enrichment models succeeded/failed\nfor a given event, instead of silently degrading.",
        "example": {
          "errors": {
            "clothing": "Model not loaded"
          },
          "failed_models": [
            "clothing"
          ],
          "status": "partial",
          "success_rate": 0.75,
          "successful_models": [
            "violence",
            "weather",
            "face"
          ]
        },
        "properties": {
          "errors": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Model name to error message mapping",
            "title": "Errors",
            "type": "object"
          },
          "failed_models": {
            "description": "List of enrichment models that failed",
            "items": {
              "type": "string"
            },
            "title": "Failed Models",
            "type": "array"
          },
          "status": {
            "$ref": "#/components/schemas/EnrichmentStatusEnum",
            "description": "Overall enrichment status (full, partial, failed, skipped)"
          },
          "success_rate": {
            "description": "Success rate (0.0 to 1.0)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Success Rate",
            "type": "number"
          },
          "successful_models": {
            "description": "List of enrichment models that succeeded",
            "items": {
              "type": "string"
            },
            "title": "Successful Models",
            "type": "array"
          }
        },
        "required": [
          "status",
          "success_rate"
        ],
        "title": "EnrichmentStatusResponse",
        "type": "object"
      },
      "EntityAppearance": {
        "description": "Schema for a single entity appearance at a specific time and camera.\n\nRepresents one sighting of an entity, including the detection it came from\nand additional attributes extracted from the image.",
        "example": {
          "attributes": {
            "carrying": "backpack",
            "clothing": "blue jacket"
          },
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "detection_id": "det_abc123",
          "similarity_score": 0.92,
          "thumbnail_url": "/api/detections/123/image",
          "timestamp": "2025-12-23T14:30:00Z"
        },
        "properties": {
          "attributes": {
            "additionalProperties": true,
            "description": "Additional attributes extracted from the detection (clothing, carrying, etc.)",
            "title": "Attributes",
            "type": "object"
          },
          "camera_id": {
            "description": "Camera ID where entity was seen",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable camera name",
            "title": "Camera Name"
          },
          "detection_id": {
            "description": "Detection ID from original detection",
            "title": "Detection Id",
            "type": "string"
          },
          "similarity_score": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Similarity score to the entity's reference embedding",
            "title": "Similarity Score"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to thumbnail image of this appearance",
            "title": "Thumbnail Url"
          },
          "timestamp": {
            "description": "When the entity was detected",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "detection_id",
          "camera_id",
          "timestamp"
        ],
        "title": "EntityAppearance",
        "type": "object"
      },
      "EntityDetail": {
        "description": "Schema for detailed entity information including appearance history.\n\nExtends EntitySummary with the full list of appearances.",
        "example": {
          "appearance_count": 3,
          "appearances": [
            {
              "attributes": {
                "clothing": "blue jacket"
              },
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_id": "det_001",
              "similarity_score": 1.0,
              "thumbnail_url": "/api/detections/1/image",
              "timestamp": "2025-12-23T10:00:00Z"
            },
            {
              "attributes": {
                "carrying": "bag",
                "clothing": "blue jacket"
              },
              "camera_id": "backyard",
              "camera_name": "Backyard",
              "detection_id": "det_002",
              "similarity_score": 0.94,
              "thumbnail_url": "/api/detections/2/image",
              "timestamp": "2025-12-23T12:15:00Z"
            }
          ],
          "cameras_seen": [
            "front_door",
            "backyard"
          ],
          "entity_type": "person",
          "first_seen": "2025-12-23T10:00:00Z",
          "id": "entity_abc123",
          "last_seen": "2025-12-23T14:30:00Z",
          "thumbnail_url": "/api/detections/123/image"
        },
        "properties": {
          "appearance_count": {
            "description": "Total number of appearances",
            "minimum": 0.0,
            "title": "Appearance Count",
            "type": "integer"
          },
          "appearances": {
            "description": "List of all appearances for this entity",
            "items": {
              "$ref": "#/components/schemas/EntityAppearance"
            },
            "title": "Appearances",
            "type": "array"
          },
          "cameras_seen": {
            "description": "List of camera IDs where entity was detected",
            "items": {
              "type": "string"
            },
            "title": "Cameras Seen",
            "type": "array"
          },
          "entity_type": {
            "description": "Type of entity: 'person' or 'vehicle'",
            "title": "Entity Type",
            "type": "string"
          },
          "first_seen": {
            "description": "Timestamp of first appearance",
            "format": "date-time",
            "title": "First Seen",
            "type": "string"
          },
          "id": {
            "description": "Unique entity identifier",
            "title": "Id",
            "type": "string"
          },
          "last_seen": {
            "description": "Timestamp of most recent appearance",
            "format": "date-time",
            "title": "Last Seen",
            "type": "string"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to the most recent thumbnail image",
            "title": "Thumbnail Url"
          },
          "trust_status": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Trust classification: 'trusted', 'untrusted', or 'unclassified'",
            "title": "Trust Status"
          },
          "trust_updated_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the trust status was last updated",
            "title": "Trust Updated At"
          }
        },
        "required": [
          "id",
          "entity_type",
          "first_seen",
          "last_seen",
          "appearance_count"
        ],
        "title": "EntityDetail",
        "type": "object"
      },
      "EntityDetectionsResponse": {
        "description": "Response for entity detections list endpoint.\n\nReturns all detections linked to a specific entity with pagination.",
        "example": {
          "detections": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "confidence": 0.95,
              "detection_id": 123,
              "object_type": "person",
              "thumbnail_url": "/api/detections/123/image",
              "timestamp": "2025-12-23T10:00:00Z"
            }
          ],
          "entity_id": "550e8400-e29b-41d4-a716-446655440000",
          "entity_type": "person",
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 5
          }
        },
        "properties": {
          "detections": {
            "description": "List of detections for this entity",
            "items": {
              "$ref": "#/components/schemas/DetectionSummary"
            },
            "title": "Detections",
            "type": "array"
          },
          "entity_id": {
            "description": "UUID of the entity",
            "title": "Entity Id",
            "type": "string"
          },
          "entity_type": {
            "description": "Type of entity",
            "title": "Entity Type",
            "type": "string"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "entity_id",
          "entity_type",
          "pagination"
        ],
        "title": "EntityDetectionsResponse",
        "type": "object"
      },
      "EntityHistoryResponse": {
        "description": "Schema for entity appearance history response.",
        "example": {
          "appearances": [
            {
              "attributes": {},
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_id": "det_001",
              "similarity_score": 1.0,
              "thumbnail_url": "/api/detections/1/image",
              "timestamp": "2025-12-23T10:00:00Z"
            }
          ],
          "count": 1,
          "entity_id": "entity_abc123",
          "entity_type": "person"
        },
        "properties": {
          "appearances": {
            "description": "List of appearances in chronological order",
            "items": {
              "$ref": "#/components/schemas/EntityAppearance"
            },
            "title": "Appearances",
            "type": "array"
          },
          "count": {
            "description": "Total number of appearances",
            "title": "Count",
            "type": "integer"
          },
          "entity_id": {
            "description": "Entity identifier",
            "title": "Entity Id",
            "type": "string"
          },
          "entity_type": {
            "description": "Type of entity",
            "title": "Entity Type",
            "type": "string"
          }
        },
        "required": [
          "entity_id",
          "entity_type",
          "appearances",
          "count"
        ],
        "title": "EntityHistoryResponse",
        "type": "object"
      },
      "EntityListResponse": {
        "description": "Schema for paginated entity list response (NEM-2075 pagination envelope).\n\nUses standardized pagination envelope with 'items' and 'pagination' fields.",
        "example": {
          "items": [
            {
              "appearance_count": 5,
              "cameras_seen": [
                "front_door",
                "backyard"
              ],
              "entity_type": "person",
              "first_seen": "2025-12-23T10:00:00Z",
              "id": "entity_abc123",
              "last_seen": "2025-12-23T14:30:00Z",
              "thumbnail_url": "/api/detections/123/image"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of tracked entities",
            "items": {
              "$ref": "#/components/schemas/EntitySummary"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "EntityListResponse",
        "type": "object"
      },
      "EntityMatchItem": {
        "description": "Schema for a single entity match result.\n\nRepresents a matching entity found through re-identification,\nincluding similarity score and time gap.",
        "example": {
          "attributes": {
            "clothing": "blue jacket"
          },
          "camera_id": "backyard",
          "camera_name": "Backyard",
          "entity_id": "det_abc123",
          "entity_type": "person",
          "similarity_score": 0.92,
          "thumbnail_url": "/api/detections/123/image",
          "time_gap_seconds": 3600.0,
          "timestamp": "2025-12-23T10:00:00Z"
        },
        "properties": {
          "attributes": {
            "additionalProperties": true,
            "description": "Additional attributes extracted from the detection",
            "title": "Attributes",
            "type": "object"
          },
          "camera_id": {
            "description": "Camera ID where entity was seen",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable camera name",
            "title": "Camera Name"
          },
          "entity_id": {
            "description": "Detection ID of the matched entity",
            "title": "Entity Id",
            "type": "string"
          },
          "entity_type": {
            "description": "Type of entity: 'person' or 'vehicle'",
            "title": "Entity Type",
            "type": "string"
          },
          "similarity_score": {
            "description": "Cosine similarity score (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Similarity Score",
            "type": "number"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to thumbnail image",
            "title": "Thumbnail Url"
          },
          "time_gap_seconds": {
            "description": "Time gap in seconds between query and match",
            "title": "Time Gap Seconds",
            "type": "number"
          },
          "timestamp": {
            "description": "When the entity was detected",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "entity_id",
          "entity_type",
          "camera_id",
          "timestamp",
          "similarity_score",
          "time_gap_seconds"
        ],
        "title": "EntityMatchItem",
        "type": "object"
      },
      "EntityMatchResponse": {
        "description": "Schema for entity match query response.\n\nReturns entities matching a specific detection's embedding,\nused for showing re-ID matches in the EventDetailModal.",
        "example": {
          "entity_type": "person",
          "matches": [
            {
              "attributes": {
                "clothing": "blue jacket"
              },
              "camera_id": "backyard",
              "camera_name": "Backyard",
              "entity_id": "det_002",
              "entity_type": "person",
              "similarity_score": 0.92,
              "thumbnail_url": "/api/detections/2/image",
              "time_gap_seconds": 3600.0,
              "timestamp": "2025-12-23T09:00:00Z"
            }
          ],
          "query_detection_id": "det_001",
          "threshold": 0.85,
          "total_matches": 1
        },
        "properties": {
          "entity_type": {
            "description": "Type of entity searched",
            "title": "Entity Type",
            "type": "string"
          },
          "matches": {
            "description": "List of matching entities sorted by similarity",
            "items": {
              "$ref": "#/components/schemas/EntityMatchItem"
            },
            "title": "Matches",
            "type": "array"
          },
          "query_detection_id": {
            "description": "Detection ID used for the query",
            "title": "Query Detection Id",
            "type": "string"
          },
          "threshold": {
            "description": "Similarity threshold used for matching",
            "title": "Threshold",
            "type": "number"
          },
          "total_matches": {
            "description": "Total number of matches found",
            "title": "Total Matches",
            "type": "integer"
          }
        },
        "required": [
          "query_detection_id",
          "entity_type",
          "total_matches",
          "threshold"
        ],
        "title": "EntityMatchResponse",
        "type": "object"
      },
      "EntityStatsResponse": {
        "description": "Response for entity statistics endpoint.\n\nReturns aggregated statistics about tracked entities.",
        "example": {
          "by_camera": {
            "backyard": 42,
            "driveway": 68,
            "front_door": 85,
            "garage": 12
          },
          "by_type": {
            "animal": 12,
            "other": 0,
            "package": 0,
            "person": 150,
            "vehicle": 45
          },
          "repeat_visitors": 89,
          "time_range": {
            "since": "2025-12-23T00:00:00Z",
            "until": "2025-12-23T23:59:59Z"
          },
          "total_appearances": 1523,
          "total_entities": 207
        },
        "properties": {
          "by_camera": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Entity counts grouped by camera",
            "title": "By Camera",
            "type": "object"
          },
          "by_type": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Entity counts grouped by entity type",
            "title": "By Type",
            "type": "object"
          },
          "repeat_visitors": {
            "description": "Count of entities seen more than once",
            "minimum": 0.0,
            "title": "Repeat Visitors",
            "type": "integer"
          },
          "time_range": {
            "anyOf": [
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "format": "date-time",
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time range for the statistics query",
            "title": "Time Range"
          },
          "total_appearances": {
            "description": "Sum of all detection counts across entities",
            "minimum": 0.0,
            "title": "Total Appearances",
            "type": "integer"
          },
          "total_entities": {
            "description": "Count of unique entities",
            "minimum": 0.0,
            "title": "Total Entities",
            "type": "integer"
          }
        },
        "required": [
          "total_entities",
          "total_appearances",
          "repeat_visitors"
        ],
        "title": "EntityStatsResponse",
        "type": "object"
      },
      "EntitySummary": {
        "description": "Schema for entity summary in list responses.\n\nProvides an overview of a tracked entity without the full appearance history.",
        "example": {
          "appearance_count": 5,
          "cameras_seen": [
            "front_door",
            "backyard",
            "driveway"
          ],
          "entity_type": "person",
          "first_seen": "2025-12-23T10:00:00Z",
          "id": "entity_abc123",
          "last_seen": "2025-12-23T14:30:00Z",
          "thumbnail_url": "/api/detections/123/image",
          "trust_status": "trusted",
          "trust_updated_at": "2025-12-23T14:30:00Z"
        },
        "properties": {
          "appearance_count": {
            "description": "Total number of appearances",
            "minimum": 0.0,
            "title": "Appearance Count",
            "type": "integer"
          },
          "cameras_seen": {
            "description": "List of camera IDs where entity was detected",
            "items": {
              "type": "string"
            },
            "title": "Cameras Seen",
            "type": "array"
          },
          "entity_type": {
            "description": "Type of entity: 'person' or 'vehicle'",
            "title": "Entity Type",
            "type": "string"
          },
          "first_seen": {
            "description": "Timestamp of first appearance",
            "format": "date-time",
            "title": "First Seen",
            "type": "string"
          },
          "id": {
            "description": "Unique entity identifier",
            "title": "Id",
            "type": "string"
          },
          "last_seen": {
            "description": "Timestamp of most recent appearance",
            "format": "date-time",
            "title": "Last Seen",
            "type": "string"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to the most recent thumbnail image",
            "title": "Thumbnail Url"
          },
          "trust_status": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Trust classification: 'trusted', 'untrusted', or 'unclassified'",
            "title": "Trust Status"
          },
          "trust_updated_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the trust status was last updated",
            "title": "Trust Updated At"
          }
        },
        "required": [
          "id",
          "entity_type",
          "first_seen",
          "last_seen",
          "appearance_count"
        ],
        "title": "EntitySummary",
        "type": "object"
      },
      "EntityTrustResponse": {
        "description": "Schema for entity trust status response.\n\nResponse from PATCH /api/entities/{entity_id}/trust endpoint and list endpoints.",
        "example": {
          "appearance_count": 5,
          "entity_type": "person",
          "first_seen": "2025-12-23T10:00:00Z",
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "last_seen": "2025-12-23T14:30:00Z",
          "thumbnail_url": "/api/detections/123/image",
          "trust_notes": "Regular mail carrier, verified by homeowner",
          "trust_status": "trusted",
          "trust_updated_at": "2025-12-23T14:30:00Z"
        },
        "properties": {
          "appearance_count": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total number of appearances",
            "title": "Appearance Count"
          },
          "entity_type": {
            "description": "Type of entity: person, vehicle, etc.",
            "title": "Entity Type",
            "type": "string"
          },
          "first_seen": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of first appearance",
            "title": "First Seen"
          },
          "id": {
            "description": "Unique entity identifier (UUID)",
            "title": "Id",
            "type": "string"
          },
          "last_seen": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of most recent appearance",
            "title": "Last Seen"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to thumbnail image",
            "title": "Thumbnail Url"
          },
          "trust_notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Notes about the trust classification",
            "title": "Trust Notes"
          },
          "trust_status": {
            "$ref": "#/components/schemas/TrustStatus",
            "description": "Current trust classification status"
          },
          "trust_updated_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the trust status was last updated",
            "title": "Trust Updated At"
          }
        },
        "required": [
          "id",
          "entity_type",
          "trust_status"
        ],
        "title": "EntityTrustResponse",
        "type": "object"
      },
      "EntityTrustUpdate": {
        "description": "Schema for updating an entity's trust status.\n\nRequest body for PATCH /api/entities/{entity_id}/trust endpoint.",
        "example": {
          "notes": "Regular mail carrier, verified by homeowner",
          "trust_status": "trusted"
        },
        "properties": {
          "notes": {
            "anyOf": [
              {
                "maxLength": 500,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional notes explaining the trust classification decision",
            "title": "Notes"
          },
          "trust_status": {
            "$ref": "#/components/schemas/TrustStatus",
            "description": "The trust classification to assign to the entity"
          }
        },
        "required": [
          "trust_status"
        ],
        "title": "EntityTrustUpdate",
        "type": "object"
      },
      "EntityTypeFilter": {
        "description": "Entity types for API query filtering.\n\nA subset of EntityTypeEnum used for filtering in API endpoints.\nCurrently only person and vehicle are supported for re-identification.",
        "enum": [
          "person",
          "vehicle"
        ],
        "title": "EntityTypeFilter",
        "type": "string"
      },
      "EventAuditResponse": {
        "description": "Full audit response for a single event.",
        "example": {
          "audited_at": "2026-01-03T10:30:00Z",
          "consistency_diff": 3,
          "consistency_risk_score": 62,
          "contributions": {
            "baseline": false,
            "clip": false,
            "clothing": true,
            "cross_camera": false,
            "florence": true,
            "image_quality": true,
            "pet": false,
            "vehicle": false,
            "violence": false,
            "weather": true,
            "yolo26": true,
            "zones": true
          },
          "enrichment_utilization": 0.85,
          "event_id": 12345,
          "id": 456,
          "improvements": {
            "confusing_sections": [],
            "format_suggestions": [],
            "missing_context": [
              "Time since last motion event"
            ],
            "model_gaps": [],
            "unused_data": []
          },
          "is_fully_evaluated": true,
          "prompt_length": 2048,
          "prompt_token_estimate": 512,
          "scores": {
            "consistency": 4.0,
            "context_usage": 4.2,
            "overall": 4.1,
            "reasoning_coherence": 4.5,
            "risk_justification": 3.8
          },
          "self_eval_critique": "More historical context would improve analysis."
        },
        "properties": {
          "audited_at": {
            "format": "date-time",
            "title": "Audited At",
            "type": "string"
          },
          "consistency_diff": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Consistency Diff"
          },
          "consistency_risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Consistency Risk Score"
          },
          "contributions": {
            "$ref": "#/components/schemas/ModelContributions"
          },
          "enrichment_utilization": {
            "title": "Enrichment Utilization",
            "type": "number"
          },
          "event_id": {
            "title": "Event Id",
            "type": "integer"
          },
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "improvements": {
            "$ref": "#/components/schemas/PromptImprovements"
          },
          "is_fully_evaluated": {
            "title": "Is Fully Evaluated",
            "type": "boolean"
          },
          "prompt_length": {
            "title": "Prompt Length",
            "type": "integer"
          },
          "prompt_token_estimate": {
            "title": "Prompt Token Estimate",
            "type": "integer"
          },
          "scores": {
            "$ref": "#/components/schemas/QualityScores"
          },
          "self_eval_critique": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Self Eval Critique"
          }
        },
        "required": [
          "id",
          "event_id",
          "audited_at",
          "is_fully_evaluated",
          "contributions",
          "prompt_length",
          "prompt_token_estimate",
          "enrichment_utilization",
          "scores",
          "improvements"
        ],
        "title": "EventAuditResponse",
        "type": "object"
      },
      "EventBulkCreateItem": {
        "description": "Schema for a single event in a bulk create request.\n\nAttributes:\n    batch_id: Batch ID that generated this event (tracks detection grouping)\n    camera_id: Camera ID that generated this event\n    started_at: Event start timestamp\n    ended_at: Optional event end timestamp\n    risk_score: Risk score from 0-100\n    risk_level: Risk level (low, medium, high, critical)\n    summary: Brief event summary\n    reasoning: Detailed reasoning from LLM analysis\n    detection_ids: List of detection IDs associated with this event",
        "properties": {
          "batch_id": {
            "description": "Batch ID that generated this event",
            "maxLength": 255,
            "minLength": 1,
            "title": "Batch Id",
            "type": "string"
          },
          "camera_id": {
            "description": "Camera ID",
            "maxLength": 255,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_-]+$",
            "title": "Camera Id",
            "type": "string"
          },
          "detection_ids": {
            "description": "Associated detection IDs",
            "items": {
              "type": "integer"
            },
            "title": "Detection Ids",
            "type": "array"
          },
          "ended_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event end timestamp",
            "title": "Ended At"
          },
          "reasoning": {
            "anyOf": [
              {
                "maxLength": 5000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM reasoning",
            "title": "Reasoning"
          },
          "risk_level": {
            "description": "Risk level",
            "pattern": "^(low|medium|high|critical)$",
            "title": "Risk Level",
            "type": "string"
          },
          "risk_score": {
            "description": "Risk score (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Risk Score",
            "type": "integer"
          },
          "started_at": {
            "description": "Event start timestamp",
            "format": "date-time",
            "title": "Started At",
            "type": "string"
          },
          "summary": {
            "description": "Event summary",
            "maxLength": 1000,
            "minLength": 1,
            "title": "Summary",
            "type": "string"
          }
        },
        "required": [
          "batch_id",
          "camera_id",
          "started_at",
          "risk_score",
          "risk_level",
          "summary"
        ],
        "title": "EventBulkCreateItem",
        "type": "object"
      },
      "EventBulkCreateRequest": {
        "description": "Request schema for bulk event creation.\n\nAttributes:\n    events: List of events to create (max 100 per request)",
        "properties": {
          "events": {
            "description": "Events to create (max 100)",
            "items": {
              "$ref": "#/components/schemas/EventBulkCreateItem"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Events",
            "type": "array"
          }
        },
        "required": [
          "events"
        ],
        "title": "EventBulkCreateRequest",
        "type": "object"
      },
      "EventBulkCreateResponse": {
        "description": "Response schema for bulk event creation.\n\nExtends BulkOperationResponse with created event IDs.",
        "properties": {
          "failed": {
            "description": "Number of failed operations",
            "minimum": 0.0,
            "title": "Failed",
            "type": "integer"
          },
          "results": {
            "description": "Per-item results",
            "items": {
              "$ref": "#/components/schemas/BulkItemResult"
            },
            "title": "Results",
            "type": "array"
          },
          "skipped": {
            "default": 0,
            "description": "Number of skipped operations",
            "minimum": 0.0,
            "title": "Skipped",
            "type": "integer"
          },
          "succeeded": {
            "description": "Number of successful operations",
            "minimum": 0.0,
            "title": "Succeeded",
            "type": "integer"
          },
          "total": {
            "description": "Total number of items in the request",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "succeeded",
          "failed"
        ],
        "title": "EventBulkCreateResponse",
        "type": "object"
      },
      "EventBulkDeleteRequest": {
        "description": "Request schema for bulk event deletion.\n\nAttributes:\n    event_ids: List of event IDs to delete (max 100 per request)\n    soft_delete: If true, mark as deleted instead of removing",
        "properties": {
          "event_ids": {
            "description": "Event IDs to delete (max 100)",
            "items": {
              "type": "integer"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Event Ids",
            "type": "array"
          },
          "soft_delete": {
            "default": true,
            "description": "Soft delete (default) vs hard delete",
            "title": "Soft Delete",
            "type": "boolean"
          }
        },
        "required": [
          "event_ids"
        ],
        "title": "EventBulkDeleteRequest",
        "type": "object"
      },
      "EventBulkUpdateItem": {
        "description": "Schema for a single event update in a bulk update request.\n\nAttributes:\n    id: Event ID to update\n    reviewed: Mark event as reviewed/dismissed\n    notes: Optional notes for the event",
        "properties": {
          "id": {
            "description": "Event ID to update",
            "exclusiveMinimum": 0.0,
            "title": "Id",
            "type": "integer"
          },
          "notes": {
            "anyOf": [
              {
                "maxLength": 2000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Notes",
            "title": "Notes"
          },
          "reviewed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Mark as reviewed",
            "title": "Reviewed"
          }
        },
        "required": [
          "id"
        ],
        "title": "EventBulkUpdateItem",
        "type": "object"
      },
      "EventBulkUpdateRequest": {
        "description": "Request schema for bulk event updates.\n\nAttributes:\n    events: List of event updates (max 100 per request)",
        "properties": {
          "events": {
            "description": "Event updates (max 100)",
            "items": {
              "$ref": "#/components/schemas/EventBulkUpdateItem"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Events",
            "type": "array"
          }
        },
        "required": [
          "events"
        ],
        "title": "EventBulkUpdateRequest",
        "type": "object"
      },
      "EventCluster": {
        "description": "Schema for an event cluster.",
        "example": {
          "cameras": [
            "front_door",
            "back_door"
          ],
          "cluster_id": "123e4567-e89b-12d3-a456-426614174000",
          "end_time": "2026-01-25T10:05:00Z",
          "event_count": 5,
          "events": [
            {
              "camera_id": "front_door",
              "id": 1,
              "risk_level": "critical",
              "risk_score": 85,
              "started_at": "2026-01-25T10:00:00Z",
              "summary": "Unknown person at door"
            }
          ],
          "object_types": {
            "person": 3,
            "vehicle": 2
          },
          "risk_levels": {
            "critical": 1,
            "high": 2,
            "low": 0,
            "medium": 2
          },
          "start_time": "2026-01-25T10:00:00Z"
        },
        "properties": {
          "cameras": {
            "description": "List of camera IDs with events in this cluster",
            "items": {
              "type": "string"
            },
            "title": "Cameras",
            "type": "array"
          },
          "cluster_id": {
            "description": "Unique identifier for the cluster",
            "title": "Cluster Id",
            "type": "string"
          },
          "end_time": {
            "description": "End time of the last event in the cluster",
            "format": "date-time",
            "title": "End Time",
            "type": "string"
          },
          "event_count": {
            "description": "Total number of events in the cluster",
            "minimum": 1.0,
            "title": "Event Count",
            "type": "integer"
          },
          "events": {
            "description": "Abbreviated event objects in the cluster",
            "items": {
              "$ref": "#/components/schemas/ClusterEventSummary"
            },
            "title": "Events",
            "type": "array"
          },
          "object_types": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of events by detected object type",
            "title": "Object Types",
            "type": "object"
          },
          "risk_levels": {
            "$ref": "#/components/schemas/ClusterRiskLevels",
            "description": "Count of events by risk level in the cluster"
          },
          "start_time": {
            "description": "Start time of the first event in the cluster",
            "format": "date-time",
            "title": "Start Time",
            "type": "string"
          }
        },
        "required": [
          "start_time",
          "end_time",
          "event_count",
          "cameras",
          "risk_levels",
          "events"
        ],
        "title": "EventCluster",
        "type": "object"
      },
      "EventClustersResponse": {
        "description": "Schema for event clusters API response.",
        "example": {
          "clusters": [
            {
              "cameras": [
                "front_door",
                "back_door"
              ],
              "cluster_id": "123e4567-e89b-12d3-a456-426614174000",
              "end_time": "2026-01-25T10:05:00Z",
              "event_count": 5,
              "events": [],
              "object_types": {
                "person": 3,
                "vehicle": 2
              },
              "risk_levels": {
                "critical": 1,
                "high": 2,
                "low": 0,
                "medium": 2
              },
              "start_time": "2026-01-25T10:00:00Z"
            }
          ],
          "total_clusters": 10,
          "unclustered_events": 15
        },
        "properties": {
          "clusters": {
            "description": "List of event clusters matching the query",
            "items": {
              "$ref": "#/components/schemas/EventCluster"
            },
            "title": "Clusters",
            "type": "array"
          },
          "total_clusters": {
            "description": "Total number of clusters found",
            "minimum": 0.0,
            "title": "Total Clusters",
            "type": "integer"
          },
          "unclustered_events": {
            "description": "Number of events not belonging to any cluster",
            "minimum": 0.0,
            "title": "Unclustered Events",
            "type": "integer"
          }
        },
        "required": [
          "clusters",
          "total_clusters",
          "unclustered_events"
        ],
        "title": "EventClustersResponse",
        "type": "object"
      },
      "EventEnrichmentsResponse": {
        "description": "Enrichment data for all detections in an event with pagination support.",
        "example": {
          "count": 2,
          "enrichments": [
            {
              "detection_id": 1,
              "enriched_at": "2026-01-03T10:30:00Z",
              "face": {
                "count": 0,
                "detected": false
              },
              "license_plate": {
                "detected": true,
                "text": "ABC-1234"
              },
              "violence": {
                "detected": false,
                "score": 0.0
              }
            },
            {
              "detection_id": 2,
              "enriched_at": "2026-01-03T10:30:05Z",
              "face": {
                "count": 1,
                "detected": true
              },
              "license_plate": {
                "detected": false
              },
              "violence": {
                "detected": false,
                "score": 0.0
              }
            }
          ],
          "event_id": 100,
          "has_more": false,
          "limit": 50,
          "offset": 0,
          "total": 10
        },
        "properties": {
          "count": {
            "description": "Number of enrichments in this response (page size)",
            "title": "Count",
            "type": "integer"
          },
          "enrichments": {
            "description": "Enrichment data per detection",
            "items": {
              "$ref": "#/components/schemas/EnrichmentResponse"
            },
            "title": "Enrichments",
            "type": "array"
          },
          "event_id": {
            "description": "Event ID",
            "title": "Event Id",
            "type": "integer"
          },
          "has_more": {
            "description": "Whether there are more results available",
            "title": "Has More",
            "type": "boolean"
          },
          "limit": {
            "description": "Maximum number of results requested",
            "title": "Limit",
            "type": "integer"
          },
          "offset": {
            "description": "Number of results skipped",
            "title": "Offset",
            "type": "integer"
          },
          "total": {
            "description": "Total number of detections with enrichment data for this event",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "event_id",
          "enrichments",
          "count",
          "total",
          "limit",
          "offset",
          "has_more"
        ],
        "title": "EventEnrichmentsResponse",
        "type": "object"
      },
      "EventFeedbackCreate": {
        "description": "Schema for creating event feedback.\n\nUsed when submitting user feedback about an event's classification.\nEnhanced with calibration fields for Nemotron prompt improvement (NEM-3330).",
        "example": {
          "actual_identity": "Mike (neighbor)",
          "actual_threat_level": "no_threat",
          "event_id": 123,
          "feedback_type": "false_positive",
          "model_failures": [
            "reid_model"
          ],
          "notes": "This was my neighbor's car, not a threat.",
          "suggested_score": 10,
          "what_was_wrong": "Re-ID should have matched this person"
        },
        "properties": {
          "actual_identity": {
            "anyOf": [
              {
                "maxLength": 100,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Identity correction for household member learning (e.g., 'Mike (neighbor)')",
            "title": "Actual Identity"
          },
          "actual_threat_level": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ActualThreatLevel"
              },
              {
                "type": "null"
              }
            ],
            "description": "User's assessment of true threat level (no_threat, minor_concern, genuine_threat)"
          },
          "event_id": {
            "description": "ID of the event this feedback is for",
            "exclusiveMinimum": 0.0,
            "title": "Event Id",
            "type": "integer"
          },
          "feedback_type": {
            "$ref": "#/components/schemas/FeedbackType",
            "description": "Type of feedback (accurate, false_positive, missed_threat, severity_wrong)"
          },
          "model_failures": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of specific AI models that failed (e.g., ['florence_vqa', 'pose_model'])",
            "title": "Model Failures"
          },
          "notes": {
            "anyOf": [
              {
                "maxLength": 1000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional notes explaining the feedback",
            "title": "Notes"
          },
          "suggested_score": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "What the user thinks the risk score should have been (0-100)",
            "title": "Suggested Score"
          },
          "what_was_wrong": {
            "anyOf": [
              {
                "maxLength": 5000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detailed explanation of what the AI got wrong",
            "title": "What Was Wrong"
          }
        },
        "required": [
          "event_id",
          "feedback_type"
        ],
        "title": "EventFeedbackCreate",
        "type": "object"
      },
      "EventFeedbackResponse": {
        "description": "Schema for event feedback response.\n\nReturned when retrieving feedback for an event.\nEnhanced with calibration fields for Nemotron prompt improvement (NEM-3330).",
        "example": {
          "actual_identity": "Mike (neighbor)",
          "actual_threat_level": "no_threat",
          "created_at": "2025-01-01T12:00:00Z",
          "event_id": 123,
          "feedback_type": "false_positive",
          "id": 1,
          "model_failures": [
            "reid_model"
          ],
          "notes": "This was my neighbor's car, not a threat.",
          "suggested_score": 10,
          "what_was_wrong": "Re-ID should have matched this person"
        },
        "properties": {
          "actual_identity": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Identity correction for household member learning",
            "title": "Actual Identity"
          },
          "actual_threat_level": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ActualThreatLevel"
              },
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "User's assessment of true threat level",
            "title": "Actual Threat Level"
          },
          "created_at": {
            "description": "When feedback was submitted",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "event_id": {
            "description": "Event ID this feedback belongs to",
            "title": "Event Id",
            "type": "integer"
          },
          "feedback_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ],
            "description": "Type of feedback provided",
            "title": "Feedback Type"
          },
          "id": {
            "description": "Feedback record ID",
            "title": "Id",
            "type": "integer"
          },
          "model_failures": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of specific AI models that failed",
            "title": "Model Failures"
          },
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional notes from user",
            "title": "Notes"
          },
          "suggested_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "What user thinks score should have been (0-100)",
            "title": "Suggested Score"
          },
          "what_was_wrong": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detailed explanation of what AI got wrong",
            "title": "What Was Wrong"
          }
        },
        "required": [
          "id",
          "event_id",
          "feedback_type",
          "created_at"
        ],
        "title": "EventFeedbackResponse",
        "type": "object"
      },
      "EventListResponse": {
        "description": "Schema for event list response with pagination.\n\nNEM-2075: Standardized pagination envelope with items + pagination structure.\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nUse cursor-based pagination for better performance with large datasets.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "detection_count": 5,
              "detection_ids": [
                1,
                2,
                3,
                4,
                5
              ],
              "ended_at": "2025-12-23T12:02:30Z",
              "id": 1,
              "reasoning": "Person approaching entrance during daytime",
              "reviewed": false,
              "risk_level": "medium",
              "risk_score": 75,
              "started_at": "2025-12-23T12:00:00Z",
              "summary": "Person detected near front entrance",
              "thumbnail_url": "/api/detections/1/image"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=",
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Warning message when using deprecated offset pagination",
            "title": "Deprecation Warning"
          },
          "items": {
            "description": "List of events",
            "items": {
              "$ref": "#/components/schemas/EventResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "EventListResponse",
        "type": "object"
      },
      "EventRegistryResponse": {
        "description": "Response containing the complete WebSocket event registry.",
        "example": {
          "channels": [
            "detections",
            "events",
            "alerts",
            "cameras",
            "jobs",
            "system"
          ],
          "deprecated_count": 3,
          "event_types": [],
          "total_count": 25
        },
        "properties": {
          "channels": {
            "description": "List of all available WebSocket channels",
            "items": {
              "type": "string"
            },
            "title": "Channels",
            "type": "array"
          },
          "deprecated_count": {
            "description": "Number of deprecated event types",
            "title": "Deprecated Count",
            "type": "integer"
          },
          "event_types": {
            "description": "List of all available event types",
            "items": {
              "$ref": "#/components/schemas/EventTypeInfo"
            },
            "title": "Event Types",
            "type": "array"
          },
          "total_count": {
            "description": "Total number of event types",
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "event_types",
          "channels",
          "total_count",
          "deprecated_count"
        ],
        "title": "EventRegistryResponse",
        "type": "object"
      },
      "EventResponse": {
        "description": "Schema for event response.",
        "example": {
          "camera_id": "front_door",
          "confidence_factors": {
            "detection_quality": "good",
            "enrichment_coverage": "full",
            "weather_impact": "none"
          },
          "detection_count": 5,
          "detection_ids": [
            1,
            2,
            3,
            4,
            5
          ],
          "ended_at": "2025-12-23T12:02:30Z",
          "enrichment_status": {
            "errors": {},
            "failed_models": [],
            "status": "full",
            "success_rate": 1.0,
            "successful_models": [
              "violence",
              "weather",
              "face",
              "clothing"
            ]
          },
          "entities": [
            {
              "description": "Individual in casual clothing",
              "threat_level": "low",
              "type": "person"
            }
          ],
          "flags": [],
          "id": 1,
          "llm_prompt": "<|im_start|>system\nYou are a home security risk analyzer...",
          "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
          "reviewed": false,
          "risk_factors": [
            {
              "contribution": -10.0,
              "description": "Activity during normal hours",
              "factor_name": "daytime_activity"
            },
            {
              "contribution": 5.0,
              "description": "Activity at primary entrance",
              "factor_name": "front_entrance"
            }
          ],
          "risk_level": "medium",
          "risk_score": 75,
          "started_at": "2025-12-23T12:00:00Z",
          "summary": "Person detected near front entrance",
          "thumbnail_url": "/api/detections/1/image",
          "version": 1
        },
        "properties": {
          "camera_id": {
            "description": "Normalized camera ID (e.g., 'front_door')",
            "title": "Camera Id",
            "type": "string"
          },
          "confidence_factors": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ConfidenceFactors"
              },
              {
                "type": "null"
              }
            ],
            "description": "Factors affecting confidence in the analysis"
          },
          "deleted_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when the event was soft-deleted (null if not deleted)",
            "title": "Deleted At"
          },
          "detection_count": {
            "default": 0,
            "description": "Number of detections in this event",
            "title": "Detection Count",
            "type": "integer"
          },
          "detection_ids": {
            "description": "List of detection IDs associated with this event",
            "items": {
              "type": "integer"
            },
            "title": "Detection Ids",
            "type": "array"
          },
          "ended_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event end timestamp",
            "title": "Ended At"
          },
          "enrichment_status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enrichment pipeline status (NEM-1672) - shows which models succeeded/failed"
          },
          "entities": {
            "description": "Entities identified in the analysis (people, vehicles, objects)",
            "items": {
              "$ref": "#/components/schemas/RiskEntity"
            },
            "title": "Entities",
            "type": "array"
          },
          "flagged": {
            "default": false,
            "description": "Whether event is flagged for follow-up (NEM-3839)",
            "title": "Flagged",
            "type": "boolean"
          },
          "flags": {
            "description": "Risk flags raised during analysis",
            "items": {
              "$ref": "#/components/schemas/RiskFlag"
            },
            "title": "Flags",
            "type": "array"
          },
          "id": {
            "description": "Event ID",
            "title": "Id",
            "type": "integer"
          },
          "llm_prompt": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Full prompt sent to Nemotron LLM (for debugging/improvement)",
            "title": "Llm Prompt"
          },
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "User notes for the event",
            "title": "Notes"
          },
          "reasoning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM reasoning for risk score",
            "title": "Reasoning"
          },
          "recommended_action": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Suggested action based on the analysis",
            "title": "Recommended Action"
          },
          "reviewed": {
            "default": false,
            "description": "Whether event has been reviewed",
            "title": "Reviewed",
            "type": "boolean"
          },
          "risk_factors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/RiskFactor"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Individual factors contributing to the risk score (NEM-3603)",
            "title": "Risk Factors"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk level (low/medium/high/critical), computed from risk_score using severity thresholds",
            "readOnly": true,
            "title": "Risk Level"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk score (0-100)",
            "title": "Risk Score"
          },
          "snooze_until": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp until which alerts for this event are snoozed (NEM-2359)",
            "title": "Snooze Until"
          },
          "started_at": {
            "description": "Event start timestamp",
            "format": "date-time",
            "title": "Started At",
            "type": "string"
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM-generated event summary",
            "title": "Summary"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to thumbnail image (first detection's media)",
            "title": "Thumbnail Url"
          },
          "version": {
            "default": 1,
            "description": "Optimistic locking version (NEM-3625). Include in updates to prevent conflicts.",
            "title": "Version",
            "type": "integer"
          }
        },
        "required": [
          "id",
          "camera_id",
          "started_at",
          "risk_level"
        ],
        "title": "EventResponse",
        "type": "object"
      },
      "EventStatsResponse": {
        "description": "Schema for aggregated event statistics.",
        "example": {
          "events_by_camera": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "event_count": 30
            },
            {
              "camera_id": "back_door",
              "camera_name": "Back Door",
              "event_count": 14
            }
          ],
          "events_by_risk_level": {
            "critical": 2,
            "high": 5,
            "low": 25,
            "medium": 12
          },
          "risk_distribution": [
            {
              "count": 2,
              "risk_level": "critical"
            },
            {
              "count": 5,
              "risk_level": "high"
            },
            {
              "count": 12,
              "risk_level": "medium"
            },
            {
              "count": 25,
              "risk_level": "low"
            }
          ],
          "total_events": 44
        },
        "properties": {
          "events_by_camera": {
            "description": "Events grouped by camera",
            "items": {
              "$ref": "#/components/schemas/EventsByCamera"
            },
            "title": "Events By Camera",
            "type": "array"
          },
          "events_by_risk_level": {
            "$ref": "#/components/schemas/EventsByRiskLevel",
            "description": "Events grouped by risk level"
          },
          "risk_distribution": {
            "description": "Events by risk level as array (for Grafana compatibility)",
            "items": {
              "$ref": "#/components/schemas/RiskDistributionItem"
            },
            "title": "Risk Distribution",
            "type": "array"
          },
          "total_events": {
            "description": "Total number of events",
            "title": "Total Events",
            "type": "integer"
          }
        },
        "required": [
          "total_events",
          "events_by_risk_level",
          "events_by_camera"
        ],
        "title": "EventStatsResponse",
        "type": "object"
      },
      "EventTypeInfo": {
        "description": "Information about a single WebSocket event type.",
        "example": {
          "channel": "detections",
          "deprecated": false,
          "description": "New detection from AI pipeline",
          "example": {
            "confidence": 0.95,
            "detection_id": "123",
            "label": "person"
          },
          "payload_schema": {
            "confidence": {
              "type": "number"
            },
            "detection_id": {
              "format": "uuid",
              "type": "string"
            },
            "label": {
              "type": "string"
            }
          },
          "type": "detection.new"
        },
        "properties": {
          "channel": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "WebSocket channel this event is broadcast on",
            "title": "Channel"
          },
          "deprecated": {
            "default": false,
            "description": "Whether this event type is deprecated",
            "title": "Deprecated",
            "type": "boolean"
          },
          "description": {
            "description": "Human-readable description",
            "title": "Description",
            "type": "string"
          },
          "example": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Example payload",
            "title": "Example"
          },
          "payload_schema": {
            "additionalProperties": true,
            "description": "JSON Schema for the event payload",
            "title": "Payload Schema",
            "type": "object"
          },
          "replacement": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Replacement event type if deprecated",
            "title": "Replacement"
          },
          "type": {
            "description": "Event type identifier",
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "type",
          "description",
          "payload_schema"
        ],
        "title": "EventTypeInfo",
        "type": "object"
      },
      "EventUpdate": {
        "description": "Schema for updating an event (PATCH).\n\nSupports optimistic locking (NEM-3625): Include the `version` field from the\nevent response to prevent concurrent modification conflicts. If the version\ndoesn't match, the server returns HTTP 409 Conflict.",
        "example": {
          "notes": "Verified - delivery person",
          "reviewed": true,
          "snooze_until": "2025-12-24T12:00:00Z",
          "version": 1
        },
        "properties": {
          "flagged": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Flag or unflag event for follow-up (NEM-3839)",
            "title": "Flagged"
          },
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "User notes for the event",
            "title": "Notes"
          },
          "reviewed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Mark event as reviewed or not reviewed",
            "title": "Reviewed"
          },
          "snooze_until": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Set or clear the alert snooze timestamp (NEM-2359)",
            "title": "Snooze Until"
          },
          "version": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optimistic locking version (NEM-3625). Include the version from the event response to detect concurrent modifications. If the version doesn't match, returns HTTP 409 Conflict.",
            "title": "Version"
          }
        },
        "title": "EventUpdate",
        "type": "object"
      },
      "EventsByCamera": {
        "description": "Schema for events count by camera.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "event_count": 15
        },
        "properties": {
          "camera_id": {
            "description": "Normalized camera ID (e.g., 'front_door')",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "description": "Camera name",
            "title": "Camera Name",
            "type": "string"
          },
          "event_count": {
            "description": "Number of events for this camera",
            "title": "Event Count",
            "type": "integer"
          }
        },
        "required": [
          "camera_id",
          "camera_name",
          "event_count"
        ],
        "title": "EventsByCamera",
        "type": "object"
      },
      "EventsByRiskLevel": {
        "description": "Schema for events count by risk level.",
        "example": {
          "critical": 2,
          "high": 5,
          "low": 25,
          "medium": 12
        },
        "properties": {
          "critical": {
            "default": 0,
            "description": "Number of critical risk events",
            "title": "Critical",
            "type": "integer"
          },
          "high": {
            "default": 0,
            "description": "Number of high risk events",
            "title": "High",
            "type": "integer"
          },
          "low": {
            "default": 0,
            "description": "Number of low risk events",
            "title": "Low",
            "type": "integer"
          },
          "medium": {
            "default": 0,
            "description": "Number of medium risk events",
            "title": "Medium",
            "type": "integer"
          }
        },
        "title": "EventsByRiskLevel",
        "type": "object"
      },
      "ExportDownloadResponse": {
        "description": "Schema for export file download metadata.\n\nReturned when checking if a file is ready for download.\nThe actual file is served via a separate streaming endpoint.",
        "example": {
          "content_type": "text/csv",
          "download_url": "/api/exports/550e8400-e29b-41d4-a716-446655440000/download",
          "filename": "events_export_20250112_143000.csv",
          "ready": true,
          "size_bytes": 125432
        },
        "properties": {
          "content_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "MIME type of the file",
            "title": "Content Type"
          },
          "download_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to download the file",
            "title": "Download Url"
          },
          "filename": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Exported filename",
            "title": "Filename"
          },
          "ready": {
            "description": "Whether the file is ready for download",
            "title": "Ready",
            "type": "boolean"
          },
          "size_bytes": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "File size in bytes",
            "title": "Size Bytes"
          }
        },
        "required": [
          "ready"
        ],
        "title": "ExportDownloadResponse",
        "type": "object"
      },
      "ExportFormat": {
        "description": "Supported export formats.",
        "enum": [
          "csv",
          "json",
          "zip"
        ],
        "title": "ExportFormat",
        "type": "string"
      },
      "ExportFormatEnum": {
        "description": "Export file formats.",
        "enum": [
          "csv",
          "json",
          "zip",
          "excel"
        ],
        "title": "ExportFormatEnum",
        "type": "string"
      },
      "ExportJobCancelResponse": {
        "description": "Schema for export job cancellation response.",
        "example": {
          "cancelled": true,
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "message": "Export job cancelled by user",
          "status": "failed"
        },
        "properties": {
          "cancelled": {
            "description": "Whether cancellation was successful",
            "title": "Cancelled",
            "type": "boolean"
          },
          "job_id": {
            "description": "Job ID that was cancelled",
            "title": "Job Id",
            "type": "string"
          },
          "message": {
            "description": "Cancellation status message",
            "title": "Message",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ExportJobStatusEnum",
            "description": "New job status after cancellation"
          }
        },
        "required": [
          "job_id",
          "status",
          "message",
          "cancelled"
        ],
        "title": "ExportJobCancelResponse",
        "type": "object"
      },
      "ExportJobCreate": {
        "description": "Schema for creating an export job.\n\nCreate a new background export job with optional filtering parameters.\nThe job will be processed asynchronously and can be monitored via\nthe job status endpoint.",
        "example": {
          "camera_id": "front_door",
          "columns": [
            "event_id",
            "camera_name",
            "risk_score",
            "summary"
          ],
          "compliance_metadata": {
            "reason": "Monthly audit report",
            "requestor": "admin@example.com"
          },
          "end_date": "2025-01-12T23:59:59Z",
          "export_format": "csv",
          "export_type": "events",
          "legal_hold": false,
          "retention_days": 30,
          "risk_level": "high",
          "start_date": "2025-01-01T00:00:00Z"
        },
        "properties": {
          "camera_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by camera ID",
            "title": "Camera Id"
          },
          "columns": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of column field names to include in export. Available: event_id, camera_name, started_at, ended_at, risk_score, risk_level, summary, detection_count, reviewed, object_types, reasoning. If null, all columns are included.",
            "title": "Columns"
          },
          "compliance_metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Audit trail info (requestor, reason, authorization)",
            "title": "Compliance Metadata"
          },
          "end_date": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter events ending before this date (ISO format)",
            "title": "End Date"
          },
          "export_format": {
            "$ref": "#/components/schemas/ExportFormatEnum",
            "default": "csv",
            "description": "Output file format (csv, json, zip, excel)"
          },
          "export_type": {
            "$ref": "#/components/schemas/ExportTypeEnum",
            "default": "events",
            "description": "Type of data to export (events, alerts, full_backup)"
          },
          "legal_hold": {
            "default": false,
            "description": "Prevent automatic deletion of this export",
            "title": "Legal Hold",
            "type": "boolean"
          },
          "retention_days": {
            "anyOf": [
              {
                "exclusiveMinimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Days to retain export file (overrides system default)",
            "title": "Retention Days"
          },
          "reviewed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by reviewed status (true=reviewed, false=unreviewed, null=all)",
            "title": "Reviewed"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by risk level (low, medium, high, critical)",
            "title": "Risk Level"
          },
          "start_date": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter events starting from this date (ISO format)",
            "title": "Start Date"
          }
        },
        "title": "ExportJobCreate",
        "type": "object"
      },
      "ExportJobListResponse": {
        "description": "Schema for export job list response with pagination.",
        "example": {
          "items": [
            {
              "completed_at": "2025-01-12T14:35:00Z",
              "created_at": "2025-01-12T14:30:00Z",
              "export_format": "csv",
              "export_type": "events",
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "progress": {
                "current_step": "Complete",
                "processed_items": 1230,
                "progress_percent": 100,
                "total_items": 1230
              },
              "result": {
                "event_count": 1230,
                "format": "csv",
                "output_path": "/api/exports/download/events_export_20250112_143000.csv",
                "output_size_bytes": 125432
              },
              "started_at": "2025-01-12T14:30:01Z",
              "status": "completed"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of export jobs",
            "items": {
              "$ref": "#/components/schemas/ExportJobResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "ExportJobListResponse",
        "type": "object"
      },
      "ExportJobProgress": {
        "description": "Schema for export job progress information.\n\nDetailed progress information for an export job, including\ntiming, item counts, and current step.",
        "example": {
          "current_step": "Processing events...",
          "estimated_completion": "2025-01-12T14:35:00Z",
          "processed_items": 245,
          "progress_percent": 20,
          "total_items": 1230
        },
        "properties": {
          "current_step": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current processing step description",
            "title": "Current Step"
          },
          "estimated_completion": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimated completion time (ISO format)",
            "title": "Estimated Completion"
          },
          "processed_items": {
            "default": 0,
            "description": "Number of items processed so far",
            "minimum": 0.0,
            "title": "Processed Items",
            "type": "integer"
          },
          "progress_percent": {
            "default": 0,
            "description": "Progress percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Progress Percent",
            "type": "integer"
          },
          "total_items": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total items to process (null if unknown)",
            "title": "Total Items"
          }
        },
        "title": "ExportJobProgress",
        "type": "object"
      },
      "ExportJobRequest": {
        "description": "Request to start an export job.",
        "example": {
          "end_date": "2024-01-15T23:59:59Z",
          "format": "csv",
          "risk_level": "high",
          "start_date": "2024-01-01T00:00:00Z"
        },
        "properties": {
          "camera_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by camera ID",
            "title": "Camera Id"
          },
          "end_date": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by end date (ISO format)",
            "title": "End Date"
          },
          "format": {
            "$ref": "#/components/schemas/ExportFormat",
            "default": "csv",
            "description": "Export format"
          },
          "reviewed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by reviewed status",
            "title": "Reviewed"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by risk level (low, medium, high, critical)",
            "title": "Risk Level"
          },
          "start_date": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by start date (ISO format)",
            "title": "Start Date"
          }
        },
        "title": "ExportJobRequest",
        "type": "object"
      },
      "ExportJobResponse": {
        "description": "Schema for export job status response.\n\nComplete status information for an export job, including\nprogress, timing, result, and any error information.",
        "example": {
          "created_at": "2025-01-12T14:30:00Z",
          "export_format": "csv",
          "export_type": "events",
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "progress": {
            "current_step": "Processing events...",
            "estimated_completion": "2025-01-12T14:35:00Z",
            "processed_items": 245,
            "progress_percent": 20,
            "total_items": 1230
          },
          "started_at": "2025-01-12T14:30:01Z",
          "status": "running"
        },
        "properties": {
          "completed_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Job completion timestamp",
            "title": "Completed At"
          },
          "compliance_metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Audit trail info (requestor, reason, authorization)",
            "title": "Compliance Metadata"
          },
          "created_at": {
            "description": "Job creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "error_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message (populated when failed)",
            "title": "Error Message"
          },
          "export_format": {
            "description": "Export file format",
            "title": "Export Format",
            "type": "string"
          },
          "export_type": {
            "description": "Type of export",
            "title": "Export Type",
            "type": "string"
          },
          "filter_params": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "JSON-serialized filter parameters used for this export",
            "title": "Filter Params"
          },
          "id": {
            "description": "Unique export job identifier",
            "title": "Id",
            "type": "string"
          },
          "legal_hold": {
            "default": false,
            "description": "Whether automatic deletion is prevented",
            "title": "Legal Hold",
            "type": "boolean"
          },
          "progress": {
            "$ref": "#/components/schemas/ExportJobProgress",
            "description": "Progress information"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ExportJobResult"
              },
              {
                "type": "null"
              }
            ],
            "description": "Export result (populated when completed)"
          },
          "retention_days": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Days to retain export file",
            "title": "Retention Days"
          },
          "started_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Job start timestamp",
            "title": "Started At"
          },
          "status": {
            "$ref": "#/components/schemas/ExportJobStatusEnum",
            "description": "Current job status"
          }
        },
        "required": [
          "id",
          "status",
          "export_type",
          "export_format",
          "created_at"
        ],
        "title": "ExportJobResponse",
        "type": "object"
      },
      "ExportJobResult": {
        "description": "Schema for completed export job result.\n\nInformation about the completed export, including download path\nand file statistics.",
        "example": {
          "event_count": 1230,
          "format": "csv",
          "output_path": "/api/exports/download/events_export_20250112_143000.csv",
          "output_size_bytes": 125432
        },
        "properties": {
          "event_count": {
            "default": 0,
            "description": "Number of records exported",
            "minimum": 0.0,
            "title": "Event Count",
            "type": "integer"
          },
          "format": {
            "description": "Export format used",
            "title": "Format",
            "type": "string"
          },
          "output_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Download path for the exported file",
            "title": "Output Path"
          },
          "output_size_bytes": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "File size in bytes",
            "title": "Output Size Bytes"
          }
        },
        "required": [
          "format"
        ],
        "title": "ExportJobResult",
        "type": "object"
      },
      "ExportJobStartResponse": {
        "description": "Response when creating an export job.\n\nReturns the job ID that can be used to track progress via\nGET /api/exports/{job_id}.",
        "example": {
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "message": "Export job created. Use GET /api/exports/{job_id} to track progress.",
          "status": "pending"
        },
        "properties": {
          "job_id": {
            "description": "Unique job identifier for tracking progress",
            "title": "Job Id",
            "type": "string"
          },
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ExportJobStatusEnum",
            "default": "pending",
            "description": "Initial job status (always pending)"
          }
        },
        "required": [
          "job_id",
          "message"
        ],
        "title": "ExportJobStartResponse",
        "type": "object"
      },
      "ExportJobStatusEnum": {
        "description": "Export job status values.",
        "enum": [
          "pending",
          "running",
          "completed",
          "failed"
        ],
        "title": "ExportJobStatusEnum",
        "type": "string"
      },
      "ExportTypeEnum": {
        "description": "Types of exports available.",
        "enum": [
          "events",
          "alerts",
          "full_backup"
        ],
        "title": "ExportTypeEnum",
        "type": "string"
      },
      "ExporterStatus": {
        "description": "Status information for a single Prometheus exporter.\n\nRepresents the health status of an exporter that provides metrics\nto Prometheus (e.g., redis-exporter, json-exporter, blackbox-exporter).",
        "example": {
          "endpoint": "http://redis-exporter:9121",
          "last_scrape": "2026-01-13T10:30:00Z",
          "name": "redis-exporter",
          "status": "up"
        },
        "properties": {
          "endpoint": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Scrape endpoint URL for this exporter",
            "title": "Endpoint"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if exporter is down",
            "title": "Error"
          },
          "last_scrape": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of last successful scrape (if available)",
            "title": "Last Scrape"
          },
          "name": {
            "description": "Exporter name (e.g., 'redis-exporter', 'json-exporter')",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ExporterStatusEnum",
            "description": "Current status: up, down, or unknown"
          }
        },
        "required": [
          "name",
          "status"
        ],
        "title": "ExporterStatus",
        "type": "object"
      },
      "ExporterStatusEnum": {
        "description": "Exporter status states.",
        "enum": [
          "up",
          "down",
          "unknown"
        ],
        "title": "ExporterStatusEnum",
        "type": "string"
      },
      "FaceDetectionEventListResponse": {
        "description": "Schema for list of face detection events.",
        "example": {
          "items": [
            {
              "age_estimate": 40,
              "bbox": [
                100,
                150,
                200,
                300
              ],
              "camera_id": "front_door",
              "created_at": "2025-01-01T10:00:00Z",
              "gender_estimate": "M",
              "id": 1,
              "is_unknown": true,
              "quality_score": 0.75,
              "timestamp": "2025-01-01T10:00:00Z"
            }
          ],
          "total": 1
        },
        "properties": {
          "items": {
            "description": "List of face detection events",
            "items": {
              "$ref": "#/components/schemas/FaceDetectionEventResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "total": {
            "description": "Total number of events",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "items",
          "total"
        ],
        "title": "FaceDetectionEventListResponse",
        "type": "object"
      },
      "FaceDetectionEventResponse": {
        "description": "Schema for face detection event response.",
        "example": {
          "age_estimate": 35,
          "bbox": [
            100,
            150,
            200,
            300
          ],
          "camera_id": "front_door",
          "created_at": "2025-01-01T10:00:00Z",
          "gender_estimate": "M",
          "id": 1,
          "is_unknown": false,
          "match_confidence": 0.92,
          "matched_person_id": 1,
          "matched_person_name": "John Doe",
          "quality_score": 0.85,
          "timestamp": "2025-01-01T10:00:00Z"
        },
        "properties": {
          "age_estimate": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimated age",
            "title": "Age Estimate"
          },
          "bbox": {
            "description": "Bounding box [x1, y1, x2, y2]",
            "items": {
              "type": "number"
            },
            "title": "Bbox",
            "type": "array"
          },
          "camera_id": {
            "description": "ID of the camera that detected the face",
            "title": "Camera Id",
            "type": "string"
          },
          "created_at": {
            "description": "When the event was recorded",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "gender_estimate": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimated gender (M/F)",
            "title": "Gender Estimate"
          },
          "id": {
            "description": "Unique identifier for the event",
            "title": "Id",
            "type": "integer"
          },
          "is_unknown": {
            "description": "Whether face is unknown",
            "title": "Is Unknown",
            "type": "boolean"
          },
          "match_confidence": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Match confidence score",
            "title": "Match Confidence"
          },
          "matched_person_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of matched person",
            "title": "Matched Person Id"
          },
          "matched_person_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Name of matched person",
            "title": "Matched Person Name"
          },
          "quality_score": {
            "description": "Face quality score",
            "title": "Quality Score",
            "type": "number"
          },
          "timestamp": {
            "description": "When the face was detected",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "id",
          "camera_id",
          "timestamp",
          "bbox",
          "is_unknown",
          "quality_score",
          "created_at"
        ],
        "title": "FaceDetectionEventResponse",
        "type": "object"
      },
      "FaceEmbeddingCreate": {
        "description": "Schema for adding a face embedding.",
        "example": {
          "embedding": [
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1
          ],
          "quality_score": 0.85,
          "source_image_path": "/data/images/john_doe_1.jpg"
        },
        "properties": {
          "embedding": {
            "description": "512-dimensional ArcFace embedding vector",
            "items": {
              "type": "number"
            },
            "maxItems": 512,
            "minItems": 512,
            "title": "Embedding",
            "type": "array"
          },
          "quality_score": {
            "default": 1.0,
            "description": "Face quality score when embedding was captured",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Quality Score",
            "type": "number"
          },
          "source_image_path": {
            "anyOf": [
              {
                "maxLength": 500,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to the source image",
            "title": "Source Image Path"
          }
        },
        "required": [
          "embedding"
        ],
        "title": "FaceEmbeddingCreate",
        "type": "object"
      },
      "FaceEmbeddingResponse": {
        "description": "Schema for face embedding response.",
        "example": {
          "created_at": "2025-01-01T10:00:00Z",
          "id": 1,
          "person_id": 1,
          "quality_score": 0.85,
          "source_image_path": "/data/images/john_doe_1.jpg"
        },
        "properties": {
          "created_at": {
            "description": "When the embedding was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "id": {
            "description": "Unique identifier for the embedding",
            "title": "Id",
            "type": "integer"
          },
          "person_id": {
            "description": "ID of the associated person",
            "title": "Person Id",
            "type": "integer"
          },
          "quality_score": {
            "description": "Face quality score",
            "title": "Quality Score",
            "type": "number"
          },
          "source_image_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to source image",
            "title": "Source Image Path"
          }
        },
        "required": [
          "id",
          "person_id",
          "quality_score",
          "created_at"
        ],
        "title": "FaceEmbeddingResponse",
        "type": "object"
      },
      "FaceEnrichment": {
        "description": "Face detection results.",
        "example": {
          "confidence": 0.88,
          "count": 1,
          "detected": true
        },
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Highest face confidence",
            "title": "Confidence"
          },
          "count": {
            "default": 0,
            "description": "Number of faces detected",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "detected": {
            "default": false,
            "description": "Whether faces were detected",
            "title": "Detected",
            "type": "boolean"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          }
        },
        "title": "FaceEnrichment",
        "type": "object"
      },
      "FaceMatchRequest": {
        "description": "Schema for face matching request.",
        "example": {
          "embedding": [
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1,
            0.1
          ],
          "threshold": 0.68
        },
        "properties": {
          "embedding": {
            "description": "512-dimensional face embedding to match",
            "items": {
              "type": "number"
            },
            "maxItems": 512,
            "minItems": 512,
            "title": "Embedding",
            "type": "array"
          },
          "threshold": {
            "default": 0.68,
            "description": "Minimum similarity threshold for a match",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Threshold",
            "type": "number"
          }
        },
        "required": [
          "embedding"
        ],
        "title": "FaceMatchRequest",
        "type": "object"
      },
      "FaceMatchResponse": {
        "description": "Schema for face matching response.",
        "example": {
          "is_household_member": true,
          "is_unknown": false,
          "matched": true,
          "person_id": 1,
          "person_name": "John Doe",
          "similarity": 0.92
        },
        "properties": {
          "is_household_member": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether matched person is a household member",
            "title": "Is Household Member"
          },
          "is_unknown": {
            "description": "Whether face is unknown",
            "title": "Is Unknown",
            "type": "boolean"
          },
          "matched": {
            "description": "Whether a match was found",
            "title": "Matched",
            "type": "boolean"
          },
          "person_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of matched person",
            "title": "Person Id"
          },
          "person_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Name of matched person",
            "title": "Person Name"
          },
          "similarity": {
            "description": "Best similarity score",
            "title": "Similarity",
            "type": "number"
          }
        },
        "required": [
          "matched",
          "similarity",
          "is_unknown"
        ],
        "title": "FaceMatchResponse",
        "type": "object"
      },
      "FeatureSettings": {
        "description": "Feature toggle settings for enabling/disabling AI pipeline components.\n\nControls which AI processing features are active in the detection pipeline.",
        "example": {
          "background_eval_enabled": true,
          "clip_generation_enabled": true,
          "image_quality_enabled": true,
          "reid_enabled": true,
          "scene_change_enabled": true,
          "vision_extraction_enabled": true
        },
        "properties": {
          "background_eval_enabled": {
            "description": "Enable automatic background AI audit evaluation when GPU is idle",
            "title": "Background Eval Enabled",
            "type": "boolean"
          },
          "clip_generation_enabled": {
            "description": "Enable automatic clip generation for events",
            "title": "Clip Generation Enabled",
            "type": "boolean"
          },
          "image_quality_enabled": {
            "description": "Enable BRISQUE image quality assessment (CPU-based)",
            "title": "Image Quality Enabled",
            "type": "boolean"
          },
          "reid_enabled": {
            "description": "Enable CLIP re-identification for tracking entities across cameras",
            "title": "Reid Enabled",
            "type": "boolean"
          },
          "scene_change_enabled": {
            "description": "Enable SSIM-based scene change detection",
            "title": "Scene Change Enabled",
            "type": "boolean"
          },
          "vision_extraction_enabled": {
            "description": "Enable Florence-2 vision extraction for vehicle/person attributes",
            "title": "Vision Extraction Enabled",
            "type": "boolean"
          }
        },
        "required": [
          "vision_extraction_enabled",
          "reid_enabled",
          "scene_change_enabled",
          "clip_generation_enabled",
          "image_quality_enabled",
          "background_eval_enabled"
        ],
        "title": "FeatureSettings",
        "type": "object"
      },
      "FeatureSettingsUpdate": {
        "description": "Feature settings update schema (all fields optional).\n\nUsed for PATCH /api/v1/settings to partially update feature toggles.",
        "example": {
          "reid_enabled": false
        },
        "properties": {
          "background_eval_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enable automatic background AI audit evaluation when GPU is idle",
            "title": "Background Eval Enabled"
          },
          "clip_generation_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enable automatic clip generation for events",
            "title": "Clip Generation Enabled"
          },
          "image_quality_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enable BRISQUE image quality assessment (CPU-based)",
            "title": "Image Quality Enabled"
          },
          "reid_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enable CLIP re-identification for tracking entities across cameras",
            "title": "Reid Enabled"
          },
          "scene_change_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enable SSIM-based scene change detection",
            "title": "Scene Change Enabled"
          },
          "vision_extraction_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enable Florence-2 vision extraction for vehicle/person attributes",
            "title": "Vision Extraction Enabled"
          }
        },
        "title": "FeatureSettingsUpdate",
        "type": "object"
      },
      "FeedbackStatsResponse": {
        "description": "Schema for aggregate feedback statistics.\n\nReturns counts of feedback by type and by camera to help\ncalibrate the AI model's risk assessment.",
        "example": {
          "by_camera": {
            "back_yard": 30,
            "front_door": 50,
            "garage": 20
          },
          "by_type": {
            "accurate": 10,
            "false_positive": 40,
            "missed_threat": 30,
            "severity_wrong": 20
          },
          "total_feedback": 100
        },
        "properties": {
          "by_camera": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of feedback entries grouped by camera ID",
            "title": "By Camera",
            "type": "object"
          },
          "by_type": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of feedback entries grouped by feedback type",
            "title": "By Type",
            "type": "object"
          },
          "total_feedback": {
            "description": "Total number of feedback entries",
            "minimum": 0.0,
            "title": "Total Feedback",
            "type": "integer"
          }
        },
        "required": [
          "total_feedback",
          "by_type",
          "by_camera"
        ],
        "title": "FeedbackStatsResponse",
        "type": "object"
      },
      "FeedbackType": {
        "description": "Types of feedback users can provide on events.\n\nValues:\n    ACCURATE: Event was correctly classified with appropriate severity\n    FALSE_POSITIVE: Event was incorrectly flagged as concerning\n    MISSED_THREAT: System failed to detect a concerning event\n    SEVERITY_WRONG: Event was flagged but with incorrect severity level",
        "enum": [
          "accurate",
          "false_positive",
          "missed_threat",
          "severity_wrong"
        ],
        "title": "FeedbackType",
        "type": "string"
      },
      "FileWatcherStatusResponse": {
        "description": "Status information for the FileWatcher service.",
        "example": {
          "camera_root": "/export/foscam",
          "observer_type": "native",
          "pending_tasks": 3,
          "running": true
        },
        "properties": {
          "camera_root": {
            "description": "Root directory being watched for camera uploads",
            "title": "Camera Root",
            "type": "string"
          },
          "observer_type": {
            "description": "Type of filesystem observer (native or polling)",
            "title": "Observer Type",
            "type": "string"
          },
          "pending_tasks": {
            "description": "Number of files pending processing (debouncing)",
            "minimum": 0.0,
            "title": "Pending Tasks",
            "type": "integer"
          },
          "running": {
            "description": "Whether the file watcher is currently running",
            "title": "Running",
            "type": "boolean"
          }
        },
        "required": [
          "running",
          "camera_root",
          "pending_tasks",
          "observer_type"
        ],
        "title": "FileWatcherStatusResponse",
        "type": "object"
      },
      "FlushQueuesResponse": {
        "description": "Response schema for queue flush endpoint.",
        "properties": {
          "duration_seconds": {
            "title": "Duration Seconds",
            "type": "number"
          },
          "items_cleared": {
            "additionalProperties": {
              "type": "integer"
            },
            "title": "Items Cleared",
            "type": "object"
          },
          "message": {
            "title": "Message",
            "type": "string"
          },
          "queues_flushed": {
            "items": {
              "type": "string"
            },
            "title": "Queues Flushed",
            "type": "array"
          }
        },
        "required": [
          "queues_flushed",
          "items_cleared",
          "duration_seconds",
          "message"
        ],
        "title": "FlushQueuesResponse",
        "type": "object"
      },
      "FrontendLogBatchRequest": {
        "description": "Batch request for multiple frontend log entries.\n\nThe frontend batches log entries to reduce API calls. Each batch may\ncontain logs from different components or at different levels.\n\nAttributes:\n    entries: List of log entries to ingest (1-100 entries)",
        "example": {
          "entries": [
            {
              "component": "App",
              "level": "INFO",
              "message": "Page loaded successfully",
              "timestamp": "2024-01-15T10:30:00Z"
            },
            {
              "component": "API",
              "extra": {
                "endpoint": "/api/events",
                "status": 500
              },
              "level": "ERROR",
              "message": "API call failed",
              "timestamp": "2024-01-15T10:30:01Z"
            }
          ]
        },
        "properties": {
          "entries": {
            "description": "List of log entries to ingest (1-100 entries)",
            "items": {
              "$ref": "#/components/schemas/FrontendLogEntry"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Entries",
            "type": "array"
          }
        },
        "required": [
          "entries"
        ],
        "title": "FrontendLogBatchRequest",
        "type": "object"
      },
      "FrontendLogEntry": {
        "description": "A single log entry from the frontend.\n\nThis schema matches the structure sent by the frontend logger.ts service.\nAll fields except level and message are optional to allow flexibility in\nwhat context the frontend can provide.\n\nAttributes:\n    level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    message: The log message content\n    timestamp: When the log was created (ISO 8601 format)\n    component: Frontend component name (e.g., \"Dashboard\", \"AlertForm\")\n    context: Additional structured context data (renamed from 'extra' in frontend)\n    url: Browser URL where the log was generated\n    user_agent: Browser user agent string",
        "example": {
          "component": "Dashboard",
          "extra": {
            "error_code": "API_TIMEOUT",
            "retry_count": 3,
            "url": "https://example.com/dashboard"
          },
          "level": "ERROR",
          "message": "Failed to load dashboard data",
          "timestamp": "2024-01-15T10:30:00Z",
          "url": "https://example.com/dashboard"
        },
        "properties": {
          "component": {
            "anyOf": [
              {
                "maxLength": 100,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Frontend component name",
            "title": "Component"
          },
          "extra": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional structured context data",
            "title": "Extra"
          },
          "level": {
            "$ref": "#/components/schemas/FrontendLogLevel",
            "description": "Log level"
          },
          "message": {
            "description": "Log message content",
            "maxLength": 10000,
            "minLength": 1,
            "title": "Message",
            "type": "string"
          },
          "timestamp": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the log was created (ISO 8601 format)",
            "title": "Timestamp"
          },
          "url": {
            "anyOf": [
              {
                "maxLength": 2000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Browser URL where log was generated",
            "title": "Url"
          },
          "user_agent": {
            "anyOf": [
              {
                "maxLength": 500,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Browser user agent string",
            "title": "User Agent"
          }
        },
        "required": [
          "level",
          "message"
        ],
        "title": "FrontendLogEntry",
        "type": "object"
      },
      "FrontendLogLevel": {
        "description": "Supported frontend log levels.\n\nThese correspond to the log levels used by the frontend logger.ts service.",
        "enum": [
          "DEBUG",
          "INFO",
          "WARNING",
          "ERROR",
          "CRITICAL"
        ],
        "title": "FrontendLogLevel",
        "type": "string"
      },
      "FrontendLogResponse": {
        "description": "Response from the frontend log ingestion endpoints.\n\nAttributes:\n    success: Whether the ingestion was successful\n    count: Number of log entries successfully ingested\n    message: Human-readable status message",
        "example": {
          "count": 5,
          "message": "Successfully ingested 5 log entry(ies)",
          "success": true
        },
        "properties": {
          "count": {
            "description": "Number of entries successfully ingested",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable status message",
            "title": "Message"
          },
          "success": {
            "description": "Whether ingestion was successful",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success",
          "count"
        ],
        "title": "FrontendLogResponse",
        "type": "object"
      },
      "FullHealthResponse": {
        "description": "Comprehensive health check response for GET /api/system/health/full.\n\nAggregates health status from all services:\n- Infrastructure (postgres, redis)\n- AI services (yolo26, nemotron, florence, clip, enrichment)\n- Circuit breakers\n- Background workers\n\nHTTP Status Codes:\n- 200: System is healthy or degraded (can still serve traffic)\n- 503: Critical services are unhealthy (should not receive traffic)",
        "example": {
          "ai_services": [
            {
              "circuit_state": "closed",
              "display_name": "YOLO26v2 Object Detection",
              "last_check": "2026-01-08T10:30:00Z",
              "name": "yolo26",
              "response_time_ms": 45.2,
              "status": "healthy",
              "url": "http://ai-detector:8090"
            }
          ],
          "circuit_breakers": {
            "breakers": {
              "nemotron": "closed",
              "yolo26": "closed"
            },
            "closed": 5,
            "half_open": 0,
            "open": 0,
            "total": 5
          },
          "message": "All systems operational",
          "postgres": {
            "message": "Database operational",
            "name": "postgres",
            "status": "healthy"
          },
          "ready": true,
          "redis": {
            "details": {
              "redis_version": "7.4.0"
            },
            "message": "Redis connected",
            "name": "redis",
            "status": "healthy"
          },
          "status": "healthy",
          "timestamp": "2026-01-08T10:30:00Z",
          "version": "0.1.0",
          "workers": [
            {
              "critical": true,
              "name": "file_watcher",
              "running": true
            }
          ]
        },
        "properties": {
          "ai_services": {
            "description": "Health status of all AI services",
            "items": {
              "$ref": "#/components/schemas/AIServiceHealthStatus"
            },
            "title": "Ai Services",
            "type": "array"
          },
          "circuit_breakers": {
            "$ref": "#/components/schemas/CircuitBreakerSummary",
            "description": "Circuit breaker summary"
          },
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "postgres": {
            "$ref": "#/components/schemas/InfrastructureHealthStatus",
            "description": "PostgreSQL health status"
          },
          "ready": {
            "description": "Whether system is ready to receive traffic",
            "title": "Ready",
            "type": "boolean"
          },
          "redis": {
            "$ref": "#/components/schemas/InfrastructureHealthStatus",
            "description": "Redis health status"
          },
          "status": {
            "$ref": "#/components/schemas/ServiceHealthState",
            "description": "Overall system health status"
          },
          "timestamp": {
            "description": "Response timestamp",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "version": {
            "description": "Application version",
            "title": "Version",
            "type": "string"
          },
          "workers": {
            "description": "Background worker statuses",
            "items": {
              "$ref": "#/components/schemas/WorkerHealthStatus"
            },
            "title": "Workers",
            "type": "array"
          }
        },
        "required": [
          "status",
          "ready",
          "message",
          "postgres",
          "redis",
          "ai_services",
          "circuit_breakers",
          "workers",
          "timestamp",
          "version"
        ],
        "title": "FullHealthResponse",
        "type": "object"
      },
      "GPUStatsHistoryResponse": {
        "description": "Response schema for GPU stats history endpoint.\n\nUses standard pagination envelope format (NEM-2178):\n- items: GPU stats samples (renamed from 'samples')\n- pagination: Standard pagination metadata",
        "example": {
          "items": [
            {
              "gpu_name": "NVIDIA RTX A5500",
              "inference_fps": 30.5,
              "memory_total": 24000,
              "memory_used": 12000,
              "power_usage": 150.0,
              "recorded_at": "2025-12-27T10:30:00Z",
              "temperature": 65.0,
              "utilization": 75.5
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 300,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "GPU stats samples (chronological order)",
            "items": {
              "$ref": "#/components/schemas/GPUStatsSample"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "GPUStatsHistoryResponse",
        "type": "object"
      },
      "GPUStatsResponse": {
        "description": "Response schema for GPU statistics endpoint.",
        "example": {
          "bar1_used": 256,
          "compute_processes_count": 2,
          "decoder_utilization": 0,
          "encoder_utilization": 0,
          "fan_speed": 45,
          "gpu_name": "NVIDIA RTX A5500",
          "inference_fps": 30.5,
          "memory_bandwidth_utilization": 35.2,
          "memory_clock": 8001,
          "memory_clock_max": 8501,
          "memory_total": 24000,
          "memory_used": 12000,
          "pcie_link_gen": 4,
          "pcie_link_width": 16,
          "pcie_replay_counter": 0,
          "pcie_rx_throughput": 95000,
          "pcie_tx_throughput": 120000,
          "power_limit": 230.0,
          "power_usage": 150.0,
          "pstate": 0,
          "sm_clock": 1800,
          "sm_clock_max": 1980,
          "temp_slowdown_threshold": 83.0,
          "temperature": 65.0,
          "throttle_reasons": 0,
          "utilization": 75.5
        },
        "properties": {
          "bar1_used": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "BAR1 memory used in MB",
            "title": "Bar1 Used"
          },
          "compute_processes_count": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of active compute processes",
            "title": "Compute Processes Count"
          },
          "decoder_utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video decoder utilization percentage (0-100)",
            "title": "Decoder Utilization"
          },
          "encoder_utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Video encoder utilization percentage (0-100)",
            "title": "Encoder Utilization"
          },
          "fan_speed": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU fan speed percentage (0-100)",
            "title": "Fan Speed"
          },
          "gpu_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU device name (e.g., 'NVIDIA RTX A5500')",
            "title": "Gpu Name"
          },
          "inference_fps": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Inference frames per second",
            "title": "Inference Fps"
          },
          "memory_bandwidth_utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Memory controller utilization percentage (0-100)",
            "title": "Memory Bandwidth Utilization"
          },
          "memory_clock": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current memory clock frequency in MHz",
            "title": "Memory Clock"
          },
          "memory_clock_max": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum memory clock frequency in MHz",
            "title": "Memory Clock Max"
          },
          "memory_total": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total GPU memory in MB",
            "title": "Memory Total"
          },
          "memory_used": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU memory used in MB",
            "title": "Memory Used"
          },
          "pcie_link_gen": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe link generation (1-4)",
            "title": "Pcie Link Gen"
          },
          "pcie_link_width": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe link width (1, 2, 4, 8, 16)",
            "title": "Pcie Link Width"
          },
          "pcie_replay_counter": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe replay counter (error indicator, should be low)",
            "title": "Pcie Replay Counter"
          },
          "pcie_rx_throughput": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe RX throughput in KB/s",
            "title": "Pcie Rx Throughput"
          },
          "pcie_tx_throughput": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe TX throughput in KB/s",
            "title": "Pcie Tx Throughput"
          },
          "power_limit": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Power limit in watts",
            "title": "Power Limit"
          },
          "power_usage": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU power usage in watts",
            "title": "Power Usage"
          },
          "pstate": {
            "anyOf": [
              {
                "maximum": 15.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Performance state (P0=max performance, P15=idle)",
            "title": "Pstate"
          },
          "sm_clock": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current SM clock frequency in MHz",
            "title": "Sm Clock"
          },
          "sm_clock_max": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum SM clock frequency in MHz",
            "title": "Sm Clock Max"
          },
          "temp_slowdown_threshold": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Temperature threshold for slowdown in Celsius",
            "title": "Temp Slowdown Threshold"
          },
          "temperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU temperature in Celsius",
            "title": "Temperature"
          },
          "throttle_reasons": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bitfield of current throttle reasons (0=none)",
            "title": "Throttle Reasons"
          },
          "utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU utilization percentage (0-100)",
            "title": "Utilization"
          }
        },
        "title": "GPUStatsResponse",
        "type": "object"
      },
      "GPUStatsSample": {
        "description": "Single time-series sample of GPU statistics.",
        "properties": {
          "bar1_used": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "BAR1 memory used in MB",
            "title": "Bar1 Used"
          },
          "compute_processes_count": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Active compute processes",
            "title": "Compute Processes Count"
          },
          "decoder_utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Decoder utilization %",
            "title": "Decoder Utilization"
          },
          "encoder_utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Encoder utilization %",
            "title": "Encoder Utilization"
          },
          "fan_speed": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU fan speed percentage",
            "title": "Fan Speed"
          },
          "gpu_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU device name",
            "title": "Gpu Name"
          },
          "inference_fps": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Inference frames per second",
            "title": "Inference Fps"
          },
          "memory_bandwidth_utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Memory controller utilization %",
            "title": "Memory Bandwidth Utilization"
          },
          "memory_clock": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Memory clock in MHz",
            "title": "Memory Clock"
          },
          "memory_clock_max": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Max memory clock in MHz",
            "title": "Memory Clock Max"
          },
          "memory_total": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total GPU memory in MB",
            "title": "Memory Total"
          },
          "memory_used": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU memory used in MB",
            "title": "Memory Used"
          },
          "pcie_link_gen": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe link generation",
            "title": "Pcie Link Gen"
          },
          "pcie_link_width": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe link width",
            "title": "Pcie Link Width"
          },
          "pcie_replay_counter": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe replay counter",
            "title": "Pcie Replay Counter"
          },
          "pcie_rx_throughput": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe RX throughput KB/s",
            "title": "Pcie Rx Throughput"
          },
          "pcie_tx_throughput": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "PCIe TX throughput KB/s",
            "title": "Pcie Tx Throughput"
          },
          "power_limit": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Power limit in watts",
            "title": "Power Limit"
          },
          "power_usage": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU power usage in watts",
            "title": "Power Usage"
          },
          "pstate": {
            "anyOf": [
              {
                "maximum": 15.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Performance state (P0-P15)",
            "title": "Pstate"
          },
          "recorded_at": {
            "description": "When the GPU sample was recorded (UTC)",
            "format": "date-time",
            "title": "Recorded At",
            "type": "string"
          },
          "sm_clock": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current SM clock in MHz",
            "title": "Sm Clock"
          },
          "sm_clock_max": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Max SM clock in MHz",
            "title": "Sm Clock Max"
          },
          "temp_slowdown_threshold": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Slowdown temp threshold",
            "title": "Temp Slowdown Threshold"
          },
          "temperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU temperature in Celsius",
            "title": "Temperature"
          },
          "throttle_reasons": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Throttle reasons bitfield",
            "title": "Throttle Reasons"
          },
          "utilization": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU utilization percentage (0-100)",
            "title": "Utilization"
          }
        },
        "required": [
          "recorded_at"
        ],
        "title": "GPUStatsSample",
        "type": "object"
      },
      "GpuApplyResponse": {
        "description": "Response schema for applying GPU configuration.\n\nReturns the result of applying GPU configuration changes,\nincluding which services were restarted and any warnings.",
        "example": {
          "restarted_services": [
            "ai-enrichment"
          ],
          "service_statuses": [
            {
              "service": "ai-enrichment",
              "status": "starting"
            }
          ],
          "success": true,
          "warnings": []
        },
        "properties": {
          "restarted_services": {
            "description": "Services that were restarted to apply changes",
            "items": {
              "type": "string"
            },
            "title": "Restarted Services",
            "type": "array"
          },
          "service_statuses": {
            "description": "Status of each affected service after apply",
            "items": {
              "$ref": "#/components/schemas/ServiceStatus"
            },
            "title": "Service Statuses",
            "type": "array"
          },
          "success": {
            "description": "Whether the configuration was applied successfully",
            "title": "Success",
            "type": "boolean"
          },
          "warnings": {
            "description": "Warnings about the configuration",
            "items": {
              "type": "string"
            },
            "title": "Warnings",
            "type": "array"
          }
        },
        "required": [
          "success"
        ],
        "title": "GpuApplyResponse",
        "type": "object"
      },
      "GpuAssignment": {
        "description": "Schema for a single service-to-GPU assignment.\n\nMaps an AI service to a specific GPU with optional VRAM budget override.",
        "example": {
          "gpu_index": 1,
          "service": "ai-enrichment",
          "vram_budget_override": 3.5
        },
        "properties": {
          "gpu_index": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Target GPU index (null for auto-assign)",
            "title": "Gpu Index"
          },
          "service": {
            "description": "Service name (e.g., 'ai-llm', 'ai-detector')",
            "maxLength": 64,
            "minLength": 1,
            "title": "Service",
            "type": "string"
          },
          "vram_budget_override": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Override VRAM budget in GB (for services with dynamic VRAM needs)",
            "title": "Vram Budget Override"
          }
        },
        "required": [
          "service"
        ],
        "title": "GpuAssignment",
        "type": "object"
      },
      "GpuAssignmentStrategy": {
        "description": "GPU assignment strategies for AI services.\n\nStrategies determine how models are distributed across GPUs:\n- MANUAL: User controls each assignment explicitly\n- VRAM_BASED: Largest models assigned to GPU with most VRAM\n- LATENCY_OPTIMIZED: Critical path models on fastest GPU\n- ISOLATION_FIRST: LLM gets dedicated GPU, others share\n- BALANCED: Distribute VRAM evenly across GPUs",
        "enum": [
          "manual",
          "vram_based",
          "latency_optimized",
          "isolation_first",
          "balanced"
        ],
        "title": "GpuAssignmentStrategy",
        "type": "string"
      },
      "GpuConfigPreviewResponse": {
        "description": "Response schema for previewing auto-assignment.\n\nReturns the proposed assignments for a given strategy without applying.",
        "example": {
          "proposed_assignments": [
            {
              "gpu_index": 0,
              "service": "ai-llm"
            },
            {
              "gpu_index": 0,
              "service": "ai-detector"
            },
            {
              "gpu_index": 1,
              "service": "ai-enrichment",
              "vram_budget_override": 3.5
            }
          ],
          "strategy": "vram_based",
          "warnings": [
            "ai-enrichment VRAM budget (6.8 GB) exceeds GPU 1 (4 GB). Suggested budget: 3.5 GB."
          ]
        },
        "properties": {
          "proposed_assignments": {
            "description": "Proposed service-to-GPU assignments",
            "items": {
              "$ref": "#/components/schemas/GpuAssignment"
            },
            "title": "Proposed Assignments",
            "type": "array"
          },
          "strategy": {
            "$ref": "#/components/schemas/GpuAssignmentStrategy",
            "description": "Strategy used for preview"
          },
          "warnings": {
            "description": "Warnings about the proposed configuration",
            "items": {
              "type": "string"
            },
            "title": "Warnings",
            "type": "array"
          }
        },
        "required": [
          "strategy",
          "proposed_assignments"
        ],
        "title": "GpuConfigPreviewResponse",
        "type": "object"
      },
      "GpuConfigResponse": {
        "description": "Response schema for current GPU configuration.\n\nReturns the current assignment strategy and all service-to-GPU mappings.",
        "example": {
          "assignments": [
            {
              "gpu_index": 0,
              "service": "ai-llm"
            },
            {
              "gpu_index": 0,
              "service": "ai-detector"
            },
            {
              "gpu_index": 1,
              "service": "ai-enrichment",
              "vram_budget_override": 3.5
            }
          ],
          "strategy": "manual",
          "updated_at": "2026-01-23T10:30:00Z"
        },
        "properties": {
          "assignments": {
            "description": "List of service-to-GPU assignments",
            "items": {
              "$ref": "#/components/schemas/GpuAssignment"
            },
            "title": "Assignments",
            "type": "array"
          },
          "strategy": {
            "$ref": "#/components/schemas/GpuAssignmentStrategy",
            "description": "Current GPU assignment strategy"
          },
          "updated_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of last configuration update",
            "title": "Updated At"
          }
        },
        "required": [
          "strategy",
          "assignments"
        ],
        "title": "GpuConfigResponse",
        "type": "object"
      },
      "GpuConfigStatusResponse": {
        "description": "Response schema for GPU configuration apply status.\n\nReturns the current status of a GPU configuration apply operation.",
        "example": {
          "in_progress": false,
          "service_statuses": [
            {
              "service": "ai-enrichment",
              "status": "running"
            }
          ],
          "services_completed": [
            "ai-enrichment"
          ],
          "services_pending": []
        },
        "properties": {
          "in_progress": {
            "description": "Whether an apply operation is currently in progress",
            "title": "In Progress",
            "type": "boolean"
          },
          "service_statuses": {
            "description": "Current status of all affected services",
            "items": {
              "$ref": "#/components/schemas/ServiceStatus"
            },
            "title": "Service Statuses",
            "type": "array"
          },
          "services_completed": {
            "description": "Services that have completed restart",
            "items": {
              "type": "string"
            },
            "title": "Services Completed",
            "type": "array"
          },
          "services_pending": {
            "description": "Services still pending restart",
            "items": {
              "type": "string"
            },
            "title": "Services Pending",
            "type": "array"
          }
        },
        "required": [
          "in_progress"
        ],
        "title": "GpuConfigStatusResponse",
        "type": "object"
      },
      "GpuConfigUpdateRequest": {
        "description": "Request schema for updating GPU configuration.\n\nAllows updating the assignment strategy and/or individual assignments.",
        "example": {
          "assignments": [
            {
              "gpu_index": 0,
              "service": "ai-llm"
            },
            {
              "gpu_index": 0,
              "service": "ai-detector"
            },
            {
              "gpu_index": 1,
              "service": "ai-enrichment",
              "vram_budget_override": 3.5
            }
          ],
          "strategy": "manual"
        },
        "properties": {
          "assignments": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/GpuAssignment"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Service-to-GPU assignments (null to keep current)",
            "title": "Assignments"
          },
          "strategy": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GpuAssignmentStrategy"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU assignment strategy (null to keep current)"
          }
        },
        "title": "GpuConfigUpdateRequest",
        "type": "object"
      },
      "GpuConfigUpdateResponse": {
        "description": "Response schema for GPU configuration update.\n\nReturns success status and any warnings about the configuration.",
        "example": {
          "success": true,
          "warnings": [
            "ai-enrichment VRAM budget (6.8 GB) exceeds GPU 1 (4 GB). Auto-adjusted to 3.5 GB."
          ]
        },
        "properties": {
          "success": {
            "description": "Whether the configuration was saved successfully",
            "title": "Success",
            "type": "boolean"
          },
          "warnings": {
            "description": "Warnings about the configuration (e.g., VRAM overages)",
            "items": {
              "type": "string"
            },
            "title": "Warnings",
            "type": "array"
          }
        },
        "required": [
          "success"
        ],
        "title": "GpuConfigUpdateResponse",
        "type": "object"
      },
      "GpuDeviceResponse": {
        "description": "Response schema for a detected GPU device.\n\nContains metadata about a GPU including VRAM capacity\nand current utilization.",
        "example": {
          "compute_capability": "8.6",
          "index": 0,
          "name": "RTX A5500",
          "vram_total_mb": 24564,
          "vram_used_mb": 19304
        },
        "properties": {
          "compute_capability": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "CUDA compute capability (e.g., '8.6')",
            "title": "Compute Capability"
          },
          "index": {
            "description": "GPU index (0-based)",
            "minimum": 0.0,
            "title": "Index",
            "type": "integer"
          },
          "name": {
            "description": "GPU name (e.g., 'NVIDIA RTX A5500')",
            "title": "Name",
            "type": "string"
          },
          "vram_total_mb": {
            "description": "Total VRAM in megabytes",
            "minimum": 0.0,
            "title": "Vram Total Mb",
            "type": "integer"
          },
          "vram_used_mb": {
            "description": "Currently used VRAM in megabytes",
            "minimum": 0.0,
            "title": "Vram Used Mb",
            "type": "integer"
          }
        },
        "required": [
          "index",
          "name",
          "vram_total_mb",
          "vram_used_mb"
        ],
        "title": "GpuDeviceResponse",
        "type": "object"
      },
      "GpuDevicesResponse": {
        "description": "Response schema for listing detected GPUs.",
        "example": {
          "gpus": [
            {
              "compute_capability": "8.6",
              "index": 0,
              "name": "RTX A5500",
              "vram_total_mb": 24564,
              "vram_used_mb": 19304
            },
            {
              "compute_capability": "8.6",
              "index": 1,
              "name": "RTX A400",
              "vram_total_mb": 4094,
              "vram_used_mb": 329
            }
          ]
        },
        "properties": {
          "gpus": {
            "description": "List of detected GPU devices",
            "items": {
              "$ref": "#/components/schemas/GpuDeviceResponse"
            },
            "title": "Gpus",
            "type": "array"
          }
        },
        "required": [
          "gpus"
        ],
        "title": "GpuDevicesResponse",
        "type": "object"
      },
      "GpuMetrics": {
        "description": "GPU metrics from nvidia-smi / pynvml.",
        "example": {
          "name": "NVIDIA RTX A5500",
          "power_watts": 31,
          "temperature": 38,
          "utilization": 38.0,
          "vram_percent": 94.58,
          "vram_total_gb": 24.0,
          "vram_used_gb": 22.7
        },
        "properties": {
          "name": {
            "description": "GPU device name (e.g., 'NVIDIA RTX A5500')",
            "title": "Name",
            "type": "string"
          },
          "power_watts": {
            "description": "GPU power usage in Watts",
            "minimum": 0.0,
            "title": "Power Watts",
            "type": "integer"
          },
          "temperature": {
            "description": "GPU temperature in Celsius",
            "minimum": 0.0,
            "title": "Temperature",
            "type": "integer"
          },
          "utilization": {
            "description": "GPU utilization percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Utilization",
            "type": "number"
          },
          "vram_percent": {
            "description": "VRAM usage percentage (0-100), computed from vram_used_gb/vram_total_gb",
            "readOnly": true,
            "title": "Vram Percent",
            "type": "number"
          },
          "vram_total_gb": {
            "description": "Total VRAM in GB",
            "exclusiveMinimum": 0.0,
            "title": "Vram Total Gb",
            "type": "number"
          },
          "vram_used_gb": {
            "description": "VRAM used in GB",
            "minimum": 0.0,
            "title": "Vram Used Gb",
            "type": "number"
          }
        },
        "required": [
          "name",
          "utilization",
          "vram_used_gb",
          "vram_total_gb",
          "temperature",
          "power_watts",
          "vram_percent"
        ],
        "title": "GpuMetrics",
        "type": "object"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "title": "Detail",
            "type": "array"
          }
        },
        "title": "HTTPValidationError",
        "type": "object"
      },
      "HealthCheckServiceStatus": {
        "description": "Status information for a service component in health checks.\n\nNote: Renamed from ServiceStatus to avoid name collision with\nbackend.api.schemas.services.ServiceStatus (orchestrator enum).",
        "properties": {
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional service-specific details (may contain nested objects)",
            "title": "Details"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional status message or error details",
            "title": "Message"
          },
          "status": {
            "description": "Service status: healthy, unhealthy, or not_initialized",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "status"
        ],
        "title": "HealthCheckServiceStatus",
        "type": "object"
      },
      "HealthEventResponse": {
        "description": "Schema for a health event in the failure history.\n\nRepresents a single health-related event such as a failure, recovery, or restart.",
        "example": {
          "event_type": "failure",
          "message": "Health check failed: connection refused",
          "service": "redis",
          "timestamp": "2025-12-23T10:30:00Z"
        },
        "properties": {
          "event_type": {
            "description": "Type of event: 'failure', 'recovery', or 'restart'",
            "title": "Event Type",
            "type": "string"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional descriptive message about the event",
            "title": "Message"
          },
          "service": {
            "description": "Name of the service this event relates to",
            "title": "Service",
            "type": "string"
          },
          "timestamp": {
            "description": "When the event occurred (UTC)",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "service",
          "event_type"
        ],
        "title": "HealthEventResponse",
        "type": "object"
      },
      "HealthResponse": {
        "description": "Response schema for health check endpoint.",
        "example": {
          "recent_events": [
            {
              "event_type": "recovery",
              "message": "Service recovered",
              "service": "redis",
              "timestamp": "2025-12-23T10:25:00Z"
            },
            {
              "event_type": "failure",
              "message": "Health check failed",
              "service": "redis",
              "timestamp": "2025-12-23T10:20:00Z"
            }
          ],
          "services": {
            "ai": {
              "message": "AI services operational",
              "status": "healthy"
            },
            "database": {
              "message": "Database operational",
              "status": "healthy"
            },
            "redis": {
              "details": {
                "redis_version": "7.0.0"
              },
              "message": "Redis connected",
              "status": "healthy"
            }
          },
          "status": "healthy",
          "timestamp": "2025-12-23T10:30:00"
        },
        "properties": {
          "recent_events": {
            "description": "Recent health events for debugging intermittent issues",
            "items": {
              "$ref": "#/components/schemas/HealthEventResponse"
            },
            "title": "Recent Events",
            "type": "array"
          },
          "services": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HealthCheckServiceStatus"
            },
            "description": "Status of individual services (database, redis, ai)",
            "title": "Services",
            "type": "object"
          },
          "status": {
            "description": "Overall system status: healthy, degraded, or unhealthy",
            "title": "Status",
            "type": "string"
          },
          "timestamp": {
            "description": "Timestamp of health check",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "status",
          "services",
          "timestamp"
        ],
        "title": "HealthResponse",
        "type": "object"
      },
      "HeatmapListResponse": {
        "description": "Response containing a list of heatmap metadata records.\n\nUsed for querying historical heatmaps without the full image data.\n\nAttributes:\n    heatmaps: List of heatmap metadata records.\n    total: Total number of heatmaps matching the query.",
        "example": {
          "heatmaps": [
            {
              "camera_id": "front_door",
              "created_at": "2026-01-26T11:00:00Z",
              "height": 48,
              "id": 1,
              "resolution": "hourly",
              "time_bucket": "2026-01-26T10:00:00Z",
              "total_detections": 150,
              "updated_at": "2026-01-26T11:00:00Z",
              "width": 64
            }
          ],
          "total": 1
        },
        "properties": {
          "heatmaps": {
            "description": "List of heatmap metadata records",
            "items": {
              "$ref": "#/components/schemas/HeatmapMetadata"
            },
            "title": "Heatmaps",
            "type": "array"
          },
          "total": {
            "description": "Total number of heatmaps matching the query",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "heatmaps",
          "total"
        ],
        "title": "HeatmapListResponse",
        "type": "object"
      },
      "HeatmapMetadata": {
        "description": "Metadata about a heatmap record.\n\nAttributes:\n    id: Unique identifier of the heatmap record.\n    camera_id: ID of the camera this heatmap belongs to.\n    time_bucket: Start time of the aggregation period.\n    resolution: Aggregation resolution (hourly, daily, weekly).\n    width: Width of the heatmap grid in pixels.\n    height: Height of the heatmap grid in pixels.\n    total_detections: Total number of detections in this time bucket.\n    created_at: When this record was created.\n    updated_at: When this record was last updated.",
        "example": {
          "camera_id": "front_door",
          "created_at": "2026-01-26T11:00:00Z",
          "height": 48,
          "id": 1,
          "resolution": "hourly",
          "time_bucket": "2026-01-26T10:00:00Z",
          "total_detections": 150,
          "updated_at": "2026-01-26T11:00:00Z",
          "width": 64
        },
        "properties": {
          "camera_id": {
            "description": "ID of the camera this heatmap belongs to",
            "title": "Camera Id",
            "type": "string"
          },
          "created_at": {
            "description": "When this record was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "height": {
            "description": "Height of the heatmap grid in pixels",
            "minimum": 1.0,
            "title": "Height",
            "type": "integer"
          },
          "id": {
            "description": "Unique identifier of the heatmap record",
            "title": "Id",
            "type": "integer"
          },
          "resolution": {
            "$ref": "#/components/schemas/HeatmapResolution",
            "description": "Aggregation resolution (hourly, daily, weekly)"
          },
          "time_bucket": {
            "description": "Start time of the aggregation period",
            "format": "date-time",
            "title": "Time Bucket",
            "type": "string"
          },
          "total_detections": {
            "description": "Total number of detections in this time bucket",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          },
          "updated_at": {
            "description": "When this record was last updated",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "width": {
            "description": "Width of the heatmap grid in pixels",
            "minimum": 1.0,
            "title": "Width",
            "type": "integer"
          }
        },
        "required": [
          "id",
          "camera_id",
          "time_bucket",
          "resolution",
          "width",
          "height",
          "total_detections",
          "created_at",
          "updated_at"
        ],
        "title": "HeatmapMetadata",
        "type": "object"
      },
      "HeatmapResolution": {
        "description": "Resolution levels for heatmap data aggregation.",
        "enum": [
          "hourly",
          "daily",
          "weekly"
        ],
        "title": "HeatmapResolution",
        "type": "string"
      },
      "HeatmapResponse": {
        "description": "Response containing a heatmap image and metadata.\n\nThe image is returned as a base64-encoded PNG string that can be\ndirectly used in HTML img tags or decoded for further processing.\n\nAttributes:\n    camera_id: ID of the camera this heatmap belongs to.\n    resolution: Aggregation resolution used.\n    time_bucket: Start time of the aggregation period.\n    image_base64: Base64-encoded PNG image of the heatmap.\n    width: Width of the heatmap image in pixels.\n    height: Height of the heatmap image in pixels.\n    total_detections: Total detections used to generate this heatmap.\n    colormap: Name of the colormap used (e.g., 'jet', 'hot', 'viridis').",
        "example": {
          "camera_id": "front_door",
          "colormap": "jet",
          "height": 480,
          "image_base64": "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk...",
          "resolution": "hourly",
          "time_bucket": "2026-01-26T10:00:00Z",
          "total_detections": 150,
          "width": 640
        },
        "properties": {
          "camera_id": {
            "description": "ID of the camera this heatmap belongs to",
            "title": "Camera Id",
            "type": "string"
          },
          "colormap": {
            "default": "jet",
            "description": "Name of the colormap used (e.g., 'jet', 'hot', 'viridis')",
            "title": "Colormap",
            "type": "string"
          },
          "height": {
            "description": "Height of the heatmap image in pixels",
            "minimum": 1.0,
            "title": "Height",
            "type": "integer"
          },
          "image_base64": {
            "description": "Base64-encoded PNG image of the heatmap",
            "title": "Image Base64",
            "type": "string"
          },
          "resolution": {
            "$ref": "#/components/schemas/HeatmapResolution",
            "description": "Aggregation resolution used"
          },
          "time_bucket": {
            "description": "Start time of the aggregation period",
            "format": "date-time",
            "title": "Time Bucket",
            "type": "string"
          },
          "total_detections": {
            "description": "Total detections used to generate this heatmap",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          },
          "width": {
            "description": "Width of the heatmap image in pixels",
            "minimum": 1.0,
            "title": "Width",
            "type": "integer"
          }
        },
        "required": [
          "camera_id",
          "resolution",
          "time_bucket",
          "image_base64",
          "width",
          "height",
          "total_detections"
        ],
        "title": "HeatmapResponse",
        "type": "object"
      },
      "HeatmapSnapshotRequest": {
        "description": "Request to force save the current heatmap accumulator.\n\nAttributes:\n    resolution: Resolution at which to save the snapshot.",
        "example": {
          "resolution": "hourly"
        },
        "properties": {
          "resolution": {
            "$ref": "#/components/schemas/HeatmapResolution",
            "default": "hourly",
            "description": "Resolution at which to save the snapshot"
          }
        },
        "title": "HeatmapSnapshotRequest",
        "type": "object"
      },
      "HeatmapSnapshotResponse": {
        "description": "Response after saving a heatmap snapshot.\n\nAttributes:\n    success: Whether the snapshot was saved successfully.\n    message: Status message.\n    heatmap_id: ID of the created heatmap record, if successful.\n    total_detections: Number of detections in the saved snapshot.",
        "example": {
          "heatmap_id": 42,
          "message": "Heatmap snapshot saved successfully",
          "success": true,
          "total_detections": 150
        },
        "properties": {
          "heatmap_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the created heatmap record, if successful",
            "title": "Heatmap Id"
          },
          "message": {
            "description": "Status message",
            "title": "Message",
            "type": "string"
          },
          "success": {
            "description": "Whether the snapshot was saved successfully",
            "title": "Success",
            "type": "boolean"
          },
          "total_detections": {
            "default": 0,
            "description": "Number of detections in the saved snapshot",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          }
        },
        "required": [
          "success",
          "message"
        ],
        "title": "HeatmapSnapshotResponse",
        "type": "object"
      },
      "HostMetrics": {
        "description": "Host system metrics from psutil.",
        "example": {
          "cpu_percent": 12,
          "disk_percent": 31.2,
          "disk_total_gb": 500,
          "disk_used_gb": 156,
          "ram_percent": 25.63,
          "ram_total_gb": 32,
          "ram_used_gb": 8.2
        },
        "properties": {
          "cpu_percent": {
            "description": "CPU utilization percentage",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Cpu Percent",
            "type": "number"
          },
          "disk_percent": {
            "description": "Disk usage percentage (0-100), computed from disk_used_gb/disk_total_gb",
            "readOnly": true,
            "title": "Disk Percent",
            "type": "number"
          },
          "disk_total_gb": {
            "description": "Total disk in GB",
            "exclusiveMinimum": 0.0,
            "title": "Disk Total Gb",
            "type": "number"
          },
          "disk_used_gb": {
            "description": "Disk used in GB",
            "minimum": 0.0,
            "title": "Disk Used Gb",
            "type": "number"
          },
          "ram_percent": {
            "description": "RAM usage percentage (0-100), computed from ram_used_gb/ram_total_gb",
            "readOnly": true,
            "title": "Ram Percent",
            "type": "number"
          },
          "ram_total_gb": {
            "description": "Total RAM in GB",
            "exclusiveMinimum": 0.0,
            "title": "Ram Total Gb",
            "type": "number"
          },
          "ram_used_gb": {
            "description": "RAM used in GB",
            "minimum": 0.0,
            "title": "Ram Used Gb",
            "type": "number"
          }
        },
        "required": [
          "cpu_percent",
          "ram_used_gb",
          "ram_total_gb",
          "disk_used_gb",
          "disk_total_gb",
          "ram_percent",
          "disk_percent"
        ],
        "title": "HostMetrics",
        "type": "object"
      },
      "HourlyPattern": {
        "description": "Activity pattern for a specific hour.",
        "example": {
          "avg_detections": 2.5,
          "sample_count": 30,
          "std_dev": 0.8
        },
        "properties": {
          "avg_detections": {
            "description": "Average number of detections during this hour",
            "minimum": 0.0,
            "title": "Avg Detections",
            "type": "number"
          },
          "sample_count": {
            "description": "Number of samples used for this calculation",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          },
          "std_dev": {
            "description": "Standard deviation of detection count",
            "minimum": 0.0,
            "title": "Std Dev",
            "type": "number"
          }
        },
        "required": [
          "avg_detections",
          "std_dev",
          "sample_count"
        ],
        "title": "HourlyPattern",
        "type": "object"
      },
      "HouseholdCreate": {
        "description": "Schema for creating a new household.\n\nA household is the top-level organizational unit that groups members,\nvehicles, and properties together.",
        "example": {
          "name": "Svoboda Family"
        },
        "properties": {
          "name": {
            "description": "Household name (e.g., 'Svoboda Family')",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "title": "HouseholdCreate",
        "type": "object"
      },
      "HouseholdListResponse": {
        "description": "Schema for listing households.\n\nReturns a list of households with pagination metadata.",
        "example": {
          "items": [
            {
              "created_at": "2026-01-20T10:00:00Z",
              "id": 1,
              "name": "Svoboda Family"
            }
          ],
          "total": 1
        },
        "properties": {
          "items": {
            "description": "List of households",
            "items": {
              "$ref": "#/components/schemas/HouseholdResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "total": {
            "description": "Total number of households",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "items",
          "total"
        ],
        "title": "HouseholdListResponse",
        "type": "object"
      },
      "HouseholdMemberCreate": {
        "description": "Schema for creating a new household member.",
        "example": {
          "name": "John Doe",
          "notes": "Works from home on Fridays",
          "role": "resident",
          "trusted_level": "full",
          "typical_schedule": {
            "weekdays": "9-17",
            "weekends": "flexible"
          }
        },
        "properties": {
          "name": {
            "description": "Display name for the person",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "notes": {
            "anyOf": [
              {
                "maxLength": 1000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Free-form notes about the person",
            "title": "Notes"
          },
          "role": {
            "$ref": "#/components/schemas/MemberRole",
            "description": "Role/relationship of the person to the household"
          },
          "trusted_level": {
            "$ref": "#/components/schemas/TrustLevel",
            "description": "Trust level determining alert suppression behavior"
          },
          "typical_schedule": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "JSON object defining expected presence schedule",
            "title": "Typical Schedule"
          }
        },
        "required": [
          "name",
          "role",
          "trusted_level"
        ],
        "title": "HouseholdMemberCreate",
        "type": "object"
      },
      "HouseholdMemberResponse": {
        "description": "Schema for household member response.",
        "example": {
          "created_at": "2025-01-01T10:00:00Z",
          "id": 1,
          "name": "John Doe",
          "notes": "Works from home on Fridays",
          "role": "resident",
          "trusted_level": "full",
          "typical_schedule": {
            "weekdays": "9-17"
          },
          "updated_at": "2025-01-01T12:00:00Z"
        },
        "properties": {
          "created_at": {
            "description": "When the member was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "id": {
            "description": "Unique identifier for the household member",
            "title": "Id",
            "type": "integer"
          },
          "name": {
            "description": "Display name for the person",
            "title": "Name",
            "type": "string"
          },
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Notes about the person",
            "title": "Notes"
          },
          "role": {
            "$ref": "#/components/schemas/MemberRole",
            "description": "Role/relationship to the household"
          },
          "trusted_level": {
            "$ref": "#/components/schemas/TrustLevel",
            "description": "Trust level for alert behavior"
          },
          "typical_schedule": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Expected presence schedule",
            "title": "Typical Schedule"
          },
          "updated_at": {
            "description": "When the member was last updated",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "role",
          "trusted_level",
          "created_at",
          "updated_at"
        ],
        "title": "HouseholdMemberResponse",
        "type": "object"
      },
      "HouseholdMemberUpdate": {
        "description": "Schema for updating an existing household member.",
        "example": {
          "name": "John Doe Updated",
          "notes": "Now works remotely full-time",
          "trusted_level": "partial"
        },
        "properties": {
          "name": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Display name for the person",
            "title": "Name"
          },
          "notes": {
            "anyOf": [
              {
                "maxLength": 1000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Free-form notes about the person",
            "title": "Notes"
          },
          "role": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MemberRole"
              },
              {
                "type": "null"
              }
            ],
            "description": "Role/relationship of the person to the household"
          },
          "trusted_level": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TrustLevel"
              },
              {
                "type": "null"
              }
            ],
            "description": "Trust level determining alert suppression behavior"
          },
          "typical_schedule": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "JSON object defining expected presence schedule",
            "title": "Typical Schedule"
          }
        },
        "title": "HouseholdMemberUpdate",
        "type": "object"
      },
      "HouseholdResponse": {
        "description": "Schema for household response.\n\nIncludes basic household information. Use nested endpoints or\nquery parameters to include related members, vehicles, or properties.",
        "example": {
          "created_at": "2026-01-20T10:00:00Z",
          "id": 1,
          "name": "Svoboda Family"
        },
        "properties": {
          "created_at": {
            "description": "Timestamp when household was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "id": {
            "description": "Unique household identifier",
            "title": "Id",
            "type": "integer"
          },
          "name": {
            "description": "Household name",
            "title": "Name",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "created_at"
        ],
        "title": "HouseholdResponse",
        "type": "object"
      },
      "HouseholdUpdate": {
        "description": "Schema for updating an existing household.\n\nAll fields are optional; only provided fields will be updated.",
        "example": {
          "name": "Svoboda-Smith Family"
        },
        "properties": {
          "name": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Household name",
            "title": "Name"
          }
        },
        "title": "HouseholdUpdate",
        "type": "object"
      },
      "ImageQualityEnrichment": {
        "description": "Image quality assessment results.",
        "example": {
          "is_blurry": false,
          "is_low_quality": false,
          "quality_issues": [],
          "score": 0.85
        },
        "properties": {
          "is_blurry": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether image is blurry",
            "title": "Is Blurry"
          },
          "is_low_quality": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether image has low quality",
            "title": "Is Low Quality"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          },
          "quality_change_detected": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether sudden quality change was detected",
            "title": "Quality Change Detected"
          },
          "quality_issues": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of detected quality issues",
            "title": "Quality Issues"
          },
          "score": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Quality score (0-100)",
            "title": "Score"
          }
        },
        "title": "ImageQualityEnrichment",
        "type": "object"
      },
      "InferenceMetrics": {
        "description": "AI inference latency and throughput metrics.",
        "example": {
          "nemotron_latency_ms": {
            "avg": 2100,
            "p95": 4800,
            "p99": 8200
          },
          "pipeline_latency_ms": {
            "avg": 3200,
            "p95": 6100
          },
          "queues": {
            "analysis": 0,
            "detection": 0
          },
          "throughput": {
            "events_per_min": 2.1,
            "images_per_min": 12.4
          },
          "yolo26_latency_ms": {
            "avg": 45,
            "p95": 82,
            "p99": 120
          }
        },
        "properties": {
          "nemotron_latency_ms": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "Nemotron latency stats (avg, p95, p99)",
            "title": "Nemotron Latency Ms",
            "type": "object"
          },
          "pipeline_latency_ms": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "Full pipeline latency stats (avg, p95)",
            "title": "Pipeline Latency Ms",
            "type": "object"
          },
          "queues": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Queue depths (detection, analysis)",
            "title": "Queues",
            "type": "object"
          },
          "throughput": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "Throughput metrics (images_per_min, events_per_min)",
            "title": "Throughput",
            "type": "object"
          },
          "yolo26_latency_ms": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "YOLO26v2 latency stats (avg, p95, p99)",
            "title": "Yolo26 Latency Ms",
            "type": "object"
          }
        },
        "required": [
          "yolo26_latency_ms",
          "nemotron_latency_ms",
          "pipeline_latency_ms",
          "throughput",
          "queues"
        ],
        "title": "InferenceMetrics",
        "type": "object"
      },
      "InfrastructureHealthStatus": {
        "description": "Health status for infrastructure services (postgres, redis).\n\nProvides detailed status including connection info and any error details.",
        "example": {
          "message": "Database operational",
          "name": "postgres",
          "status": "healthy"
        },
        "properties": {
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional details (e.g., redis version)",
            "title": "Details"
          },
          "message": {
            "description": "Status message or error description",
            "title": "Message",
            "type": "string"
          },
          "name": {
            "description": "Service name (e.g., 'postgres', 'redis')",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ServiceHealthState",
            "description": "Current health state"
          }
        },
        "required": [
          "name",
          "status",
          "message"
        ],
        "title": "InfrastructureHealthStatus",
        "type": "object"
      },
      "IntegrationType": {
        "description": "Pre-built integration types.",
        "enum": [
          "generic",
          "slack",
          "discord",
          "telegram",
          "teams"
        ],
        "title": "IntegrationType",
        "type": "string"
      },
      "JobAbortResponse": {
        "description": "Response model for job abort request.",
        "example": {
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "message": "Job abort requested - worker notified",
          "status": "failed"
        },
        "properties": {
          "job_id": {
            "description": "Job ID that is being aborted",
            "title": "Job Id",
            "type": "string"
          },
          "message": {
            "description": "Abort status message",
            "title": "Message",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatusEnum",
            "description": "New job status (aborting/failed)"
          }
        },
        "required": [
          "job_id",
          "status",
          "message"
        ],
        "title": "JobAbortResponse",
        "type": "object"
      },
      "JobAttemptResponse": {
        "description": "A single job execution attempt record.",
        "example": {
          "attempt_number": 1,
          "duration_seconds": 89.0,
          "ended_at": "2024-01-15T10:31:30Z",
          "result": {
            "processed": 1000
          },
          "started_at": "2024-01-15T10:30:01Z",
          "status": "succeeded",
          "worker_id": "worker-1"
        },
        "properties": {
          "attempt_number": {
            "description": "Sequential attempt number (1-based)",
            "minimum": 1.0,
            "title": "Attempt Number",
            "type": "integer"
          },
          "duration_seconds": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Duration in seconds if completed",
            "title": "Duration Seconds"
          },
          "ended_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When this attempt ended",
            "title": "Ended At"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if failed",
            "title": "Error"
          },
          "result": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Result data if successful",
            "title": "Result"
          },
          "started_at": {
            "description": "When this attempt started",
            "format": "date-time",
            "title": "Started At",
            "type": "string"
          },
          "status": {
            "description": "Status of this attempt (started, succeeded, failed, cancelled)",
            "title": "Status",
            "type": "string"
          },
          "worker_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of worker that processed this attempt",
            "title": "Worker Id"
          }
        },
        "required": [
          "attempt_number",
          "started_at",
          "status"
        ],
        "title": "JobAttemptResponse",
        "type": "object"
      },
      "JobCancelResponse": {
        "description": "Response model for job cancellation request.",
        "example": {
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "message": "Job cancellation requested",
          "status": "failed"
        },
        "properties": {
          "job_id": {
            "description": "Job ID that was cancelled",
            "title": "Job Id",
            "type": "string"
          },
          "message": {
            "description": "Cancellation status message",
            "title": "Message",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatusEnum",
            "description": "New job status after cancellation"
          }
        },
        "required": [
          "job_id",
          "status",
          "message"
        ],
        "title": "JobCancelResponse",
        "type": "object"
      },
      "JobDetailResponse": {
        "description": "Detailed response model for a single job.\n\nProvides comprehensive information about a job including progress details,\ntiming information, retry status, and execution metadata.\n\nNEM-2390: GET /api/jobs/{job_id} detail endpoint response.",
        "example": {
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "job_type": "ai_analysis",
          "metadata": {
            "input_params": {
              "event_ids": [
                "evt-1",
                "evt-2"
              ]
            },
            "worker_id": "worker-001"
          },
          "priority": 1,
          "progress": {
            "current_step": "Analyzing detections",
            "items_processed": 450,
            "items_total": 1000,
            "percent": 45
          },
          "queue_name": "high_priority",
          "retry_info": {
            "attempt_number": 1,
            "max_attempts": 3,
            "previous_errors": []
          },
          "status": "running",
          "timing": {
            "created_at": "2024-01-15T10:30:00Z",
            "duration_seconds": 45.5,
            "estimated_remaining_seconds": 55.0,
            "started_at": "2024-01-15T10:30:01Z"
          }
        },
        "properties": {
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message (if failed)",
            "title": "Error"
          },
          "id": {
            "description": "Unique job identifier",
            "title": "Id",
            "type": "string"
          },
          "job_type": {
            "description": "Type of job (e.g., 'export', 'ai_analysis')",
            "title": "Job Type",
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/JobMetadata",
            "description": "Job execution metadata"
          },
          "priority": {
            "default": 0,
            "description": "Job priority (0=lowest, 10=highest)",
            "maximum": 10.0,
            "minimum": 0.0,
            "title": "Priority",
            "type": "integer"
          },
          "progress": {
            "$ref": "#/components/schemas/JobProgressDetail",
            "description": "Detailed progress information"
          },
          "queue_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Name of the job queue",
            "title": "Queue Name"
          },
          "result": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "description": "Job result data (if completed)",
            "title": "Result"
          },
          "retry_info": {
            "$ref": "#/components/schemas/JobRetryInfo",
            "description": "Retry attempt information"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatusEnum",
            "description": "Current job status"
          },
          "timing": {
            "$ref": "#/components/schemas/JobTiming",
            "description": "Job timing and duration information"
          }
        },
        "required": [
          "id",
          "job_type",
          "status",
          "progress",
          "timing",
          "retry_info",
          "metadata"
        ],
        "title": "JobDetailResponse",
        "type": "object"
      },
      "JobHistoryResponse": {
        "description": "Complete job history with transitions and attempts.\n\nNEM-2396: GET /api/jobs/{job_id}/history endpoint response.",
        "example": {
          "attempts": [
            {
              "attempt_number": 1,
              "duration_seconds": 89.0,
              "ended_at": "2024-01-15T10:31:30Z",
              "result": {
                "events_exported": 1000
              },
              "started_at": "2024-01-15T10:30:01Z",
              "status": "succeeded",
              "worker_id": "worker-1"
            }
          ],
          "completed_at": "2024-01-15T10:31:30Z",
          "created_at": "2024-01-15T10:30:00Z",
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "job_type": "export",
          "started_at": "2024-01-15T10:30:01Z",
          "status": "completed",
          "transitions": [
            {
              "at": "2024-01-15T10:30:00Z",
              "to": "queued",
              "triggered_by": "api"
            },
            {
              "at": "2024-01-15T10:30:01Z",
              "details": {
                "worker_id": "worker-1"
              },
              "from": "queued",
              "to": "running",
              "triggered_by": "worker"
            },
            {
              "at": "2024-01-15T10:31:30Z",
              "from": "running",
              "to": "completed",
              "triggered_by": "worker"
            }
          ]
        },
        "properties": {
          "attempts": {
            "description": "Execution attempts in order",
            "items": {
              "$ref": "#/components/schemas/JobAttemptResponse"
            },
            "title": "Attempts",
            "type": "array"
          },
          "completed_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the job finished",
            "title": "Completed At"
          },
          "created_at": {
            "description": "When the job was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "job_id": {
            "description": "Unique job identifier",
            "title": "Job Id",
            "type": "string"
          },
          "job_type": {
            "description": "Type of job (e.g., 'export', 'cleanup')",
            "title": "Job Type",
            "type": "string"
          },
          "started_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When job execution started",
            "title": "Started At"
          },
          "status": {
            "description": "Current job status",
            "title": "Status",
            "type": "string"
          },
          "transitions": {
            "description": "State transitions in chronological order",
            "items": {
              "$ref": "#/components/schemas/JobTransitionResponse"
            },
            "title": "Transitions",
            "type": "array"
          }
        },
        "required": [
          "job_id",
          "job_type",
          "status",
          "created_at"
        ],
        "title": "JobHistoryResponse",
        "type": "object"
      },
      "JobListResponse": {
        "description": "Response model for listing jobs with pagination.\n\nUses the standardized pagination envelope format (NEM-2178).",
        "example": {
          "items": [
            {
              "created_at": "2024-01-15T10:30:00Z",
              "job_id": "550e8400-e29b-41d4-a716-446655440000",
              "job_type": "export",
              "message": "Exporting events: 450/1000",
              "progress": 45,
              "started_at": "2024-01-15T10:30:01Z",
              "status": "running"
            }
          ],
          "pagination": {
            "has_more": true,
            "limit": 50,
            "offset": 0,
            "total": 100
          }
        },
        "properties": {
          "items": {
            "description": "List of jobs",
            "items": {
              "$ref": "#/components/schemas/JobResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "JobListResponse",
        "type": "object"
      },
      "JobLogEntryResponse": {
        "description": "A single job log entry.",
        "example": {
          "attempt_number": 1,
          "context": {
            "event_count": 1000
          },
          "level": "INFO",
          "message": "Starting export of 1000 events",
          "timestamp": "2024-01-15T10:30:05Z"
        },
        "properties": {
          "attempt_number": {
            "default": 1,
            "description": "Which attempt generated this log",
            "minimum": 1.0,
            "title": "Attempt Number",
            "type": "integer"
          },
          "context": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional context data",
            "title": "Context"
          },
          "level": {
            "description": "Log level (DEBUG, INFO, WARNING, ERROR)",
            "title": "Level",
            "type": "string"
          },
          "message": {
            "description": "Log message",
            "title": "Message",
            "type": "string"
          },
          "timestamp": {
            "description": "When the log entry was created",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "level",
          "message"
        ],
        "title": "JobLogEntryResponse",
        "type": "object"
      },
      "JobLogsResponse": {
        "description": "Response for job logs endpoint.\n\nNEM-2396: GET /api/jobs/{job_id}/logs endpoint response.",
        "example": {
          "has_more": false,
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "logs": [
            {
              "attempt_number": 1,
              "level": "INFO",
              "message": "Job started",
              "timestamp": "2024-01-15T10:30:01Z"
            },
            {
              "attempt_number": 1,
              "context": {
                "progress": 0
              },
              "level": "INFO",
              "message": "Processing events: 0/1000",
              "timestamp": "2024-01-15T10:30:05Z"
            },
            {
              "attempt_number": 1,
              "context": {
                "events_exported": 1000
              },
              "level": "INFO",
              "message": "Export completed successfully",
              "timestamp": "2024-01-15T10:31:30Z"
            }
          ],
          "total": 3
        },
        "properties": {
          "has_more": {
            "default": false,
            "description": "Whether more logs exist beyond the limit",
            "title": "Has More",
            "type": "boolean"
          },
          "job_id": {
            "description": "Unique job identifier",
            "title": "Job Id",
            "type": "string"
          },
          "logs": {
            "description": "Log entries in chronological order",
            "items": {
              "$ref": "#/components/schemas/JobLogEntryResponse"
            },
            "title": "Logs",
            "type": "array"
          },
          "total": {
            "description": "Total number of log entries returned",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "job_id",
          "total"
        ],
        "title": "JobLogsResponse",
        "type": "object"
      },
      "JobMetadata": {
        "description": "Metadata about job execution.\n\nContains input parameters and execution context.",
        "example": {
          "input_params": {
            "camera_id": "cam-1",
            "format": "csv"
          },
          "worker_id": "worker-abc-123"
        },
        "properties": {
          "input_params": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Input parameters provided when job was created",
            "title": "Input Params"
          },
          "worker_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the worker executing the job",
            "title": "Worker Id"
          }
        },
        "title": "JobMetadata",
        "type": "object"
      },
      "JobProgressDetail": {
        "description": "Detailed progress information for a job.\n\nProvides granular progress tracking beyond a simple percentage.",
        "example": {
          "current_step": "Processing events",
          "items_processed": 450,
          "items_total": 1000,
          "percent": 45
        },
        "properties": {
          "current_step": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current processing step description",
            "title": "Current Step"
          },
          "items_processed": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of items processed so far",
            "title": "Items Processed"
          },
          "items_total": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total number of items to process",
            "title": "Items Total"
          },
          "percent": {
            "description": "Progress percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Percent",
            "type": "integer"
          }
        },
        "required": [
          "percent"
        ],
        "title": "JobProgressDetail",
        "type": "object"
      },
      "JobResponse": {
        "description": "Response model for job status.",
        "example": {
          "created_at": "2024-01-15T10:30:00Z",
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "job_type": "export",
          "message": "Exporting events: 450/1000",
          "progress": 45,
          "started_at": "2024-01-15T10:30:01Z",
          "status": "running"
        },
        "properties": {
          "completed_at": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ISO 8601 timestamp when job finished",
            "title": "Completed At"
          },
          "created_at": {
            "description": "ISO 8601 timestamp when job was created",
            "title": "Created At",
            "type": "string"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message (if failed)",
            "title": "Error"
          },
          "job_id": {
            "description": "Unique job identifier",
            "title": "Job Id",
            "type": "string"
          },
          "job_type": {
            "description": "Type of job (e.g., 'export')",
            "title": "Job Type",
            "type": "string"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable status message",
            "title": "Message"
          },
          "progress": {
            "description": "Progress percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Progress",
            "type": "integer"
          },
          "result": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "description": "Job result data (if completed)",
            "title": "Result"
          },
          "started_at": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ISO 8601 timestamp when job started",
            "title": "Started At"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatusEnum",
            "description": "Current job status"
          }
        },
        "required": [
          "job_id",
          "job_type",
          "status",
          "progress",
          "created_at"
        ],
        "title": "JobResponse",
        "type": "object"
      },
      "JobRetryInfo": {
        "description": "Retry information for a job.\n\nTracks retry attempts and failure history.",
        "example": {
          "attempt_number": 2,
          "max_attempts": 3,
          "next_retry_at": "2024-01-15T10:35:00Z",
          "previous_errors": [
            "Connection timeout"
          ]
        },
        "properties": {
          "attempt_number": {
            "description": "Current attempt number (1-indexed)",
            "minimum": 1.0,
            "title": "Attempt Number",
            "type": "integer"
          },
          "max_attempts": {
            "description": "Maximum number of retry attempts allowed",
            "minimum": 1.0,
            "title": "Max Attempts",
            "type": "integer"
          },
          "next_retry_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the next retry will occur (if applicable)",
            "title": "Next Retry At"
          },
          "previous_errors": {
            "description": "List of error messages from previous attempts",
            "items": {
              "type": "string"
            },
            "title": "Previous Errors",
            "type": "array"
          }
        },
        "required": [
          "attempt_number",
          "max_attempts"
        ],
        "title": "JobRetryInfo",
        "type": "object"
      },
      "JobSearchAggregations": {
        "description": "Aggregation counts for job search results.",
        "example": {
          "by_status": {
            "completed": 100,
            "failed": 35,
            "pending": 10,
            "running": 5
          },
          "by_type": {
            "ai_analysis": 120,
            "cleanup": 10,
            "export": 20
          }
        },
        "properties": {
          "by_status": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of matching jobs by status",
            "title": "By Status",
            "type": "object"
          },
          "by_type": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Count of matching jobs by job type",
            "title": "By Type",
            "type": "object"
          }
        },
        "title": "JobSearchAggregations",
        "type": "object"
      },
      "JobSearchResponse": {
        "description": "Response model for job search with aggregations.\n\nExtends the standard list response with aggregation data for faceted search.\n\nNEM-2392: GET /api/jobs/search endpoint response.",
        "example": {
          "aggregations": {
            "by_status": {
              "completed": 100,
              "failed": 35,
              "pending": 10,
              "running": 5
            },
            "by_type": {
              "backup": 10,
              "cleanup": 20,
              "export": 120
            }
          },
          "data": [
            {
              "completed_at": "2024-01-15T10:31:30Z",
              "created_at": "2024-01-15T10:30:00Z",
              "job_id": "550e8400-e29b-41d4-a716-446655440000",
              "job_type": "export",
              "message": "Export completed successfully",
              "progress": 100,
              "result": {
                "file_path": "/exports/data.csv"
              },
              "started_at": "2024-01-15T10:30:01Z",
              "status": "completed"
            }
          ],
          "meta": {
            "has_more": true,
            "limit": 50,
            "offset": 0,
            "total": 150
          }
        },
        "properties": {
          "aggregations": {
            "$ref": "#/components/schemas/JobSearchAggregations",
            "description": "Aggregation counts for faceted filtering"
          },
          "data": {
            "description": "List of matching jobs",
            "items": {
              "$ref": "#/components/schemas/JobResponse"
            },
            "title": "Data",
            "type": "array"
          },
          "meta": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "data",
          "meta",
          "aggregations"
        ],
        "title": "JobSearchResponse",
        "type": "object"
      },
      "JobStatsResponse": {
        "description": "Response model for job statistics.\n\nProvides aggregate statistics about jobs including counts by status,\ncounts by type, and timing information.",
        "example": {
          "average_duration_seconds": 45.5,
          "by_status": [
            {
              "count": 75,
              "status": "completed"
            },
            {
              "count": 5,
              "status": "running"
            },
            {
              "count": 10,
              "status": "pending"
            },
            {
              "count": 10,
              "status": "failed"
            }
          ],
          "by_type": [
            {
              "count": 60,
              "job_type": "export"
            },
            {
              "count": 30,
              "job_type": "cleanup"
            },
            {
              "count": 10,
              "job_type": "backup"
            }
          ],
          "oldest_pending_job_age_seconds": 120.0,
          "total_jobs": 100
        },
        "properties": {
          "average_duration_seconds": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Average job duration in seconds (for completed jobs)",
            "title": "Average Duration Seconds"
          },
          "by_status": {
            "description": "Job counts by status",
            "items": {
              "$ref": "#/components/schemas/JobStatusCount"
            },
            "title": "By Status",
            "type": "array"
          },
          "by_type": {
            "description": "Job counts by type",
            "items": {
              "$ref": "#/components/schemas/JobTypeCount"
            },
            "title": "By Type",
            "type": "array"
          },
          "oldest_pending_job_age_seconds": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Age of the oldest pending job in seconds",
            "title": "Oldest Pending Job Age Seconds"
          },
          "total_jobs": {
            "description": "Total number of jobs tracked",
            "minimum": 0.0,
            "title": "Total Jobs",
            "type": "integer"
          }
        },
        "required": [
          "total_jobs",
          "by_status",
          "by_type"
        ],
        "title": "JobStatsResponse",
        "type": "object"
      },
      "JobStatusCount": {
        "description": "Count of jobs by status.",
        "example": {
          "count": 42,
          "status": "completed"
        },
        "properties": {
          "count": {
            "description": "Number of jobs with this status",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatusEnum",
            "description": "Job status"
          }
        },
        "required": [
          "status",
          "count"
        ],
        "title": "JobStatusCount",
        "type": "object"
      },
      "JobStatusEnum": {
        "description": "Status of a background job.",
        "enum": [
          "pending",
          "running",
          "completed",
          "failed"
        ],
        "title": "JobStatusEnum",
        "type": "string"
      },
      "JobTargetSummary": {
        "description": "Summary of target health for a specific Prometheus job.",
        "example": {
          "down": 0,
          "job": "hsi-backend-metrics",
          "total": 1,
          "unknown": 0,
          "up": 1
        },
        "properties": {
          "down": {
            "description": "Number of targets that are down",
            "minimum": 0.0,
            "title": "Down",
            "type": "integer"
          },
          "job": {
            "description": "Prometheus job name",
            "title": "Job",
            "type": "string"
          },
          "total": {
            "description": "Total number of targets in this job",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          },
          "unknown": {
            "default": 0,
            "description": "Number of targets with unknown status",
            "minimum": 0.0,
            "title": "Unknown",
            "type": "integer"
          },
          "up": {
            "description": "Number of targets that are up",
            "minimum": 0.0,
            "title": "Up",
            "type": "integer"
          }
        },
        "required": [
          "job",
          "total",
          "up",
          "down"
        ],
        "title": "JobTargetSummary",
        "type": "object"
      },
      "JobTiming": {
        "description": "Timing information for a job.\n\nTracks job lifecycle timestamps and duration calculations.",
        "example": {
          "created_at": "2024-01-15T10:30:00Z",
          "duration_seconds": 45.5,
          "estimated_remaining_seconds": 55.0,
          "started_at": "2024-01-15T10:30:01Z"
        },
        "properties": {
          "completed_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the job completed or failed",
            "title": "Completed At"
          },
          "created_at": {
            "description": "When the job was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "duration_seconds": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total duration in seconds (if started)",
            "title": "Duration Seconds"
          },
          "estimated_remaining_seconds": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimated time remaining (if running)",
            "title": "Estimated Remaining Seconds"
          },
          "started_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When job execution started",
            "title": "Started At"
          }
        },
        "required": [
          "created_at"
        ],
        "title": "JobTiming",
        "type": "object"
      },
      "JobTransitionResponse": {
        "description": "A single state transition record in job history.",
        "example": {
          "at": "2024-01-15T10:30:00Z",
          "details": {
            "user": "system"
          },
          "to": "queued",
          "triggered_by": "api"
        },
        "properties": {
          "at": {
            "description": "Timestamp of the transition",
            "format": "date-time",
            "title": "At",
            "type": "string"
          },
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional transition details",
            "title": "Details"
          },
          "from": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Previous status (null for initial)",
            "title": "From"
          },
          "to": {
            "description": "New status after transition",
            "title": "To",
            "type": "string"
          },
          "triggered_by": {
            "description": "What triggered the transition (api, worker, system, etc)",
            "title": "Triggered By",
            "type": "string"
          }
        },
        "required": [
          "to",
          "at",
          "triggered_by"
        ],
        "title": "JobTransitionResponse",
        "type": "object"
      },
      "JobTypeCount": {
        "description": "Count of jobs by type.",
        "example": {
          "count": 25,
          "job_type": "export"
        },
        "properties": {
          "count": {
            "description": "Number of jobs of this type",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "job_type": {
            "description": "Job type name",
            "title": "Job Type",
            "type": "string"
          }
        },
        "required": [
          "job_type",
          "count"
        ],
        "title": "JobTypeCount",
        "type": "object"
      },
      "JobTypeInfo": {
        "description": "Information about a job type.",
        "example": {
          "description": "Export events to CSV, JSON, or ZIP format",
          "name": "export"
        },
        "properties": {
          "description": {
            "description": "Human-readable description of the job type",
            "title": "Description",
            "type": "string"
          },
          "name": {
            "description": "Job type name (e.g., 'export', 'cleanup')",
            "title": "Name",
            "type": "string"
          }
        },
        "required": [
          "name",
          "description"
        ],
        "title": "JobTypeInfo",
        "type": "object"
      },
      "JobTypesResponse": {
        "description": "Response model for listing job types.",
        "example": {
          "job_types": [
            {
              "description": "Export events to CSV, JSON, or ZIP format",
              "name": "export"
            },
            {
              "description": "Clean up old data and temporary files",
              "name": "cleanup"
            }
          ]
        },
        "properties": {
          "job_types": {
            "description": "List of available job types",
            "items": {
              "$ref": "#/components/schemas/JobTypeInfo"
            },
            "title": "Job Types",
            "type": "array"
          }
        },
        "required": [
          "job_types"
        ],
        "title": "JobTypesResponse",
        "type": "object"
      },
      "KnownPersonCreate": {
        "description": "Schema for creating a new known person.",
        "example": {
          "is_household_member": true,
          "name": "John Doe",
          "notes": "Family member - always trusted"
        },
        "properties": {
          "is_household_member": {
            "default": false,
            "description": "Whether person is a trusted household member",
            "title": "Is Household Member",
            "type": "boolean"
          },
          "name": {
            "description": "Display name of the person",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "notes": {
            "anyOf": [
              {
                "maxLength": 1000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional notes about the person",
            "title": "Notes"
          }
        },
        "required": [
          "name"
        ],
        "title": "KnownPersonCreate",
        "type": "object"
      },
      "KnownPersonListResponse": {
        "description": "Schema for list of known persons.",
        "example": {
          "items": [
            {
              "created_at": "2025-01-01T10:00:00Z",
              "embedding_count": 3,
              "id": 1,
              "is_household_member": true,
              "name": "John Doe",
              "notes": "Family member",
              "updated_at": "2025-01-01T12:00:00Z"
            }
          ],
          "total": 1
        },
        "properties": {
          "items": {
            "description": "List of known persons",
            "items": {
              "$ref": "#/components/schemas/KnownPersonResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "total": {
            "description": "Total number of known persons",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "items",
          "total"
        ],
        "title": "KnownPersonListResponse",
        "type": "object"
      },
      "KnownPersonResponse": {
        "description": "Schema for known person response.",
        "example": {
          "created_at": "2025-01-01T10:00:00Z",
          "embedding_count": 3,
          "id": 1,
          "is_household_member": true,
          "name": "John Doe",
          "notes": "Family member",
          "updated_at": "2025-01-01T12:00:00Z"
        },
        "properties": {
          "created_at": {
            "description": "When the person was registered",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "embedding_count": {
            "default": 0,
            "description": "Number of face embeddings stored for this person",
            "title": "Embedding Count",
            "type": "integer"
          },
          "id": {
            "description": "Unique identifier for the person",
            "title": "Id",
            "type": "integer"
          },
          "is_household_member": {
            "description": "Whether person is a household member",
            "title": "Is Household Member",
            "type": "boolean"
          },
          "name": {
            "description": "Display name of the person",
            "title": "Name",
            "type": "string"
          },
          "notes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Notes about the person",
            "title": "Notes"
          },
          "updated_at": {
            "description": "When the record was last updated",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "is_household_member",
          "created_at",
          "updated_at"
        ],
        "title": "KnownPersonResponse",
        "type": "object"
      },
      "KnownPersonUpdate": {
        "description": "Schema for updating an existing known person.",
        "example": {
          "is_household_member": true,
          "name": "John Smith",
          "notes": "Updated notes"
        },
        "properties": {
          "is_household_member": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether person is a trusted household member",
            "title": "Is Household Member"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Display name of the person",
            "title": "Name"
          },
          "notes": {
            "anyOf": [
              {
                "maxLength": 1000,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional notes about the person",
            "title": "Notes"
          }
        },
        "title": "KnownPersonUpdate",
        "type": "object"
      },
      "LatencyHistorySnapshot": {
        "description": "Single time-bucket snapshot of pipeline latency metrics.",
        "properties": {
          "stages": {
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LatencyHistoryStageStats"
                },
                {
                  "type": "null"
                }
              ]
            },
            "description": "Latency stats for each pipeline stage (None if no samples)",
            "title": "Stages",
            "type": "object"
          },
          "timestamp": {
            "description": "Bucket start time (ISO format)",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "stages"
        ],
        "title": "LatencyHistorySnapshot",
        "type": "object"
      },
      "LatencyHistoryStageStats": {
        "description": "Latency statistics for a single stage in a history snapshot.",
        "properties": {
          "avg_ms": {
            "description": "Average latency in milliseconds",
            "title": "Avg Ms",
            "type": "number"
          },
          "p50_ms": {
            "description": "50th percentile (median) latency",
            "title": "P50 Ms",
            "type": "number"
          },
          "p95_ms": {
            "description": "95th percentile latency",
            "title": "P95 Ms",
            "type": "number"
          },
          "p99_ms": {
            "description": "99th percentile latency",
            "title": "P99 Ms",
            "type": "number"
          },
          "sample_count": {
            "description": "Number of samples in this bucket",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "avg_ms",
          "p50_ms",
          "p95_ms",
          "p99_ms",
          "sample_count"
        ],
        "title": "LatencyHistoryStageStats",
        "type": "object"
      },
      "LatestSummariesResponse": {
        "description": "Schema for the combined latest summaries response.\n\nReturns both the latest hourly and daily summaries in a single response.\nEither field can be null if no summary exists for that time period.",
        "example": {
          "daily": {
            "content": "Today has seen minimal high-priority activity. The only notable event was at 2:15 PM at the front door. Morning and evening periods have been quiet with routine traffic only.",
            "event_count": 1,
            "generated_at": "2026-01-18T14:55:00Z",
            "id": 2,
            "window_end": "2026-01-18T15:00:00Z",
            "window_start": "2026-01-18T00:00:00Z"
          },
          "hourly": {
            "content": "Over the past hour, one critical event occurred at 2:15 PM when an unrecognized person approached the front door.",
            "event_count": 1,
            "generated_at": "2026-01-18T14:55:00Z",
            "id": 1,
            "window_end": "2026-01-18T15:00:00Z",
            "window_start": "2026-01-18T14:00:00Z"
          }
        },
        "properties": {
          "daily": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SummaryResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latest daily summary (since midnight), null if none exists"
          },
          "hourly": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SummaryResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latest hourly summary (past 60 minutes), null if none exists"
          }
        },
        "title": "LatestSummariesResponse",
        "type": "object"
      },
      "LeaderboardResponse": {
        "description": "Model leaderboard response.",
        "example": {
          "entries": [
            {
              "contribution_rate": 0.98,
              "event_count": 1200,
              "model_name": "yolo26",
              "quality_correlation": 0.85
            },
            {
              "contribution_rate": 0.85,
              "event_count": 1050,
              "model_name": "florence",
              "quality_correlation": 0.72
            }
          ],
          "period_days": 30
        },
        "properties": {
          "entries": {
            "items": {
              "$ref": "#/components/schemas/ModelLeaderboardEntry"
            },
            "title": "Entries",
            "type": "array"
          },
          "period_days": {
            "title": "Period Days",
            "type": "integer"
          }
        },
        "required": [
          "entries",
          "period_days"
        ],
        "title": "LeaderboardResponse",
        "type": "object"
      },
      "LicensePlateEnrichment": {
        "description": "License plate detection and OCR results.",
        "example": {
          "bbox": [
            100.0,
            200.0,
            300.0,
            250.0
          ],
          "confidence": 0.92,
          "detected": true,
          "ocr_confidence": 0.88,
          "text": "ABC-1234"
        },
        "properties": {
          "bbox": {
            "anyOf": [
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bounding box [x1, y1, x2, y2]",
            "title": "Bbox"
          },
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detection confidence",
            "title": "Confidence"
          },
          "detected": {
            "default": false,
            "description": "Whether a license plate was detected",
            "title": "Detected",
            "type": "boolean"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          },
          "ocr_confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "OCR confidence",
            "title": "Ocr Confidence"
          },
          "text": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "OCR-extracted plate text",
            "title": "Text"
          }
        },
        "title": "LicensePlateEnrichment",
        "type": "object"
      },
      "LineZoneCreate": {
        "description": "Schema for creating a new line zone.\n\nRequires camera_id to associate the zone with a specific camera.",
        "example": {
          "alert_on_cross": true,
          "camera_id": "front_door",
          "end_x": 400,
          "end_y": 200,
          "name": "Front Door Entry Line",
          "start_x": 100,
          "start_y": 200,
          "target_classes": [
            "person"
          ]
        },
        "properties": {
          "alert_on_cross": {
            "default": true,
            "description": "Whether to generate alerts when objects cross this line",
            "title": "Alert On Cross",
            "type": "boolean"
          },
          "camera_id": {
            "description": "ID of the camera this line zone belongs to",
            "maxLength": 255,
            "minLength": 1,
            "title": "Camera Id",
            "type": "string"
          },
          "end_x": {
            "description": "X coordinate of line end point (pixels)",
            "minimum": 0.0,
            "title": "End X",
            "type": "integer"
          },
          "end_y": {
            "description": "Y coordinate of line end point (pixels)",
            "minimum": 0.0,
            "title": "End Y",
            "type": "integer"
          },
          "name": {
            "description": "Descriptive name for the line zone",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "start_x": {
            "description": "X coordinate of line start point (pixels)",
            "minimum": 0.0,
            "title": "Start X",
            "type": "integer"
          },
          "start_y": {
            "description": "Y coordinate of line start point (pixels)",
            "minimum": 0.0,
            "title": "Start Y",
            "type": "integer"
          },
          "target_classes": {
            "description": "Object classes to track for this line (e.g., person, car, dog)",
            "items": {
              "type": "string"
            },
            "title": "Target Classes",
            "type": "array"
          }
        },
        "required": [
          "name",
          "start_x",
          "start_y",
          "end_x",
          "end_y",
          "camera_id"
        ],
        "title": "LineZoneCreate",
        "type": "object"
      },
      "LineZoneListResponse": {
        "description": "Paginated list of line zones.",
        "example": {
          "total": 1,
          "zones": [
            {
              "alert_on_cross": true,
              "camera_id": "front_door",
              "created_at": "2026-01-26T10:00:00Z",
              "end_x": 400,
              "end_y": 200,
              "id": 1,
              "in_count": 42,
              "name": "Front Door Entry Line",
              "out_count": 38,
              "start_x": 100,
              "start_y": 200,
              "target_classes": [
                "person"
              ]
            }
          ]
        },
        "properties": {
          "total": {
            "description": "Total number of line zones",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          },
          "zones": {
            "description": "List of line zones",
            "items": {
              "$ref": "#/components/schemas/LineZoneResponse"
            },
            "title": "Zones",
            "type": "array"
          }
        },
        "required": [
          "zones",
          "total"
        ],
        "title": "LineZoneListResponse",
        "type": "object"
      },
      "LineZoneResponse": {
        "description": "Response schema for a line zone.\n\nIncludes computed counts from crossing events.",
        "example": {
          "alert_on_cross": true,
          "camera_id": "front_door",
          "created_at": "2026-01-26T10:00:00Z",
          "end_x": 400,
          "end_y": 200,
          "id": 1,
          "in_count": 42,
          "name": "Front Door Entry Line",
          "out_count": 38,
          "start_x": 100,
          "start_y": 200,
          "target_classes": [
            "person"
          ]
        },
        "properties": {
          "alert_on_cross": {
            "default": true,
            "description": "Whether to generate alerts when objects cross this line",
            "title": "Alert On Cross",
            "type": "boolean"
          },
          "camera_id": {
            "description": "ID of the camera this line zone belongs to",
            "title": "Camera Id",
            "type": "string"
          },
          "created_at": {
            "description": "Timestamp when the zone was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "end_x": {
            "description": "X coordinate of line end point (pixels)",
            "minimum": 0.0,
            "title": "End X",
            "type": "integer"
          },
          "end_y": {
            "description": "Y coordinate of line end point (pixels)",
            "minimum": 0.0,
            "title": "End Y",
            "type": "integer"
          },
          "id": {
            "description": "Unique line zone identifier",
            "title": "Id",
            "type": "integer"
          },
          "in_count": {
            "default": 0,
            "description": "Total number of inbound crossings",
            "minimum": 0.0,
            "title": "In Count",
            "type": "integer"
          },
          "name": {
            "description": "Descriptive name for the line zone",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "out_count": {
            "default": 0,
            "description": "Total number of outbound crossings",
            "minimum": 0.0,
            "title": "Out Count",
            "type": "integer"
          },
          "start_x": {
            "description": "X coordinate of line start point (pixels)",
            "minimum": 0.0,
            "title": "Start X",
            "type": "integer"
          },
          "start_y": {
            "description": "Y coordinate of line start point (pixels)",
            "minimum": 0.0,
            "title": "Start Y",
            "type": "integer"
          },
          "target_classes": {
            "description": "Object classes to track for this line (e.g., person, car, dog)",
            "items": {
              "type": "string"
            },
            "title": "Target Classes",
            "type": "array"
          }
        },
        "required": [
          "name",
          "start_x",
          "start_y",
          "end_x",
          "end_y",
          "id",
          "camera_id",
          "created_at"
        ],
        "title": "LineZoneResponse",
        "type": "object"
      },
      "LineZoneUpdate": {
        "description": "Schema for updating an existing line zone.\n\nAll fields are optional; only provided fields are updated.",
        "example": {
          "alert_on_cross": false,
          "name": "Updated Entry Line"
        },
        "properties": {
          "alert_on_cross": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether to generate alerts when objects cross this line",
            "title": "Alert On Cross"
          },
          "end_x": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "X coordinate of line end point",
            "title": "End X"
          },
          "end_y": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Y coordinate of line end point",
            "title": "End Y"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Descriptive name for the line zone",
            "title": "Name"
          },
          "start_x": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "X coordinate of line start point",
            "title": "Start X"
          },
          "start_y": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Y coordinate of line start point",
            "title": "Start Y"
          },
          "target_classes": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object classes to track for this line",
            "title": "Target Classes"
          }
        },
        "title": "LineZoneUpdate",
        "type": "object"
      },
      "LogEntryResponse": {
        "description": "Schema for a single log entry in query responses.\n\nThis schema is used for GET /api/logs responses and represents\na log record from the database.\n\nAttributes:\n    id: Unique log entry identifier\n    timestamp: When the log was created (UTC)\n    level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    component: Component that generated the log (e.g., \"backend.api.routes.events\")\n    message: The log message content\n    camera_id: Optional camera ID associated with this log\n    event_id: Optional event ID associated with this log\n    request_id: Optional request ID for correlation\n    detection_id: Optional detection ID associated with this log\n    duration_ms: Optional duration in milliseconds (for timing logs)\n    extra: Additional structured context data (JSON)\n    source: Log source (backend or frontend)",
        "example": {
          "camera_id": "front_door",
          "component": "backend.services.detector",
          "detection_id": 789,
          "duration_ms": 30000,
          "event_id": 456,
          "extra": {
            "error_code": "TIMEOUT",
            "retry_count": 3
          },
          "id": 12345,
          "level": "ERROR",
          "message": "Detection failed: timeout after 30s",
          "request_id": "req-abc123",
          "source": "backend",
          "timestamp": "2026-01-15T10:30:00Z"
        },
        "properties": {
          "camera_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Associated camera ID",
            "title": "Camera Id"
          },
          "component": {
            "description": "Component that generated the log",
            "maxLength": 100,
            "title": "Component",
            "type": "string"
          },
          "detection_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Associated detection ID",
            "title": "Detection Id"
          },
          "duration_ms": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Duration in milliseconds",
            "title": "Duration Ms"
          },
          "event_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Associated event ID",
            "title": "Event Id"
          },
          "extra": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional structured context",
            "title": "Extra"
          },
          "id": {
            "description": "Unique log entry ID",
            "minimum": 1.0,
            "title": "Id",
            "type": "integer"
          },
          "level": {
            "description": "Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
            "title": "Level",
            "type": "string"
          },
          "message": {
            "description": "Log message content",
            "title": "Message",
            "type": "string"
          },
          "request_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Request ID for correlation",
            "title": "Request Id"
          },
          "source": {
            "default": "backend",
            "description": "Log source (backend or frontend)",
            "title": "Source",
            "type": "string"
          },
          "timestamp": {
            "description": "When the log was created (UTC)",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "id",
          "timestamp",
          "level",
          "component",
          "message"
        ],
        "title": "LogEntryResponse",
        "type": "object"
      },
      "LogLevelRequest": {
        "description": "Request to change log level.",
        "properties": {
          "level": {
            "description": "New log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
            "title": "Level",
            "type": "string"
          }
        },
        "required": [
          "level"
        ],
        "title": "LogLevelRequest",
        "type": "object"
      },
      "LogLevelResponse": {
        "description": "Response for log level operations.",
        "properties": {
          "level": {
            "description": "Current log level",
            "title": "Level",
            "type": "string"
          },
          "previous_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Previous log level (on change)",
            "title": "Previous Level"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "level",
          "timestamp"
        ],
        "title": "LogLevelResponse",
        "type": "object"
      },
      "LogStats": {
        "description": "Schema for log statistics dashboard.\n\nProvides aggregated statistics about logs for the dashboard,\nincluding counts by level and component.\n\nAttributes:\n    errors_today: Number of ERROR logs today\n    warnings_today: Number of WARNING logs today\n    total_today: Total number of logs today\n    top_component: The component with the most logs today (if any)\n    by_component: Breakdown of log counts by component",
        "example": {
          "by_component": {
            "backend.api.routes.events": 280,
            "backend.services.analyzer": 150,
            "backend.services.detector": 350,
            "frontend": 200
          },
          "errors_today": 15,
          "top_component": "backend.services.detector",
          "total_today": 1500,
          "warnings_today": 42
        },
        "properties": {
          "by_component": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Log counts by component",
            "title": "By Component",
            "type": "object"
          },
          "errors_today": {
            "description": "Number of errors today",
            "minimum": 0.0,
            "title": "Errors Today",
            "type": "integer"
          },
          "top_component": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Component with most logs today",
            "title": "Top Component"
          },
          "total_today": {
            "description": "Total logs today",
            "minimum": 0.0,
            "title": "Total Today",
            "type": "integer"
          },
          "warnings_today": {
            "description": "Number of warnings today",
            "minimum": 0.0,
            "title": "Warnings Today",
            "type": "integer"
          }
        },
        "required": [
          "errors_today",
          "warnings_today",
          "total_today"
        ],
        "title": "LogStats",
        "type": "object"
      },
      "LogsListResponse": {
        "description": "Schema for paginated log query response.\n\nSupports both cursor-based pagination (recommended) and offset pagination.\nCursor-based pagination offers better performance for large datasets.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "component": "backend.services.detector",
              "id": 12345,
              "level": "ERROR",
              "message": "Detection failed",
              "request_id": "req-abc123",
              "source": "backend",
              "timestamp": "2026-01-15T10:30:00Z"
            }
          ],
          "pagination": {
            "has_more": true,
            "limit": 50,
            "next_cursor": "eyJpZCI6IDEyMzQ1fQ==",
            "offset": 0,
            "total": 1500
          }
        },
        "properties": {
          "deprecation_warning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Warning when using deprecated offset pagination",
            "title": "Deprecation Warning"
          },
          "items": {
            "description": "List of log entries",
            "items": {
              "$ref": "#/components/schemas/LogEntryResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "LogsListResponse",
        "type": "object"
      },
      "LoiteringAlert": {
        "description": "Alert generated when an object exceeds the loitering threshold.\n\nThis schema represents a loitering event where an object has been\ndetected in a zone for longer than the configured threshold.",
        "example": {
          "camera_id": "front_door",
          "dwell_seconds": 350.5,
          "entry_time": "2026-01-26T12:00:00Z",
          "object_class": "person",
          "record_id": 123,
          "threshold_seconds": 300.0,
          "track_id": 42,
          "zone_id": 1
        },
        "properties": {
          "camera_id": {
            "description": "ID of the camera where detection occurred",
            "title": "Camera Id",
            "type": "string"
          },
          "dwell_seconds": {
            "description": "Current dwell time in seconds",
            "minimum": 0.0,
            "title": "Dwell Seconds",
            "type": "number"
          },
          "entry_time": {
            "description": "When the object entered the zone",
            "format": "date-time",
            "title": "Entry Time",
            "type": "string"
          },
          "object_class": {
            "description": "Classification of the loitering object",
            "title": "Object Class",
            "type": "string"
          },
          "record_id": {
            "description": "ID of the associated dwell time record",
            "title": "Record Id",
            "type": "integer"
          },
          "threshold_seconds": {
            "description": "Loitering threshold that was exceeded",
            "minimum": 0.0,
            "title": "Threshold Seconds",
            "type": "number"
          },
          "track_id": {
            "description": "Tracking ID of the loitering object",
            "title": "Track Id",
            "type": "integer"
          },
          "zone_id": {
            "description": "ID of the polygon zone where loitering detected",
            "title": "Zone Id",
            "type": "integer"
          }
        },
        "required": [
          "zone_id",
          "track_id",
          "camera_id",
          "object_class",
          "entry_time",
          "dwell_seconds",
          "threshold_seconds",
          "record_id"
        ],
        "title": "LoiteringAlert",
        "type": "object"
      },
      "LoiteringCheckRequest": {
        "description": "Request to check for loitering in a zone.",
        "example": {
          "threshold_seconds": 300.0
        },
        "properties": {
          "threshold_seconds": {
            "description": "Dwell time threshold in seconds to trigger loitering alert",
            "exclusiveMinimum": 0.0,
            "title": "Threshold Seconds",
            "type": "number"
          }
        },
        "required": [
          "threshold_seconds"
        ],
        "title": "LoiteringCheckRequest",
        "type": "object"
      },
      "LoiteringCheckResponse": {
        "description": "Response containing loitering alerts for a zone.",
        "example": {
          "alerts": [
            {
              "camera_id": "front_door",
              "dwell_seconds": 350.5,
              "entry_time": "2026-01-26T12:00:00Z",
              "object_class": "person",
              "record_id": 123,
              "threshold_seconds": 300.0,
              "track_id": 42,
              "zone_id": 1
            }
          ],
          "threshold_seconds": 300.0,
          "total_alerts": 1,
          "zone_id": 1
        },
        "properties": {
          "alerts": {
            "description": "Loitering alerts detected",
            "items": {
              "$ref": "#/components/schemas/LoiteringAlert"
            },
            "title": "Alerts",
            "type": "array"
          },
          "threshold_seconds": {
            "description": "Threshold used for checking",
            "title": "Threshold Seconds",
            "type": "number"
          },
          "total_alerts": {
            "description": "Total number of alerts",
            "minimum": 0.0,
            "title": "Total Alerts",
            "type": "integer"
          },
          "zone_id": {
            "description": "ID of the polygon zone checked",
            "title": "Zone Id",
            "type": "integer"
          }
        },
        "required": [
          "zone_id",
          "threshold_seconds",
          "alerts",
          "total_alerts"
        ],
        "title": "LoiteringCheckResponse",
        "type": "object"
      },
      "MediaErrorResponse": {
        "description": "Error response for media access failures.",
        "example": {
          "error": "File not found",
          "path": "/export/foscam/front_door/image_001.jpg"
        },
        "properties": {
          "error": {
            "description": "Error message describing what went wrong",
            "maxLength": 500,
            "minLength": 1,
            "title": "Error",
            "type": "string"
          },
          "path": {
            "description": "The path that was attempted to be accessed",
            "maxLength": 4096,
            "minLength": 0,
            "title": "Path",
            "type": "string"
          }
        },
        "required": [
          "error",
          "path"
        ],
        "title": "MediaErrorResponse",
        "type": "object"
      },
      "MemberRole": {
        "description": "Role of a household member for access categorization.",
        "enum": [
          "resident",
          "family",
          "service_worker",
          "frequent_visitor"
        ],
        "title": "MemberRole",
        "type": "string"
      },
      "MemoryGCStats": {
        "description": "Garbage collector statistics.",
        "properties": {
          "collected": {
            "description": "Total objects collected",
            "title": "Collected",
            "type": "integer"
          },
          "collections": {
            "description": "Number of collections per generation",
            "items": {
              "type": "integer"
            },
            "title": "Collections",
            "type": "array"
          },
          "thresholds": {
            "description": "Collection thresholds per generation",
            "items": {
              "type": "integer"
            },
            "title": "Thresholds",
            "type": "array"
          },
          "uncollectable": {
            "description": "Number of uncollectable objects",
            "title": "Uncollectable",
            "type": "integer"
          }
        },
        "required": [
          "collections",
          "collected",
          "uncollectable",
          "thresholds"
        ],
        "title": "MemoryGCStats",
        "type": "object"
      },
      "MemoryObjectStats": {
        "description": "Statistics for a single object type.",
        "properties": {
          "count": {
            "description": "Number of instances",
            "title": "Count",
            "type": "integer"
          },
          "size_bytes": {
            "description": "Total size in bytes",
            "title": "Size Bytes",
            "type": "integer"
          },
          "size_human": {
            "description": "Human-readable size",
            "title": "Size Human",
            "type": "string"
          },
          "type_name": {
            "description": "Object type name",
            "title": "Type Name",
            "type": "string"
          }
        },
        "required": [
          "type_name",
          "count",
          "size_bytes",
          "size_human"
        ],
        "title": "MemoryObjectStats",
        "type": "object"
      },
      "MemoryStatsResponse": {
        "description": "Response for memory statistics.",
        "properties": {
          "gc_stats": {
            "$ref": "#/components/schemas/MemoryGCStats",
            "description": "Garbage collector statistics"
          },
          "process_rss_bytes": {
            "description": "Process RSS memory in bytes",
            "title": "Process Rss Bytes",
            "type": "integer"
          },
          "process_rss_human": {
            "description": "Human-readable RSS memory",
            "title": "Process Rss Human",
            "type": "string"
          },
          "process_vms_bytes": {
            "description": "Process virtual memory in bytes",
            "title": "Process Vms Bytes",
            "type": "integer"
          },
          "process_vms_human": {
            "description": "Human-readable virtual memory",
            "title": "Process Vms Human",
            "type": "string"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          },
          "top_objects": {
            "description": "Top object types by memory usage",
            "items": {
              "$ref": "#/components/schemas/MemoryObjectStats"
            },
            "title": "Top Objects",
            "type": "array"
          },
          "tracemalloc_stats": {
            "$ref": "#/components/schemas/TraceMallocStats",
            "description": "Tracemalloc statistics"
          }
        },
        "required": [
          "process_rss_bytes",
          "process_rss_human",
          "process_vms_bytes",
          "process_vms_human",
          "gc_stats",
          "tracemalloc_stats",
          "top_objects",
          "timestamp"
        ],
        "title": "MemoryStatsResponse",
        "type": "object"
      },
      "MetricsCollectionStatus": {
        "description": "Status of metrics collection from Prometheus.",
        "example": {
          "collecting": true,
          "last_successful_scrape": "2026-01-13T10:30:00Z",
          "scrape_interval_seconds": 15,
          "total_series": 15000
        },
        "properties": {
          "collecting": {
            "description": "Whether Prometheus is actively collecting metrics",
            "title": "Collecting",
            "type": "boolean"
          },
          "last_successful_scrape": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of most recent successful scrape across all targets",
            "title": "Last Successful Scrape"
          },
          "scrape_interval_seconds": {
            "default": 15,
            "description": "Configured global scrape interval in seconds",
            "minimum": 1.0,
            "title": "Scrape Interval Seconds",
            "type": "integer"
          },
          "total_series": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total number of time series in Prometheus (if available)",
            "title": "Total Series"
          }
        },
        "required": [
          "collecting"
        ],
        "title": "MetricsCollectionStatus",
        "type": "object"
      },
      "ModelContributions": {
        "description": "Model contribution flags.",
        "example": {
          "baseline": false,
          "clip": false,
          "clothing": true,
          "cross_camera": false,
          "florence": true,
          "image_quality": true,
          "pet": false,
          "vehicle": false,
          "violence": false,
          "weather": true,
          "yolo26": true,
          "zones": true
        },
        "properties": {
          "baseline": {
            "default": false,
            "description": "Baseline comparison",
            "title": "Baseline",
            "type": "boolean"
          },
          "clip": {
            "default": false,
            "description": "CLIP embeddings",
            "title": "Clip",
            "type": "boolean"
          },
          "clothing": {
            "default": false,
            "description": "Clothing analysis",
            "title": "Clothing",
            "type": "boolean"
          },
          "cross_camera": {
            "default": false,
            "description": "Cross-camera correlation",
            "title": "Cross Camera",
            "type": "boolean"
          },
          "florence": {
            "default": false,
            "description": "Florence-2 vision attributes",
            "title": "Florence",
            "type": "boolean"
          },
          "image_quality": {
            "default": false,
            "description": "Image quality assessment",
            "title": "Image Quality",
            "type": "boolean"
          },
          "pet": {
            "default": false,
            "description": "Pet classification",
            "title": "Pet",
            "type": "boolean"
          },
          "vehicle": {
            "default": false,
            "description": "Vehicle classification",
            "title": "Vehicle",
            "type": "boolean"
          },
          "violence": {
            "default": false,
            "description": "Violence detection",
            "title": "Violence",
            "type": "boolean"
          },
          "weather": {
            "default": false,
            "description": "Weather classification",
            "title": "Weather",
            "type": "boolean"
          },
          "yolo26": {
            "default": false,
            "description": "YOLO26 object detection",
            "title": "Yolo26",
            "type": "boolean"
          },
          "zones": {
            "default": false,
            "description": "Zone analysis",
            "title": "Zones",
            "type": "boolean"
          }
        },
        "title": "ModelContributions",
        "type": "object"
      },
      "ModelLatencyHistoryResponse": {
        "description": "Response schema for Model Zoo latency history endpoint.\n\nReturns time-series latency data for a specific Model Zoo model.\nUsed to populate the dropdown-controlled latency chart.",
        "example": {
          "bucket_seconds": 60,
          "display_name": "YOLO11 License Plate",
          "has_data": true,
          "model_name": "yolo11-license-plate",
          "snapshots": [
            {
              "stats": {
                "avg_ms": 45.0,
                "p50_ms": 42.0,
                "p95_ms": 68.0,
                "sample_count": 15
              },
              "timestamp": "2026-01-04T10:00:00+00:00"
            }
          ],
          "timestamp": "2026-01-04T10:30:00Z",
          "window_minutes": 60
        },
        "properties": {
          "bucket_seconds": {
            "description": "Bucket size for aggregation",
            "minimum": 1.0,
            "title": "Bucket Seconds",
            "type": "integer"
          },
          "display_name": {
            "description": "Human-readable display name",
            "title": "Display Name",
            "type": "string"
          },
          "has_data": {
            "description": "Whether any latency data exists for this model",
            "title": "Has Data",
            "type": "boolean"
          },
          "model_name": {
            "description": "Name of the model this data is for",
            "title": "Model Name",
            "type": "string"
          },
          "snapshots": {
            "description": "Chronologically ordered latency snapshots",
            "items": {
              "$ref": "#/components/schemas/ModelLatencyHistorySnapshot"
            },
            "title": "Snapshots",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp when history was retrieved",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "window_minutes": {
            "description": "Time window covered by the history",
            "minimum": 1.0,
            "title": "Window Minutes",
            "type": "integer"
          }
        },
        "required": [
          "model_name",
          "display_name",
          "snapshots",
          "window_minutes",
          "bucket_seconds",
          "has_data",
          "timestamp"
        ],
        "title": "ModelLatencyHistoryResponse",
        "type": "object"
      },
      "ModelLatencyHistorySnapshot": {
        "description": "Single time-bucket snapshot of Model Zoo model latency.",
        "properties": {
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModelLatencyStageStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency statistics for this time bucket (None if no data)"
          },
          "timestamp": {
            "description": "Bucket start time (ISO format)",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp"
        ],
        "title": "ModelLatencyHistorySnapshot",
        "type": "object"
      },
      "ModelLatencyStageStats": {
        "description": "Latency statistics for a Model Zoo model at a point in time.",
        "properties": {
          "avg_ms": {
            "description": "Average latency in milliseconds",
            "minimum": 0.0,
            "title": "Avg Ms",
            "type": "number"
          },
          "p50_ms": {
            "description": "50th percentile (median) latency in milliseconds",
            "minimum": 0.0,
            "title": "P50 Ms",
            "type": "number"
          },
          "p95_ms": {
            "description": "95th percentile latency in milliseconds",
            "minimum": 0.0,
            "title": "P95 Ms",
            "type": "number"
          },
          "sample_count": {
            "description": "Number of samples in this time bucket",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "avg_ms",
          "p50_ms",
          "p95_ms",
          "sample_count"
        ],
        "title": "ModelLatencyStageStats",
        "type": "object"
      },
      "ModelLeaderboardEntry": {
        "description": "Single entry in model leaderboard.",
        "example": {
          "contribution_rate": 0.85,
          "event_count": 1050,
          "model_name": "florence",
          "quality_correlation": 0.72
        },
        "properties": {
          "contribution_rate": {
            "title": "Contribution Rate",
            "type": "number"
          },
          "event_count": {
            "title": "Event Count",
            "type": "integer"
          },
          "model_name": {
            "title": "Model Name",
            "type": "string"
          },
          "quality_correlation": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quality Correlation"
          }
        },
        "required": [
          "model_name",
          "contribution_rate",
          "quality_correlation",
          "event_count"
        ],
        "title": "ModelLeaderboardEntry",
        "type": "object"
      },
      "ModelPromptConfig": {
        "description": "Configuration for a specific AI model.",
        "example": {
          "change_description": "Added weather context to prompt",
          "config": {
            "max_tokens": 2048,
            "system_prompt": "You are a home security AI assistant...",
            "temperature": 0.7
          },
          "created_at": "2026-01-03T10:30:00Z",
          "created_by": "admin",
          "model": "nemotron",
          "version": 3
        },
        "properties": {
          "change_description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Description of changes",
            "title": "Change Description"
          },
          "config": {
            "additionalProperties": true,
            "description": "Model-specific configuration",
            "title": "Config",
            "type": "object"
          },
          "created_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When this version was created",
            "title": "Created At"
          },
          "created_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Who created this version",
            "title": "Created By"
          },
          "model": {
            "$ref": "#/components/schemas/AIModelEnum"
          },
          "version": {
            "description": "Version number of this configuration",
            "title": "Version",
            "type": "integer"
          }
        },
        "required": [
          "model",
          "config",
          "version"
        ],
        "title": "ModelPromptConfig",
        "type": "object"
      },
      "ModelRegistryResponse": {
        "description": "Response schema for model registry endpoint.\n\nReturns comprehensive information about all models in the Model Zoo\nincluding VRAM budget, current usage, and individual model statuses.",
        "example": {
          "loading_strategy": "sequential",
          "max_concurrent_models": 1,
          "models": [],
          "vram_available_mb": 1350,
          "vram_budget_mb": 1650,
          "vram_used_mb": 300
        },
        "properties": {
          "loading_strategy": {
            "default": "sequential",
            "description": "Model loading strategy (sequential = one at a time)",
            "title": "Loading Strategy",
            "type": "string"
          },
          "max_concurrent_models": {
            "default": 1,
            "description": "Maximum number of models that can be loaded concurrently",
            "minimum": 1.0,
            "title": "Max Concurrent Models",
            "type": "integer"
          },
          "models": {
            "description": "List of all models in the registry with their status",
            "items": {
              "$ref": "#/components/schemas/ModelStatusResponse"
            },
            "title": "Models",
            "type": "array"
          },
          "vram_available_mb": {
            "description": "Available VRAM for loading additional models",
            "minimum": 0.0,
            "title": "Vram Available Mb",
            "type": "integer"
          },
          "vram_budget_mb": {
            "description": "Total VRAM budget available for Model Zoo models (excludes Nemotron and YOLO26v2)",
            "minimum": 0.0,
            "title": "Vram Budget Mb",
            "type": "integer"
          },
          "vram_used_mb": {
            "description": "Currently used VRAM by loaded models",
            "minimum": 0.0,
            "title": "Vram Used Mb",
            "type": "integer"
          }
        },
        "required": [
          "vram_budget_mb",
          "vram_used_mb",
          "vram_available_mb",
          "models"
        ],
        "title": "ModelRegistryResponse",
        "type": "object"
      },
      "ModelStatusEnum": {
        "description": "Model loading status.",
        "enum": [
          "loaded",
          "unloaded",
          "disabled",
          "loading",
          "error"
        ],
        "title": "ModelStatusEnum",
        "type": "string"
      },
      "ModelStatusResponse": {
        "description": "Status information for a single model in the Model Zoo.\n\nProvides detailed information about a model including:\n- Identity: name, display_name, category\n- Configuration: vram_mb, enabled, available, path\n- Runtime status: status, load_count",
        "example": {
          "available": false,
          "category": "detection",
          "display_name": "YOLO11 License Plate",
          "enabled": true,
          "load_count": 0,
          "name": "yolo11-license-plate",
          "path": "/models/model-zoo/yolo11-license-plate/license-plate-finetune-v1n.pt",
          "status": "unloaded",
          "vram_mb": 300
        },
        "properties": {
          "available": {
            "description": "Whether the model has been successfully loaded at least once",
            "title": "Available",
            "type": "boolean"
          },
          "category": {
            "description": "Model category (detection, recognition, ocr, embedding, etc.)",
            "title": "Category",
            "type": "string"
          },
          "display_name": {
            "description": "Human-readable display name for the model",
            "title": "Display Name",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the model is enabled for use",
            "title": "Enabled",
            "type": "boolean"
          },
          "load_count": {
            "default": 0,
            "description": "Current reference count for loaded model (0 if not loaded)",
            "minimum": 0.0,
            "title": "Load Count",
            "type": "integer"
          },
          "name": {
            "description": "Unique identifier for the model (e.g., 'yolo11-license-plate')",
            "title": "Name",
            "type": "string"
          },
          "path": {
            "description": "HuggingFace repo path or local file path for the model",
            "title": "Path",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ModelStatusEnum",
            "description": "Current loading status: loaded, unloaded, disabled, loading, error"
          },
          "vram_mb": {
            "description": "Estimated VRAM usage in megabytes when loaded",
            "minimum": 0.0,
            "title": "Vram Mb",
            "type": "integer"
          }
        },
        "required": [
          "name",
          "display_name",
          "vram_mb",
          "status",
          "category",
          "enabled",
          "available",
          "path"
        ],
        "title": "ModelStatusResponse",
        "type": "object"
      },
      "ModelZooStatusItem": {
        "description": "Status information for a single Model Zoo model.\n\nUsed in the compact status card display for Model Zoo models.",
        "properties": {
          "category": {
            "description": "Model category (detection, classification, segmentation, etc.)",
            "title": "Category",
            "type": "string"
          },
          "display_name": {
            "description": "Human-readable display name",
            "title": "Display Name",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the model is enabled for use",
            "title": "Enabled",
            "type": "boolean"
          },
          "last_used_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of last model usage (null if never used)",
            "title": "Last Used At"
          },
          "name": {
            "description": "Model identifier (e.g., 'yolo11-license-plate')",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ModelStatusEnum",
            "description": "Current status: loaded (green), unloaded (gray), disabled (yellow)"
          },
          "vram_mb": {
            "description": "VRAM usage in megabytes when loaded",
            "minimum": 0.0,
            "title": "Vram Mb",
            "type": "integer"
          }
        },
        "required": [
          "name",
          "display_name",
          "category",
          "status",
          "vram_mb",
          "enabled"
        ],
        "title": "ModelZooStatusItem",
        "type": "object"
      },
      "ModelZooStatusResponse": {
        "description": "Response schema for Model Zoo status endpoint.\n\nReturns status information for all 18 Model Zoo models organized by category.\nUsed to populate the compact status cards in the UI.",
        "example": {
          "disabled_count": 3,
          "loaded_count": 0,
          "models": [
            {
              "category": "detection",
              "display_name": "YOLO11 License Plate",
              "enabled": true,
              "name": "yolo11-license-plate",
              "status": "unloaded",
              "vram_mb": 300
            }
          ],
          "timestamp": "2026-01-04T10:30:00Z",
          "total_models": 18,
          "vram_budget_mb": 1650,
          "vram_used_mb": 0
        },
        "properties": {
          "disabled_count": {
            "description": "Number of disabled models",
            "minimum": 0.0,
            "title": "Disabled Count",
            "type": "integer"
          },
          "loaded_count": {
            "description": "Number of currently loaded models",
            "minimum": 0.0,
            "title": "Loaded Count",
            "type": "integer"
          },
          "models": {
            "description": "List of all Model Zoo models with their current status",
            "items": {
              "$ref": "#/components/schemas/ModelZooStatusItem"
            },
            "title": "Models",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "total_models": {
            "description": "Total number of models in the registry",
            "minimum": 0.0,
            "title": "Total Models",
            "type": "integer"
          },
          "vram_budget_mb": {
            "description": "Total VRAM budget for Model Zoo",
            "minimum": 0.0,
            "title": "Vram Budget Mb",
            "type": "integer"
          },
          "vram_used_mb": {
            "description": "Currently used VRAM",
            "minimum": 0.0,
            "title": "Vram Used Mb",
            "type": "integer"
          }
        },
        "required": [
          "models",
          "total_models",
          "loaded_count",
          "disabled_count",
          "vram_budget_mb",
          "vram_used_mb",
          "timestamp"
        ],
        "title": "ModelZooStatusResponse",
        "type": "object"
      },
      "MonitoringHealthResponse": {
        "description": "Response schema for monitoring stack health endpoint.\n\nProvides comprehensive health status of the monitoring infrastructure:\n- Prometheus server reachability and status\n- Scrape target health summary by job\n- Exporter status (redis-exporter, json-exporter, blackbox-exporter)\n- Metrics collection status\n\nThis endpoint helps operators quickly identify issues with the\nmonitoring stack without accessing Prometheus UI directly.",
        "example": {
          "exporters": [
            {
              "endpoint": "http://redis-exporter:9121",
              "last_scrape": "2026-01-13T10:30:00Z",
              "name": "redis-exporter",
              "status": "up"
            },
            {
              "endpoint": "http://json-exporter:7979",
              "last_scrape": "2026-01-13T10:30:00Z",
              "name": "json-exporter",
              "status": "up"
            }
          ],
          "healthy": true,
          "issues": [],
          "metrics_collection": {
            "collecting": true,
            "last_successful_scrape": "2026-01-13T10:30:00Z",
            "scrape_interval_seconds": 15,
            "total_series": 15000
          },
          "prometheus_reachable": true,
          "prometheus_url": "http://prometheus:9090",
          "targets_summary": [
            {
              "down": 0,
              "job": "hsi-backend-metrics",
              "total": 1,
              "unknown": 0,
              "up": 1
            },
            {
              "down": 0,
              "job": "redis",
              "total": 1,
              "unknown": 0,
              "up": 1
            },
            {
              "down": 0,
              "job": "blackbox-http-health",
              "total": 1,
              "unknown": 0,
              "up": 1
            }
          ],
          "timestamp": "2026-01-13T10:30:00Z"
        },
        "properties": {
          "exporters": {
            "description": "Status of known exporters",
            "items": {
              "$ref": "#/components/schemas/ExporterStatus"
            },
            "title": "Exporters",
            "type": "array"
          },
          "healthy": {
            "description": "Overall monitoring stack health: True if Prometheus reachable and majority of targets up",
            "title": "Healthy",
            "type": "boolean"
          },
          "issues": {
            "description": "List of identified issues with the monitoring stack",
            "items": {
              "type": "string"
            },
            "title": "Issues",
            "type": "array"
          },
          "metrics_collection": {
            "$ref": "#/components/schemas/MetricsCollectionStatus",
            "description": "Metrics collection status"
          },
          "prometheus_reachable": {
            "description": "Whether Prometheus server is reachable",
            "title": "Prometheus Reachable",
            "type": "boolean"
          },
          "prometheus_url": {
            "description": "Configured Prometheus server URL",
            "title": "Prometheus Url",
            "type": "string"
          },
          "targets_summary": {
            "description": "Summary of target health by job",
            "items": {
              "$ref": "#/components/schemas/JobTargetSummary"
            },
            "title": "Targets Summary",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp of health check",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "healthy",
          "prometheus_reachable",
          "prometheus_url",
          "targets_summary",
          "exporters",
          "metrics_collection",
          "timestamp"
        ],
        "title": "MonitoringHealthResponse",
        "type": "object"
      },
      "MonitoringTargetsResponse": {
        "description": "Response schema for detailed monitoring targets endpoint.\n\nReturns complete information about all Prometheus scrape targets\nincluding their health status, labels, and scrape timing.",
        "example": {
          "down": 0,
          "jobs": [
            "hsi-backend-metrics",
            "redis"
          ],
          "targets": [
            {
              "health": "up",
              "instance": "backend:8000",
              "job": "hsi-backend-metrics",
              "labels": {
                "service": "home-security-intelligence"
              },
              "last_scrape": "2026-01-13T10:30:00Z",
              "scrape_duration_seconds": 0.025
            },
            {
              "health": "up",
              "instance": "redis-exporter:9121",
              "job": "redis",
              "labels": {},
              "last_scrape": "2026-01-13T10:30:00Z",
              "scrape_duration_seconds": 0.015
            }
          ],
          "timestamp": "2026-01-13T10:30:00Z",
          "total": 2,
          "up": 2
        },
        "properties": {
          "down": {
            "description": "Number of targets that are down",
            "minimum": 0.0,
            "title": "Down",
            "type": "integer"
          },
          "jobs": {
            "description": "List of unique job names",
            "items": {
              "type": "string"
            },
            "title": "Jobs",
            "type": "array"
          },
          "targets": {
            "description": "Detailed status of all scrape targets",
            "items": {
              "$ref": "#/components/schemas/TargetHealth"
            },
            "title": "Targets",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp of targets query",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "total": {
            "description": "Total number of targets",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          },
          "up": {
            "description": "Number of targets that are up",
            "minimum": 0.0,
            "title": "Up",
            "type": "integer"
          }
        },
        "required": [
          "targets",
          "total",
          "up",
          "down",
          "jobs",
          "timestamp"
        ],
        "title": "MonitoringTargetsResponse",
        "type": "object"
      },
      "MovementMetrics": {
        "description": "Calculated movement metrics for a track.\n\nAggregated statistics computed from the track's trajectory points,\nuseful for behavioral analysis and anomaly detection.",
        "example": {
          "avg_speed": 45.2,
          "direction": 135.0,
          "duration_seconds": 27.7,
          "total_distance": 1250.5
        },
        "properties": {
          "avg_speed": {
            "description": "Average speed (pixels/second)",
            "minimum": 0.0,
            "title": "Avg Speed",
            "type": "number"
          },
          "direction": {
            "anyOf": [
              {
                "maximum": 360.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Overall direction in degrees (0-360, where 0=right, 90=down)",
            "title": "Direction"
          },
          "duration_seconds": {
            "description": "Track duration in seconds",
            "minimum": 0.0,
            "title": "Duration Seconds",
            "type": "number"
          },
          "total_distance": {
            "description": "Total distance traveled (pixels)",
            "minimum": 0.0,
            "title": "Total Distance",
            "type": "number"
          }
        },
        "required": [
          "total_distance",
          "avg_speed",
          "duration_seconds"
        ],
        "title": "MovementMetrics",
        "type": "object"
      },
      "NemotronMetrics": {
        "description": "Metrics for Nemotron LLM.",
        "example": {
          "context_size": 4096,
          "slots_active": 1,
          "slots_total": 2,
          "status": "healthy"
        },
        "properties": {
          "context_size": {
            "description": "Context window size in tokens",
            "minimum": 0.0,
            "title": "Context Size",
            "type": "integer"
          },
          "slots_active": {
            "description": "Number of active inference slots",
            "minimum": 0.0,
            "title": "Slots Active",
            "type": "integer"
          },
          "slots_total": {
            "description": "Total available inference slots",
            "minimum": 0.0,
            "title": "Slots Total",
            "type": "integer"
          },
          "status": {
            "description": "Health status: healthy, unhealthy, unreachable",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "status",
          "slots_active",
          "slots_total",
          "context_size"
        ],
        "title": "NemotronMetrics",
        "type": "object"
      },
      "NotificationChannel": {
        "description": "Notification channel types.",
        "enum": [
          "email",
          "webhook",
          "push"
        ],
        "title": "NotificationChannel",
        "type": "string"
      },
      "NotificationConfigResponse": {
        "description": "Schema for notification configuration status.",
        "example": {
          "available_channels": [
            "email",
            "webhook"
          ],
          "default_email_recipients": [
            "user@example.com"
          ],
          "default_webhook_url": "https://example.com/webhook",
          "email_configured": true,
          "notification_enabled": true,
          "push_configured": false,
          "smtp_from_address": "alerts@example.com",
          "smtp_host": "smtp.example.com",
          "smtp_port": 587,
          "smtp_use_tls": true,
          "webhook_configured": true,
          "webhook_timeout_seconds": 30
        },
        "properties": {
          "available_channels": {
            "description": "List of channels that are properly configured",
            "items": {
              "$ref": "#/components/schemas/NotificationChannel"
            },
            "title": "Available Channels",
            "type": "array"
          },
          "default_email_recipients": {
            "description": "Default email recipients",
            "items": {
              "type": "string"
            },
            "title": "Default Email Recipients",
            "type": "array"
          },
          "default_webhook_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Default webhook URL",
            "title": "Default Webhook Url"
          },
          "email_configured": {
            "description": "Whether email (SMTP) is configured",
            "title": "Email Configured",
            "type": "boolean"
          },
          "notification_enabled": {
            "description": "Whether notifications are enabled",
            "title": "Notification Enabled",
            "type": "boolean"
          },
          "push_configured": {
            "description": "Whether push notifications are configured",
            "title": "Push Configured",
            "type": "boolean"
          },
          "smtp_from_address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configured sender email",
            "title": "Smtp From Address"
          },
          "smtp_host": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configured SMTP host (if any)",
            "title": "Smtp Host"
          },
          "smtp_port": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configured SMTP port",
            "title": "Smtp Port"
          },
          "smtp_use_tls": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether TLS is enabled for SMTP",
            "title": "Smtp Use Tls"
          },
          "webhook_configured": {
            "description": "Whether webhook is configured",
            "title": "Webhook Configured",
            "type": "boolean"
          },
          "webhook_timeout_seconds": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Webhook request timeout",
            "title": "Webhook Timeout Seconds"
          }
        },
        "required": [
          "notification_enabled",
          "email_configured",
          "webhook_configured",
          "push_configured",
          "available_channels"
        ],
        "title": "NotificationConfigResponse",
        "type": "object"
      },
      "NotificationConfigUpdate": {
        "description": "Schema for updating notification configuration.\n\nAll fields are optional to support partial updates.\nOnly specified fields will be updated.",
        "example": {
          "default_webhook_url": "https://hooks.example.com/webhook",
          "smtp_enabled": true,
          "smtp_from_address": "alerts@example.com",
          "smtp_host": "smtp.example.com",
          "smtp_port": 587,
          "webhook_enabled": true
        },
        "properties": {
          "default_webhook_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Default webhook URL for notifications. Must be HTTPS and not point to private IPs.",
            "title": "Default Webhook Url"
          },
          "smtp_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enable or disable SMTP notifications",
            "title": "Smtp Enabled"
          },
          "smtp_from_address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Sender email address for notifications",
            "title": "Smtp From Address"
          },
          "smtp_host": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "SMTP server hostname",
            "title": "Smtp Host"
          },
          "smtp_port": {
            "anyOf": [
              {
                "maximum": 65535.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "SMTP server port (1-65535)",
            "title": "Smtp Port"
          },
          "webhook_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enable or disable webhook notifications",
            "title": "Webhook Enabled"
          }
        },
        "title": "NotificationConfigUpdate",
        "type": "object"
      },
      "NotificationConfigUpdateResponse": {
        "description": "Schema for notification configuration update response.\n\nReturns the full configuration state after the update.",
        "example": {
          "default_webhook_url": "https://hooks.example.com/webhook",
          "message": "Configuration updated successfully",
          "smtp_enabled": true,
          "smtp_from_address": "alerts@example.com",
          "smtp_host": "smtp.example.com",
          "smtp_port": 587,
          "webhook_enabled": true
        },
        "properties": {
          "default_webhook_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Default webhook URL",
            "title": "Default Webhook Url"
          },
          "message": {
            "description": "Human-readable result message",
            "title": "Message",
            "type": "string"
          },
          "smtp_enabled": {
            "description": "Whether SMTP notifications are enabled",
            "title": "Smtp Enabled",
            "type": "boolean"
          },
          "smtp_from_address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configured sender email",
            "title": "Smtp From Address"
          },
          "smtp_host": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configured SMTP host",
            "title": "Smtp Host"
          },
          "smtp_port": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configured SMTP port",
            "title": "Smtp Port"
          },
          "webhook_enabled": {
            "description": "Whether webhook notifications are enabled",
            "title": "Webhook Enabled",
            "type": "boolean"
          }
        },
        "required": [
          "smtp_enabled",
          "webhook_enabled",
          "message"
        ],
        "title": "NotificationConfigUpdateResponse",
        "type": "object"
      },
      "NotificationHistoryEntry": {
        "description": "Schema for a notification history entry.",
        "example": {
          "alert_id": "550e8400-e29b-41d4-a716-446655440001",
          "channel": "email",
          "created_at": "2025-12-28T12:00:29Z",
          "delivered_at": "2025-12-28T12:00:30Z",
          "id": "550e8400-e29b-41d4-a716-446655440002",
          "recipient": "user@example.com",
          "success": true
        },
        "properties": {
          "alert_id": {
            "description": "Associated alert ID",
            "title": "Alert Id",
            "type": "string"
          },
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "Notification channel"
          },
          "created_at": {
            "description": "Record creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "delivered_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Delivery timestamp",
            "title": "Delivered At"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if failed",
            "title": "Error"
          },
          "id": {
            "description": "Notification delivery ID",
            "title": "Id",
            "type": "string"
          },
          "recipient": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Recipient identifier",
            "title": "Recipient"
          },
          "success": {
            "description": "Whether delivery was successful",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "id",
          "alert_id",
          "channel",
          "success",
          "created_at"
        ],
        "title": "NotificationHistoryEntry",
        "type": "object"
      },
      "NotificationHistoryResponse": {
        "description": "Schema for notification history list response.",
        "example": {
          "count": 1,
          "entries": [
            {
              "alert_id": "550e8400-e29b-41d4-a716-446655440001",
              "channel": "email",
              "created_at": "2025-12-28T12:00:29Z",
              "delivered_at": "2025-12-28T12:00:30Z",
              "id": "550e8400-e29b-41d4-a716-446655440002",
              "recipient": "user@example.com",
              "success": true
            }
          ],
          "limit": 50,
          "offset": 0
        },
        "properties": {
          "count": {
            "description": "Total number of entries matching filters",
            "title": "Count",
            "type": "integer"
          },
          "entries": {
            "description": "Notification history entries",
            "items": {
              "$ref": "#/components/schemas/NotificationHistoryEntry"
            },
            "title": "Entries",
            "type": "array"
          },
          "limit": {
            "description": "Maximum number of results returned",
            "title": "Limit",
            "type": "integer"
          },
          "offset": {
            "description": "Number of results skipped",
            "title": "Offset",
            "type": "integer"
          }
        },
        "required": [
          "entries",
          "count",
          "limit",
          "offset"
        ],
        "title": "NotificationHistoryResponse",
        "type": "object"
      },
      "NotificationPreferencesResponse": {
        "description": "Schema for notification preferences response.",
        "example": {
          "enabled": true,
          "id": 1,
          "risk_filters": [
            "critical",
            "high",
            "medium"
          ],
          "sound": "default"
        },
        "properties": {
          "enabled": {
            "description": "Whether notifications are globally enabled",
            "title": "Enabled",
            "type": "boolean"
          },
          "id": {
            "default": 1,
            "description": "Preferences ID (always 1, singleton)",
            "title": "Id",
            "type": "integer"
          },
          "risk_filters": {
            "description": "Risk levels that trigger notifications (critical, high, medium, low)",
            "items": {
              "type": "string"
            },
            "title": "Risk Filters",
            "type": "array"
          },
          "sound": {
            "description": "Notification sound (none, default, alert, chime, urgent)",
            "title": "Sound",
            "type": "string"
          }
        },
        "required": [
          "enabled",
          "sound",
          "risk_filters"
        ],
        "title": "NotificationPreferencesResponse",
        "type": "object"
      },
      "NotificationPreferencesUpdate": {
        "description": "Schema for updating notification preferences.",
        "example": {
          "enabled": true,
          "risk_filters": [
            "critical",
            "high"
          ],
          "sound": "alert"
        },
        "properties": {
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether notifications are globally enabled",
            "title": "Enabled"
          },
          "risk_filters": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk levels that trigger notifications (critical, high, medium, low)",
            "title": "Risk Filters"
          },
          "sound": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Notification sound (none, default, alert, chime, urgent)",
            "title": "Sound"
          }
        },
        "title": "NotificationPreferencesUpdate",
        "type": "object"
      },
      "ObjectBaseline": {
        "description": "Baseline statistics for a specific object class.",
        "example": {
          "avg_hourly": 2.3,
          "peak_hour": 17,
          "total_detections": 550
        },
        "properties": {
          "avg_hourly": {
            "description": "Average hourly detection count for this object type",
            "minimum": 0.0,
            "title": "Avg Hourly",
            "type": "number"
          },
          "peak_hour": {
            "description": "Hour with most detections of this type (0-23)",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Peak Hour",
            "type": "integer"
          },
          "total_detections": {
            "description": "Total detections of this type in the baseline period",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          }
        },
        "required": [
          "avg_hourly",
          "peak_hour",
          "total_detections"
        ],
        "title": "ObjectBaseline",
        "type": "object"
      },
      "ObjectClassDistributionItem": {
        "description": "Schema for a single object class distribution item (for Grafana compatibility).",
        "example": {
          "count": 23,
          "object_class": "person"
        },
        "properties": {
          "count": {
            "description": "Number of detections of this class",
            "title": "Count",
            "type": "integer"
          },
          "object_class": {
            "description": "Object class name (e.g., person, car)",
            "title": "Object Class",
            "type": "string"
          }
        },
        "required": [
          "object_class",
          "count"
        ],
        "title": "ObjectClassDistributionItem",
        "type": "object"
      },
      "ObjectDistributionDataPoint": {
        "description": "Schema for a single object distribution data point.",
        "example": {
          "count": 120,
          "object_type": "person",
          "percentage": 45.5
        },
        "properties": {
          "count": {
            "description": "Number of detections for this object type",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "object_type": {
            "description": "Detected object type (e.g., 'person', 'car')",
            "title": "Object Type",
            "type": "string"
          },
          "percentage": {
            "description": "Percentage of total detections (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Percentage",
            "type": "number"
          }
        },
        "required": [
          "object_type",
          "count",
          "percentage"
        ],
        "title": "ObjectDistributionDataPoint",
        "type": "object"
      },
      "ObjectDistributionResponse": {
        "description": "Schema for detection counts by object type.",
        "example": {
          "end_date": "2025-01-07",
          "object_types": [
            {
              "count": 120,
              "object_type": "person",
              "percentage": 45.5
            },
            {
              "count": 80,
              "object_type": "car",
              "percentage": 30.3
            },
            {
              "count": 64,
              "object_type": "dog",
              "percentage": 24.2
            }
          ],
          "start_date": "2025-01-01",
          "total_detections": 264
        },
        "properties": {
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "object_types": {
            "description": "Detection counts by object type",
            "items": {
              "$ref": "#/components/schemas/ObjectDistributionDataPoint"
            },
            "title": "Object Types",
            "type": "array"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          },
          "total_detections": {
            "description": "Total detections in date range",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          }
        },
        "required": [
          "object_types",
          "total_detections",
          "start_date",
          "end_date"
        ],
        "title": "ObjectDistributionResponse",
        "type": "object"
      },
      "OldestJobInfo": {
        "description": "Information about the oldest job in a queue.",
        "example": {
          "id": "job_12345",
          "queued_at": "2025-12-23T10:30:00.000000",
          "wait_seconds": 45.2
        },
        "properties": {
          "id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Job identifier (if available)",
            "title": "Id"
          },
          "queued_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp when the job was queued",
            "title": "Queued At"
          },
          "wait_seconds": {
            "description": "How long the oldest job has been waiting in seconds",
            "minimum": 0.0,
            "title": "Wait Seconds",
            "type": "number"
          }
        },
        "required": [
          "wait_seconds"
        ],
        "title": "OldestJobInfo",
        "type": "object"
      },
      "OrphanCleanupRequest": {
        "description": "Request schema for orphan cleanup endpoint.",
        "properties": {
          "dry_run": {
            "default": true,
            "description": "If True, only report what would be deleted without actually deleting",
            "title": "Dry Run",
            "type": "boolean"
          },
          "max_delete_gb": {
            "default": 10.0,
            "description": "Maximum gigabytes to delete in one run (0.1-100)",
            "maximum": 100.0,
            "minimum": 0.1,
            "title": "Max Delete Gb",
            "type": "number"
          },
          "min_age_hours": {
            "default": 24,
            "description": "Minimum age in hours before a file can be deleted (1-720)",
            "maximum": 720.0,
            "minimum": 1.0,
            "title": "Min Age Hours",
            "type": "integer"
          }
        },
        "title": "OrphanCleanupRequest",
        "type": "object"
      },
      "OrphanCleanupResponse": {
        "description": "Response schema for orphan cleanup endpoint.",
        "properties": {
          "deleted_bytes": {
            "title": "Deleted Bytes",
            "type": "integer"
          },
          "deleted_bytes_formatted": {
            "title": "Deleted Bytes Formatted",
            "type": "string"
          },
          "deleted_files": {
            "title": "Deleted Files",
            "type": "integer"
          },
          "dry_run": {
            "title": "Dry Run",
            "type": "boolean"
          },
          "duration_seconds": {
            "title": "Duration Seconds",
            "type": "number"
          },
          "failed_count": {
            "title": "Failed Count",
            "type": "integer"
          },
          "failed_deletions": {
            "items": {
              "type": "string"
            },
            "title": "Failed Deletions",
            "type": "array"
          },
          "orphaned_files": {
            "title": "Orphaned Files",
            "type": "integer"
          },
          "scanned_files": {
            "title": "Scanned Files",
            "type": "integer"
          },
          "skipped_size_limit": {
            "title": "Skipped Size Limit",
            "type": "integer"
          },
          "skipped_young": {
            "title": "Skipped Young",
            "type": "integer"
          }
        },
        "required": [
          "scanned_files",
          "orphaned_files",
          "deleted_files",
          "deleted_bytes",
          "deleted_bytes_formatted",
          "failed_count",
          "failed_deletions",
          "duration_seconds",
          "dry_run",
          "skipped_young",
          "skipped_size_limit"
        ],
        "title": "OrphanCleanupResponse",
        "type": "object"
      },
      "OrphanedFileCleanupResponse": {
        "description": "Response schema for orphaned file cleanup endpoint.\n\nReturns statistics about orphaned files found (and optionally deleted).\nOrphaned files are files on disk not referenced in the database.",
        "example": {
          "dry_run": true,
          "job_id": "550e8400-e29b-41d4-a716-446655440000",
          "orphaned_count": 25,
          "orphaned_files": [
            "/data/thumbnails/orphaned1.jpg",
            "/data/thumbnails/orphaned2.jpg"
          ],
          "timestamp": "2025-12-30T10:30:00Z",
          "total_size": 524288000,
          "total_size_formatted": "500.00 MB"
        },
        "properties": {
          "dry_run": {
            "description": "Whether this was a dry run (no actual deletion performed)",
            "title": "Dry Run",
            "type": "boolean"
          },
          "job_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Background job ID for tracking progress",
            "title": "Job Id"
          },
          "orphaned_count": {
            "description": "Number of orphaned files found (or deleted if dry_run=False)",
            "minimum": 0.0,
            "title": "Orphaned Count",
            "type": "integer"
          },
          "orphaned_files": {
            "description": "List of orphaned file paths (limited to first 100)",
            "items": {
              "type": "string"
            },
            "title": "Orphaned Files",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp of cleanup operation",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "total_size": {
            "description": "Total size of orphaned files in bytes",
            "minimum": 0.0,
            "title": "Total Size",
            "type": "integer"
          },
          "total_size_formatted": {
            "description": "Human-readable total size (e.g., '1.5 GB')",
            "title": "Total Size Formatted",
            "type": "string"
          }
        },
        "required": [
          "orphaned_count",
          "total_size",
          "total_size_formatted",
          "dry_run",
          "timestamp"
        ],
        "title": "OrphanedFileCleanupResponse",
        "type": "object"
      },
      "PaginationInfo": {
        "description": "Pagination metadata for list responses (NEM-2075).\n\nStandard pagination envelope used by entities and other list endpoints.\nSupports both cursor-based pagination (recommended) and offset pagination.",
        "properties": {
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current cursor position",
            "title": "Cursor"
          },
          "has_more": {
            "default": false,
            "description": "Whether more results are available",
            "title": "Has More",
            "type": "boolean"
          },
          "limit": {
            "description": "Page size (1-1000)",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "type": "integer"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Cursor for next page",
            "title": "Next Cursor"
          },
          "offset": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Page offset (0-based, for offset pagination)",
            "title": "Offset"
          },
          "total": {
            "description": "Total count matching filters",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "limit"
        ],
        "title": "PaginationInfo",
        "type": "object"
      },
      "PaginationMeta": {
        "description": "Pagination metadata for list responses.\n\nContains information about the current page and total results.\nSupports both offset-based and cursor-based pagination.",
        "example": {
          "has_more": true,
          "limit": 50,
          "next_cursor": "eyJpZCI6IDUwfQ",
          "offset": 0,
          "total": 150
        },
        "properties": {
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current cursor position (cursor-based pagination)",
            "title": "Cursor"
          },
          "has_more": {
            "description": "Whether more items are available beyond this page",
            "title": "Has More",
            "type": "boolean"
          },
          "limit": {
            "description": "Maximum number of items returned per page",
            "maximum": 10000.0,
            "minimum": 1.0,
            "title": "Limit",
            "type": "integer"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Cursor for the next page of results",
            "title": "Next Cursor"
          },
          "offset": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of items skipped (offset-based pagination)",
            "title": "Offset"
          },
          "total": {
            "description": "Total number of items matching the query",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "total",
          "limit",
          "has_more"
        ],
        "title": "PaginationMeta",
        "type": "object"
      },
      "PerformanceAlert": {
        "description": "Alert when metric exceeds threshold.",
        "example": {
          "message": "GPU temperature high: 82C",
          "metric": "gpu_temperature",
          "severity": "warning",
          "threshold": 80,
          "value": 82
        },
        "properties": {
          "message": {
            "description": "Human-readable alert message",
            "title": "Message",
            "type": "string"
          },
          "metric": {
            "description": "Metric name that triggered the alert",
            "title": "Metric",
            "type": "string"
          },
          "severity": {
            "description": "Alert severity: warning or critical",
            "title": "Severity",
            "type": "string"
          },
          "threshold": {
            "description": "Threshold that was exceeded",
            "title": "Threshold",
            "type": "number"
          },
          "value": {
            "description": "Current metric value",
            "title": "Value",
            "type": "number"
          }
        },
        "required": [
          "severity",
          "metric",
          "value",
          "threshold",
          "message"
        ],
        "title": "PerformanceAlert",
        "type": "object"
      },
      "PerformanceHistoryResponse": {
        "description": "Response containing historical performance data.\n\nUsed by GET /api/system/performance/history endpoint.",
        "example": {
          "count": 0,
          "snapshots": [],
          "time_range": "5m"
        },
        "properties": {
          "count": {
            "description": "Number of snapshots returned",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "snapshots": {
            "description": "List of performance snapshots ordered chronologically",
            "items": {
              "$ref": "#/components/schemas/PerformanceUpdate"
            },
            "title": "Snapshots",
            "type": "array"
          },
          "time_range": {
            "$ref": "#/components/schemas/TimeRange",
            "description": "Time range of the history"
          }
        },
        "required": [
          "snapshots",
          "time_range",
          "count"
        ],
        "title": "PerformanceHistoryResponse",
        "type": "object"
      },
      "PerformanceUpdate": {
        "description": "Complete performance update sent via WebSocket.\n\nThis is the main payload broadcast to frontend clients every 5 seconds.\nAll fields are optional to allow partial updates.",
        "example": {
          "ai_models": {
            "yolo26": {
              "device": "cuda:0",
              "model": "yolo26",
              "status": "healthy",
              "vram_gb": 0.17
            }
          },
          "alerts": [],
          "gpu": {
            "name": "NVIDIA RTX A5500",
            "power_watts": 31,
            "temperature": 38,
            "utilization": 38.0,
            "vram_total_gb": 24.0,
            "vram_used_gb": 22.7
          },
          "host": {
            "cpu_percent": 12,
            "disk_total_gb": 500,
            "disk_used_gb": 156,
            "ram_total_gb": 32,
            "ram_used_gb": 8.2
          },
          "timestamp": "2025-12-31T10:30:00Z"
        },
        "properties": {
          "ai_models": {
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/AiModelMetrics"
                },
                {
                  "$ref": "#/components/schemas/NemotronMetrics"
                }
              ]
            },
            "description": "AI model metrics keyed by model name",
            "title": "Ai Models",
            "type": "object"
          },
          "alerts": {
            "description": "Active performance alerts",
            "items": {
              "$ref": "#/components/schemas/PerformanceAlert"
            },
            "title": "Alerts",
            "type": "array"
          },
          "containers": {
            "description": "Container health statuses",
            "items": {
              "$ref": "#/components/schemas/ContainerMetrics"
            },
            "title": "Containers",
            "type": "array"
          },
          "databases": {
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/DatabaseMetrics"
                },
                {
                  "$ref": "#/components/schemas/RedisMetrics"
                }
              ]
            },
            "description": "Database metrics keyed by name",
            "title": "Databases",
            "type": "object"
          },
          "gpu": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GpuMetrics"
              },
              {
                "type": "null"
              }
            ],
            "description": "GPU metrics"
          },
          "host": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HostMetrics"
              },
              {
                "type": "null"
              }
            ],
            "description": "Host system metrics"
          },
          "inference": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/InferenceMetrics"
              },
              {
                "type": "null"
              }
            ],
            "description": "AI inference latency and throughput"
          },
          "nemotron": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/NemotronMetrics"
              },
              {
                "type": "null"
              }
            ],
            "description": "Nemotron-specific metrics"
          },
          "timestamp": {
            "description": "When this update was generated (UTC)",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "title": "PerformanceUpdate",
        "type": "object"
      },
      "PersonEmbeddingResponse": {
        "description": "Schema for person embedding response.",
        "example": {
          "confidence": 0.95,
          "created_at": "2025-01-01T10:00:00Z",
          "id": 1,
          "member_id": 1,
          "source_event_id": 100
        },
        "properties": {
          "confidence": {
            "description": "Reliability score (0-1)",
            "title": "Confidence",
            "type": "number"
          },
          "created_at": {
            "description": "When the embedding was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "id": {
            "description": "Unique identifier for the embedding",
            "title": "Id",
            "type": "integer"
          },
          "member_id": {
            "description": "ID of the associated household member",
            "title": "Member Id",
            "type": "integer"
          },
          "source_event_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event ID where embedding was captured",
            "title": "Source Event Id"
          }
        },
        "required": [
          "id",
          "member_id",
          "confidence",
          "created_at"
        ],
        "title": "PersonEmbeddingResponse",
        "type": "object"
      },
      "PetEnrichment": {
        "description": "Pet classification results for false positive reduction.",
        "example": {
          "confidence": 0.94,
          "detected": true,
          "is_household_pet": true,
          "type": "dog"
        },
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Classification confidence",
            "title": "Confidence"
          },
          "detected": {
            "default": false,
            "description": "Whether a pet was detected",
            "title": "Detected",
            "type": "boolean"
          },
          "is_household_pet": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether classified as household pet",
            "title": "Is Household Pet"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          },
          "type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Pet type (cat, dog)",
            "title": "Type"
          }
        },
        "title": "PetEnrichment",
        "type": "object"
      },
      "PipelineErrorsResponse": {
        "description": "Response for pipeline errors retrieval.",
        "properties": {
          "errors": {
            "description": "List of recent pipeline errors",
            "items": {
              "$ref": "#/components/schemas/RecentError"
            },
            "title": "Errors",
            "type": "array"
          },
          "limit": {
            "description": "Maximum errors requested",
            "title": "Limit",
            "type": "integer"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          },
          "total": {
            "description": "Total number of errors returned",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "errors",
          "total",
          "limit",
          "timestamp"
        ],
        "title": "PipelineErrorsResponse",
        "type": "object"
      },
      "PipelineLatencies": {
        "description": "Latency statistics for all pipeline stages.\n\nPipeline stages:\n- watch: File watcher detecting new images (file event -> queue)\n- detect: YOLO26v2 object detection (image -> detections)\n- batch: Batch aggregation window (detections -> batch)\n- analyze: Nemotron LLM risk analysis (batch -> event)",
        "example": {
          "analyze": {
            "avg_ms": 5000.0,
            "max_ms": 15000.0,
            "min_ms": 2000.0,
            "p50_ms": 4500.0,
            "p95_ms": 12000.0,
            "p99_ms": 14000.0,
            "sample_count": 100
          },
          "batch": {
            "avg_ms": 30000.0,
            "max_ms": 90000.0,
            "min_ms": 5000.0,
            "p50_ms": 25000.0,
            "p95_ms": 80000.0,
            "p99_ms": 88000.0,
            "sample_count": 100
          },
          "detect": {
            "avg_ms": 200.0,
            "max_ms": 800.0,
            "min_ms": 100.0,
            "p50_ms": 180.0,
            "p95_ms": 600.0,
            "p99_ms": 750.0,
            "sample_count": 500
          },
          "watch": {
            "avg_ms": 10.0,
            "max_ms": 50.0,
            "min_ms": 5.0,
            "p50_ms": 8.0,
            "p95_ms": 40.0,
            "p99_ms": 48.0,
            "sample_count": 500
          }
        },
        "properties": {
          "analyze": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM analysis stage latency (Nemotron inference)"
          },
          "batch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Batch aggregation window time"
          },
          "detect": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object detection stage latency (YOLO26v2 inference)"
          },
          "watch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "File watcher stage latency (file event to queue)"
          }
        },
        "title": "PipelineLatencies",
        "type": "object"
      },
      "PipelineLatencyHistoryResponse": {
        "description": "Response schema for pipeline latency history endpoint.\n\nProvides time-series latency data for charting and trend analysis.\nEach snapshot contains aggregated metrics for a time bucket.",
        "example": {
          "bucket_seconds": 60,
          "snapshots": [
            {
              "stages": {
                "watch_to_detect": {
                  "avg_ms": 50.0,
                  "p50_ms": 45.0,
                  "p95_ms": 120.0,
                  "p99_ms": 150.0,
                  "sample_count": 15
                }
              },
              "timestamp": "2025-12-28T10:00:00+00:00"
            }
          ],
          "timestamp": "2025-12-28T10:30:00Z",
          "window_minutes": 60
        },
        "properties": {
          "bucket_seconds": {
            "description": "Bucket size for aggregation",
            "minimum": 1.0,
            "title": "Bucket Seconds",
            "type": "integer"
          },
          "snapshots": {
            "description": "Chronologically ordered latency snapshots",
            "items": {
              "$ref": "#/components/schemas/LatencyHistorySnapshot"
            },
            "title": "Snapshots",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp when history was retrieved",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "window_minutes": {
            "description": "Time window covered by the history",
            "minimum": 1.0,
            "title": "Window Minutes",
            "type": "integer"
          }
        },
        "required": [
          "snapshots",
          "window_minutes",
          "bucket_seconds",
          "timestamp"
        ],
        "title": "PipelineLatencyHistoryResponse",
        "type": "object"
      },
      "PipelineLatencyResponse": {
        "description": "Response schema for pipeline latency endpoint.\n\nProvides latency metrics for each stage transition in the AI pipeline:\n- watch_to_detect: Time from file watcher detecting image to YOLO26 processing start\n- detect_to_batch: Time from detection completion to batch aggregation\n- batch_to_analyze: Time from batch completion to Nemotron analysis start\n- total_pipeline: Total end-to-end processing time",
        "example": {
          "batch_to_analyze": {
            "avg_ms": 5000.0,
            "max_ms": 15000.0,
            "min_ms": 2000.0,
            "p50_ms": 4500.0,
            "p95_ms": 12000.0,
            "p99_ms": 14000.0,
            "sample_count": 100
          },
          "detect_to_batch": {
            "avg_ms": 100.0,
            "max_ms": 500.0,
            "min_ms": 20.0,
            "p50_ms": 80.0,
            "p95_ms": 400.0,
            "p99_ms": 480.0,
            "sample_count": 500
          },
          "timestamp": "2025-12-28T10:30:00Z",
          "total_pipeline": {
            "avg_ms": 35000.0,
            "max_ms": 120000.0,
            "min_ms": 10000.0,
            "p50_ms": 30000.0,
            "p95_ms": 100000.0,
            "p99_ms": 110000.0,
            "sample_count": 100
          },
          "watch_to_detect": {
            "avg_ms": 50.0,
            "max_ms": 200.0,
            "min_ms": 10.0,
            "p50_ms": 40.0,
            "p95_ms": 150.0,
            "p99_ms": 180.0,
            "sample_count": 500
          },
          "window_minutes": 60
        },
        "properties": {
          "batch_to_analyze": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency from batch to Nemotron analysis"
          },
          "detect_to_batch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency from detection to batch aggregation"
          },
          "timestamp": {
            "description": "Timestamp of latency snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "total_pipeline": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Total end-to-end pipeline latency"
          },
          "watch_to_detect": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineStageLatency"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency from file detection to YOLO26 processing"
          },
          "window_minutes": {
            "description": "Time window used for calculating statistics",
            "minimum": 1.0,
            "title": "Window Minutes",
            "type": "integer"
          }
        },
        "required": [
          "window_minutes",
          "timestamp"
        ],
        "title": "PipelineLatencyResponse",
        "type": "object"
      },
      "PipelineStageLatency": {
        "description": "Latency statistics for a single pipeline transition stage.\n\nTracks time between pipeline stages:\n- watch_to_detect: File detection to YOLO26 processing\n- detect_to_batch: Detection to batch aggregation\n- batch_to_analyze: Batch to Nemotron analysis\n- total_pipeline: End-to-end latency",
        "example": {
          "avg_ms": 150.5,
          "max_ms": 500.0,
          "min_ms": 50.0,
          "p50_ms": 120.0,
          "p95_ms": 400.0,
          "p99_ms": 480.0,
          "sample_count": 100
        },
        "properties": {
          "avg_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Average latency in milliseconds",
            "title": "Avg Ms"
          },
          "max_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum latency in milliseconds",
            "title": "Max Ms"
          },
          "min_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum latency in milliseconds",
            "title": "Min Ms"
          },
          "p50_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "50th percentile (median) latency in milliseconds",
            "title": "P50 Ms"
          },
          "p95_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "95th percentile latency in milliseconds",
            "title": "P95 Ms"
          },
          "p99_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "99th percentile latency in milliseconds",
            "title": "P99 Ms"
          },
          "sample_count": {
            "description": "Number of samples used to calculate statistics",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "sample_count"
        ],
        "title": "PipelineStageLatency",
        "type": "object"
      },
      "PipelineStateResponse": {
        "description": "Response for pipeline state inspection.",
        "properties": {
          "correlation_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Correlation ID from request",
            "title": "Correlation Id"
          },
          "queue_depths": {
            "$ref": "#/components/schemas/QueueDepths",
            "description": "Current queue depths"
          },
          "recent_errors": {
            "description": "Recent errors (last 10)",
            "items": {
              "$ref": "#/components/schemas/RecentError"
            },
            "title": "Recent Errors",
            "type": "array"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          },
          "workers": {
            "$ref": "#/components/schemas/PipelineWorkersStatus",
            "description": "Worker status"
          }
        },
        "required": [
          "queue_depths",
          "workers",
          "timestamp"
        ],
        "title": "PipelineStateResponse",
        "type": "object"
      },
      "PipelineStatusResponse": {
        "description": "Combined status of all pipeline operations.\n\nProvides visibility into:\n- FileWatcher: Monitoring camera directories for new uploads\n- BatchAggregator: Grouping detections into time-based batches\n- DegradationManager: Graceful degradation and service health",
        "example": {
          "batch_aggregator": {
            "active_batches": 1,
            "batch_window_seconds": 90,
            "batches": [],
            "idle_timeout_seconds": 30
          },
          "degradation": {
            "available_features": [
              "detection",
              "analysis",
              "events",
              "media"
            ],
            "fallback_queues": {},
            "is_degraded": false,
            "memory_queue_size": 0,
            "mode": "normal",
            "redis_healthy": true,
            "services": []
          },
          "file_watcher": {
            "camera_root": "/export/foscam",
            "observer_type": "native",
            "pending_tasks": 0,
            "running": true
          },
          "timestamp": "2025-12-30T10:30:00Z"
        },
        "properties": {
          "batch_aggregator": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BatchAggregatorStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "BatchAggregator service status (null if not running)"
          },
          "degradation": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DegradationStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "DegradationManager service status (null if not initialized)"
          },
          "file_watcher": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FileWatcherStatusResponse"
              },
              {
                "type": "null"
              }
            ],
            "description": "FileWatcher service status (null if not running)"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp"
        ],
        "title": "PipelineStatusResponse",
        "type": "object"
      },
      "PipelineWorkerStatus": {
        "description": "Status of a pipeline worker.",
        "properties": {
          "error_count": {
            "default": 0,
            "description": "Number of recent errors",
            "title": "Error Count",
            "type": "integer"
          },
          "last_activity": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "ISO timestamp of last activity",
            "title": "Last Activity"
          },
          "name": {
            "description": "Worker name",
            "title": "Name",
            "type": "string"
          },
          "running": {
            "description": "Whether worker is currently running",
            "title": "Running",
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "running"
        ],
        "title": "PipelineWorkerStatus",
        "type": "object"
      },
      "PipelineWorkersStatus": {
        "description": "Status of all pipeline workers.",
        "properties": {
          "analyzer": {
            "$ref": "#/components/schemas/PipelineWorkerStatus",
            "description": "Analyzer worker status"
          },
          "detector": {
            "$ref": "#/components/schemas/PipelineWorkerStatus",
            "description": "Detector worker status"
          },
          "file_watcher": {
            "$ref": "#/components/schemas/PipelineWorkerStatus",
            "description": "File watcher status"
          }
        },
        "required": [
          "file_watcher",
          "detector",
          "analyzer"
        ],
        "title": "PipelineWorkersStatus",
        "type": "object"
      },
      "PlateReadCreate": {
        "description": "Schema for creating a new plate read record.\n\nUsed when manually creating plate reads via the API (e.g., from\nexternal ALPR systems or manual entry).",
        "example": {
          "bbox": [
            100.0,
            200.0,
            250.0,
            240.0
          ],
          "camera_id": "driveway",
          "detection_confidence": 0.95,
          "image_quality_score": 0.85,
          "is_blurry": false,
          "is_enhanced": false,
          "ocr_confidence": 0.92,
          "plate_text": "ABC1234",
          "raw_text": "ABC-1234",
          "timestamp": "2026-01-26T14:30:00Z"
        },
        "properties": {
          "bbox": {
            "description": "Bounding box [x1, y1, x2, y2]",
            "items": {
              "type": "number"
            },
            "maxItems": 4,
            "minItems": 4,
            "title": "Bbox",
            "type": "array"
          },
          "camera_id": {
            "description": "Camera ID where plate was detected",
            "title": "Camera Id",
            "type": "string"
          },
          "detection_confidence": {
            "description": "Plate detection confidence (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Detection Confidence",
            "type": "number"
          },
          "image_quality_score": {
            "description": "Image quality assessment (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Image Quality Score",
            "type": "number"
          },
          "is_blurry": {
            "default": false,
            "description": "Whether motion blur was detected",
            "title": "Is Blurry",
            "type": "boolean"
          },
          "is_enhanced": {
            "default": false,
            "description": "Whether low-light enhancement was applied",
            "title": "Is Enhanced",
            "type": "boolean"
          },
          "ocr_confidence": {
            "description": "Text recognition confidence (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Ocr Confidence",
            "type": "number"
          },
          "plate_text": {
            "description": "Recognized plate text (alphanumeric only)",
            "maxLength": 20,
            "minLength": 1,
            "title": "Plate Text",
            "type": "string"
          },
          "raw_text": {
            "description": "Raw OCR output before filtering",
            "maxLength": 50,
            "title": "Raw Text",
            "type": "string"
          },
          "timestamp": {
            "description": "Detection timestamp",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "camera_id",
          "timestamp",
          "plate_text",
          "raw_text",
          "detection_confidence",
          "ocr_confidence",
          "bbox",
          "image_quality_score"
        ],
        "title": "PlateReadCreate",
        "type": "object"
      },
      "PlateReadListResponse": {
        "description": "Paginated list of plate reads.\n\nStandard pagination envelope for plate read list endpoints.",
        "example": {
          "page": 1,
          "page_size": 50,
          "plate_reads": [
            {
              "bbox": [
                100.0,
                200.0,
                250.0,
                240.0
              ],
              "camera_id": "driveway",
              "created_at": "2026-01-26T14:30:05Z",
              "detection_confidence": 0.95,
              "id": 1,
              "image_quality_score": 0.85,
              "is_blurry": false,
              "is_enhanced": false,
              "ocr_confidence": 0.92,
              "plate_text": "ABC1234",
              "raw_text": "ABC-1234",
              "timestamp": "2026-01-26T14:30:00Z"
            }
          ],
          "total": 1
        },
        "properties": {
          "page": {
            "description": "Current page number (1-indexed)",
            "minimum": 1.0,
            "title": "Page",
            "type": "integer"
          },
          "page_size": {
            "description": "Number of items per page",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Page Size",
            "type": "integer"
          },
          "plate_reads": {
            "description": "List of plate reads",
            "items": {
              "$ref": "#/components/schemas/PlateReadResponse"
            },
            "title": "Plate Reads",
            "type": "array"
          },
          "total": {
            "description": "Total number of plate reads matching query",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "plate_reads",
          "total",
          "page",
          "page_size"
        ],
        "title": "PlateReadListResponse",
        "type": "object"
      },
      "PlateReadResponse": {
        "description": "Response schema for a plate read record.\n\nIncludes the database ID for reference and linking.",
        "example": {
          "bbox": [
            100.0,
            200.0,
            250.0,
            240.0
          ],
          "camera_id": "driveway",
          "created_at": "2026-01-26T14:30:05Z",
          "detection_confidence": 0.95,
          "id": 1,
          "image_quality_score": 0.85,
          "is_blurry": false,
          "is_enhanced": false,
          "ocr_confidence": 0.92,
          "plate_text": "ABC1234",
          "raw_text": "ABC-1234",
          "timestamp": "2026-01-26T14:30:00Z"
        },
        "properties": {
          "bbox": {
            "description": "Bounding box [x1, y1, x2, y2]",
            "items": {
              "type": "number"
            },
            "maxItems": 4,
            "minItems": 4,
            "title": "Bbox",
            "type": "array"
          },
          "camera_id": {
            "description": "Camera ID where plate was detected",
            "title": "Camera Id",
            "type": "string"
          },
          "created_at": {
            "description": "Record creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "detection_confidence": {
            "description": "Plate detection confidence (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Detection Confidence",
            "type": "number"
          },
          "id": {
            "description": "Database record ID",
            "title": "Id",
            "type": "integer"
          },
          "image_quality_score": {
            "description": "Image quality assessment (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Image Quality Score",
            "type": "number"
          },
          "is_blurry": {
            "default": false,
            "description": "Whether motion blur was detected",
            "title": "Is Blurry",
            "type": "boolean"
          },
          "is_enhanced": {
            "default": false,
            "description": "Whether low-light enhancement was applied",
            "title": "Is Enhanced",
            "type": "boolean"
          },
          "ocr_confidence": {
            "description": "Text recognition confidence (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Ocr Confidence",
            "type": "number"
          },
          "plate_text": {
            "description": "Recognized plate text (alphanumeric only)",
            "maxLength": 20,
            "minLength": 1,
            "title": "Plate Text",
            "type": "string"
          },
          "raw_text": {
            "description": "Raw OCR output before filtering",
            "maxLength": 50,
            "title": "Raw Text",
            "type": "string"
          },
          "timestamp": {
            "description": "Detection timestamp",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "camera_id",
          "timestamp",
          "plate_text",
          "raw_text",
          "detection_confidence",
          "ocr_confidence",
          "bbox",
          "image_quality_score",
          "id",
          "created_at"
        ],
        "title": "PlateReadResponse",
        "type": "object"
      },
      "PlateRecognizeRequest": {
        "description": "Request schema for plate recognition from image data.\n\nUsed for the /recognize endpoint to extract plate text from\nuploaded images or base64-encoded image data.",
        "example": {
          "camera_id": "driveway",
          "detection_bbox": [
            100.0,
            200.0,
            250.0,
            240.0
          ],
          "detection_confidence": 0.95,
          "image_base64": "data:image/jpeg;base64,/9j/4AAQSkZ..."
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID for the source image",
            "title": "Camera Id",
            "type": "string"
          },
          "detection_bbox": {
            "anyOf": [
              {
                "items": {
                  "type": "number"
                },
                "maxItems": 4,
                "minItems": 4,
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional bounding box for plate region [x1, y1, x2, y2]",
            "title": "Detection Bbox"
          },
          "detection_confidence": {
            "default": 1.0,
            "description": "Detection confidence from upstream detector",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Detection Confidence",
            "type": "number"
          },
          "image_base64": {
            "description": "Base64-encoded image data (JPEG or PNG)",
            "title": "Image Base64",
            "type": "string"
          }
        },
        "required": [
          "camera_id",
          "image_base64"
        ],
        "title": "PlateRecognizeRequest",
        "type": "object"
      },
      "PlateRecognizeResponse": {
        "description": "Response schema for plate recognition request.\n\nReturns the recognized plate text and confidence metrics\nwithout storing to database (for preview/testing).",
        "example": {
          "image_quality_score": 0.85,
          "is_blurry": false,
          "is_enhanced": false,
          "ocr_confidence": 0.92,
          "plate_read_id": 123,
          "plate_text": "ABC1234",
          "raw_text": "ABC-1234",
          "stored": true
        },
        "properties": {
          "image_quality_score": {
            "description": "Image quality score (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Image Quality Score",
            "type": "number"
          },
          "is_blurry": {
            "description": "Whether motion blur was detected",
            "title": "Is Blurry",
            "type": "boolean"
          },
          "is_enhanced": {
            "description": "Whether low-light enhancement was applied",
            "title": "Is Enhanced",
            "type": "boolean"
          },
          "ocr_confidence": {
            "description": "OCR confidence (0-1)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Ocr Confidence",
            "type": "number"
          },
          "plate_read_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Database ID if stored (null if not stored)",
            "title": "Plate Read Id"
          },
          "plate_text": {
            "description": "Recognized plate text (alphanumeric only)",
            "title": "Plate Text",
            "type": "string"
          },
          "raw_text": {
            "description": "Raw OCR output before filtering",
            "title": "Raw Text",
            "type": "string"
          },
          "stored": {
            "description": "Whether the read was stored in database",
            "title": "Stored",
            "type": "boolean"
          }
        },
        "required": [
          "plate_text",
          "raw_text",
          "ocr_confidence",
          "image_quality_score",
          "is_enhanced",
          "is_blurry",
          "stored"
        ],
        "title": "PlateRecognizeResponse",
        "type": "object"
      },
      "PlateStatisticsResponse": {
        "description": "Statistics for plate recognition performance and activity.\n\nAggregated metrics for monitoring ALPR system health and usage.",
        "example": {
          "avg_ocr_confidence": 0.89,
          "avg_quality_score": 0.82,
          "blurry_count": 45,
          "enhanced_count": 127,
          "reads_last_24h": 198,
          "reads_last_hour": 23,
          "total_reads": 1523,
          "unique_plates": 342
        },
        "properties": {
          "avg_ocr_confidence": {
            "description": "Average OCR confidence",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Avg Ocr Confidence",
            "type": "number"
          },
          "avg_quality_score": {
            "description": "Average image quality score",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Avg Quality Score",
            "type": "number"
          },
          "blurry_count": {
            "description": "Number of reads with motion blur",
            "minimum": 0.0,
            "title": "Blurry Count",
            "type": "integer"
          },
          "enhanced_count": {
            "description": "Number of reads with low-light enhancement",
            "minimum": 0.0,
            "title": "Enhanced Count",
            "type": "integer"
          },
          "reads_last_24h": {
            "description": "Reads in the last 24 hours",
            "minimum": 0.0,
            "title": "Reads Last 24H",
            "type": "integer"
          },
          "reads_last_hour": {
            "description": "Reads in the last hour",
            "minimum": 0.0,
            "title": "Reads Last Hour",
            "type": "integer"
          },
          "total_reads": {
            "description": "Total number of plate reads",
            "minimum": 0.0,
            "title": "Total Reads",
            "type": "integer"
          },
          "unique_plates": {
            "description": "Count of unique plate texts",
            "minimum": 0.0,
            "title": "Unique Plates",
            "type": "integer"
          }
        },
        "required": [
          "total_reads",
          "unique_plates",
          "avg_ocr_confidence",
          "avg_quality_score",
          "enhanced_count",
          "blurry_count",
          "reads_last_hour",
          "reads_last_24h"
        ],
        "title": "PlateStatisticsResponse",
        "type": "object"
      },
      "PolygonZoneCreate": {
        "description": "Schema for creating a new polygon zone.\n\nRequires camera_id to associate the zone with a specific camera.",
        "example": {
          "alert_threshold": 1,
          "camera_id": "front_door",
          "color": "#FF0000",
          "is_active": true,
          "name": "Restricted Area",
          "polygon": [
            [
              100,
              100
            ],
            [
              400,
              100
            ],
            [
              400,
              300
            ],
            [
              100,
              300
            ]
          ],
          "target_classes": [
            "person"
          ],
          "zone_type": "restricted"
        },
        "properties": {
          "alert_threshold": {
            "default": 0,
            "description": "Number of objects that trigger an alert (0 = any entry alerts)",
            "minimum": 0.0,
            "title": "Alert Threshold",
            "type": "integer"
          },
          "camera_id": {
            "description": "ID of the camera this polygon zone belongs to",
            "maxLength": 255,
            "minLength": 1,
            "title": "Camera Id",
            "type": "string"
          },
          "color": {
            "default": "#FF0000",
            "description": "Hex color for UI display",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "title": "Color",
            "type": "string"
          },
          "is_active": {
            "default": true,
            "description": "Whether the zone is actively monitoring",
            "title": "Is Active",
            "type": "boolean"
          },
          "name": {
            "description": "Descriptive name for the polygon zone",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "polygon": {
            "description": "List of [x, y] points defining the polygon (minimum 3 points)",
            "items": {
              "items": {
                "type": "integer"
              },
              "type": "array"
            },
            "minItems": 3,
            "title": "Polygon",
            "type": "array"
          },
          "target_classes": {
            "description": "Object classes to monitor in this zone",
            "items": {
              "type": "string"
            },
            "title": "Target Classes",
            "type": "array"
          },
          "zone_type": {
            "$ref": "#/components/schemas/PolygonZoneType",
            "default": "monitored",
            "description": "Type of zone: restricted, monitored, or entry"
          }
        },
        "required": [
          "name",
          "polygon",
          "camera_id"
        ],
        "title": "PolygonZoneCreate",
        "type": "object"
      },
      "PolygonZoneListResponse": {
        "description": "Paginated list of polygon zones.",
        "example": {
          "total": 1,
          "zones": [
            {
              "alert_threshold": 1,
              "camera_id": "front_door",
              "color": "#FF0000",
              "created_at": "2026-01-26T10:00:00Z",
              "current_count": 0,
              "id": 1,
              "is_active": true,
              "name": "Restricted Area",
              "polygon": [
                [
                  100,
                  100
                ],
                [
                  400,
                  100
                ],
                [
                  400,
                  300
                ],
                [
                  100,
                  300
                ]
              ],
              "target_classes": [
                "person"
              ],
              "zone_type": "restricted"
            }
          ]
        },
        "properties": {
          "total": {
            "description": "Total number of polygon zones",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          },
          "zones": {
            "description": "List of polygon zones",
            "items": {
              "$ref": "#/components/schemas/PolygonZoneResponse"
            },
            "title": "Zones",
            "type": "array"
          }
        },
        "required": [
          "zones",
          "total"
        ],
        "title": "PolygonZoneListResponse",
        "type": "object"
      },
      "PolygonZoneResponse": {
        "description": "Response schema for a polygon zone.\n\nIncludes current occupancy count.",
        "example": {
          "alert_threshold": 1,
          "camera_id": "front_door",
          "color": "#FF0000",
          "created_at": "2026-01-26T10:00:00Z",
          "current_count": 0,
          "id": 1,
          "is_active": true,
          "name": "Restricted Area",
          "polygon": [
            [
              100,
              100
            ],
            [
              400,
              100
            ],
            [
              400,
              300
            ],
            [
              100,
              300
            ]
          ],
          "target_classes": [
            "person"
          ],
          "zone_type": "restricted"
        },
        "properties": {
          "alert_threshold": {
            "default": 0,
            "description": "Number of objects that trigger an alert (0 = any entry alerts)",
            "minimum": 0.0,
            "title": "Alert Threshold",
            "type": "integer"
          },
          "camera_id": {
            "description": "ID of the camera this zone belongs to",
            "title": "Camera Id",
            "type": "string"
          },
          "color": {
            "default": "#FF0000",
            "description": "Hex color for UI display",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "title": "Color",
            "type": "string"
          },
          "created_at": {
            "description": "Timestamp when the zone was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "current_count": {
            "default": 0,
            "description": "Current object count in zone",
            "minimum": 0.0,
            "title": "Current Count",
            "type": "integer"
          },
          "id": {
            "description": "Unique polygon zone identifier",
            "title": "Id",
            "type": "integer"
          },
          "is_active": {
            "default": true,
            "description": "Whether the zone is actively monitoring",
            "title": "Is Active",
            "type": "boolean"
          },
          "name": {
            "description": "Descriptive name for the polygon zone",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "polygon": {
            "description": "List of [x, y] points defining the polygon (minimum 3 points)",
            "items": {
              "items": {
                "type": "integer"
              },
              "type": "array"
            },
            "minItems": 3,
            "title": "Polygon",
            "type": "array"
          },
          "target_classes": {
            "description": "Object classes to monitor in this zone",
            "items": {
              "type": "string"
            },
            "title": "Target Classes",
            "type": "array"
          },
          "zone_type": {
            "$ref": "#/components/schemas/PolygonZoneType",
            "default": "monitored",
            "description": "Type of zone: restricted, monitored, or entry"
          }
        },
        "required": [
          "name",
          "polygon",
          "id",
          "camera_id",
          "created_at"
        ],
        "title": "PolygonZoneResponse",
        "type": "object"
      },
      "PolygonZoneType": {
        "description": "Type classification for polygon zones.",
        "enum": [
          "restricted",
          "monitored",
          "entry"
        ],
        "title": "PolygonZoneType",
        "type": "string"
      },
      "PolygonZoneUpdate": {
        "description": "Schema for updating an existing polygon zone.\n\nAll fields are optional; only provided fields are updated.",
        "example": {
          "alert_threshold": 2,
          "is_active": false,
          "name": "Updated Restricted Area"
        },
        "properties": {
          "alert_threshold": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of objects that trigger an alert",
            "title": "Alert Threshold"
          },
          "color": {
            "anyOf": [
              {
                "pattern": "^#[0-9A-Fa-f]{6}$",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Hex color for UI display",
            "title": "Color"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether the zone is actively monitoring",
            "title": "Is Active"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Descriptive name for the polygon zone",
            "title": "Name"
          },
          "polygon": {
            "anyOf": [
              {
                "items": {
                  "items": {
                    "type": "integer"
                  },
                  "type": "array"
                },
                "minItems": 3,
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "List of [x, y] points defining the polygon",
            "title": "Polygon"
          },
          "target_classes": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Object classes to monitor in this zone",
            "title": "Target Classes"
          },
          "zone_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PolygonZoneType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Type of zone: restricted, monitored, or entry"
          }
        },
        "title": "PolygonZoneUpdate",
        "type": "object"
      },
      "PoseEnrichment": {
        "description": "Pose estimation results from ViTPose integration.",
        "example": {
          "alerts": [
            "person_crouching"
          ],
          "confidence": 0.82,
          "keypoint_count": 17,
          "keypoints": [
            [
              100,
              150,
              0.9
            ],
            [
              120,
              160,
              0.85
            ]
          ],
          "posture": "standing",
          "security_alerts": [
            "person_crouching"
          ]
        },
        "properties": {
          "alerts": {
            "description": "Pose-related security alerts",
            "items": {
              "type": "string"
            },
            "title": "Alerts",
            "type": "array"
          },
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Pose estimation confidence",
            "title": "Confidence"
          },
          "keypoint_count": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of detected keypoints",
            "title": "Keypoint Count"
          },
          "keypoints": {
            "anyOf": [
              {
                "items": {
                  "items": {
                    "type": "number"
                  },
                  "type": "array"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Body keypoints [[x, y, conf], ...]",
            "title": "Keypoints"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          },
          "posture": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detected posture (standing, sitting, etc.)",
            "title": "Posture"
          },
          "security_alerts": {
            "description": "Backward compatibility alias for alerts",
            "items": {
              "type": "string"
            },
            "title": "Security Alerts",
            "type": "array"
          }
        },
        "title": "PoseEnrichment",
        "type": "object"
      },
      "ProfileStartResponse": {
        "description": "Response for starting profiling.",
        "properties": {
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "started_at": {
            "description": "ISO timestamp when profiling started",
            "title": "Started At",
            "type": "string"
          },
          "status": {
            "description": "Profiling status ('started' or 'already_running')",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "status",
          "started_at",
          "message"
        ],
        "title": "ProfileStartResponse",
        "type": "object"
      },
      "ProfileStatsResponse": {
        "description": "Response for profiling statistics.",
        "properties": {
          "is_profiling": {
            "description": "Whether profiling is currently active",
            "title": "Is Profiling",
            "type": "boolean"
          },
          "last_profile_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to last saved profile",
            "title": "Last Profile Path"
          },
          "stats_text": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable profiling statistics",
            "title": "Stats Text"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "is_profiling",
          "timestamp"
        ],
        "title": "ProfileStatsResponse",
        "type": "object"
      },
      "ProfileStopResponse": {
        "description": "Response for stopping profiling.",
        "properties": {
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "profile_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to saved profile file",
            "title": "Profile Path"
          },
          "status": {
            "description": "Profiling status ('stopped' or 'not_running')",
            "title": "Status",
            "type": "string"
          },
          "stopped_at": {
            "description": "ISO timestamp when profiling stopped",
            "title": "Stopped At",
            "type": "string"
          }
        },
        "required": [
          "status",
          "stopped_at",
          "message"
        ],
        "title": "ProfileStopResponse",
        "type": "object"
      },
      "PrometheusAlertStatus": {
        "description": "Prometheus alert status values.",
        "enum": [
          "firing",
          "resolved"
        ],
        "title": "PrometheusAlertStatus",
        "type": "string"
      },
      "PromptDiffEntry": {
        "description": "Diff entry for a single model's configuration.",
        "example": {
          "changes": [
            "temperature: 0.7 -> 0.8",
            "system_prompt: modified (length: 40 -> 55 chars)"
          ],
          "current_config": {
            "max_tokens": 2048,
            "system_prompt": "You are a home security AI...",
            "temperature": 0.7
          },
          "current_version": 3,
          "has_changes": true,
          "imported_config": {
            "max_tokens": 2048,
            "system_prompt": "You are a home security AI with enhanced context...",
            "temperature": 0.8
          },
          "model": "nemotron"
        },
        "properties": {
          "changes": {
            "description": "List of human-readable change descriptions",
            "items": {
              "type": "string"
            },
            "title": "Changes",
            "type": "array"
          },
          "current_config": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current configuration",
            "title": "Current Config"
          },
          "current_version": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Current version number",
            "title": "Current Version"
          },
          "has_changes": {
            "description": "Whether there are changes",
            "title": "Has Changes",
            "type": "boolean"
          },
          "imported_config": {
            "additionalProperties": true,
            "description": "Configuration to import",
            "title": "Imported Config",
            "type": "object"
          },
          "model": {
            "description": "Model name",
            "title": "Model",
            "type": "string"
          }
        },
        "required": [
          "model",
          "has_changes",
          "imported_config"
        ],
        "title": "PromptDiffEntry",
        "type": "object"
      },
      "PromptHistoryResponse": {
        "description": "Response containing version history for prompts.",
        "example": {
          "total_count": 3,
          "versions": [
            {
              "change_description": "Added weather context to prompt",
              "created_at": "2026-01-03T10:30:00Z",
              "created_by": "admin",
              "id": 15,
              "is_active": true,
              "model": "nemotron",
              "version": 3
            },
            {
              "change_description": "Initial configuration",
              "created_at": "2026-01-02T14:00:00Z",
              "created_by": "system",
              "id": 12,
              "is_active": false,
              "model": "nemotron",
              "version": 2
            }
          ]
        },
        "properties": {
          "total_count": {
            "title": "Total Count",
            "type": "integer"
          },
          "versions": {
            "items": {
              "$ref": "#/components/schemas/PromptVersionInfo"
            },
            "title": "Versions",
            "type": "array"
          }
        },
        "required": [
          "versions",
          "total_count"
        ],
        "title": "PromptHistoryResponse",
        "type": "object"
      },
      "PromptImprovements": {
        "description": "Prompt improvement suggestions from self-evaluation.",
        "example": {
          "confusing_sections": [
            "Zone overlap handling unclear"
          ],
          "format_suggestions": [
            "Add structured detection summary"
          ],
          "missing_context": [
            "Time since last motion event",
            "Weather conditions"
          ],
          "model_gaps": [
            "Pet detection model not active"
          ],
          "unused_data": [
            "Vehicle color data not utilized"
          ]
        },
        "properties": {
          "confusing_sections": {
            "items": {
              "type": "string"
            },
            "title": "Confusing Sections",
            "type": "array"
          },
          "format_suggestions": {
            "items": {
              "type": "string"
            },
            "title": "Format Suggestions",
            "type": "array"
          },
          "missing_context": {
            "items": {
              "type": "string"
            },
            "title": "Missing Context",
            "type": "array"
          },
          "model_gaps": {
            "items": {
              "type": "string"
            },
            "title": "Model Gaps",
            "type": "array"
          },
          "unused_data": {
            "items": {
              "type": "string"
            },
            "title": "Unused Data",
            "type": "array"
          }
        },
        "title": "PromptImprovements",
        "type": "object"
      },
      "PromptRestoreResponse": {
        "description": "Response after restoring a prompt version.",
        "example": {
          "message": "Successfully restored version 2 as new version 4",
          "model": "nemotron",
          "new_version": 4,
          "restored_version": 2
        },
        "properties": {
          "message": {
            "title": "Message",
            "type": "string"
          },
          "model": {
            "$ref": "#/components/schemas/AIModelEnum"
          },
          "new_version": {
            "description": "The new active version number",
            "title": "New Version",
            "type": "integer"
          },
          "restored_version": {
            "title": "Restored Version",
            "type": "integer"
          }
        },
        "required": [
          "restored_version",
          "model",
          "new_version",
          "message"
        ],
        "title": "PromptRestoreResponse",
        "type": "object"
      },
      "PromptTestRequest": {
        "description": "Request to test a prompt with modified configuration.",
        "example": {
          "config": {
            "max_tokens": 2048,
            "system_prompt": "You are a home security AI assistant...",
            "temperature": 0.7
          },
          "event_id": 12345,
          "model": "nemotron"
        },
        "properties": {
          "config": {
            "additionalProperties": true,
            "description": "Configuration to test",
            "title": "Config",
            "type": "object"
          },
          "event_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional event ID to test against",
            "title": "Event Id"
          },
          "image_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional image path to test with",
            "title": "Image Path"
          },
          "model": {
            "$ref": "#/components/schemas/AIModelEnum",
            "description": "Model to test"
          }
        },
        "required": [
          "model",
          "config"
        ],
        "title": "PromptTestRequest",
        "type": "object"
      },
      "PromptTestResult": {
        "description": "Result of a prompt test.",
        "example": {
          "after_response": {
            "risk_level": "low",
            "risk_score": 45,
            "summary": "Regular visitor detected - matches known delivery pattern"
          },
          "after_score": 45,
          "before_response": {
            "risk_level": "medium",
            "risk_score": 65,
            "summary": "Person detected at front door during evening hours"
          },
          "before_score": 65,
          "improved": true,
          "model": "nemotron",
          "test_duration_ms": 1250
        },
        "properties": {
          "after_response": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Full response after changes",
            "title": "After Response"
          },
          "after_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk score after changes",
            "title": "After Score"
          },
          "before_response": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Full response before changes",
            "title": "Before Response"
          },
          "before_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk score before changes",
            "title": "Before Score"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if test failed",
            "title": "Error"
          },
          "improved": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether the change improved results",
            "title": "Improved"
          },
          "model": {
            "$ref": "#/components/schemas/AIModelEnum"
          },
          "test_duration_ms": {
            "description": "Test duration in milliseconds",
            "title": "Test Duration Ms",
            "type": "integer"
          }
        },
        "required": [
          "model",
          "test_duration_ms"
        ],
        "title": "PromptTestResult",
        "type": "object"
      },
      "PromptUpdateRequest": {
        "description": "Request to update a model's prompt configuration.\n\nSupports optimistic locking via expected_version field to prevent\nrace conditions when multiple clients update simultaneously.",
        "example": {
          "change_description": "Increased temperature for more creative responses",
          "config": {
            "max_tokens": 2048,
            "system_prompt": "You are a home security AI assistant with enhanced context awareness...",
            "temperature": 0.8
          },
          "expected_version": 3
        },
        "properties": {
          "change_description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional description of what changed",
            "title": "Change Description"
          },
          "config": {
            "additionalProperties": true,
            "description": "New configuration for the model",
            "title": "Config",
            "type": "object"
          },
          "expected_version": {
            "anyOf": [
              {
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Expected current version for optimistic locking. If provided, the update will fail with 409 Conflict if the current version doesn't match, indicating someone else updated the config concurrently.",
            "title": "Expected Version"
          }
        },
        "required": [
          "config"
        ],
        "title": "PromptUpdateRequest",
        "type": "object"
      },
      "PromptVersionInfo": {
        "description": "Information about a single prompt version.",
        "example": {
          "change_description": "Added weather context to prompt",
          "created_at": "2026-01-03T10:30:00Z",
          "created_by": "admin",
          "id": 15,
          "is_active": true,
          "model": "nemotron",
          "version": 3
        },
        "properties": {
          "change_description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Change Description"
          },
          "created_at": {
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "created_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created By"
          },
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "is_active": {
            "title": "Is Active",
            "type": "boolean"
          },
          "model": {
            "$ref": "#/components/schemas/AIModelEnum"
          },
          "version": {
            "title": "Version",
            "type": "integer"
          }
        },
        "required": [
          "id",
          "model",
          "version",
          "created_at",
          "created_by",
          "change_description",
          "is_active"
        ],
        "title": "PromptVersionInfo",
        "type": "object"
      },
      "PromptsExportResponse": {
        "description": "Export of all prompt configurations.",
        "example": {
          "exported_at": "2026-01-03T10:30:00Z",
          "prompts": {
            "florence2": {
              "vqa_queries": [
                "What is this person wearing?"
              ]
            },
            "nemotron": {
              "max_tokens": 2048,
              "system_prompt": "You are a home security AI assistant...",
              "temperature": 0.7
            },
            "yolo_world": {
              "confidence_threshold": 0.35,
              "object_classes": [
                "person",
                "car",
                "truck"
              ]
            }
          },
          "version": "1.0"
        },
        "properties": {
          "exported_at": {
            "format": "date-time",
            "title": "Exported At",
            "type": "string"
          },
          "prompts": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "description": "All model configurations",
            "title": "Prompts",
            "type": "object"
          },
          "version": {
            "default": "1.0",
            "description": "Export format version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "exported_at",
          "prompts"
        ],
        "title": "PromptsExportResponse",
        "type": "object"
      },
      "PromptsImportPreviewRequest": {
        "description": "Request to preview prompt configuration import without applying.",
        "example": {
          "prompts": {
            "nemotron": {
              "max_tokens": 2048,
              "system_prompt": "You are a home security AI assistant...",
              "temperature": 0.8
            }
          },
          "version": "1.0"
        },
        "properties": {
          "prompts": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "description": "Model configurations to preview",
            "title": "Prompts",
            "type": "object"
          },
          "version": {
            "default": "1.0",
            "description": "Import format version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "prompts"
        ],
        "title": "PromptsImportPreviewRequest",
        "type": "object"
      },
      "PromptsImportPreviewResponse": {
        "description": "Response with preview of import changes.",
        "example": {
          "diffs": [
            {
              "changes": [
                "temperature: 0.7 -> 0.8"
              ],
              "current_config": {
                "system_prompt": "You are a home security AI...",
                "temperature": 0.7
              },
              "current_version": 3,
              "has_changes": true,
              "imported_config": {
                "system_prompt": "You are a home security AI...",
                "temperature": 0.8
              },
              "model": "nemotron"
            }
          ],
          "total_changes": 1,
          "unknown_models": [],
          "valid": true,
          "validation_errors": [],
          "version": "1.0"
        },
        "properties": {
          "diffs": {
            "description": "Diff entries for each model",
            "items": {
              "$ref": "#/components/schemas/PromptDiffEntry"
            },
            "title": "Diffs",
            "type": "array"
          },
          "total_changes": {
            "default": 0,
            "description": "Total number of models with changes",
            "title": "Total Changes",
            "type": "integer"
          },
          "unknown_models": {
            "description": "Models not recognized",
            "items": {
              "type": "string"
            },
            "title": "Unknown Models",
            "type": "array"
          },
          "valid": {
            "description": "Whether the import data is valid",
            "title": "Valid",
            "type": "boolean"
          },
          "validation_errors": {
            "description": "List of validation errors",
            "items": {
              "type": "string"
            },
            "title": "Validation Errors",
            "type": "array"
          },
          "version": {
            "description": "Import format version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "version",
          "valid"
        ],
        "title": "PromptsImportPreviewResponse",
        "type": "object"
      },
      "PromptsImportRequest": {
        "description": "Request to import prompt configurations.",
        "example": {
          "prompts": {
            "florence2": {
              "vqa_queries": [
                "What is this person wearing?"
              ]
            },
            "nemotron": {
              "max_tokens": 2048,
              "system_prompt": "You are a home security AI assistant...",
              "temperature": 0.7
            }
          },
          "version": "1.0"
        },
        "properties": {
          "prompts": {
            "additionalProperties": {
              "additionalProperties": true,
              "type": "object"
            },
            "description": "Model configurations to import",
            "title": "Prompts",
            "type": "object"
          },
          "version": {
            "default": "1.0",
            "description": "Import format version",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "prompts"
        ],
        "title": "PromptsImportRequest",
        "type": "object"
      },
      "PromptsImportResponse": {
        "description": "Response after importing prompt configurations.",
        "example": {
          "imported_models": [
            "nemotron",
            "florence2"
          ],
          "message": "Successfully imported 2 prompt configurations, skipped 1",
          "new_versions": {
            "florence2": 2,
            "nemotron": 4
          },
          "skipped_models": [
            "yolo_world"
          ]
        },
        "properties": {
          "imported_models": {
            "items": {
              "type": "string"
            },
            "title": "Imported Models",
            "type": "array"
          },
          "message": {
            "title": "Message",
            "type": "string"
          },
          "new_versions": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "New version numbers for each imported model",
            "title": "New Versions",
            "type": "object"
          },
          "skipped_models": {
            "items": {
              "type": "string"
            },
            "title": "Skipped Models",
            "type": "array"
          }
        },
        "required": [
          "imported_models",
          "new_versions",
          "message"
        ],
        "title": "PromptsImportResponse",
        "type": "object"
      },
      "PropertyCreate": {
        "description": "Schema for creating a new property.\n\nA property represents a physical location within a household\n(e.g., main house, beach house).",
        "example": {
          "address": "123 Main St, City, ST 12345",
          "name": "Main House",
          "timezone": "America/New_York"
        },
        "properties": {
          "address": {
            "anyOf": [
              {
                "maxLength": 500,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional street address",
            "title": "Address"
          },
          "name": {
            "description": "Property name (e.g., 'Main House')",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "timezone": {
            "default": "UTC",
            "description": "Timezone for the property (IANA format)",
            "maxLength": 50,
            "title": "Timezone",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "title": "PropertyCreate",
        "type": "object"
      },
      "PropertyListResponse": {
        "description": "Schema for listing properties.",
        "example": {
          "items": [
            {
              "address": "123 Main St",
              "created_at": "2026-01-20T10:00:00Z",
              "household_id": 1,
              "id": 1,
              "name": "Main House",
              "timezone": "America/New_York"
            }
          ],
          "total": 1
        },
        "properties": {
          "items": {
            "description": "List of properties",
            "items": {
              "$ref": "#/components/schemas/PropertyResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "total": {
            "description": "Total number of properties",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "items",
          "total"
        ],
        "title": "PropertyListResponse",
        "type": "object"
      },
      "PropertyResponse": {
        "description": "Schema for property response.",
        "example": {
          "address": "123 Main St, City, ST 12345",
          "created_at": "2026-01-20T10:00:00Z",
          "household_id": 1,
          "id": 1,
          "name": "Main House",
          "timezone": "America/New_York"
        },
        "properties": {
          "address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Street address",
            "title": "Address"
          },
          "created_at": {
            "description": "Timestamp when property was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "household_id": {
            "description": "ID of the owning household",
            "title": "Household Id",
            "type": "integer"
          },
          "id": {
            "description": "Unique property identifier",
            "title": "Id",
            "type": "integer"
          },
          "name": {
            "description": "Property name",
            "title": "Name",
            "type": "string"
          },
          "timezone": {
            "description": "Timezone (IANA format)",
            "title": "Timezone",
            "type": "string"
          }
        },
        "required": [
          "id",
          "household_id",
          "name",
          "timezone",
          "created_at"
        ],
        "title": "PropertyResponse",
        "type": "object"
      },
      "PropertyUpdate": {
        "description": "Schema for updating an existing property.\n\nAll fields are optional; only provided fields will be updated.",
        "example": {
          "name": "Main Residence",
          "timezone": "America/Chicago"
        },
        "properties": {
          "address": {
            "anyOf": [
              {
                "maxLength": 500,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Street address",
            "title": "Address"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Property name",
            "title": "Name"
          },
          "timezone": {
            "anyOf": [
              {
                "maxLength": 50,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timezone (IANA format)",
            "title": "Timezone"
          }
        },
        "title": "PropertyUpdate",
        "type": "object"
      },
      "QualityScores": {
        "description": "Self-evaluation quality scores (1-5 scale).",
        "example": {
          "consistency": 4.0,
          "context_usage": 4.2,
          "overall": 4.1,
          "reasoning_coherence": 4.5,
          "risk_justification": 3.8
        },
        "properties": {
          "consistency": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Consistency"
          },
          "context_usage": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Context Usage"
          },
          "overall": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Overall"
          },
          "reasoning_coherence": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reasoning Coherence"
          },
          "risk_justification": {
            "anyOf": [
              {
                "maximum": 5.0,
                "minimum": 1.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Risk Justification"
          }
        },
        "title": "QualityScores",
        "type": "object"
      },
      "QueueDepthInfo": {
        "description": "Queue depth information for a processing queue.\n\nTracks the number of items in the main queue and the dead letter queue\nfor monitoring backlog and failed processing.",
        "example": {
          "depth": 5,
          "dlq_depth": 0
        },
        "properties": {
          "depth": {
            "description": "Number of items currently in the queue",
            "minimum": 0.0,
            "title": "Depth",
            "type": "integer"
          },
          "dlq_depth": {
            "default": 0,
            "description": "Number of items in the dead letter queue",
            "minimum": 0.0,
            "title": "Dlq Depth",
            "type": "integer"
          }
        },
        "required": [
          "depth"
        ],
        "title": "QueueDepthInfo",
        "type": "object"
      },
      "QueueDepths": {
        "description": "Queue depth information for pipeline queues.",
        "example": {
          "analysis_queue": 2,
          "detection_queue": 5
        },
        "properties": {
          "analysis_queue": {
            "description": "Number of batches in analysis queue waiting for Nemotron LLM analysis",
            "minimum": 0.0,
            "title": "Analysis Queue",
            "type": "integer"
          },
          "detection_queue": {
            "description": "Number of items in detection queue waiting for YOLO26v2 processing",
            "minimum": 0.0,
            "title": "Detection Queue",
            "type": "integer"
          }
        },
        "required": [
          "detection_queue",
          "analysis_queue"
        ],
        "title": "QueueDepths",
        "type": "object"
      },
      "QueueHealthStatus": {
        "description": "Health status for a queue based on depth and wait time.",
        "enum": [
          "healthy",
          "warning",
          "critical"
        ],
        "title": "QueueHealthStatus",
        "type": "string"
      },
      "QueueSettings": {
        "description": "Queue settings for Redis-based processing queues.\n\nControls queue size limits and backpressure thresholds for the detection\nand analysis processing queues.",
        "example": {
          "backpressure_threshold": 0.8,
          "max_size": 10000
        },
        "properties": {
          "backpressure_threshold": {
            "description": "Queue fill ratio (0.0-1.0) at which to start backpressure warnings",
            "maximum": 1.0,
            "minimum": 0.5,
            "title": "Backpressure Threshold",
            "type": "number"
          },
          "max_size": {
            "description": "Maximum size of Redis queues",
            "minimum": 100.0,
            "title": "Max Size",
            "type": "integer"
          }
        },
        "required": [
          "max_size",
          "backpressure_threshold"
        ],
        "title": "QueueSettings",
        "type": "object"
      },
      "QueueSettingsUpdate": {
        "description": "Queue settings update schema (all fields optional).\n\nUsed for PATCH /api/v1/settings to partially update queue configuration.",
        "example": {
          "max_size": 15000
        },
        "properties": {
          "backpressure_threshold": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.5,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Queue fill ratio (0.0-1.0) at which to start backpressure warnings",
            "title": "Backpressure Threshold"
          },
          "max_size": {
            "anyOf": [
              {
                "maximum": 100000.0,
                "minimum": 100.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum size of Redis queues",
            "title": "Max Size"
          }
        },
        "title": "QueueSettingsUpdate",
        "type": "object"
      },
      "QueueStatus": {
        "description": "Status of a single job queue.",
        "example": {
          "depth": 15,
          "name": "ai_analysis",
          "oldest_job": {
            "id": "job_12345",
            "queued_at": "2025-12-23T10:30:00.000000",
            "wait_seconds": 45.2
          },
          "running": 2,
          "status": "healthy",
          "throughput": {
            "avg_processing_seconds": 4.8,
            "jobs_per_minute": 12.5
          },
          "workers": 4
        },
        "properties": {
          "depth": {
            "description": "Number of jobs waiting in the queue",
            "minimum": 0.0,
            "title": "Depth",
            "type": "integer"
          },
          "name": {
            "description": "Queue name",
            "title": "Name",
            "type": "string"
          },
          "oldest_job": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OldestJobInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Information about the oldest job waiting (if any)"
          },
          "running": {
            "description": "Number of jobs currently being processed",
            "minimum": 0.0,
            "title": "Running",
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/QueueHealthStatus",
            "description": "Health status of the queue"
          },
          "throughput": {
            "$ref": "#/components/schemas/ThroughputMetrics",
            "description": "Throughput metrics for the queue"
          },
          "workers": {
            "description": "Number of workers available for this queue",
            "minimum": 0.0,
            "title": "Workers",
            "type": "integer"
          }
        },
        "required": [
          "name",
          "status",
          "depth",
          "running",
          "workers",
          "throughput"
        ],
        "title": "QueueStatus",
        "type": "object"
      },
      "QueueStatusSummary": {
        "description": "Summary statistics across all queues.",
        "example": {
          "overall_status": "healthy",
          "total_queued": 45,
          "total_running": 8,
          "total_workers": 12
        },
        "properties": {
          "overall_status": {
            "$ref": "#/components/schemas/QueueHealthStatus",
            "description": "Overall health status (worst status across all queues)"
          },
          "total_queued": {
            "description": "Total number of jobs waiting across all queues",
            "minimum": 0.0,
            "title": "Total Queued",
            "type": "integer"
          },
          "total_running": {
            "description": "Total number of jobs currently being processed",
            "minimum": 0.0,
            "title": "Total Running",
            "type": "integer"
          },
          "total_workers": {
            "description": "Total number of workers across all queues",
            "minimum": 0.0,
            "title": "Total Workers",
            "type": "integer"
          }
        },
        "required": [
          "total_queued",
          "total_running",
          "total_workers",
          "overall_status"
        ],
        "title": "QueueStatusSummary",
        "type": "object"
      },
      "QueuesStatusResponse": {
        "description": "Response schema for GET /api/queues/status endpoint.",
        "example": {
          "queues": [
            {
              "depth": 15,
              "name": "ai_analysis",
              "oldest_job": {
                "id": "job_12345",
                "queued_at": "2025-12-23T10:30:00.000000",
                "wait_seconds": 45.2
              },
              "running": 2,
              "status": "healthy",
              "throughput": {
                "avg_processing_seconds": 4.8,
                "jobs_per_minute": 12.5
              },
              "workers": 4
            },
            {
              "depth": 55,
              "name": "detection",
              "running": 3,
              "status": "warning",
              "throughput": {
                "avg_processing_seconds": 7.3,
                "jobs_per_minute": 8.2
              },
              "workers": 4
            }
          ],
          "summary": {
            "overall_status": "warning",
            "total_queued": 70,
            "total_running": 5,
            "total_workers": 8
          }
        },
        "properties": {
          "queues": {
            "description": "Status of each queue",
            "items": {
              "$ref": "#/components/schemas/QueueStatus"
            },
            "title": "Queues",
            "type": "array"
          },
          "summary": {
            "$ref": "#/components/schemas/QueueStatusSummary",
            "description": "Summary statistics across all queues"
          }
        },
        "required": [
          "queues",
          "summary"
        ],
        "title": "QueuesStatusResponse",
        "type": "object"
      },
      "QuietHoursPeriodCreate": {
        "description": "Schema for creating a quiet hours period.",
        "example": {
          "days": [
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday"
          ],
          "end_time": "06:00:00",
          "label": "Night Time",
          "start_time": "22:00:00"
        },
        "properties": {
          "days": {
            "description": "Days of week when period is active",
            "items": {
              "type": "string"
            },
            "title": "Days",
            "type": "array"
          },
          "end_time": {
            "description": "End time (HH:MM:SS)",
            "format": "time",
            "title": "End Time",
            "type": "string"
          },
          "label": {
            "description": "Period label",
            "maxLength": 255,
            "minLength": 1,
            "title": "Label",
            "type": "string"
          },
          "start_time": {
            "description": "Start time (HH:MM:SS)",
            "format": "time",
            "title": "Start Time",
            "type": "string"
          }
        },
        "required": [
          "label",
          "start_time",
          "end_time"
        ],
        "title": "QuietHoursPeriodCreate",
        "type": "object"
      },
      "QuietHoursPeriodResponse": {
        "description": "Schema for quiet hours period response.",
        "example": {
          "days": [
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday"
          ],
          "end_time": "06:00:00",
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "label": "Night Time",
          "start_time": "22:00:00"
        },
        "properties": {
          "days": {
            "description": "Days of week when period is active",
            "items": {
              "type": "string"
            },
            "title": "Days",
            "type": "array"
          },
          "end_time": {
            "description": "End time",
            "format": "time",
            "title": "End Time",
            "type": "string"
          },
          "id": {
            "description": "Period UUID",
            "title": "Id",
            "type": "string"
          },
          "label": {
            "description": "Period label",
            "title": "Label",
            "type": "string"
          },
          "start_time": {
            "description": "Start time",
            "format": "time",
            "title": "Start Time",
            "type": "string"
          }
        },
        "required": [
          "id",
          "label",
          "start_time",
          "end_time",
          "days"
        ],
        "title": "QuietHoursPeriodResponse",
        "type": "object"
      },
      "QuietHoursPeriodsListResponse": {
        "description": "Schema for quiet hours periods list response with pagination.",
        "example": {
          "items": [
            {
              "days": [
                "monday",
                "tuesday",
                "wednesday",
                "thursday",
                "friday"
              ],
              "end_time": "06:00:00",
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "label": "Night Time",
              "start_time": "22:00:00"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of quiet hours periods",
            "items": {
              "$ref": "#/components/schemas/QuietHoursPeriodResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "QuietHoursPeriodsListResponse",
        "type": "object"
      },
      "RUMBatchRequest": {
        "description": "Batch request for multiple Core Web Vitals metrics.\n\nThe frontend batches metrics to reduce API calls. Each batch may contain\nmetrics from different pages or navigation events.\n\nAttributes:\n    metrics: List of Core Web Vital metrics to ingest\n    session_id: Optional session identifier for correlating metrics\n    user_agent: Optional user agent string for device/browser analysis",
        "example": {
          "metrics": [
            {
              "delta": 2500.0,
              "id": "v1-1234567890123-1234567890123",
              "name": "LCP",
              "rating": "good",
              "value": 2500.0
            },
            {
              "delta": 0.02,
              "id": "v1-1234567890123-1234567890124",
              "name": "CLS",
              "rating": "good",
              "value": 0.05
            }
          ],
          "session_id": "sess-12345"
        },
        "properties": {
          "metrics": {
            "description": "List of metrics to ingest (non-empty)",
            "items": {
              "$ref": "#/components/schemas/WebVitalMetric"
            },
            "minItems": 1,
            "title": "Metrics",
            "type": "array"
          },
          "session_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional session identifier",
            "title": "Session Id"
          },
          "user_agent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional user agent string",
            "title": "User Agent"
          }
        },
        "required": [
          "metrics"
        ],
        "title": "RUMBatchRequest",
        "type": "object"
      },
      "RUMIngestResponse": {
        "description": "Response from the RUM metrics ingestion endpoint.\n\nAttributes:\n    success: Whether the ingestion was successful\n    metrics_count: Number of metrics successfully ingested\n    message: Human-readable status message\n    errors: List of any errors encountered during ingestion",
        "example": {
          "errors": [],
          "message": "Successfully ingested 5 metrics",
          "metrics_count": 5,
          "success": true
        },
        "properties": {
          "errors": {
            "description": "List of any errors encountered",
            "items": {
              "type": "string"
            },
            "title": "Errors",
            "type": "array"
          },
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "metrics_count": {
            "description": "Number of metrics successfully ingested",
            "minimum": 0.0,
            "title": "Metrics Count",
            "type": "integer"
          },
          "success": {
            "description": "Whether ingestion was successful",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success",
          "metrics_count",
          "message"
        ],
        "title": "RUMIngestResponse",
        "type": "object"
      },
      "RateLimitingSettings": {
        "description": "Rate limiting settings for API protection.\n\nControls request rate limits to prevent abuse and ensure fair resource usage.",
        "example": {
          "burst_size": 10,
          "enabled": true,
          "requests_per_minute": 60
        },
        "properties": {
          "burst_size": {
            "description": "Additional burst allowance for short request spikes",
            "minimum": 1.0,
            "title": "Burst Size",
            "type": "integer"
          },
          "enabled": {
            "description": "Enable rate limiting for API endpoints",
            "title": "Enabled",
            "type": "boolean"
          },
          "requests_per_minute": {
            "description": "Maximum requests per minute per client IP",
            "minimum": 1.0,
            "title": "Requests Per Minute",
            "type": "integer"
          }
        },
        "required": [
          "enabled",
          "requests_per_minute",
          "burst_size"
        ],
        "title": "RateLimitingSettings",
        "type": "object"
      },
      "RateLimitingSettingsUpdate": {
        "description": "Rate limiting settings update schema (all fields optional).\n\nUsed for PATCH /api/v1/settings to partially update rate limiting.",
        "example": {
          "requests_per_minute": 120
        },
        "properties": {
          "burst_size": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional burst allowance for short request spikes",
            "title": "Burst Size"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Enable rate limiting for API endpoints",
            "title": "Enabled"
          },
          "requests_per_minute": {
            "anyOf": [
              {
                "maximum": 10000.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum requests per minute per client IP",
            "title": "Requests Per Minute"
          }
        },
        "title": "RateLimitingSettingsUpdate",
        "type": "object"
      },
      "ReadinessResponse": {
        "description": "Response schema for readiness probe endpoint.\n\nReadiness probes indicate whether the application is ready to receive\ntraffic and process requests. This checks all dependencies:\n- Database connectivity\n- Redis connectivity\n- AI services availability\n- Background worker status",
        "example": {
          "ready": true,
          "services": {
            "ai": {
              "message": "AI services operational",
              "status": "healthy"
            },
            "database": {
              "message": "Database operational",
              "status": "healthy"
            },
            "redis": {
              "details": {
                "redis_version": "7.0.0"
              },
              "message": "Redis connected",
              "status": "healthy"
            }
          },
          "status": "ready",
          "supervisor_healthy": true,
          "timestamp": "2025-12-23T10:30:00",
          "workers": [
            {
              "name": "gpu_monitor",
              "running": true
            },
            {
              "name": "cleanup_service",
              "running": true
            }
          ]
        },
        "properties": {
          "ai_warmth_status": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Warmth status of AI models (NEM-1670). Keys are model names (e.g., 'yolo26', 'nemotron'), values are states: 'cold', 'warming', 'warm'",
            "title": "Ai Warmth Status"
          },
          "ready": {
            "description": "Overall readiness status: True if system can process requests",
            "title": "Ready",
            "type": "boolean"
          },
          "services": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HealthCheckServiceStatus"
            },
            "description": "Status of infrastructure services (database, redis, ai)",
            "title": "Services",
            "type": "object"
          },
          "status": {
            "description": "Status string: 'ready', 'degraded', or 'not_ready'",
            "title": "Status",
            "type": "string"
          },
          "supervisor_healthy": {
            "default": true,
            "description": "Whether the worker supervisor is running and healthy (NEM-2462). True if supervisor is active, False if not initialized or has failed workers.",
            "title": "Supervisor Healthy",
            "type": "boolean"
          },
          "timestamp": {
            "description": "Timestamp of readiness check",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "workers": {
            "description": "Status of background workers",
            "items": {
              "$ref": "#/components/schemas/WorkerStatus"
            },
            "title": "Workers",
            "type": "array"
          }
        },
        "required": [
          "ready",
          "status",
          "services",
          "timestamp"
        ],
        "title": "ReadinessResponse",
        "type": "object"
      },
      "RecentError": {
        "description": "Recent error information.",
        "properties": {
          "component": {
            "description": "Component that generated error",
            "title": "Component",
            "type": "string"
          },
          "error_type": {
            "description": "Type of error",
            "title": "Error Type",
            "type": "string"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message",
            "title": "Message"
          },
          "timestamp": {
            "description": "ISO timestamp of error",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "error_type",
          "component"
        ],
        "title": "RecentError",
        "type": "object"
      },
      "RecommendationItem": {
        "description": "Single recommendation item.",
        "example": {
          "category": "missing_context",
          "frequency": 25,
          "priority": "high",
          "suggestion": "Add time since last motion event to prompt"
        },
        "properties": {
          "category": {
            "title": "Category",
            "type": "string"
          },
          "frequency": {
            "title": "Frequency",
            "type": "integer"
          },
          "priority": {
            "title": "Priority",
            "type": "string"
          },
          "suggestion": {
            "title": "Suggestion",
            "type": "string"
          }
        },
        "required": [
          "category",
          "suggestion",
          "frequency",
          "priority"
        ],
        "title": "RecommendationItem",
        "type": "object"
      },
      "RecommendationsResponse": {
        "description": "Aggregated recommendations response.",
        "example": {
          "recommendations": [
            {
              "category": "missing_context",
              "frequency": 25,
              "priority": "high",
              "suggestion": "Add time since last motion event"
            },
            {
              "category": "model_gaps",
              "frequency": 12,
              "priority": "medium",
              "suggestion": "Enable pet detection model"
            }
          ],
          "total_events_analyzed": 500
        },
        "properties": {
          "recommendations": {
            "items": {
              "$ref": "#/components/schemas/RecommendationItem"
            },
            "title": "Recommendations",
            "type": "array"
          },
          "total_events_analyzed": {
            "title": "Total Events Analyzed",
            "type": "integer"
          }
        },
        "required": [
          "recommendations",
          "total_events_analyzed"
        ],
        "title": "RecommendationsResponse",
        "type": "object"
      },
      "RecordingResponse": {
        "description": "Response for a single recording.",
        "properties": {
          "body_truncated": {
            "default": false,
            "description": "Whether body was truncated",
            "title": "Body Truncated",
            "type": "boolean"
          },
          "duration_ms": {
            "description": "Request duration in milliseconds",
            "title": "Duration Ms",
            "type": "number"
          },
          "method": {
            "description": "HTTP method",
            "title": "Method",
            "type": "string"
          },
          "path": {
            "description": "Request path",
            "title": "Path",
            "type": "string"
          },
          "recording_id": {
            "description": "Unique recording ID",
            "title": "Recording Id",
            "type": "string"
          },
          "status_code": {
            "description": "HTTP response status code",
            "title": "Status Code",
            "type": "integer"
          },
          "timestamp": {
            "description": "ISO timestamp when recorded",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "recording_id",
          "timestamp",
          "method",
          "path",
          "status_code",
          "duration_ms"
        ],
        "title": "RecordingResponse",
        "type": "object"
      },
      "RecordingsListResponse": {
        "description": "Response for listing recordings.",
        "properties": {
          "recordings": {
            "description": "List of recordings",
            "items": {
              "$ref": "#/components/schemas/RecordingResponse"
            },
            "title": "Recordings",
            "type": "array"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          },
          "total": {
            "description": "Total number of recordings",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "recordings",
          "total",
          "timestamp"
        ],
        "title": "RecordingsListResponse",
        "type": "object"
      },
      "RedisInfoResponse": {
        "description": "Response for Redis connection stats.",
        "properties": {
          "info": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Redis INFO command output",
            "title": "Info"
          },
          "pubsub": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "description": "Pub/sub channel information",
            "title": "Pubsub"
          },
          "status": {
            "description": "Redis connection status (connected, unavailable)",
            "title": "Status",
            "type": "string"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "status",
          "timestamp"
        ],
        "title": "RedisInfoResponse",
        "type": "object"
      },
      "RedisMetrics": {
        "description": "Redis cache metrics.",
        "example": {
          "blocked_clients": 0,
          "connected_clients": 8,
          "hit_ratio": 99.5,
          "memory_mb": 1.5,
          "status": "healthy"
        },
        "properties": {
          "blocked_clients": {
            "description": "Number of blocked clients",
            "minimum": 0.0,
            "title": "Blocked Clients",
            "type": "integer"
          },
          "connected_clients": {
            "description": "Number of connected clients",
            "minimum": 0.0,
            "title": "Connected Clients",
            "type": "integer"
          },
          "hit_ratio": {
            "description": "Cache hit ratio percentage",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Hit Ratio",
            "type": "number"
          },
          "memory_mb": {
            "description": "Memory used in MB",
            "minimum": 0.0,
            "title": "Memory Mb",
            "type": "number"
          },
          "status": {
            "description": "Health status: healthy, unhealthy, unreachable",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "status",
          "connected_clients",
          "memory_mb",
          "hit_ratio",
          "blocked_clients"
        ],
        "title": "RedisMetrics",
        "type": "object"
      },
      "RegisteredVehicleCreate": {
        "description": "Schema for creating a new registered vehicle.",
        "example": {
          "color": "Silver",
          "description": "Silver Tesla Model 3",
          "license_plate": "ABC123",
          "owner_id": 1,
          "trusted": true,
          "vehicle_type": "car"
        },
        "properties": {
          "color": {
            "anyOf": [
              {
                "maxLength": 50,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Color description",
            "title": "Color"
          },
          "description": {
            "description": "Human-readable description (e.g., 'Silver Tesla Model 3')",
            "maxLength": 200,
            "minLength": 1,
            "title": "Description",
            "type": "string"
          },
          "license_plate": {
            "anyOf": [
              {
                "maxLength": 20,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "License plate number",
            "title": "License Plate"
          },
          "owner_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the vehicle owner (HouseholdMember)",
            "title": "Owner Id"
          },
          "trusted": {
            "default": true,
            "description": "Whether this vehicle should suppress alerts",
            "title": "Trusted",
            "type": "boolean"
          },
          "vehicle_type": {
            "$ref": "#/components/schemas/VehicleType",
            "description": "Type/category of the vehicle"
          }
        },
        "required": [
          "description",
          "vehicle_type"
        ],
        "title": "RegisteredVehicleCreate",
        "type": "object"
      },
      "RegisteredVehicleResponse": {
        "description": "Schema for registered vehicle response.",
        "example": {
          "color": "Silver",
          "created_at": "2025-01-01T10:00:00Z",
          "description": "Silver Tesla Model 3",
          "id": 1,
          "license_plate": "ABC123",
          "owner_id": 1,
          "trusted": true,
          "vehicle_type": "car"
        },
        "properties": {
          "color": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Color description",
            "title": "Color"
          },
          "created_at": {
            "description": "When the vehicle was registered",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "description": {
            "description": "Human-readable description",
            "title": "Description",
            "type": "string"
          },
          "id": {
            "description": "Unique identifier for the vehicle",
            "title": "Id",
            "type": "integer"
          },
          "license_plate": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "License plate number",
            "title": "License Plate"
          },
          "owner_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the vehicle owner",
            "title": "Owner Id"
          },
          "trusted": {
            "description": "Whether vehicle suppresses alerts",
            "title": "Trusted",
            "type": "boolean"
          },
          "vehicle_type": {
            "$ref": "#/components/schemas/VehicleType",
            "description": "Type of vehicle"
          }
        },
        "required": [
          "id",
          "description",
          "vehicle_type",
          "trusted",
          "created_at"
        ],
        "title": "RegisteredVehicleResponse",
        "type": "object"
      },
      "RegisteredVehicleUpdate": {
        "description": "Schema for updating an existing registered vehicle.",
        "example": {
          "description": "Updated Tesla Description",
          "license_plate": "NEW456",
          "trusted": false
        },
        "properties": {
          "color": {
            "anyOf": [
              {
                "maxLength": 50,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Color description",
            "title": "Color"
          },
          "description": {
            "anyOf": [
              {
                "maxLength": 200,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Human-readable description",
            "title": "Description"
          },
          "license_plate": {
            "anyOf": [
              {
                "maxLength": 20,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "License plate number",
            "title": "License Plate"
          },
          "owner_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the vehicle owner (HouseholdMember)",
            "title": "Owner Id"
          },
          "trusted": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether this vehicle should suppress alerts",
            "title": "Trusted"
          },
          "vehicle_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VehicleType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Type/category of the vehicle"
          }
        },
        "title": "RegisteredVehicleUpdate",
        "type": "object"
      },
      "ReplayResponse": {
        "description": "Response for request replay.",
        "properties": {
          "original_status_code": {
            "description": "Original response status code",
            "title": "Original Status Code",
            "type": "integer"
          },
          "recording_id": {
            "description": "ID of the replayed recording",
            "title": "Recording Id",
            "type": "string"
          },
          "replay_metadata": {
            "additionalProperties": true,
            "description": "Metadata about the replay",
            "title": "Replay Metadata",
            "type": "object"
          },
          "replay_response": {
            "description": "Response from replayed request",
            "title": "Replay Response"
          },
          "replay_status_code": {
            "description": "Replay response status code",
            "title": "Replay Status Code",
            "type": "integer"
          },
          "timestamp": {
            "description": "ISO timestamp of replay",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "recording_id",
          "original_status_code",
          "replay_status_code",
          "replay_response",
          "replay_metadata",
          "timestamp"
        ],
        "title": "ReplayResponse",
        "type": "object"
      },
      "ReportFormat": {
        "description": "Output format options for scheduled reports.\n\nValues:\n    PDF: Portable Document Format with charts and summaries\n    CSV: Comma-separated values for data analysis\n    JSON: Machine-readable JSON format",
        "enum": [
          "pdf",
          "csv",
          "json"
        ],
        "title": "ReportFormat",
        "type": "string"
      },
      "ReportFrequency": {
        "description": "Frequency options for scheduled reports.\n\nValues:\n    DAILY: Report runs every day at specified time\n    WEEKLY: Report runs on specified day of week\n    MONTHLY: Report runs on specified day of month",
        "enum": [
          "daily",
          "weekly",
          "monthly"
        ],
        "title": "ReportFrequency",
        "type": "string"
      },
      "RestartHistoryEvent": {
        "description": "A single restart event in the history.\n\nRecords when a worker was restarted (automatically or manually).",
        "example": {
          "attempt": 1,
          "error": "Connection timeout",
          "status": "success",
          "timestamp": "2026-01-13T10:30:00Z",
          "worker_name": "file_watcher"
        },
        "properties": {
          "attempt": {
            "description": "Restart attempt number (0 for manual restarts)",
            "minimum": 0.0,
            "title": "Attempt",
            "type": "integer"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message that triggered the restart, if any",
            "title": "Error"
          },
          "status": {
            "description": "Result of the restart: 'success' or 'failed'",
            "title": "Status",
            "type": "string"
          },
          "timestamp": {
            "description": "When the restart occurred (UTC)",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "worker_name": {
            "description": "Name of the worker that was restarted",
            "title": "Worker Name",
            "type": "string"
          }
        },
        "required": [
          "worker_name",
          "timestamp",
          "attempt",
          "status"
        ],
        "title": "RestartHistoryEvent",
        "type": "object"
      },
      "RestartHistoryResponse": {
        "description": "Response schema for restart history endpoint.\n\nProvides paginated list of worker restart events.",
        "example": {
          "items": [
            {
              "attempt": 1,
              "error": "Connection timeout",
              "status": "success",
              "timestamp": "2026-01-13T10:30:00Z",
              "worker_name": "file_watcher"
            },
            {
              "attempt": 2,
              "error": "Memory allocation failed",
              "status": "success",
              "timestamp": "2026-01-13T10:25:00Z",
              "worker_name": "detector"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 15
          }
        },
        "properties": {
          "items": {
            "description": "List of restart events (newest first)",
            "items": {
              "$ref": "#/components/schemas/RestartHistoryEvent"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "pagination"
        ],
        "title": "RestartHistoryResponse",
        "type": "object"
      },
      "RetentionSettings": {
        "description": "Data retention settings for events and logs.\n\nControls how long events, detections, and logs are retained before cleanup.",
        "example": {
          "days": 30,
          "log_days": 7
        },
        "properties": {
          "days": {
            "description": "Number of days to retain events and detections",
            "exclusiveMinimum": 0.0,
            "title": "Days",
            "type": "integer"
          },
          "log_days": {
            "description": "Number of days to retain logs",
            "exclusiveMinimum": 0.0,
            "title": "Log Days",
            "type": "integer"
          }
        },
        "required": [
          "days",
          "log_days"
        ],
        "title": "RetentionSettings",
        "type": "object"
      },
      "RetentionSettingsUpdate": {
        "description": "Retention settings update schema (all fields optional).\n\nUsed for PATCH /api/v1/settings to partially update retention policies.",
        "example": {
          "days": 60
        },
        "properties": {
          "days": {
            "anyOf": [
              {
                "maximum": 365.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of days to retain events and detections (1-365)",
            "title": "Days"
          },
          "log_days": {
            "anyOf": [
              {
                "maximum": 365.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Number of days to retain logs (1-365)",
            "title": "Log Days"
          }
        },
        "title": "RetentionSettingsUpdate",
        "type": "object"
      },
      "RiskDistributionItem": {
        "description": "Schema for a single risk distribution item (for Grafana compatibility).",
        "example": {
          "count": 5,
          "risk_level": "high"
        },
        "properties": {
          "count": {
            "description": "Number of events with this risk level",
            "title": "Count",
            "type": "integer"
          },
          "risk_level": {
            "description": "Risk level name (critical, high, medium, low)",
            "title": "Risk Level",
            "type": "string"
          }
        },
        "required": [
          "risk_level",
          "count"
        ],
        "title": "RiskDistributionItem",
        "type": "object"
      },
      "RiskEntity": {
        "description": "Entity identified during risk analysis.\n\nEntities represent objects of interest detected in the scene that\ncontribute to the overall risk assessment (e.g., people, vehicles,\npackages).\n\nAttributes:\n    type: Category of entity (e.g., \"person\", \"vehicle\", \"package\")\n    description: Detailed description of the entity\n    threat_level: Risk level attributed to this entity",
        "example": {
          "description": "Unknown individual near front entrance",
          "threat_level": "medium",
          "type": "person"
        },
        "properties": {
          "description": {
            "description": "Detailed description of the entity",
            "title": "Description",
            "type": "string"
          },
          "threat_level": {
            "description": "Risk level attributed to this entity",
            "enum": [
              "low",
              "medium",
              "high"
            ],
            "title": "Threat Level",
            "type": "string"
          },
          "type": {
            "description": "Category of entity (e.g., person, vehicle, package)",
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "type",
          "description",
          "threat_level"
        ],
        "title": "RiskEntity",
        "type": "object"
      },
      "RiskFactor": {
        "description": "Individual factor contributing to the overall risk score (NEM-3603).\n\nRisk factors represent specific aspects of the analysis that contribute\npositively or negatively to the overall risk score. Positive contributions\nincrease risk (e.g., nighttime activity, unknown person), while negative\ncontributions decrease risk (e.g., recognized face, routine timing).\n\nAttributes:\n    factor_name: Name of the risk factor (e.g., \"nighttime_activity\", \"recognized_face\")\n    contribution: Contribution to risk score (positive increases risk, negative decreases)\n    description: Optional explanation of why this factor applies",
        "example": {
          "contribution": 15.0,
          "description": "Activity detected outside normal hours (11 PM - 6 AM)",
          "factor_name": "nighttime_activity"
        },
        "properties": {
          "contribution": {
            "description": "Contribution to risk score (positive increases, negative decreases)",
            "title": "Contribution",
            "type": "number"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional explanation of why this factor applies",
            "title": "Description"
          },
          "factor_name": {
            "description": "Name of the risk factor",
            "title": "Factor Name",
            "type": "string"
          }
        },
        "required": [
          "factor_name",
          "contribution"
        ],
        "title": "RiskFactor",
        "type": "object"
      },
      "RiskFlag": {
        "description": "Risk flag indicating a specific concern or anomaly.\n\nFlags represent specific behaviors, patterns, or conditions that\nwarrant attention (e.g., loitering, nighttime activity, weapon detected).\n\nAttributes:\n    type: Category of flag (e.g., \"loitering\", \"weapon_detected\")\n    description: Explanation of the flag\n    severity: How severe this flag is (warning, alert, critical)",
        "example": {
          "description": "Person has been stationary for over 5 minutes",
          "severity": "warning",
          "type": "loitering"
        },
        "properties": {
          "description": {
            "description": "Explanation of the flag",
            "title": "Description",
            "type": "string"
          },
          "severity": {
            "description": "Severity level of this flag",
            "enum": [
              "warning",
              "alert",
              "critical"
            ],
            "title": "Severity",
            "type": "string"
          },
          "type": {
            "description": "Category of flag (e.g., loitering, weapon_detected)",
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "type",
          "description",
          "severity"
        ],
        "title": "RiskFlag",
        "type": "object"
      },
      "RiskHistoryDataPoint": {
        "description": "Schema for a single risk history data point.",
        "example": {
          "critical": 1,
          "date": "2025-01-07",
          "high": 2,
          "low": 10,
          "medium": 5
        },
        "properties": {
          "critical": {
            "default": 0,
            "description": "Count of critical risk events",
            "minimum": 0.0,
            "title": "Critical",
            "type": "integer"
          },
          "date": {
            "description": "Date of the data point",
            "format": "date",
            "title": "Date",
            "type": "string"
          },
          "high": {
            "default": 0,
            "description": "Count of high risk events",
            "minimum": 0.0,
            "title": "High",
            "type": "integer"
          },
          "low": {
            "default": 0,
            "description": "Count of low risk events",
            "minimum": 0.0,
            "title": "Low",
            "type": "integer"
          },
          "medium": {
            "default": 0,
            "description": "Count of medium risk events",
            "minimum": 0.0,
            "title": "Medium",
            "type": "integer"
          }
        },
        "required": [
          "date"
        ],
        "title": "RiskHistoryDataPoint",
        "type": "object"
      },
      "RiskHistoryResponse": {
        "description": "Schema for risk score distribution over time.",
        "example": {
          "data_points": [
            {
              "critical": 1,
              "date": "2025-01-01",
              "high": 2,
              "low": 10,
              "medium": 5
            },
            {
              "critical": 0,
              "date": "2025-01-02",
              "high": 3,
              "low": 12,
              "medium": 4
            }
          ],
          "end_date": "2025-01-02",
          "start_date": "2025-01-01"
        },
        "properties": {
          "data_points": {
            "description": "Risk level counts aggregated by day",
            "items": {
              "$ref": "#/components/schemas/RiskHistoryDataPoint"
            },
            "title": "Data Points",
            "type": "array"
          },
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          }
        },
        "required": [
          "data_points",
          "start_date",
          "end_date"
        ],
        "title": "RiskHistoryResponse",
        "type": "object"
      },
      "RiskScoreDistributionBucket": {
        "description": "Schema for a single risk score distribution bucket.",
        "example": {
          "count": 15,
          "max_score": 10,
          "min_score": 0
        },
        "properties": {
          "count": {
            "description": "Number of events in this bucket",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "max_score": {
            "description": "Maximum score in this bucket (exclusive)",
            "minimum": 0.0,
            "title": "Max Score",
            "type": "integer"
          },
          "min_score": {
            "description": "Minimum score in this bucket (inclusive)",
            "minimum": 0.0,
            "title": "Min Score",
            "type": "integer"
          }
        },
        "required": [
          "min_score",
          "max_score",
          "count"
        ],
        "title": "RiskScoreDistributionBucket",
        "type": "object"
      },
      "RiskScoreDistributionResponse": {
        "description": "Schema for risk score distribution histogram.",
        "example": {
          "bucket_size": 10,
          "buckets": [
            {
              "count": 15,
              "max_score": 10,
              "min_score": 0
            },
            {
              "count": 12,
              "max_score": 20,
              "min_score": 10
            },
            {
              "count": 8,
              "max_score": 30,
              "min_score": 20
            },
            {
              "count": 6,
              "max_score": 40,
              "min_score": 30
            },
            {
              "count": 4,
              "max_score": 50,
              "min_score": 40
            },
            {
              "count": 3,
              "max_score": 60,
              "min_score": 50
            },
            {
              "count": 2,
              "max_score": 70,
              "min_score": 60
            },
            {
              "count": 2,
              "max_score": 80,
              "min_score": 70
            },
            {
              "count": 1,
              "max_score": 90,
              "min_score": 80
            },
            {
              "count": 1,
              "max_score": 100,
              "min_score": 90
            }
          ],
          "end_date": "2025-01-07",
          "start_date": "2025-01-01",
          "total_events": 54
        },
        "properties": {
          "bucket_size": {
            "description": "Size of each bucket",
            "minimum": 1.0,
            "title": "Bucket Size",
            "type": "integer"
          },
          "buckets": {
            "description": "Risk score distribution buckets",
            "items": {
              "$ref": "#/components/schemas/RiskScoreDistributionBucket"
            },
            "title": "Buckets",
            "type": "array"
          },
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          },
          "total_events": {
            "description": "Total events with risk scores in date range",
            "minimum": 0.0,
            "title": "Total Events",
            "type": "integer"
          }
        },
        "required": [
          "buckets",
          "total_events",
          "start_date",
          "end_date",
          "bucket_size"
        ],
        "title": "RiskScoreDistributionResponse",
        "type": "object"
      },
      "RiskScoreTrendDataPoint": {
        "description": "Schema for a single risk score trend data point.",
        "example": {
          "avg_score": 45.5,
          "count": 12,
          "date": "2025-01-07"
        },
        "properties": {
          "avg_score": {
            "description": "Average risk score on this date",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Avg Score",
            "type": "number"
          },
          "count": {
            "description": "Number of events on this date",
            "minimum": 0.0,
            "title": "Count",
            "type": "integer"
          },
          "date": {
            "description": "Date of the data point",
            "format": "date",
            "title": "Date",
            "type": "string"
          }
        },
        "required": [
          "date",
          "avg_score",
          "count"
        ],
        "title": "RiskScoreTrendDataPoint",
        "type": "object"
      },
      "RiskScoreTrendsResponse": {
        "description": "Schema for risk score trends over time.",
        "example": {
          "data_points": [
            {
              "avg_score": 35.2,
              "count": 10,
              "date": "2025-01-01"
            },
            {
              "avg_score": 42.1,
              "count": 15,
              "date": "2025-01-02"
            },
            {
              "avg_score": 38.7,
              "count": 12,
              "date": "2025-01-03"
            }
          ],
          "end_date": "2025-01-03",
          "start_date": "2025-01-01"
        },
        "properties": {
          "data_points": {
            "description": "Average risk score aggregated by day",
            "items": {
              "$ref": "#/components/schemas/RiskScoreTrendDataPoint"
            },
            "title": "Data Points",
            "type": "array"
          },
          "end_date": {
            "description": "End date of the date range",
            "format": "date",
            "title": "End Date",
            "type": "string"
          },
          "start_date": {
            "description": "Start date of the date range",
            "format": "date",
            "title": "Start Date",
            "type": "string"
          }
        },
        "required": [
          "data_points",
          "start_date",
          "end_date"
        ],
        "title": "RiskScoreTrendsResponse",
        "type": "object"
      },
      "RuleTestEventResult": {
        "description": "Schema for a single event's test result.",
        "example": {
          "camera_id": "front_door",
          "event_id": 123,
          "matched_conditions": [
            "risk_score >= 70",
            "object_type in ['person']"
          ],
          "matches": true,
          "object_types": [
            "person"
          ],
          "risk_score": 75,
          "started_at": "2025-12-28T22:15:00Z"
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "event_id": {
            "description": "Event ID",
            "title": "Event Id",
            "type": "integer"
          },
          "matched_conditions": {
            "description": "List of conditions that matched",
            "items": {
              "type": "string"
            },
            "title": "Matched Conditions",
            "type": "array"
          },
          "matches": {
            "description": "Whether the rule matched this event",
            "title": "Matches",
            "type": "boolean"
          },
          "object_types": {
            "description": "Detected object types",
            "items": {
              "type": "string"
            },
            "title": "Object Types",
            "type": "array"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event risk score",
            "title": "Risk Score"
          },
          "started_at": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event start timestamp",
            "title": "Started At"
          }
        },
        "required": [
          "event_id",
          "camera_id",
          "matches"
        ],
        "title": "RuleTestEventResult",
        "type": "object"
      },
      "RuleTestRequest": {
        "description": "Schema for testing a rule against historical events.",
        "example": {
          "event_ids": [
            1,
            2,
            3,
            4,
            5
          ],
          "test_time": "2025-12-28T22:30:00Z"
        },
        "properties": {
          "event_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "integer"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Specific event IDs to test against. If not provided, tests against recent events.",
            "title": "Event Ids"
          },
          "limit": {
            "default": 10,
            "description": "Maximum number of recent events to test (if event_ids not provided)",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "type": "integer"
          },
          "test_time": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Override current time for schedule testing (ISO format)",
            "title": "Test Time"
          }
        },
        "title": "RuleTestRequest",
        "type": "object"
      },
      "RuleTestResponse": {
        "description": "Schema for rule test response.",
        "example": {
          "events_matched": 3,
          "events_tested": 10,
          "match_rate": 0.3,
          "results": [
            {
              "camera_id": "front_door",
              "event_id": 123,
              "matched_conditions": [
                "risk_score >= 70",
                "object_type in ['person']"
              ],
              "matches": true,
              "object_types": [
                "person"
              ],
              "risk_score": 75,
              "started_at": "2025-12-28T22:15:00Z"
            }
          ],
          "rule_id": "550e8400-e29b-41d4-a716-446655440000",
          "rule_name": "Night Intruder Alert"
        },
        "properties": {
          "events_matched": {
            "description": "Number of events that matched the rule",
            "title": "Events Matched",
            "type": "integer"
          },
          "events_tested": {
            "description": "Number of events tested",
            "title": "Events Tested",
            "type": "integer"
          },
          "match_rate": {
            "description": "Proportion of events that matched (0.0-1.0)",
            "title": "Match Rate",
            "type": "number"
          },
          "results": {
            "description": "Per-event test results",
            "items": {
              "$ref": "#/components/schemas/RuleTestEventResult"
            },
            "title": "Results",
            "type": "array"
          },
          "rule_id": {
            "description": "Rule ID that was tested",
            "title": "Rule Id",
            "type": "string"
          },
          "rule_name": {
            "description": "Rule name",
            "title": "Rule Name",
            "type": "string"
          }
        },
        "required": [
          "rule_id",
          "rule_name",
          "events_tested",
          "events_matched",
          "match_rate",
          "results"
        ],
        "title": "RuleTestResponse",
        "type": "object"
      },
      "SceneChangeAcknowledgeResponse": {
        "description": "Response schema for acknowledging a scene change.\n\nConfirms that a scene change has been acknowledged.",
        "example": {
          "acknowledged": true,
          "acknowledged_at": "2026-01-03T11:00:00Z",
          "id": 1
        },
        "properties": {
          "acknowledged": {
            "default": true,
            "description": "Acknowledgement status (always True)",
            "title": "Acknowledged",
            "type": "boolean"
          },
          "acknowledged_at": {
            "description": "When the change was acknowledged",
            "format": "date-time",
            "title": "Acknowledged At",
            "type": "string"
          },
          "id": {
            "description": "Scene change ID",
            "title": "Id",
            "type": "integer"
          }
        },
        "required": [
          "id",
          "acknowledged_at"
        ],
        "title": "SceneChangeAcknowledgeResponse",
        "type": "object"
      },
      "SceneChangeListResponse": {
        "description": "Response schema for listing scene changes.\n\nReturns a list of scene changes for a camera with cursor-based pagination.",
        "example": {
          "camera_id": "front_door",
          "has_more": true,
          "next_cursor": "2026-01-03T09:30:00Z",
          "scene_changes": [
            {
              "acknowledged": false,
              "change_type": "view_blocked",
              "detected_at": "2026-01-03T10:30:00Z",
              "id": 1,
              "similarity_score": 0.23
            }
          ],
          "total_changes": 1
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "has_more": {
            "default": false,
            "description": "Whether there are more results available",
            "title": "Has More",
            "type": "boolean"
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Cursor for fetching the next page (ISO 8601 timestamp)",
            "title": "Next Cursor"
          },
          "scene_changes": {
            "description": "List of scene changes",
            "items": {
              "$ref": "#/components/schemas/SceneChangeResponse"
            },
            "title": "Scene Changes",
            "type": "array"
          },
          "total_changes": {
            "default": 0,
            "description": "Number of scene changes returned",
            "minimum": 0.0,
            "title": "Total Changes",
            "type": "integer"
          }
        },
        "required": [
          "camera_id"
        ],
        "title": "SceneChangeListResponse",
        "type": "object"
      },
      "SceneChangeResponse": {
        "description": "Response schema for a single scene change.\n\nRepresents a detected camera view change that may indicate\ntampering, angle changes, or blocked views.",
        "example": {
          "acknowledged": false,
          "change_type": "view_blocked",
          "detected_at": "2026-01-03T10:30:00Z",
          "file_path": "/export/foscam/front_door/image.jpg",
          "id": 1,
          "similarity_score": 0.23
        },
        "properties": {
          "acknowledged": {
            "default": false,
            "description": "Whether the change has been acknowledged",
            "title": "Acknowledged",
            "type": "boolean"
          },
          "acknowledged_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the change was acknowledged",
            "title": "Acknowledged At"
          },
          "change_type": {
            "description": "Type of change: view_blocked, angle_changed, view_tampered, unknown",
            "title": "Change Type",
            "type": "string"
          },
          "detected_at": {
            "description": "When the scene change was detected",
            "format": "date-time",
            "title": "Detected At",
            "type": "string"
          },
          "file_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to the image that triggered detection",
            "title": "File Path"
          },
          "id": {
            "description": "Unique scene change ID",
            "title": "Id",
            "type": "integer"
          },
          "similarity_score": {
            "description": "SSIM similarity score (0-1, lower means more different)",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Similarity Score",
            "type": "number"
          }
        },
        "required": [
          "id",
          "detected_at",
          "change_type",
          "similarity_score"
        ],
        "title": "SceneChangeResponse",
        "type": "object"
      },
      "ScheduledReportCreate": {
        "description": "Schema for creating a new scheduled report.\n\nUsed when setting up a new automated report schedule.",
        "example": {
          "day_of_week": 1,
          "email_recipients": [
            "admin@example.com"
          ],
          "enabled": true,
          "format": "pdf",
          "frequency": "weekly",
          "hour": 8,
          "include_charts": true,
          "include_event_details": true,
          "minute": 0,
          "name": "Weekly Security Summary",
          "timezone": "America/New_York"
        },
        "properties": {
          "day_of_month": {
            "anyOf": [
              {
                "maximum": 31.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Day of month (1-31) for monthly reports",
            "title": "Day Of Month"
          },
          "day_of_week": {
            "anyOf": [
              {
                "maximum": 6.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Day of week (0=Monday, 6=Sunday) for weekly reports",
            "title": "Day Of Week"
          },
          "email_recipients": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "maxItems": 10,
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Email addresses to send report to (max 10)",
            "title": "Email Recipients"
          },
          "enabled": {
            "default": true,
            "description": "Whether the scheduled report is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "format": {
            "$ref": "#/components/schemas/ReportFormat",
            "default": "pdf",
            "description": "Output format for the report (pdf, csv, json)"
          },
          "frequency": {
            "$ref": "#/components/schemas/ReportFrequency",
            "description": "How often the report should run (daily, weekly, monthly)"
          },
          "hour": {
            "default": 8,
            "description": "Hour of day to run report (0-23, default 8)",
            "maximum": 23.0,
            "minimum": 0.0,
            "title": "Hour",
            "type": "integer"
          },
          "include_charts": {
            "default": true,
            "description": "Include visual charts in the report",
            "title": "Include Charts",
            "type": "boolean"
          },
          "include_event_details": {
            "default": true,
            "description": "Include detailed event breakdowns",
            "title": "Include Event Details",
            "type": "boolean"
          },
          "minute": {
            "default": 0,
            "description": "Minute of hour to run report (0-59, default 0)",
            "maximum": 59.0,
            "minimum": 0.0,
            "title": "Minute",
            "type": "integer"
          },
          "name": {
            "description": "Name/title of the scheduled report",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "timezone": {
            "default": "UTC",
            "description": "Timezone for schedule (e.g., 'America/New_York', 'UTC')",
            "maxLength": 50,
            "title": "Timezone",
            "type": "string"
          }
        },
        "required": [
          "name",
          "frequency"
        ],
        "title": "ScheduledReportCreate",
        "type": "object"
      },
      "ScheduledReportListResponse": {
        "description": "Schema for scheduled report list response.\n\nReturns a list of scheduled reports with total count.",
        "example": {
          "items": [
            {
              "created_at": "2025-01-01T12:00:00Z",
              "day_of_week": 1,
              "email_recipients": [
                "admin@example.com"
              ],
              "enabled": true,
              "format": "pdf",
              "frequency": "weekly",
              "hour": 8,
              "id": 1,
              "include_charts": true,
              "include_event_details": true,
              "last_run_at": "2025-01-20T08:00:00Z",
              "minute": 0,
              "name": "Weekly Security Summary",
              "next_run_at": "2025-01-27T08:00:00Z",
              "timezone": "America/New_York",
              "updated_at": "2025-01-15T09:30:00Z"
            }
          ],
          "total": 1
        },
        "properties": {
          "items": {
            "description": "List of scheduled reports",
            "items": {
              "$ref": "#/components/schemas/ScheduledReportResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "total": {
            "description": "Total number of scheduled reports",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "items",
          "total"
        ],
        "title": "ScheduledReportListResponse",
        "type": "object"
      },
      "ScheduledReportResponse": {
        "description": "Schema for scheduled report response.\n\nReturned when retrieving or creating a scheduled report.",
        "example": {
          "created_at": "2025-01-01T12:00:00Z",
          "day_of_week": 1,
          "email_recipients": [
            "admin@example.com"
          ],
          "enabled": true,
          "format": "pdf",
          "frequency": "weekly",
          "hour": 8,
          "id": 1,
          "include_charts": true,
          "include_event_details": true,
          "last_run_at": "2025-01-20T08:00:00Z",
          "minute": 0,
          "name": "Weekly Security Summary",
          "next_run_at": "2025-01-27T08:00:00Z",
          "timezone": "America/New_York",
          "updated_at": "2025-01-15T09:30:00Z"
        },
        "properties": {
          "created_at": {
            "description": "When the report was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "day_of_month": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Day of month (1-31) for monthly reports",
            "title": "Day Of Month"
          },
          "day_of_week": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Day of week (0=Monday, 6=Sunday) for weekly reports",
            "title": "Day Of Week"
          },
          "email_recipients": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Email addresses to send report to",
            "title": "Email Recipients"
          },
          "enabled": {
            "description": "Whether the scheduled report is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "format": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ReportFormat"
              },
              {
                "type": "string"
              }
            ],
            "description": "Output format for the report",
            "title": "Format"
          },
          "frequency": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ReportFrequency"
              },
              {
                "type": "string"
              }
            ],
            "description": "How often the report runs",
            "title": "Frequency"
          },
          "hour": {
            "description": "Hour of day to run report (0-23)",
            "title": "Hour",
            "type": "integer"
          },
          "id": {
            "description": "Scheduled report ID",
            "title": "Id",
            "type": "integer"
          },
          "include_charts": {
            "description": "Include visual charts in the report",
            "title": "Include Charts",
            "type": "boolean"
          },
          "include_event_details": {
            "description": "Include detailed event breakdowns",
            "title": "Include Event Details",
            "type": "boolean"
          },
          "last_run_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the report last ran successfully",
            "title": "Last Run At"
          },
          "minute": {
            "description": "Minute of hour to run report (0-59)",
            "title": "Minute",
            "type": "integer"
          },
          "name": {
            "description": "Name/title of the scheduled report",
            "title": "Name",
            "type": "string"
          },
          "next_run_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the report is scheduled to run next",
            "title": "Next Run At"
          },
          "timezone": {
            "description": "Timezone for schedule",
            "title": "Timezone",
            "type": "string"
          },
          "updated_at": {
            "description": "When the report was last updated",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "frequency",
          "hour",
          "minute",
          "timezone",
          "format",
          "enabled",
          "include_charts",
          "include_event_details",
          "created_at",
          "updated_at"
        ],
        "title": "ScheduledReportResponse",
        "type": "object"
      },
      "ScheduledReportRunResponse": {
        "description": "Schema for manual report run response.\n\nReturned when a report is manually triggered.",
        "example": {
          "message": "Report generation started",
          "report_id": 1,
          "started_at": "2025-01-25T10:30:00Z",
          "status": "running"
        },
        "properties": {
          "message": {
            "description": "Status message",
            "title": "Message",
            "type": "string"
          },
          "report_id": {
            "description": "ID of the report being run",
            "title": "Report Id",
            "type": "integer"
          },
          "started_at": {
            "description": "When the run was initiated",
            "format": "date-time",
            "title": "Started At",
            "type": "string"
          },
          "status": {
            "description": "Status of the run (running, queued, failed)",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "report_id",
          "status",
          "message",
          "started_at"
        ],
        "title": "ScheduledReportRunResponse",
        "type": "object"
      },
      "ScheduledReportUpdate": {
        "description": "Schema for updating an existing scheduled report.\n\nAll fields are optional for partial updates.",
        "example": {
          "enabled": false,
          "name": "Updated Weekly Report"
        },
        "properties": {
          "day_of_month": {
            "anyOf": [
              {
                "maximum": 31.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Day of month (1-31) for monthly reports",
            "title": "Day Of Month"
          },
          "day_of_week": {
            "anyOf": [
              {
                "maximum": 6.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Day of week (0=Monday, 6=Sunday) for weekly reports",
            "title": "Day Of Week"
          },
          "email_recipients": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "maxItems": 10,
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Email addresses to send report to (max 10)",
            "title": "Email Recipients"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether the scheduled report is active",
            "title": "Enabled"
          },
          "format": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ReportFormat"
              },
              {
                "type": "null"
              }
            ],
            "description": "Output format for the report (pdf, csv, json)"
          },
          "frequency": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ReportFrequency"
              },
              {
                "type": "null"
              }
            ],
            "description": "How often the report should run (daily, weekly, monthly)"
          },
          "hour": {
            "anyOf": [
              {
                "maximum": 23.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Hour of day to run report (0-23)",
            "title": "Hour"
          },
          "include_charts": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Include visual charts in the report",
            "title": "Include Charts"
          },
          "include_event_details": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Include detailed event breakdowns",
            "title": "Include Event Details"
          },
          "minute": {
            "anyOf": [
              {
                "maximum": 59.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minute of hour to run report (0-59)",
            "title": "Minute"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 255,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Name/title of the scheduled report",
            "title": "Name"
          },
          "timezone": {
            "anyOf": [
              {
                "maxLength": 50,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timezone for schedule (e.g., 'America/New_York', 'UTC')",
            "title": "Timezone"
          }
        },
        "title": "ScheduledReportUpdate",
        "type": "object"
      },
      "SearchResponse": {
        "description": "Schema for search response with pagination.",
        "example": {
          "limit": 50,
          "offset": 0,
          "results": [
            {
              "camera_id": "front_door",
              "camera_name": "Front Door",
              "detection_count": 5,
              "detection_ids": [
                1,
                2,
                3,
                4,
                5
              ],
              "ended_at": "2025-12-23T12:02:30Z",
              "id": 1,
              "object_types": "person, vehicle",
              "reasoning": "Unknown individual approaching entrance during nighttime",
              "relevance_score": 0.85,
              "reviewed": false,
              "risk_level": "medium",
              "risk_score": 75,
              "started_at": "2025-12-23T12:00:00Z",
              "summary": "Suspicious person detected near front entrance"
            }
          ],
          "total_count": 42
        },
        "properties": {
          "limit": {
            "description": "Maximum number of results returned",
            "title": "Limit",
            "type": "integer"
          },
          "offset": {
            "description": "Number of results skipped",
            "title": "Offset",
            "type": "integer"
          },
          "results": {
            "description": "List of search results",
            "items": {
              "$ref": "#/components/schemas/SearchResult"
            },
            "title": "Results",
            "type": "array"
          },
          "total_count": {
            "description": "Total number of matching events",
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "results",
          "total_count",
          "limit",
          "offset"
        ],
        "title": "SearchResponse",
        "type": "object"
      },
      "SearchResult": {
        "description": "Schema for a single search result.",
        "example": {
          "camera_id": "front_door",
          "camera_name": "Front Door",
          "detection_count": 5,
          "detection_ids": [
            1,
            2,
            3,
            4,
            5
          ],
          "ended_at": "2025-12-23T12:02:30Z",
          "id": 1,
          "object_types": "person, vehicle",
          "reasoning": "Unknown individual approaching entrance during nighttime hours",
          "relevance_score": 0.85,
          "reviewed": false,
          "risk_level": "medium",
          "risk_score": 75,
          "started_at": "2025-12-23T12:00:00Z",
          "summary": "Suspicious person detected near front entrance"
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID",
            "title": "Camera Id",
            "type": "string"
          },
          "camera_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Camera display name",
            "title": "Camera Name"
          },
          "detection_count": {
            "default": 0,
            "description": "Number of detections in this event",
            "title": "Detection Count",
            "type": "integer"
          },
          "detection_ids": {
            "description": "List of detection IDs associated with this event",
            "items": {
              "type": "integer"
            },
            "title": "Detection Ids",
            "type": "array"
          },
          "ended_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Event end timestamp",
            "title": "Ended At"
          },
          "id": {
            "description": "Event ID",
            "title": "Id",
            "type": "integer"
          },
          "object_types": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Comma-separated detected object types",
            "title": "Object Types"
          },
          "reasoning": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM reasoning for risk score",
            "title": "Reasoning"
          },
          "relevance_score": {
            "default": 0.0,
            "description": "Full-text search relevance score (higher is more relevant)",
            "title": "Relevance Score",
            "type": "number"
          },
          "reviewed": {
            "default": false,
            "description": "Whether event has been reviewed",
            "title": "Reviewed",
            "type": "boolean"
          },
          "risk_level": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk level (low/medium/high/critical), computed from risk_score using severity thresholds",
            "readOnly": true,
            "title": "Risk Level"
          },
          "risk_score": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Risk score (0-100)",
            "title": "Risk Score"
          },
          "started_at": {
            "description": "Event start timestamp",
            "format": "date-time",
            "title": "Started At",
            "type": "string"
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "LLM-generated event summary",
            "title": "Summary"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to event thumbnail image (from first detection)",
            "title": "Thumbnail Url"
          }
        },
        "required": [
          "id",
          "camera_id",
          "started_at",
          "risk_level"
        ],
        "title": "SearchResult",
        "type": "object"
      },
      "SeedCamerasRequest": {
        "description": "Request schema for seeding cameras.",
        "properties": {
          "clear_existing": {
            "default": false,
            "description": "Remove existing cameras first",
            "title": "Clear Existing",
            "type": "boolean"
          },
          "count": {
            "default": 6,
            "description": "Number of cameras to create (1-6)",
            "maximum": 6.0,
            "minimum": 1.0,
            "title": "Count",
            "type": "integer"
          },
          "create_folders": {
            "default": false,
            "description": "Create camera folders on filesystem",
            "title": "Create Folders",
            "type": "boolean"
          }
        },
        "title": "SeedCamerasRequest",
        "type": "object"
      },
      "SeedCamerasResponse": {
        "description": "Response schema for seed cameras endpoint.",
        "properties": {
          "cameras": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "title": "Cameras",
            "type": "array"
          },
          "cleared": {
            "title": "Cleared",
            "type": "integer"
          },
          "created": {
            "title": "Created",
            "type": "integer"
          }
        },
        "required": [
          "created",
          "cleared",
          "cameras"
        ],
        "title": "SeedCamerasResponse",
        "type": "object"
      },
      "SeedEventsRequest": {
        "description": "Request schema for seeding events.",
        "properties": {
          "clear_existing": {
            "default": false,
            "description": "Remove existing events and detections",
            "title": "Clear Existing",
            "type": "boolean"
          },
          "count": {
            "default": 15,
            "description": "Number of events to create (1-100)",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Count",
            "type": "integer"
          }
        },
        "title": "SeedEventsRequest",
        "type": "object"
      },
      "SeedEventsResponse": {
        "description": "Response schema for seed events endpoint.",
        "properties": {
          "detections_cleared": {
            "title": "Detections Cleared",
            "type": "integer"
          },
          "detections_created": {
            "title": "Detections Created",
            "type": "integer"
          },
          "events_cleared": {
            "title": "Events Cleared",
            "type": "integer"
          },
          "events_created": {
            "title": "Events Created",
            "type": "integer"
          }
        },
        "required": [
          "events_created",
          "detections_created",
          "events_cleared",
          "detections_cleared"
        ],
        "title": "SeedEventsResponse",
        "type": "object"
      },
      "SeedPipelineLatencyRequest": {
        "description": "Request schema for seeding pipeline latency data.",
        "properties": {
          "num_samples": {
            "default": 100,
            "description": "Number of latency samples to generate per stage (10-1000)",
            "maximum": 1000.0,
            "minimum": 10.0,
            "title": "Num Samples",
            "type": "integer"
          },
          "time_span_hours": {
            "default": 24,
            "description": "Time span in hours for the generated samples (1-168)",
            "maximum": 168.0,
            "minimum": 1.0,
            "title": "Time Span Hours",
            "type": "integer"
          }
        },
        "title": "SeedPipelineLatencyRequest",
        "type": "object"
      },
      "SeedPipelineLatencyResponse": {
        "description": "Response schema for seed pipeline latency endpoint.",
        "properties": {
          "message": {
            "title": "Message",
            "type": "string"
          },
          "samples_per_stage": {
            "title": "Samples Per Stage",
            "type": "integer"
          },
          "stages_seeded": {
            "items": {
              "type": "string"
            },
            "title": "Stages Seeded",
            "type": "array"
          },
          "time_span_hours": {
            "title": "Time Span Hours",
            "type": "integer"
          }
        },
        "required": [
          "samples_per_stage",
          "stages_seeded",
          "time_span_hours",
          "message"
        ],
        "title": "SeedPipelineLatencyResponse",
        "type": "object"
      },
      "ServiceActionResponse": {
        "description": "Response for service action endpoints (restart, enable, disable, start).\n\nReturned after POST /api/system/services/{name}/restart, enable, disable, or start.",
        "example": {
          "message": "Service restarted successfully",
          "service": {
            "category": "ai",
            "container_id": "abc123...",
            "display_name": "YOLO26v2",
            "enabled": true,
            "failure_count": 0,
            "image": "ghcr.io/.../yolo26:latest",
            "last_restart_at": "2026-01-05T15:50:00Z",
            "name": "ai-detector",
            "port": 8090,
            "restart_count": 3,
            "status": "starting"
          },
          "success": true
        },
        "properties": {
          "message": {
            "description": "Human-readable result message",
            "title": "Message",
            "type": "string"
          },
          "service": {
            "$ref": "#/components/schemas/ServiceInfo",
            "description": "Updated service information after the action"
          },
          "success": {
            "description": "Whether the action completed successfully",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success",
          "message",
          "service"
        ],
        "title": "ServiceActionResponse",
        "type": "object"
      },
      "ServiceCategory": {
        "description": "Service category for classification and restart policy.\n\nCategories determine restart behavior and priority:\n- INFRASTRUCTURE: Critical services (PostgreSQL, Redis) with aggressive restart\n- AI: AI/ML services with standard backoff\n- MONITORING: Optional monitoring services with lenient restart",
        "enum": [
          "infrastructure",
          "ai",
          "monitoring"
        ],
        "title": "ServiceCategory",
        "type": "string"
      },
      "ServiceHealthResponse": {
        "description": "Response schema for AI service health status.\n\nReturns health status of all AI services including GPU assignments.",
        "example": {
          "services": [
            {
              "gpu_index": 0,
              "health": "healthy",
              "name": "ai-llm",
              "status": "running"
            },
            {
              "gpu_index": 1,
              "health": "healthy",
              "name": "ai-detector",
              "status": "running"
            }
          ]
        },
        "properties": {
          "services": {
            "description": "Status of all AI services",
            "items": {
              "$ref": "#/components/schemas/ServiceHealthStatus"
            },
            "title": "Services",
            "type": "array"
          }
        },
        "required": [
          "services"
        ],
        "title": "ServiceHealthResponse",
        "type": "object"
      },
      "ServiceHealthState": {
        "description": "Health state for a service in the full health check.\n\nStates:\n- healthy: Service is fully operational\n- unhealthy: Service is down or experiencing critical issues\n- degraded: Service is partially operational\n- unknown: Service status cannot be determined",
        "enum": [
          "healthy",
          "unhealthy",
          "degraded",
          "unknown"
        ],
        "title": "ServiceHealthState",
        "type": "string"
      },
      "ServiceHealthStatus": {
        "description": "Schema for service health status including GPU assignment.\n\nProvides comprehensive service health information for the GPU settings UI,\nincluding container status, health check result, and GPU assignment.",
        "example": {
          "gpu_index": 0,
          "health": "healthy",
          "name": "ai-llm",
          "status": "running"
        },
        "properties": {
          "gpu_index": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Assigned GPU index",
            "title": "Gpu Index"
          },
          "health": {
            "description": "Health check result (healthy, unhealthy, unknown)",
            "title": "Health",
            "type": "string"
          },
          "name": {
            "description": "Service name (e.g., 'ai-llm')",
            "title": "Name",
            "type": "string"
          },
          "restart_status": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Restart status if currently restarting (pending, completed)",
            "title": "Restart Status"
          },
          "status": {
            "description": "Container status (running, stopped, etc.)",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "name",
          "status",
          "health"
        ],
        "title": "ServiceHealthStatus",
        "type": "object"
      },
      "ServiceHealthStatusResponse": {
        "description": "Health status of a registered service.",
        "properties": {
          "consecutive_failures": {
            "description": "Count of consecutive health check failures",
            "minimum": 0.0,
            "title": "Consecutive Failures",
            "type": "integer"
          },
          "error_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Last error message if unhealthy",
            "title": "Error Message"
          },
          "last_check": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Monotonic time of last health check",
            "title": "Last Check"
          },
          "name": {
            "description": "Service name",
            "title": "Name",
            "type": "string"
          },
          "status": {
            "description": "Health status (healthy, unhealthy, unknown)",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "name",
          "status",
          "consecutive_failures"
        ],
        "title": "ServiceHealthStatusResponse",
        "type": "object"
      },
      "ServiceInfo": {
        "description": "Information about a single managed service.\n\nContains identity, configuration, and runtime status for a container\nmanaged by the orchestrator.",
        "example": {
          "category": "ai",
          "container_id": "abc123def456",
          "display_name": "YOLO26v2",
          "enabled": true,
          "failure_count": 0,
          "image": "ghcr.io/.../yolo26:latest",
          "last_restart_at": "2026-01-05T10:30:00Z",
          "name": "ai-detector",
          "port": 8090,
          "restart_count": 2,
          "status": "running",
          "uptime_seconds": 3600
        },
        "properties": {
          "category": {
            "$ref": "#/components/schemas/ServiceCategory",
            "description": "Service category: infrastructure, ai, or monitoring"
          },
          "container_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Docker container ID (short form)",
            "title": "Container Id"
          },
          "display_name": {
            "description": "Human-readable display name (e.g., 'YOLO26v2', 'PostgreSQL')",
            "title": "Display Name",
            "type": "string"
          },
          "enabled": {
            "default": true,
            "description": "Whether auto-restart is enabled for this service",
            "title": "Enabled",
            "type": "boolean"
          },
          "failure_count": {
            "default": 0,
            "description": "Consecutive health check failure count",
            "minimum": 0.0,
            "title": "Failure Count",
            "type": "integer"
          },
          "image": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Container image (e.g., 'postgres:16-alpine', 'ghcr.io/.../yolo26:latest')",
            "title": "Image"
          },
          "last_restart_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of last restart (null if never restarted)",
            "title": "Last Restart At"
          },
          "name": {
            "description": "Service identifier (e.g., 'ai-detector', 'postgres', 'grafana')",
            "title": "Name",
            "type": "string"
          },
          "port": {
            "description": "Primary service port",
            "maximum": 65535.0,
            "minimum": 1.0,
            "title": "Port",
            "type": "integer"
          },
          "restart_count": {
            "default": 0,
            "description": "Total restarts since backend boot",
            "minimum": 0.0,
            "title": "Restart Count",
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/ContainerServiceStatus",
            "description": "Current service status: running, starting, unhealthy, stopped, disabled, not_found"
          },
          "uptime_seconds": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Seconds since container started (null if not running)",
            "title": "Uptime Seconds"
          }
        },
        "required": [
          "name",
          "display_name",
          "category",
          "status",
          "port"
        ],
        "title": "ServiceInfo",
        "type": "object"
      },
      "ServiceStatus": {
        "description": "Schema for service status after GPU config apply.\n\nReports the status of a service after applying GPU configuration changes.",
        "example": {
          "service": "ai-llm",
          "status": "running"
        },
        "properties": {
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional status message or error details",
            "title": "Message"
          },
          "service": {
            "description": "Service name",
            "title": "Service",
            "type": "string"
          },
          "status": {
            "description": "Service status (running, starting, stopped, error)",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "service",
          "status"
        ],
        "title": "ServiceStatus",
        "type": "object"
      },
      "ServicesResponse": {
        "description": "Response for GET /api/system/services.\n\nReturns a list of all managed services with their current status\nand category-level summaries.",
        "example": {
          "by_category": {
            "ai": {
              "healthy": 3,
              "total": 5,
              "unhealthy": 2
            },
            "infrastructure": {
              "healthy": 2,
              "total": 2,
              "unhealthy": 0
            },
            "monitoring": {
              "healthy": 4,
              "total": 4,
              "unhealthy": 0
            }
          },
          "services": [
            {
              "category": "infrastructure",
              "container_id": "def456...",
              "display_name": "PostgreSQL",
              "enabled": true,
              "failure_count": 0,
              "image": "postgres:16-alpine",
              "name": "postgres",
              "port": 5432,
              "restart_count": 0,
              "status": "running",
              "uptime_seconds": 86400
            },
            {
              "category": "ai",
              "container_id": "abc123...",
              "display_name": "YOLO26v2",
              "enabled": true,
              "failure_count": 0,
              "image": "ghcr.io/.../yolo26:latest",
              "last_restart_at": "2026-01-05T10:30:00Z",
              "name": "ai-detector",
              "port": 8090,
              "restart_count": 2,
              "status": "running",
              "uptime_seconds": 3600
            }
          ],
          "timestamp": "2026-01-05T15:45:00Z"
        },
        "properties": {
          "by_category": {
            "additionalProperties": {
              "$ref": "#/components/schemas/CategorySummary"
            },
            "description": "Health summary by category (infrastructure, ai, monitoring)",
            "title": "By Category",
            "type": "object"
          },
          "services": {
            "description": "List of all managed services with current status",
            "items": {
              "$ref": "#/components/schemas/ServiceInfo"
            },
            "title": "Services",
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp of status snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "services",
          "by_category",
          "timestamp"
        ],
        "title": "ServicesResponse",
        "type": "object"
      },
      "SettingsResponse": {
        "description": "Complete settings response with all configurable settings grouped by category.\n\nThis is the response schema for GET /api/v1/settings, containing all\nuser-configurable settings organized into logical groups.",
        "example": {
          "batch": {
            "idle_timeout_seconds": 30,
            "window_seconds": 90
          },
          "detection": {
            "confidence_threshold": 0.5,
            "fast_path_threshold": 0.9
          },
          "features": {
            "background_eval_enabled": true,
            "clip_generation_enabled": true,
            "image_quality_enabled": true,
            "reid_enabled": true,
            "scene_change_enabled": true,
            "vision_extraction_enabled": true
          },
          "queue": {
            "backpressure_threshold": 0.8,
            "max_size": 10000
          },
          "rate_limiting": {
            "burst_size": 10,
            "enabled": true,
            "requests_per_minute": 60
          },
          "retention": {
            "days": 30,
            "log_days": 7
          },
          "severity": {
            "high_max": 84,
            "low_max": 29,
            "medium_max": 59
          }
        },
        "properties": {
          "batch": {
            "$ref": "#/components/schemas/BatchSettings",
            "description": "Batch processing settings"
          },
          "detection": {
            "$ref": "#/components/schemas/DetectionSettings",
            "description": "Detection confidence threshold settings"
          },
          "features": {
            "$ref": "#/components/schemas/FeatureSettings",
            "description": "Feature toggle settings"
          },
          "queue": {
            "$ref": "#/components/schemas/QueueSettings",
            "description": "Queue settings"
          },
          "rate_limiting": {
            "$ref": "#/components/schemas/RateLimitingSettings",
            "description": "Rate limiting settings"
          },
          "retention": {
            "$ref": "#/components/schemas/RetentionSettings",
            "description": "Data retention settings"
          },
          "severity": {
            "$ref": "#/components/schemas/SeveritySettings",
            "description": "Severity threshold settings for risk categorization"
          }
        },
        "required": [
          "detection",
          "batch",
          "severity",
          "features",
          "rate_limiting",
          "queue",
          "retention"
        ],
        "title": "SettingsResponse",
        "type": "object"
      },
      "SettingsUpdate": {
        "description": "Schema for updating runtime settings via PATCH.\n\nAll fields are optional to support partial updates. Only provided\nfields will be updated. Changes are written to data/runtime.env\nand take effect immediately without server restart.",
        "example": {
          "detection": {
            "confidence_threshold": 0.6
          },
          "features": {
            "reid_enabled": false
          }
        },
        "properties": {
          "batch": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BatchSettingsUpdate"
              },
              {
                "type": "null"
              }
            ],
            "description": "Batch processing settings"
          },
          "detection": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DetectionSettingsUpdate"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detection confidence threshold settings"
          },
          "features": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeatureSettingsUpdate"
              },
              {
                "type": "null"
              }
            ],
            "description": "Feature toggle settings"
          },
          "queue": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/QueueSettingsUpdate"
              },
              {
                "type": "null"
              }
            ],
            "description": "Queue settings"
          },
          "rate_limiting": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RateLimitingSettingsUpdate"
              },
              {
                "type": "null"
              }
            ],
            "description": "Rate limiting settings"
          },
          "retention": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RetentionSettingsUpdate"
              },
              {
                "type": "null"
              }
            ],
            "description": "Data retention settings"
          },
          "severity": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SeveritySettingsUpdate"
              },
              {
                "type": "null"
              }
            ],
            "description": "Severity threshold settings for risk categorization"
          }
        },
        "title": "SettingsUpdate",
        "type": "object"
      },
      "SeverityDefinitionResponse": {
        "description": "Definition of a single severity level.",
        "example": {
          "color": "#f97316",
          "description": "Concerning activity, review soon",
          "label": "High",
          "max_score": 84,
          "min_score": 60,
          "priority": 1,
          "severity": "high"
        },
        "properties": {
          "color": {
            "description": "Hex color code for UI display (e.g., '#22c55e')",
            "pattern": "^#[0-9a-fA-F]{6}$",
            "title": "Color",
            "type": "string"
          },
          "description": {
            "description": "Description of when this severity applies",
            "title": "Description",
            "type": "string"
          },
          "label": {
            "description": "Human-readable label for the severity level",
            "title": "Label",
            "type": "string"
          },
          "max_score": {
            "description": "Maximum risk score for this severity (inclusive)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Max Score",
            "type": "integer"
          },
          "min_score": {
            "description": "Minimum risk score for this severity (inclusive)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Min Score",
            "type": "integer"
          },
          "priority": {
            "description": "Sort priority (0 = highest priority, 3 = lowest)",
            "maximum": 3.0,
            "minimum": 0.0,
            "title": "Priority",
            "type": "integer"
          },
          "severity": {
            "$ref": "#/components/schemas/SeverityEnum",
            "description": "The severity level identifier"
          }
        },
        "required": [
          "severity",
          "label",
          "description",
          "color",
          "priority",
          "min_score",
          "max_score"
        ],
        "title": "SeverityDefinitionResponse",
        "type": "object"
      },
      "SeverityEnum": {
        "description": "Severity levels for API responses.",
        "enum": [
          "low",
          "medium",
          "high",
          "critical"
        ],
        "title": "SeverityEnum",
        "type": "string"
      },
      "SeverityMetadataResponse": {
        "description": "Response schema for severity metadata endpoint.\n\nProvides complete information about severity levels including:\n- All severity definitions with thresholds and colors\n- Current threshold configuration\n- Useful for frontend to display severity information consistently",
        "example": {
          "definitions": [
            {
              "color": "#22c55e",
              "description": "Routine activity, no concern",
              "label": "Low",
              "max_score": 29,
              "min_score": 0,
              "priority": 3,
              "severity": "low"
            },
            {
              "color": "#eab308",
              "description": "Notable activity, worth reviewing",
              "label": "Medium",
              "max_score": 59,
              "min_score": 30,
              "priority": 2,
              "severity": "medium"
            },
            {
              "color": "#f97316",
              "description": "Concerning activity, review soon",
              "label": "High",
              "max_score": 84,
              "min_score": 60,
              "priority": 1,
              "severity": "high"
            },
            {
              "color": "#ef4444",
              "description": "Immediate attention required",
              "label": "Critical",
              "max_score": 100,
              "min_score": 85,
              "priority": 0,
              "severity": "critical"
            }
          ],
          "thresholds": {
            "high_max": 84,
            "low_max": 29,
            "medium_max": 59
          }
        },
        "properties": {
          "definitions": {
            "description": "List of all severity level definitions",
            "items": {
              "$ref": "#/components/schemas/SeverityDefinitionResponse"
            },
            "title": "Definitions",
            "type": "array"
          },
          "thresholds": {
            "$ref": "#/components/schemas/SeverityThresholds",
            "description": "Current severity threshold configuration"
          }
        },
        "required": [
          "definitions",
          "thresholds"
        ],
        "title": "SeverityMetadataResponse",
        "type": "object"
      },
      "SeveritySettings": {
        "description": "Severity threshold settings for risk score categorization.\n\nDefines the maximum risk score values for each severity level.\nRisk scores are 0-100, and severity is determined by:\n- LOW: 0 to low_max\n- MEDIUM: low_max+1 to medium_max\n- HIGH: medium_max+1 to high_max\n- CRITICAL: above high_max",
        "example": {
          "high_max": 84,
          "low_max": 29,
          "medium_max": 59
        },
        "properties": {
          "high_max": {
            "description": "Maximum risk score for HIGH severity (above = CRITICAL)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "High Max",
            "type": "integer"
          },
          "low_max": {
            "description": "Maximum risk score for LOW severity (0 to this value = LOW)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Low Max",
            "type": "integer"
          },
          "medium_max": {
            "description": "Maximum risk score for MEDIUM severity",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Medium Max",
            "type": "integer"
          }
        },
        "required": [
          "low_max",
          "medium_max",
          "high_max"
        ],
        "title": "SeveritySettings",
        "type": "object"
      },
      "SeveritySettingsUpdate": {
        "description": "Severity settings update schema (all fields optional).\n\nUsed for PATCH /api/v1/settings to partially update severity thresholds.\nValidates that severity thresholds maintain proper ordering (low < medium < high).",
        "example": {
          "low_max": 25
        },
        "properties": {
          "high_max": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum risk score for HIGH severity (above = CRITICAL)",
            "title": "High Max"
          },
          "low_max": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum risk score for LOW severity (0 to this value = LOW)",
            "title": "Low Max"
          },
          "medium_max": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum risk score for MEDIUM severity",
            "title": "Medium Max"
          }
        },
        "title": "SeveritySettingsUpdate",
        "type": "object"
      },
      "SeverityThresholds": {
        "description": "Current severity threshold configuration.",
        "example": {
          "high_max": 84,
          "low_max": 29,
          "medium_max": 59
        },
        "properties": {
          "high_max": {
            "description": "Maximum risk score for HIGH severity (medium_max+1 to this value = HIGH)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "High Max",
            "type": "integer"
          },
          "low_max": {
            "description": "Maximum risk score for LOW severity (0 to this value = LOW)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Low Max",
            "type": "integer"
          },
          "medium_max": {
            "description": "Maximum risk score for MEDIUM severity (low_max+1 to this value = MEDIUM)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Medium Max",
            "type": "integer"
          }
        },
        "required": [
          "low_max",
          "medium_max",
          "high_max"
        ],
        "title": "SeverityThresholds",
        "type": "object"
      },
      "SeverityThresholdsUpdateRequest": {
        "description": "Request schema for updating severity thresholds.\n\nThe thresholds must form contiguous ranges from 0-100:\n- LOW: 0 to low_max (inclusive)\n- MEDIUM: low_max+1 to medium_max (inclusive)\n- HIGH: medium_max+1 to high_max (inclusive)\n- CRITICAL: high_max+1 to 100 (inclusive)\n\nValidation rules:\n- 0 < low_max < medium_max < high_max < 100\n- This ensures all ranges are valid and cover 0-100 without gaps or overlaps",
        "example": {
          "high_max": 84,
          "low_max": 29,
          "medium_max": 59
        },
        "properties": {
          "high_max": {
            "description": "Maximum risk score for HIGH severity (3-99)",
            "maximum": 99.0,
            "minimum": 3.0,
            "title": "High Max",
            "type": "integer"
          },
          "low_max": {
            "description": "Maximum risk score for LOW severity (1-98)",
            "maximum": 98.0,
            "minimum": 1.0,
            "title": "Low Max",
            "type": "integer"
          },
          "medium_max": {
            "description": "Maximum risk score for MEDIUM severity (2-99)",
            "maximum": 99.0,
            "minimum": 2.0,
            "title": "Medium Max",
            "type": "integer"
          }
        },
        "required": [
          "low_max",
          "medium_max",
          "high_max"
        ],
        "title": "SeverityThresholdsUpdateRequest",
        "type": "object"
      },
      "SourceFilter": {
        "description": "Data source for entity queries.\n\nControls which storage backend to query for entities:\n- redis: Only query Redis hot cache (24h window)\n- postgres: Only query PostgreSQL (30d retention)\n- both: Query both and merge results (default)",
        "enum": [
          "redis",
          "postgres",
          "both"
        ],
        "title": "SourceFilter",
        "type": "string"
      },
      "StageLatency": {
        "description": "Latency statistics for a single pipeline stage.",
        "example": {
          "avg_ms": 150.5,
          "max_ms": 500.0,
          "min_ms": 50.0,
          "p50_ms": 120.0,
          "p95_ms": 400.0,
          "p99_ms": 480.0,
          "sample_count": 100
        },
        "properties": {
          "avg_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Average latency in milliseconds",
            "title": "Avg Ms"
          },
          "max_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum latency in milliseconds",
            "title": "Max Ms"
          },
          "min_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum latency in milliseconds",
            "title": "Min Ms"
          },
          "p50_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "50th percentile (median) latency in milliseconds",
            "title": "P50 Ms"
          },
          "p95_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "95th percentile latency in milliseconds",
            "title": "P95 Ms"
          },
          "p99_ms": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "99th percentile latency in milliseconds",
            "title": "P99 Ms"
          },
          "sample_count": {
            "description": "Number of samples used to calculate statistics",
            "minimum": 0.0,
            "title": "Sample Count",
            "type": "integer"
          }
        },
        "required": [
          "sample_count"
        ],
        "title": "StageLatency",
        "type": "object"
      },
      "StorageCategoryStats": {
        "description": "Storage statistics for a single category.",
        "properties": {
          "file_count": {
            "description": "Number of files in this category",
            "minimum": 0.0,
            "title": "File Count",
            "type": "integer"
          },
          "size_bytes": {
            "description": "Total size in bytes for this category",
            "minimum": 0.0,
            "title": "Size Bytes",
            "type": "integer"
          }
        },
        "required": [
          "file_count",
          "size_bytes"
        ],
        "title": "StorageCategoryStats",
        "type": "object"
      },
      "StorageStatsResponse": {
        "description": "Response schema for storage statistics endpoint.\n\nProvides detailed storage usage information including:\n- Disk usage for the storage volume\n- Breakdown by data category (thumbnails, images, clips)\n- Database record counts",
        "example": {
          "clips": {
            "file_count": 50,
            "size_bytes": 500000000
          },
          "detections_count": 892,
          "disk_free_bytes": 429496729600,
          "disk_total_bytes": 536870912000,
          "disk_usage_percent": 20.0,
          "disk_used_bytes": 107374182400,
          "events_count": 156,
          "gpu_stats_count": 2880,
          "images": {
            "file_count": 10000,
            "size_bytes": 5000000000
          },
          "logs_count": 5000,
          "thumbnails": {
            "file_count": 1500,
            "size_bytes": 75000000
          },
          "timestamp": "2025-12-30T10:30:00Z"
        },
        "properties": {
          "clips": {
            "$ref": "#/components/schemas/StorageCategoryStats",
            "description": "Storage used by event video clips"
          },
          "detections_count": {
            "description": "Total number of detections in database",
            "minimum": 0.0,
            "title": "Detections Count",
            "type": "integer"
          },
          "disk_free_bytes": {
            "description": "Free disk space in bytes",
            "minimum": 0.0,
            "title": "Disk Free Bytes",
            "type": "integer"
          },
          "disk_total_bytes": {
            "description": "Total disk space available in bytes",
            "minimum": 0.0,
            "title": "Disk Total Bytes",
            "type": "integer"
          },
          "disk_usage_percent": {
            "description": "Disk usage percentage (0-100)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Disk Usage Percent",
            "type": "number"
          },
          "disk_used_bytes": {
            "description": "Total disk space used in bytes",
            "minimum": 0.0,
            "title": "Disk Used Bytes",
            "type": "integer"
          },
          "events_count": {
            "description": "Total number of events in database",
            "minimum": 0.0,
            "title": "Events Count",
            "type": "integer"
          },
          "gpu_stats_count": {
            "description": "Total number of GPU stats records in database",
            "minimum": 0.0,
            "title": "Gpu Stats Count",
            "type": "integer"
          },
          "images": {
            "$ref": "#/components/schemas/StorageCategoryStats",
            "description": "Storage used by original camera images"
          },
          "logs_count": {
            "description": "Total number of log entries in database",
            "minimum": 0.0,
            "title": "Logs Count",
            "type": "integer"
          },
          "thumbnails": {
            "$ref": "#/components/schemas/StorageCategoryStats",
            "description": "Storage used by detection thumbnails"
          },
          "timestamp": {
            "description": "Timestamp of storage stats snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "disk_used_bytes",
          "disk_total_bytes",
          "disk_free_bytes",
          "disk_usage_percent",
          "thumbnails",
          "images",
          "clips",
          "events_count",
          "detections_count",
          "gpu_stats_count",
          "logs_count",
          "timestamp"
        ],
        "title": "StorageStatsResponse",
        "type": "object"
      },
      "StructuredSummarySchema": {
        "description": "Schema for structured summary data extracted from LLM content.\n\nContains categorized information extracted from the narrative summary\nfor display in the dashboard UI with visual elements.",
        "example": {
          "bullet_points": [
            {
              "icon": "camera",
              "severity": "high",
              "text": "Activity at Beach Front Left: person approaching"
            },
            {
              "icon": "alert-circle",
              "severity": "high",
              "text": "Loitering behavior detected"
            }
          ],
          "dominant_patterns": [
            "loitering",
            "obscured face"
          ],
          "focus_areas": [
            "Beach Front Left",
            "Dock Right"
          ],
          "max_risk_score": 85,
          "weather_conditions": [
            "nighttime"
          ]
        },
        "properties": {
          "bullet_points": {
            "description": "List of bullet points for visual display",
            "items": {
              "$ref": "#/components/schemas/BulletPointSchema"
            },
            "title": "Bullet Points",
            "type": "array"
          },
          "dominant_patterns": {
            "description": "Behavior patterns detected (loitering, obscured face, etc.)",
            "items": {
              "type": "string"
            },
            "title": "Dominant Patterns",
            "type": "array"
          },
          "focus_areas": {
            "description": "Camera names mentioned in the summary",
            "items": {
              "type": "string"
            },
            "title": "Focus Areas",
            "type": "array"
          },
          "max_risk_score": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Maximum risk score from events (0-100)",
            "title": "Max Risk Score"
          },
          "weather_conditions": {
            "description": "Weather/environmental conditions (rainy, nighttime, etc.)",
            "items": {
              "type": "string"
            },
            "title": "Weather Conditions",
            "type": "array"
          }
        },
        "title": "StructuredSummarySchema",
        "type": "object"
      },
      "SummaryResponse": {
        "description": "Schema for a single summary (hourly or daily).\n\nRepresents an LLM-generated narrative summary of security events within\na specific time window, with both raw content and structured data.",
        "example": {
          "content": "Over the past hour, one critical event occurred at 2:15 PM when an unrecognized person approached the front door. The individual remained at the door for approximately 45 seconds before leaving via the driveway.",
          "event_count": 1,
          "generated_at": "2026-01-18T14:55:00Z",
          "id": 1,
          "structured": {
            "bullet_points": [
              {
                "icon": "camera",
                "severity": "critical",
                "text": "Activity at front door: unrecognized person"
              }
            ],
            "dominant_patterns": [],
            "focus_areas": [
              "Front Door"
            ],
            "max_risk_score": 85,
            "weather_conditions": []
          },
          "window_end": "2026-01-18T15:00:00Z",
          "window_start": "2026-01-18T14:00:00Z"
        },
        "properties": {
          "content": {
            "description": "LLM-generated narrative text (2-4 sentences)",
            "title": "Content",
            "type": "string"
          },
          "event_count": {
            "description": "Number of high/critical events included in this summary",
            "minimum": 0.0,
            "title": "Event Count",
            "type": "integer"
          },
          "generated_at": {
            "description": "When the LLM produced this summary",
            "format": "date-time",
            "title": "Generated At",
            "type": "string"
          },
          "id": {
            "description": "Summary ID",
            "title": "Id",
            "type": "integer"
          },
          "structured": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StructuredSummarySchema"
              },
              {
                "type": "null"
              }
            ],
            "description": "Structured data extracted from the summary content"
          },
          "window_end": {
            "description": "End of the time window covered",
            "format": "date-time",
            "title": "Window End",
            "type": "string"
          },
          "window_start": {
            "description": "Start of the time window covered",
            "format": "date-time",
            "title": "Window Start",
            "type": "string"
          }
        },
        "required": [
          "id",
          "content",
          "event_count",
          "window_start",
          "window_end",
          "generated_at"
        ],
        "title": "SummaryResponse",
        "type": "object"
      },
      "SupervisedWorkerInfo": {
        "description": "Information about a supervised worker.\n\nProvides detailed status and restart metrics for a single worker\nmanaged by the WorkerSupervisor.",
        "example": {
          "last_started_at": "2026-01-13T10:30:00Z",
          "max_restarts": 5,
          "name": "detection_worker",
          "restart_count": 0,
          "status": "running"
        },
        "properties": {
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Last error message if worker crashed",
            "title": "Error"
          },
          "last_crashed_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the worker last crashed",
            "title": "Last Crashed At"
          },
          "last_started_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the worker was last started",
            "title": "Last Started At"
          },
          "max_restarts": {
            "description": "Maximum allowed restart attempts before failing",
            "minimum": 0.0,
            "title": "Max Restarts",
            "type": "integer"
          },
          "name": {
            "description": "Unique identifier for the worker",
            "title": "Name",
            "type": "string"
          },
          "restart_count": {
            "description": "Number of times the worker has been restarted",
            "minimum": 0.0,
            "title": "Restart Count",
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/SupervisedWorkerStatusEnum",
            "description": "Current health status of the worker"
          }
        },
        "required": [
          "name",
          "status",
          "restart_count",
          "max_restarts"
        ],
        "title": "SupervisedWorkerInfo",
        "type": "object"
      },
      "SupervisedWorkerStatusEnum": {
        "description": "Status enum for supervised workers.",
        "enum": [
          "running",
          "stopped",
          "crashed",
          "restarting",
          "failed"
        ],
        "title": "SupervisedWorkerStatusEnum",
        "type": "string"
      },
      "SuspiciousActionsResponse": {
        "description": "Schema for suspicious actions summary response.",
        "example": {
          "items": [
            {
              "action": "climbing",
              "all_scores": {
                "climbing": 0.92,
                "walking normally": 0.05
              },
              "camera_id": "back_yard",
              "confidence": 0.92,
              "created_at": "2026-01-26T14:30:00Z",
              "frame_count": 8,
              "id": 5,
              "is_suspicious": true,
              "timestamp": "2026-01-26T14:30:00Z",
              "track_id": 17
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          },
          "suspicious_count": 1,
          "total_count": 25
        },
        "properties": {
          "items": {
            "description": "List of suspicious action events",
            "items": {
              "$ref": "#/components/schemas/ActionEventResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          },
          "suspicious_count": {
            "description": "Total count of suspicious actions",
            "title": "Suspicious Count",
            "type": "integer"
          },
          "total_count": {
            "description": "Total count of all action events",
            "title": "Total Count",
            "type": "integer"
          }
        },
        "required": [
          "items",
          "pagination",
          "suspicious_count",
          "total_count"
        ],
        "title": "SuspiciousActionsResponse",
        "type": "object"
      },
      "SystemSettingListResponse": {
        "description": "Response schema for listing all system settings.",
        "example": {
          "items": [
            {
              "key": "default_gpu_strategy",
              "updated_at": "2026-01-25T12:00:00Z",
              "value": {
                "strategy": "vram_based"
              }
            },
            {
              "key": "notification_defaults",
              "updated_at": "2026-01-25T11:00:00Z",
              "value": {
                "email": true,
                "push": false
              }
            }
          ],
          "total": 2
        },
        "properties": {
          "items": {
            "description": "List of system settings",
            "items": {
              "$ref": "#/components/schemas/SystemSettingResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "total": {
            "description": "Total number of settings",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "items",
          "total"
        ],
        "title": "SystemSettingListResponse",
        "type": "object"
      },
      "SystemSettingResponse": {
        "description": "Response schema for a system setting.\n\nRepresents a single key-value pair from the SystemSetting table.",
        "example": {
          "key": "default_gpu_strategy",
          "updated_at": "2026-01-25T12:00:00Z",
          "value": {
            "fallback": "balanced",
            "strategy": "vram_based"
          }
        },
        "properties": {
          "key": {
            "description": "Setting key (primary key)",
            "maxLength": 64,
            "title": "Key",
            "type": "string"
          },
          "updated_at": {
            "description": "Last update timestamp",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "value": {
            "additionalProperties": true,
            "description": "Setting value as JSON object",
            "title": "Value",
            "type": "object"
          }
        },
        "required": [
          "key",
          "value",
          "updated_at"
        ],
        "title": "SystemSettingResponse",
        "type": "object"
      },
      "SystemSettingUpdate": {
        "description": "Request schema for updating a system setting.\n\nThe value is a flexible JSON object that can store any configuration.",
        "example": {
          "value": {
            "fallback": "balanced",
            "strategy": "vram_based"
          }
        },
        "properties": {
          "value": {
            "additionalProperties": true,
            "description": "New value for the setting (JSON object). Replaces the existing value entirely (not merged).",
            "title": "Value",
            "type": "object"
          }
        },
        "required": [
          "value"
        ],
        "title": "SystemSettingUpdate",
        "type": "object"
      },
      "SystemStatsResponse": {
        "description": "Response schema for system statistics endpoint.",
        "example": {
          "total_cameras": 4,
          "total_detections": 892,
          "total_events": 156,
          "uptime_seconds": 86400.5
        },
        "properties": {
          "total_cameras": {
            "description": "Total number of cameras in the system",
            "minimum": 0.0,
            "title": "Total Cameras",
            "type": "integer"
          },
          "total_detections": {
            "description": "Total number of detections recorded",
            "minimum": 0.0,
            "title": "Total Detections",
            "type": "integer"
          },
          "total_events": {
            "description": "Total number of events recorded",
            "minimum": 0.0,
            "title": "Total Events",
            "type": "integer"
          },
          "uptime_seconds": {
            "description": "Application uptime in seconds",
            "minimum": 0.0,
            "title": "Uptime Seconds",
            "type": "number"
          }
        },
        "required": [
          "total_cameras",
          "total_events",
          "total_detections",
          "uptime_seconds"
        ],
        "title": "SystemStatsResponse",
        "type": "object"
      },
      "TargetHealth": {
        "description": "Health status for a single Prometheus scrape target.",
        "example": {
          "health": "up",
          "instance": "backend:8000",
          "job": "hsi-backend-metrics",
          "labels": {
            "service": "home-security-intelligence"
          },
          "last_scrape": "2026-01-13T10:30:00Z",
          "scrape_duration_seconds": 0.025
        },
        "properties": {
          "health": {
            "description": "Target health: 'up' or 'down'",
            "title": "Health",
            "type": "string"
          },
          "instance": {
            "description": "Target instance identifier (typically host:port)",
            "title": "Instance",
            "type": "string"
          },
          "job": {
            "description": "Job name this target belongs to",
            "title": "Job",
            "type": "string"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels associated with this target",
            "title": "Labels",
            "type": "object"
          },
          "last_error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error from last failed scrape (if any)",
            "title": "Last Error"
          },
          "last_scrape": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Timestamp of last scrape attempt",
            "title": "Last Scrape"
          },
          "scrape_duration_seconds": {
            "anyOf": [
              {
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Duration of last scrape in seconds",
            "title": "Scrape Duration Seconds"
          }
        },
        "required": [
          "job",
          "instance",
          "health"
        ],
        "title": "TargetHealth",
        "type": "object"
      },
      "TelemetryResponse": {
        "description": "Response schema for pipeline telemetry endpoint.\n\nProvides real-time visibility into:\n- Queue depths: How many items are waiting in detection/analysis queues\n- Stage latencies: How long each pipeline stage is taking\n\nThis helps operators:\n- Identify pipeline bottlenecks\n- Detect backlog situations\n- Monitor processing performance\n- Debug pipeline stalls",
        "example": {
          "latencies": {
            "detect": {
              "avg_ms": 200.0,
              "max_ms": 800.0,
              "min_ms": 100.0,
              "p50_ms": 180.0,
              "p95_ms": 600.0,
              "p99_ms": 750.0,
              "sample_count": 500
            },
            "watch": {
              "avg_ms": 10.0,
              "max_ms": 50.0,
              "min_ms": 5.0,
              "p50_ms": 8.0,
              "p95_ms": 40.0,
              "p99_ms": 48.0,
              "sample_count": 500
            }
          },
          "queues": {
            "analysis_queue": 2,
            "detection_queue": 5
          },
          "timestamp": "2025-12-27T10:30:00Z"
        },
        "properties": {
          "latencies": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipelineLatencies"
              },
              {
                "type": "null"
              }
            ],
            "description": "Latency statistics for each pipeline stage"
          },
          "queues": {
            "$ref": "#/components/schemas/QueueDepths",
            "description": "Current queue depths for detection and analysis queues"
          },
          "timestamp": {
            "description": "Timestamp of telemetry snapshot",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "queues",
          "timestamp"
        ],
        "title": "TelemetryResponse",
        "type": "object"
      },
      "TestNotificationResponse": {
        "description": "Schema for test notification result.",
        "example": {
          "channel": "email",
          "message": "Test email sent successfully to test@example.com",
          "success": true
        },
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "Channel that was tested"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if test failed",
            "title": "Error"
          },
          "message": {
            "description": "Human-readable result message",
            "title": "Message",
            "type": "string"
          },
          "success": {
            "description": "Whether the test was successful",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "channel",
          "success",
          "message"
        ],
        "title": "TestNotificationResponse",
        "type": "object"
      },
      "ThroughputMetrics": {
        "description": "Throughput metrics for a queue.",
        "example": {
          "avg_processing_seconds": 4.8,
          "jobs_per_minute": 12.5
        },
        "properties": {
          "avg_processing_seconds": {
            "description": "Average time to process a job in seconds",
            "minimum": 0.0,
            "title": "Avg Processing Seconds",
            "type": "number"
          },
          "jobs_per_minute": {
            "description": "Average number of jobs processed per minute",
            "minimum": 0.0,
            "title": "Jobs Per Minute",
            "type": "number"
          }
        },
        "required": [
          "jobs_per_minute",
          "avg_processing_seconds"
        ],
        "title": "ThroughputMetrics",
        "type": "object"
      },
      "TimeRange": {
        "description": "Time range options for historical data.",
        "enum": [
          "5m",
          "15m",
          "60m"
        ],
        "title": "TimeRange",
        "type": "string"
      },
      "TimelineBucketResponse": {
        "description": "Schema for a single time bucket in the timeline summary (NEM-2932).\n\nEach bucket represents a time period with aggregated event data.",
        "example": {
          "event_count": 15,
          "max_risk_score": 85,
          "timestamp": "2026-01-15T12:00:00Z"
        },
        "properties": {
          "event_count": {
            "description": "Number of events in this bucket",
            "minimum": 0.0,
            "title": "Event Count",
            "type": "integer"
          },
          "max_risk_score": {
            "default": 0,
            "description": "Maximum risk score of events in this bucket",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Max Risk Score",
            "type": "integer"
          },
          "timestamp": {
            "description": "Start timestamp of this bucket",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp",
          "event_count"
        ],
        "title": "TimelineBucketResponse",
        "type": "object"
      },
      "TimelineSummaryResponse": {
        "description": "Schema for timeline summary response (NEM-2932).\n\nReturns bucketed event data for timeline visualization.\nSupports different zoom levels with varying bucket sizes.",
        "example": {
          "buckets": [
            {
              "event_count": 5,
              "max_risk_score": 45,
              "timestamp": "2026-01-15T06:00:00Z"
            },
            {
              "event_count": 12,
              "max_risk_score": 85,
              "timestamp": "2026-01-15T07:00:00Z"
            },
            {
              "event_count": 3,
              "max_risk_score": 25,
              "timestamp": "2026-01-15T08:00:00Z"
            }
          ],
          "end_date": "2026-01-15T09:00:00Z",
          "start_date": "2026-01-15T06:00:00Z",
          "total_events": 20
        },
        "properties": {
          "buckets": {
            "description": "List of time buckets with aggregated event data",
            "items": {
              "$ref": "#/components/schemas/TimelineBucketResponse"
            },
            "title": "Buckets",
            "type": "array"
          },
          "end_date": {
            "description": "End of the timeline range",
            "format": "date-time",
            "title": "End Date",
            "type": "string"
          },
          "start_date": {
            "description": "Start of the timeline range",
            "format": "date-time",
            "title": "Start Date",
            "type": "string"
          },
          "total_events": {
            "description": "Total events in the time range",
            "minimum": 0.0,
            "title": "Total Events",
            "type": "integer"
          }
        },
        "required": [
          "buckets",
          "total_events",
          "start_date",
          "end_date"
        ],
        "title": "TimelineSummaryResponse",
        "type": "object"
      },
      "TraceMallocStats": {
        "description": "Tracemalloc statistics if enabled.",
        "properties": {
          "current_bytes": {
            "default": 0,
            "description": "Current traced memory in bytes",
            "title": "Current Bytes",
            "type": "integer"
          },
          "enabled": {
            "description": "Whether tracemalloc is enabled",
            "title": "Enabled",
            "type": "boolean"
          },
          "peak_bytes": {
            "default": 0,
            "description": "Peak traced memory in bytes",
            "title": "Peak Bytes",
            "type": "integer"
          },
          "top_allocations": {
            "description": "Top memory allocations by size",
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "title": "Top Allocations",
            "type": "array"
          }
        },
        "required": [
          "enabled"
        ],
        "title": "TraceMallocStats",
        "type": "object"
      },
      "TrackHistoryResponse": {
        "description": "Response with full track history including trajectory.\n\nIncludes complete trajectory data for visualization and analysis.\nUse for track detail views and trajectory plotting.",
        "example": {
          "camera_id": "front_door",
          "first_seen": "2026-01-26T12:00:00Z",
          "id": 1,
          "last_seen": "2026-01-26T12:00:27Z",
          "metrics": {
            "avg_speed": 45.2,
            "direction": 135.0,
            "duration_seconds": 27.7,
            "total_distance": 1250.5
          },
          "object_class": "person",
          "track_id": 42,
          "trajectory": [
            {
              "timestamp": "2026-01-26T12:00:00Z",
              "x": 100.0,
              "y": 200.0
            },
            {
              "timestamp": "2026-01-26T12:00:05Z",
              "x": 150.5,
              "y": 220.3
            },
            {
              "timestamp": "2026-01-26T12:00:10Z",
              "x": 210.2,
              "y": 245.8
            },
            {
              "timestamp": "2026-01-26T12:00:15Z",
              "x": 280.0,
              "y": 270.0
            },
            {
              "timestamp": "2026-01-26T12:00:20Z",
              "x": 350.5,
              "y": 300.2
            },
            {
              "timestamp": "2026-01-26T12:00:27Z",
              "x": 420.0,
              "y": 330.5
            }
          ]
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID where track was observed",
            "title": "Camera Id",
            "type": "string"
          },
          "first_seen": {
            "description": "Timestamp of first observation",
            "format": "date-time",
            "title": "First Seen",
            "type": "string"
          },
          "id": {
            "description": "Database track ID",
            "title": "Id",
            "type": "integer"
          },
          "last_seen": {
            "description": "Timestamp of last observation",
            "format": "date-time",
            "title": "Last Seen",
            "type": "string"
          },
          "metrics": {
            "$ref": "#/components/schemas/MovementMetrics",
            "description": "Computed movement metrics"
          },
          "object_class": {
            "description": "Detected object class (person, car, etc.)",
            "title": "Object Class",
            "type": "string"
          },
          "track_id": {
            "description": "Tracker-assigned ID (unique per camera session)",
            "title": "Track Id",
            "type": "integer"
          },
          "trajectory": {
            "description": "Ordered list of trajectory points",
            "items": {
              "$ref": "#/components/schemas/TrajectoryPoint"
            },
            "title": "Trajectory",
            "type": "array"
          }
        },
        "required": [
          "id",
          "track_id",
          "camera_id",
          "object_class",
          "first_seen",
          "last_seen",
          "trajectory",
          "metrics"
        ],
        "title": "TrackHistoryResponse",
        "type": "object"
      },
      "TrackListResponse": {
        "description": "Paginated list of tracks.\n\nStandard pagination envelope for track list endpoints.",
        "example": {
          "page": 1,
          "page_size": 50,
          "total": 2,
          "tracks": [
            {
              "camera_id": "front_door",
              "first_seen": "2026-01-26T12:00:00Z",
              "id": 1,
              "last_seen": "2026-01-26T12:00:27Z",
              "metrics": {
                "avg_speed": 45.2,
                "direction": 135.0,
                "duration_seconds": 27.7,
                "total_distance": 1250.5
              },
              "object_class": "person",
              "track_id": 42
            },
            {
              "camera_id": "front_door",
              "first_seen": "2026-01-26T12:01:00Z",
              "id": 2,
              "last_seen": "2026-01-26T12:01:15Z",
              "metrics": {
                "avg_speed": 140.0,
                "direction": 270.0,
                "duration_seconds": 15.0,
                "total_distance": 2100.0
              },
              "object_class": "car",
              "track_id": 43
            }
          ]
        },
        "properties": {
          "page": {
            "description": "Current page number (1-indexed)",
            "minimum": 1.0,
            "title": "Page",
            "type": "integer"
          },
          "page_size": {
            "description": "Number of items per page",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Page Size",
            "type": "integer"
          },
          "total": {
            "description": "Total number of tracks matching the query",
            "minimum": 0.0,
            "title": "Total",
            "type": "integer"
          },
          "tracks": {
            "description": "List of tracks",
            "items": {
              "$ref": "#/components/schemas/TrackResponse"
            },
            "title": "Tracks",
            "type": "array"
          }
        },
        "required": [
          "tracks",
          "total",
          "page",
          "page_size"
        ],
        "title": "TrackListResponse",
        "type": "object"
      },
      "TrackResponse": {
        "description": "Response for a single track.\n\nBasic track information without full trajectory data.\nUse TrackHistoryResponse for full trajectory details.",
        "example": {
          "camera_id": "front_door",
          "first_seen": "2026-01-26T12:00:00Z",
          "id": 1,
          "last_seen": "2026-01-26T12:00:27Z",
          "metrics": {
            "avg_speed": 45.2,
            "direction": 135.0,
            "duration_seconds": 27.7,
            "total_distance": 1250.5
          },
          "object_class": "person",
          "track_id": 42
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID where track was observed",
            "title": "Camera Id",
            "type": "string"
          },
          "first_seen": {
            "description": "Timestamp of first observation",
            "format": "date-time",
            "title": "First Seen",
            "type": "string"
          },
          "id": {
            "description": "Database track ID",
            "title": "Id",
            "type": "integer"
          },
          "last_seen": {
            "description": "Timestamp of last observation",
            "format": "date-time",
            "title": "Last Seen",
            "type": "string"
          },
          "metrics": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MovementMetrics"
              },
              {
                "type": "null"
              }
            ],
            "description": "Computed movement metrics (may be null for short tracks)"
          },
          "object_class": {
            "description": "Detected object class (person, car, etc.)",
            "title": "Object Class",
            "type": "string"
          },
          "track_id": {
            "description": "Tracker-assigned ID (unique per camera session)",
            "title": "Track Id",
            "type": "integer"
          }
        },
        "required": [
          "id",
          "track_id",
          "camera_id",
          "object_class",
          "first_seen",
          "last_seen"
        ],
        "title": "TrackResponse",
        "type": "object"
      },
      "TrajectoryPoint": {
        "description": "Single point in a track trajectory.\n\nRepresents a discrete position observation of a tracked object\nat a specific point in time.",
        "example": {
          "timestamp": "2026-01-26T12:00:00Z",
          "x": 640.5,
          "y": 480.2
        },
        "properties": {
          "timestamp": {
            "description": "Time of this position",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "x": {
            "description": "X coordinate (pixels)",
            "title": "X",
            "type": "number"
          },
          "y": {
            "description": "Y coordinate (pixels)",
            "title": "Y",
            "type": "number"
          }
        },
        "required": [
          "x",
          "y",
          "timestamp"
        ],
        "title": "TrajectoryPoint",
        "type": "object"
      },
      "TrustCheckResponse": {
        "description": "Schema for trust check response.\n\nIndicates the trust level an entity has in a specific zone.",
        "example": {
          "entity_id": 1,
          "entity_type": "member",
          "reason": "Entity is the zone owner",
          "trust_level": "full",
          "zone_id": "550e8400-e29b-41d4-a716-446655440000"
        },
        "properties": {
          "entity_id": {
            "description": "ID of the entity being checked",
            "title": "Entity Id",
            "type": "integer"
          },
          "entity_type": {
            "description": "Type of entity ('member' or 'vehicle')",
            "title": "Entity Type",
            "type": "string"
          },
          "reason": {
            "description": "Human-readable explanation of the trust level",
            "title": "Reason",
            "type": "string"
          },
          "trust_level": {
            "$ref": "#/components/schemas/TrustLevelResult",
            "description": "Trust level result (full, partial, monitor, none)"
          },
          "zone_id": {
            "description": "ID of the zone",
            "title": "Zone Id",
            "type": "string"
          }
        },
        "required": [
          "zone_id",
          "entity_id",
          "entity_type",
          "trust_level",
          "reason"
        ],
        "title": "TrustCheckResponse",
        "type": "object"
      },
      "TrustLevel": {
        "description": "Trust level for household members determining alert behavior.\n\n- FULL: Never trigger alerts for this person\n- PARTIAL: Reduced alert severity, still monitored\n- MONITOR: Log activity but don't suppress alerts",
        "enum": [
          "full",
          "partial",
          "monitor"
        ],
        "title": "TrustLevel",
        "type": "string"
      },
      "TrustLevelResult": {
        "description": "Trust level result from zone access check.\n\nThese values indicate the level of trust an entity has in a specific zone:\n- FULL: Entity is the zone owner - full trust, never alert\n- PARTIAL: Entity is allowed member/vehicle - reduced alert severity\n- MONITOR: Entity is scheduled for access at current time - log only\n- NONE: Entity has no special trust in this zone",
        "enum": [
          "full",
          "partial",
          "monitor",
          "none"
        ],
        "title": "TrustLevelResult",
        "type": "string"
      },
      "TrustStatus": {
        "description": "Trust classification status for entities.\n\nEntities can be classified as trusted (known/safe), untrusted (unknown/suspicious),\nor unclassified (no classification assigned yet).",
        "enum": [
          "trusted",
          "untrusted",
          "unclassified"
        ],
        "title": "TrustStatus",
        "type": "string"
      },
      "TrustedEntityListResponse": {
        "description": "Schema for paginated list of trusted or untrusted entities.\n\nResponse from GET /api/entities/trusted and GET /api/entities/untrusted endpoints.",
        "example": {
          "items": [
            {
              "appearance_count": 5,
              "entity_type": "person",
              "first_seen": "2025-12-23T10:00:00Z",
              "id": "550e8400-e29b-41d4-a716-446655440000",
              "last_seen": "2025-12-23T14:30:00Z",
              "thumbnail_url": "/api/detections/123/image",
              "trust_notes": "Mail carrier",
              "trust_status": "trusted",
              "trust_updated_at": "2025-12-23T14:30:00Z"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of entities with their trust status",
            "items": {
              "$ref": "#/components/schemas/EntityTrustResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "TrustedEntityListResponse",
        "type": "object"
      },
      "UnknownStrangerAlert": {
        "description": "Schema for unknown stranger alert.",
        "example": {
          "age_estimate": 35,
          "bbox": [
            100,
            150,
            200,
            300
          ],
          "camera_id": "front_door",
          "event_id": 1,
          "gender_estimate": "M",
          "quality_score": 0.85,
          "thumbnail_path": "/data/thumbnails/stranger_1.jpg",
          "timestamp": "2025-01-01T10:00:00Z"
        },
        "properties": {
          "age_estimate": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimated age",
            "title": "Age Estimate"
          },
          "bbox": {
            "description": "Bounding box coordinates",
            "items": {
              "type": "number"
            },
            "title": "Bbox",
            "type": "array"
          },
          "camera_id": {
            "description": "ID of the camera",
            "title": "Camera Id",
            "type": "string"
          },
          "event_id": {
            "description": "ID of the face detection event",
            "title": "Event Id",
            "type": "integer"
          },
          "gender_estimate": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Estimated gender",
            "title": "Gender Estimate"
          },
          "quality_score": {
            "description": "Face quality score",
            "title": "Quality Score",
            "type": "number"
          },
          "thumbnail_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to face thumbnail",
            "title": "Thumbnail Path"
          },
          "timestamp": {
            "description": "When the stranger was detected",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "event_id",
          "camera_id",
          "timestamp",
          "bbox",
          "quality_score"
        ],
        "title": "UnknownStrangerAlert",
        "type": "object"
      },
      "UnknownStrangerListResponse": {
        "description": "Schema for list of unknown stranger alerts.",
        "example": {
          "items": [
            {
              "age_estimate": 35,
              "bbox": [
                100,
                150,
                200,
                300
              ],
              "camera_id": "front_door",
              "event_id": 1,
              "gender_estimate": "M",
              "quality_score": 0.85,
              "timestamp": "2025-01-01T10:00:00Z"
            }
          ],
          "total": 1
        },
        "properties": {
          "items": {
            "description": "List of unknown strangers",
            "items": {
              "$ref": "#/components/schemas/UnknownStrangerAlert"
            },
            "title": "Items",
            "type": "array"
          },
          "total": {
            "description": "Total number of unknown strangers",
            "title": "Total",
            "type": "integer"
          }
        },
        "required": [
          "items",
          "total"
        ],
        "title": "UnknownStrangerListResponse",
        "type": "object"
      },
      "UserCalibrationResponse": {
        "description": "Schema for user calibration response.\n\nReturned when retrieving or modifying calibration settings.\nIncludes feedback counts to show calibration history.",
        "example": {
          "created_at": "2025-01-01T12:00:00Z",
          "decay_factor": 0.1,
          "false_positive_count": 5,
          "high_threshold": 85,
          "id": 1,
          "low_threshold": 30,
          "medium_threshold": 60,
          "missed_threat_count": 3,
          "updated_at": "2025-01-01T12:00:00Z",
          "user_id": "default"
        },
        "properties": {
          "created_at": {
            "description": "When calibration was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "decay_factor": {
            "description": "Learning rate for threshold adjustment (0.0-1.0)",
            "title": "Decay Factor",
            "type": "number"
          },
          "false_positive_count": {
            "description": "Number of false positive feedbacks received",
            "title": "False Positive Count",
            "type": "integer"
          },
          "high_threshold": {
            "description": "Score threshold for high risk (0-100)",
            "title": "High Threshold",
            "type": "integer"
          },
          "id": {
            "description": "Calibration record ID",
            "title": "Id",
            "type": "integer"
          },
          "low_threshold": {
            "description": "Score threshold for low risk (0-100)",
            "title": "Low Threshold",
            "type": "integer"
          },
          "medium_threshold": {
            "description": "Score threshold for medium risk (0-100)",
            "title": "Medium Threshold",
            "type": "integer"
          },
          "missed_threat_count": {
            "description": "Number of missed threat feedbacks received",
            "title": "Missed Threat Count",
            "type": "integer"
          },
          "updated_at": {
            "description": "When calibration was last modified",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "user_id": {
            "description": "User identifier",
            "title": "User Id",
            "type": "string"
          }
        },
        "required": [
          "id",
          "user_id",
          "low_threshold",
          "medium_threshold",
          "high_threshold",
          "decay_factor",
          "false_positive_count",
          "missed_threat_count",
          "created_at",
          "updated_at"
        ],
        "title": "UserCalibrationResponse",
        "type": "object"
      },
      "UserCalibrationUpdate": {
        "description": "Schema for updating user calibration settings.\n\nAll fields are optional - only provided fields will be updated.\nWhen all three thresholds are provided, ordering is validated\n(low < medium < high).",
        "example": {
          "decay_factor": 0.15,
          "high_threshold": 80,
          "low_threshold": 25,
          "medium_threshold": 55
        },
        "properties": {
          "decay_factor": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Learning rate for threshold adjustment (0.0-1.0)",
            "title": "Decay Factor"
          },
          "high_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Score threshold for high risk classification (0-100)",
            "title": "High Threshold"
          },
          "low_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Score threshold for low risk classification (0-100)",
            "title": "Low Threshold"
          },
          "medium_threshold": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Score threshold for medium risk classification (0-100)",
            "title": "Medium Threshold"
          }
        },
        "title": "UserCalibrationUpdate",
        "type": "object"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "title": "Location",
            "type": "array"
          },
          "msg": {
            "title": "Message",
            "type": "string"
          },
          "type": {
            "title": "Error Type",
            "type": "string"
          }
        },
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError",
        "type": "object"
      },
      "VehicleEnrichment": {
        "description": "Vehicle classification results.",
        "example": {
          "color": "silver",
          "confidence": 0.91,
          "is_commercial": false,
          "type": "sedan"
        },
        "properties": {
          "color": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Vehicle color (if detected)",
            "title": "Color"
          },
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Classification confidence",
            "title": "Confidence"
          },
          "damage_detected": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether vehicle damage was detected",
            "title": "Damage Detected"
          },
          "damage_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Types of damage detected",
            "title": "Damage Types"
          },
          "is_commercial": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether vehicle is commercial/delivery",
            "title": "Is Commercial"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          },
          "type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Vehicle type (sedan, suv, truck, etc.)",
            "title": "Type"
          }
        },
        "title": "VehicleEnrichment",
        "type": "object"
      },
      "VehicleType": {
        "description": "Type of vehicle for categorization.",
        "enum": [
          "car",
          "truck",
          "motorcycle",
          "suv",
          "van",
          "other"
        ],
        "title": "VehicleType",
        "type": "string"
      },
      "ViolenceEnrichment": {
        "description": "Violence detection results.",
        "example": {
          "confidence": 0.88,
          "detected": false,
          "score": 0.12
        },
        "properties": {
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model confidence",
            "title": "Confidence"
          },
          "detected": {
            "default": false,
            "description": "Whether violence was detected",
            "title": "Detected",
            "type": "boolean"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          },
          "score": {
            "default": 0.0,
            "description": "Violence probability score",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Score",
            "type": "number"
          }
        },
        "title": "ViolenceEnrichment",
        "type": "object"
      },
      "WeatherEnrichment": {
        "description": "Weather classification results.",
        "example": {
          "condition": "clear",
          "confidence": 0.95
        },
        "properties": {
          "condition": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Weather condition (clear, rain, fog, etc.)",
            "title": "Condition"
          },
          "confidence": {
            "anyOf": [
              {
                "maximum": 1.0,
                "minimum": 0.0,
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Classification confidence",
            "title": "Confidence"
          },
          "model_info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EnrichmentModelInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model that produced this result"
          }
        },
        "title": "WeatherEnrichment",
        "type": "object"
      },
      "WebSocketBroadcasterStatus": {
        "description": "Status of a WebSocket broadcaster's circuit breaker.",
        "properties": {
          "failure_count": {
            "description": "Current consecutive failure count",
            "minimum": 0.0,
            "title": "Failure Count",
            "type": "integer"
          },
          "is_degraded": {
            "description": "Whether the broadcaster is in degraded mode",
            "title": "Is Degraded",
            "type": "boolean"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional status message or error details",
            "title": "Message"
          },
          "state": {
            "$ref": "#/components/schemas/CircuitBreakerStateEnum",
            "description": "Current circuit state: closed (normal), open (failing), half_open (testing), unavailable (not initialized)"
          }
        },
        "required": [
          "state",
          "failure_count",
          "is_degraded"
        ],
        "title": "WebSocketBroadcasterStatus",
        "type": "object"
      },
      "WebSocketConnectionsResponse": {
        "description": "Response for WebSocket connection states.",
        "properties": {
          "event_broadcaster": {
            "$ref": "#/components/schemas/DebugWebSocketBroadcasterStatus",
            "description": "Event broadcaster status"
          },
          "system_broadcaster": {
            "$ref": "#/components/schemas/DebugWebSocketBroadcasterStatus",
            "description": "System broadcaster status"
          },
          "timestamp": {
            "description": "ISO timestamp of response",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "event_broadcaster",
          "system_broadcaster",
          "timestamp"
        ],
        "title": "WebSocketConnectionsResponse",
        "type": "object"
      },
      "WebSocketHealthResponse": {
        "description": "Response schema for WebSocket health endpoint.",
        "example": {
          "event_broadcaster": {
            "failure_count": 0,
            "is_degraded": false,
            "state": "closed"
          },
          "system_broadcaster": {
            "failure_count": 0,
            "is_degraded": false,
            "state": "closed"
          },
          "timestamp": "2025-12-30T10:30:00Z"
        },
        "properties": {
          "event_broadcaster": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebSocketBroadcasterStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status of the event broadcaster circuit breaker"
          },
          "system_broadcaster": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebSocketBroadcasterStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status of the system broadcaster circuit breaker"
          },
          "timestamp": {
            "description": "Timestamp of health check",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          }
        },
        "required": [
          "timestamp"
        ],
        "title": "WebSocketHealthResponse",
        "type": "object"
      },
      "WebVitalMetric": {
        "description": "A single Core Web Vital metric measurement from the frontend.\n\nThis schema matches the structure returned by the web-vitals library's\nonLCP, onFID, onINP, onCLS, onTTFB, and onFCP functions.\n\nAttributes:\n    name: The Core Web Vital metric name (LCP, FID, INP, CLS, TTFB, FCP)\n    value: The metric value (milliseconds for most, dimensionless for CLS)\n    rating: Performance rating based on thresholds (good, needs-improvement, poor)\n    delta: The delta since the last report (for CLS this accumulates)\n    id: Unique identifier for this metric instance\n    navigationType: The type of navigation (navigate, reload, back_forward, prerender)\n    path: The page path where the metric was measured",
        "example": {
          "delta": 2500.0,
          "id": "v1-1234567890123-1234567890123",
          "name": "LCP",
          "navigationType": "navigate",
          "path": "/dashboard",
          "rating": "good",
          "value": 2500.0
        },
        "properties": {
          "delta": {
            "description": "Delta since last report",
            "title": "Delta",
            "type": "number"
          },
          "id": {
            "description": "Unique metric identifier from web-vitals",
            "title": "Id",
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/WebVitalName",
            "description": "Core Web Vital metric name"
          },
          "navigationType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Navigation type (navigate, reload, back_forward, prerender)",
            "title": "Navigationtype"
          },
          "path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Page path where metric was measured",
            "title": "Path"
          },
          "rating": {
            "description": "Performance rating",
            "enum": [
              "good",
              "needs-improvement",
              "poor"
            ],
            "title": "Rating",
            "type": "string"
          },
          "value": {
            "description": "Metric value (ms for most, dimensionless for CLS)",
            "title": "Value",
            "type": "number"
          }
        },
        "required": [
          "name",
          "value",
          "rating",
          "delta",
          "id"
        ],
        "title": "WebVitalMetric",
        "type": "object"
      },
      "WebVitalName": {
        "description": "Supported Core Web Vitals metric names.\n\nThese correspond to the metrics collected by the web-vitals library,\nplus custom metrics like PAGE_LOAD_TIME from Navigation Timing API.",
        "enum": [
          "LCP",
          "FID",
          "INP",
          "CLS",
          "TTFB",
          "FCP",
          "PAGE_LOAD_TIME"
        ],
        "title": "WebVitalName",
        "type": "string"
      },
      "WebhookAlert": {
        "description": "Schema for a single alert in webhook payload.\n\nRepresents one alert instance with its labels, annotations, and timing.\nThis is the legacy webhook schema - prefer AlertmanagerAlert from alertmanager.py.",
        "example": {
          "annotations": {
            "description": "GPU memory usage is above 90% for 5 minutes",
            "summary": "GPU memory usage is high"
          },
          "endsAt": "0001-01-01T00:00:00Z",
          "fingerprint": "abc123def456",
          "generatorURL": "http://prometheus:9090/graph?...",
          "labels": {
            "alertname": "HSIGPUMemoryHigh",
            "component": "gpu",
            "severity": "warning"
          },
          "startsAt": "2026-01-17T12:22:56.068Z",
          "status": "firing"
        },
        "properties": {
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Alert annotations (summary, description)",
            "title": "Annotations",
            "type": "object"
          },
          "endsAt": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the alert was resolved",
            "title": "Endsat"
          },
          "fingerprint": {
            "description": "Unique identifier for deduplication",
            "title": "Fingerprint",
            "type": "string"
          },
          "generatorURL": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to the Prometheus graph",
            "title": "Generatorurl"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Alert labels (alertname, severity, etc.)",
            "title": "Labels",
            "type": "object"
          },
          "startsAt": {
            "description": "When the alert started firing",
            "format": "date-time",
            "title": "Startsat",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/AlertmanagerStatus",
            "description": "Alert status (firing or resolved)"
          }
        },
        "required": [
          "status",
          "startsAt",
          "fingerprint"
        ],
        "title": "WebhookAlert",
        "type": "object"
      },
      "WebhookAuthConfig": {
        "description": "Authentication configuration for webhook requests.\n\nSupports multiple authentication types:\n- none: No authentication\n- bearer: Bearer token authentication\n- basic: Basic authentication with username/password\n- header: Custom header authentication\n\nAttributes:\n    type: Authentication type (none, bearer, basic, header).\n    token: Bearer token for bearer auth.\n    username: Username for basic auth.\n    password: Password for basic auth.\n    header_name: Custom header name for header auth.\n    header_value: Custom header value for header auth.",
        "properties": {
          "header_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Custom header name (if type=header)",
            "title": "Header Name"
          },
          "header_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Custom header value (if type=header)",
            "title": "Header Value"
          },
          "password": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Password (if type=basic)",
            "title": "Password"
          },
          "token": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Bearer token (if type=bearer)",
            "title": "Token"
          },
          "type": {
            "default": "none",
            "description": "Auth type: none, bearer, basic, header",
            "title": "Type",
            "type": "string"
          },
          "username": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Username (if type=basic)",
            "title": "Username"
          }
        },
        "title": "WebhookAuthConfig",
        "type": "object"
      },
      "WebhookCreate": {
        "description": "Schema for creating a new outbound webhook.\n\nCreate a new webhook configuration for sending notifications to external\nsystems when specified events occur.\n\nAttributes:\n    name: Human-readable name for the webhook.\n    url: Webhook endpoint URL.\n    event_types: List of events that trigger this webhook.\n    integration_type: Type of integration (generic, slack, discord, etc.).\n    enabled: Whether the webhook is active.\n    auth: Optional authentication configuration.\n    custom_headers: Additional HTTP headers to send.\n    payload_template: Optional Jinja2 template for custom payload.\n    max_retries: Maximum number of retry attempts on failure.\n    retry_delay_seconds: Initial delay between retries.",
        "example": {
          "auth": {
            "type": "none"
          },
          "custom_headers": {},
          "enabled": true,
          "event_types": [
            "alert_fired",
            "alert_dismissed"
          ],
          "integration_type": "slack",
          "name": "Slack Alerts",
          "url": "https://hooks.slack.com/services/xxx/yyy/zzz"
        },
        "properties": {
          "auth": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebhookAuthConfig"
              },
              {
                "type": "null"
              }
            ],
            "description": "Authentication config"
          },
          "custom_headers": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom HTTP headers",
            "title": "Custom Headers",
            "type": "object"
          },
          "enabled": {
            "default": true,
            "description": "Whether webhook is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "event_types": {
            "description": "Events to subscribe to",
            "items": {
              "$ref": "#/components/schemas/WebhookEventType"
            },
            "minItems": 1,
            "title": "Event Types",
            "type": "array"
          },
          "integration_type": {
            "$ref": "#/components/schemas/IntegrationType",
            "default": "generic",
            "description": "Integration type"
          },
          "max_retries": {
            "default": 4,
            "description": "Max retry attempts",
            "maximum": 10.0,
            "minimum": 0.0,
            "title": "Max Retries",
            "type": "integer"
          },
          "name": {
            "description": "Webhook name",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "payload_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Custom payload template (Jinja2)",
            "title": "Payload Template"
          },
          "retry_delay_seconds": {
            "default": 10,
            "description": "Initial retry delay",
            "maximum": 3600.0,
            "minimum": 1.0,
            "title": "Retry Delay Seconds",
            "type": "integer"
          },
          "url": {
            "description": "Webhook endpoint URL",
            "format": "uri",
            "maxLength": 2083,
            "minLength": 1,
            "title": "Url",
            "type": "string"
          }
        },
        "required": [
          "name",
          "url",
          "event_types"
        ],
        "title": "WebhookCreate",
        "type": "object"
      },
      "WebhookDeliveryListResponse": {
        "description": "Response for listing webhook deliveries.\n\nIncludes pagination information for navigating large delivery histories.\n\nAttributes:\n    deliveries: List of delivery records.\n    total: Total number of deliveries.\n    limit: Page size.\n    offset: Page offset.\n    has_more: Whether more pages exist.",
        "properties": {
          "deliveries": {
            "items": {
              "$ref": "#/components/schemas/WebhookDeliveryResponse"
            },
            "title": "Deliveries",
            "type": "array"
          },
          "has_more": {
            "default": false,
            "title": "Has More",
            "type": "boolean"
          },
          "limit": {
            "default": 50,
            "title": "Limit",
            "type": "integer"
          },
          "offset": {
            "default": 0,
            "title": "Offset",
            "type": "integer"
          },
          "total": {
            "default": 0,
            "title": "Total",
            "type": "integer"
          }
        },
        "title": "WebhookDeliveryListResponse",
        "type": "object"
      },
      "WebhookDeliveryResponse": {
        "description": "Response for a webhook delivery attempt.\n\nProvides details about a single webhook delivery attempt including\nstatus, timing, and any error information.\n\nAttributes:\n    id: Delivery ID.\n    webhook_id: Parent webhook ID.\n    event_type: Event that triggered delivery.\n    event_id: Related event ID.\n    status: Delivery status.\n    status_code: HTTP response status code.\n    response_time_ms: Response time in milliseconds.\n    error_message: Error message if failed.\n    attempt_count: Number of attempts.\n    next_retry_at: Next retry timestamp.\n    created_at: Delivery creation timestamp.\n    delivered_at: Successful delivery timestamp.",
        "properties": {
          "attempt_count": {
            "default": 1,
            "description": "Number of attempts",
            "title": "Attempt Count",
            "type": "integer"
          },
          "created_at": {
            "description": "Delivery creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "delivered_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Successful delivery timestamp",
            "title": "Delivered At"
          },
          "error_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error message if failed",
            "title": "Error Message"
          },
          "event_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Related event ID",
            "title": "Event Id"
          },
          "event_type": {
            "$ref": "#/components/schemas/WebhookEventType",
            "description": "Event that triggered delivery"
          },
          "id": {
            "description": "Delivery ID",
            "title": "Id",
            "type": "string"
          },
          "next_retry_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Next retry timestamp",
            "title": "Next Retry At"
          },
          "response_time_ms": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Response time in milliseconds",
            "title": "Response Time Ms"
          },
          "status": {
            "$ref": "#/components/schemas/WebhookDeliveryStatus",
            "description": "Delivery status"
          },
          "status_code": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "HTTP response status code",
            "title": "Status Code"
          },
          "webhook_id": {
            "description": "Parent webhook ID",
            "title": "Webhook Id",
            "type": "string"
          }
        },
        "required": [
          "id",
          "webhook_id",
          "event_type",
          "status",
          "created_at"
        ],
        "title": "WebhookDeliveryResponse",
        "type": "object"
      },
      "WebhookDeliveryStatus": {
        "description": "Webhook delivery attempt status.",
        "enum": [
          "pending",
          "success",
          "failed",
          "retrying"
        ],
        "title": "WebhookDeliveryStatus",
        "type": "string"
      },
      "WebhookEventType": {
        "description": "Event types that can trigger webhooks.",
        "enum": [
          "alert_fired",
          "alert_dismissed",
          "alert_acknowledged",
          "event_created",
          "event_enriched",
          "entity_discovered",
          "anomaly_detected",
          "system_health_changed",
          "batch_analysis_started",
          "batch_analysis_completed",
          "batch_analysis_failed"
        ],
        "title": "WebhookEventType",
        "type": "string"
      },
      "WebhookHealthSummary": {
        "description": "Health summary for all webhooks.\n\nProvides an overview of webhook health across the system including\ndelivery statistics for the last 24 hours.\n\nAttributes:\n    total_webhooks: Total number of configured webhooks.\n    enabled_webhooks: Number of enabled webhooks.\n    healthy_webhooks: Webhooks with >90% success rate.\n    unhealthy_webhooks: Webhooks with <50% success rate.\n    total_deliveries_24h: Total deliveries in last 24 hours.\n    successful_deliveries_24h: Successful deliveries in last 24 hours.\n    failed_deliveries_24h: Failed deliveries in last 24 hours.\n    average_response_time_ms: Average response time.",
        "properties": {
          "average_response_time_ms": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Average Response Time Ms"
          },
          "enabled_webhooks": {
            "default": 0,
            "title": "Enabled Webhooks",
            "type": "integer"
          },
          "failed_deliveries_24h": {
            "default": 0,
            "title": "Failed Deliveries 24H",
            "type": "integer"
          },
          "healthy_webhooks": {
            "default": 0,
            "description": "Webhooks with >90% success rate",
            "title": "Healthy Webhooks",
            "type": "integer"
          },
          "successful_deliveries_24h": {
            "default": 0,
            "title": "Successful Deliveries 24H",
            "type": "integer"
          },
          "total_deliveries_24h": {
            "default": 0,
            "title": "Total Deliveries 24H",
            "type": "integer"
          },
          "total_webhooks": {
            "default": 0,
            "title": "Total Webhooks",
            "type": "integer"
          },
          "unhealthy_webhooks": {
            "default": 0,
            "description": "Webhooks with <50% success rate",
            "title": "Unhealthy Webhooks",
            "type": "integer"
          }
        },
        "title": "WebhookHealthSummary",
        "type": "object"
      },
      "WebhookListResponse": {
        "description": "Response for listing webhooks.\n\nAttributes:\n    webhooks: List of webhook configurations.\n    total: Total number of webhooks.",
        "properties": {
          "total": {
            "default": 0,
            "description": "Total count",
            "title": "Total",
            "type": "integer"
          },
          "webhooks": {
            "items": {
              "$ref": "#/components/schemas/WebhookResponse"
            },
            "title": "Webhooks",
            "type": "array"
          }
        },
        "title": "WebhookListResponse",
        "type": "object"
      },
      "WebhookProcessingResponse": {
        "description": "Schema for webhook processing response.",
        "example": {
          "message": "Processed 1 alert(s)",
          "processed": 1,
          "received": 1,
          "status": "ok"
        },
        "properties": {
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "processed": {
            "description": "Number of alerts processed",
            "title": "Processed",
            "type": "integer"
          },
          "received": {
            "description": "Number of alerts received",
            "title": "Received",
            "type": "integer"
          },
          "status": {
            "description": "Processing status (ok or error)",
            "title": "Status",
            "type": "string"
          }
        },
        "required": [
          "status",
          "received",
          "processed",
          "message"
        ],
        "title": "WebhookProcessingResponse",
        "type": "object"
      },
      "WebhookResponse": {
        "description": "Full webhook configuration response.\n\nReturns complete webhook information including configuration,\nmetadata, and delivery statistics.\n\nAttributes:\n    id: Unique webhook identifier.\n    name: Webhook name.\n    url: Webhook endpoint URL.\n    event_types: Subscribed event types.\n    integration_type: Integration type.\n    enabled: Whether active.\n    custom_headers: Custom HTTP headers.\n    payload_template: Jinja2 payload template.\n    max_retries: Max retry attempts.\n    retry_delay_seconds: Initial retry delay.\n    created_at: Creation timestamp.\n    updated_at: Last update timestamp.\n    total_deliveries: Total delivery attempts.\n    successful_deliveries: Successful delivery count.\n    last_delivery_at: Last delivery timestamp.\n    last_delivery_status: Status of last delivery.",
        "properties": {
          "created_at": {
            "description": "Creation timestamp",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "custom_headers": {
            "additionalProperties": {
              "type": "string"
            },
            "title": "Custom Headers",
            "type": "object"
          },
          "enabled": {
            "description": "Whether active",
            "title": "Enabled",
            "type": "boolean"
          },
          "event_types": {
            "description": "Subscribed events",
            "items": {
              "$ref": "#/components/schemas/WebhookEventType"
            },
            "title": "Event Types",
            "type": "array"
          },
          "id": {
            "description": "Unique webhook identifier",
            "title": "Id",
            "type": "string"
          },
          "integration_type": {
            "$ref": "#/components/schemas/IntegrationType",
            "description": "Integration type"
          },
          "last_delivery_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Last delivery timestamp",
            "title": "Last Delivery At"
          },
          "last_delivery_status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebhookDeliveryStatus"
              },
              {
                "type": "null"
              }
            ]
          },
          "max_retries": {
            "title": "Max Retries",
            "type": "integer"
          },
          "name": {
            "description": "Webhook name",
            "title": "Name",
            "type": "string"
          },
          "payload_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Payload Template"
          },
          "retry_delay_seconds": {
            "title": "Retry Delay Seconds",
            "type": "integer"
          },
          "successful_deliveries": {
            "default": 0,
            "description": "Successful deliveries",
            "title": "Successful Deliveries",
            "type": "integer"
          },
          "total_deliveries": {
            "default": 0,
            "description": "Total delivery attempts",
            "title": "Total Deliveries",
            "type": "integer"
          },
          "updated_at": {
            "description": "Last update timestamp",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "url": {
            "description": "Webhook endpoint URL",
            "title": "Url",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "url",
          "event_types",
          "integration_type",
          "enabled",
          "max_retries",
          "retry_delay_seconds",
          "created_at",
          "updated_at"
        ],
        "title": "WebhookResponse",
        "type": "object"
      },
      "WebhookTestNotificationRequest": {
        "description": "Schema for testing notification configuration.",
        "example": {
          "channel": "email",
          "email_recipients": [
            "test@example.com"
          ]
        },
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "Channel to test"
          },
          "email_recipients": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Email recipients for email test",
            "title": "Email Recipients"
          },
          "webhook_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Webhook URL for webhook test. Must be HTTPS and not point to private IPs.",
            "title": "Webhook Url"
          }
        },
        "required": [
          "channel"
        ],
        "title": "WebhookTestNotificationRequest",
        "type": "object"
      },
      "WebhookTestRequest": {
        "description": "Request to test a webhook with sample data.\n\nAllows testing a webhook configuration with a simulated event\nto verify connectivity and payload format.\n\nAttributes:\n    event_type: Event type to use for test payload.",
        "properties": {
          "event_type": {
            "$ref": "#/components/schemas/WebhookEventType",
            "default": "alert_fired",
            "description": "Event type for test payload"
          }
        },
        "title": "WebhookTestRequest",
        "type": "object"
      },
      "WebhookTestResponse": {
        "description": "Response from testing a webhook.\n\nReturns the result of a webhook test including response details\nand any errors encountered.\n\nAttributes:\n    success: Whether test succeeded.\n    status_code: HTTP response code.\n    response_time_ms: Response time.\n    response_body: Response body (truncated).\n    error_message: Error if failed.",
        "properties": {
          "error_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error if failed",
            "title": "Error Message"
          },
          "response_body": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Response body (truncated)",
            "title": "Response Body"
          },
          "response_time_ms": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Response time",
            "title": "Response Time Ms"
          },
          "status_code": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "HTTP response code",
            "title": "Status Code"
          },
          "success": {
            "description": "Whether test succeeded",
            "title": "Success",
            "type": "boolean"
          }
        },
        "required": [
          "success"
        ],
        "title": "WebhookTestResponse",
        "type": "object"
      },
      "WebhookUpdate": {
        "description": "Schema for updating an existing webhook.\n\nAll fields are optional - only provided fields will be updated.\n\nAttributes:\n    name: New webhook name.\n    url: New webhook URL.\n    event_types: New list of subscribed events.\n    integration_type: New integration type.\n    enabled: New enabled status.\n    auth: New authentication configuration.\n    custom_headers: New custom headers.\n    payload_template: New payload template.\n    max_retries: New max retry count.\n    retry_delay_seconds: New retry delay.",
        "properties": {
          "auth": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebhookAuthConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "custom_headers": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Custom Headers"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enabled"
          },
          "event_types": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/WebhookEventType"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Event Types"
          },
          "integration_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/IntegrationType"
              },
              {
                "type": "null"
              }
            ]
          },
          "max_retries": {
            "anyOf": [
              {
                "maximum": 10.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Retries"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 100,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name"
          },
          "payload_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Payload Template"
          },
          "retry_delay_seconds": {
            "anyOf": [
              {
                "maximum": 3600.0,
                "minimum": 1.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Retry Delay Seconds"
          },
          "url": {
            "anyOf": [
              {
                "format": "uri",
                "maxLength": 2083,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Url"
          }
        },
        "title": "WebhookUpdate",
        "type": "object"
      },
      "WorkerControlResponse": {
        "description": "Response schema for worker control operations (start/stop/restart).\n\nUsed by endpoints that control individual workers.",
        "example": {
          "message": "Worker 'file_watcher' restarted successfully",
          "success": true,
          "worker_name": "file_watcher"
        },
        "properties": {
          "message": {
            "description": "Human-readable status message",
            "title": "Message",
            "type": "string"
          },
          "success": {
            "description": "Whether the operation was successful",
            "title": "Success",
            "type": "boolean"
          },
          "worker_name": {
            "description": "Name of the worker that was controlled",
            "title": "Worker Name",
            "type": "string"
          }
        },
        "required": [
          "success",
          "message",
          "worker_name"
        ],
        "title": "WorkerControlResponse",
        "type": "object"
      },
      "WorkerHealthStatus": {
        "description": "Health status for a background worker.\n\nWorkers are background processes that perform periodic or event-driven tasks.",
        "example": {
          "critical": true,
          "name": "file_watcher",
          "running": true
        },
        "properties": {
          "critical": {
            "description": "Whether this worker is critical for system operation",
            "title": "Critical",
            "type": "boolean"
          },
          "name": {
            "description": "Worker name (e.g., 'file_watcher')",
            "title": "Name",
            "type": "string"
          },
          "running": {
            "description": "Whether the worker is currently running",
            "title": "Running",
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "running",
          "critical"
        ],
        "title": "WorkerHealthStatus",
        "type": "object"
      },
      "WorkerStatus": {
        "description": "Status information for a background worker/service.",
        "properties": {
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional status message or error details",
            "title": "Message"
          },
          "name": {
            "description": "Worker/service name",
            "title": "Name",
            "type": "string"
          },
          "running": {
            "description": "Whether the worker is currently running",
            "title": "Running",
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "running"
        ],
        "title": "WorkerStatus",
        "type": "object"
      },
      "WorkerSupervisorStatusResponse": {
        "description": "Response schema for worker supervisor status endpoint.\n\nProvides overall supervisor status and detailed information about\nall supervised workers including their health status and restart metrics.",
        "example": {
          "running": true,
          "timestamp": "2026-01-13T10:35:00Z",
          "worker_count": 4,
          "workers": [
            {
              "last_started_at": "2026-01-13T10:30:00Z",
              "max_restarts": 5,
              "name": "detection_worker",
              "restart_count": 0,
              "status": "running"
            },
            {
              "error": "Connection timeout",
              "last_crashed_at": "2026-01-13T10:30:30Z",
              "last_started_at": "2026-01-13T10:31:00Z",
              "max_restarts": 5,
              "name": "analysis_worker",
              "restart_count": 1,
              "status": "running"
            }
          ]
        },
        "properties": {
          "running": {
            "description": "Whether the supervisor is currently running",
            "title": "Running",
            "type": "boolean"
          },
          "timestamp": {
            "description": "Timestamp of status query",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "worker_count": {
            "description": "Total number of registered workers",
            "minimum": 0.0,
            "title": "Worker Count",
            "type": "integer"
          },
          "workers": {
            "description": "Detailed status of all supervised workers",
            "items": {
              "$ref": "#/components/schemas/SupervisedWorkerInfo"
            },
            "title": "Workers",
            "type": "array"
          }
        },
        "required": [
          "running",
          "worker_count",
          "timestamp"
        ],
        "title": "WorkerSupervisorStatusResponse",
        "type": "object"
      },
      "ZoneAnomalyAcknowledgeResponse": {
        "description": "Response schema for acknowledging an anomaly.",
        "example": {
          "acknowledged": true,
          "acknowledged_at": "2025-01-24T04:00:00Z",
          "id": "123e4567-e89b-12d3-a456-426614174000"
        },
        "properties": {
          "acknowledged": {
            "description": "Whether the anomaly is now acknowledged",
            "title": "Acknowledged",
            "type": "boolean"
          },
          "acknowledged_at": {
            "description": "When the anomaly was acknowledged",
            "format": "date-time",
            "title": "Acknowledged At",
            "type": "string"
          },
          "acknowledged_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Who acknowledged the anomaly",
            "title": "Acknowledged By"
          },
          "id": {
            "description": "Anomaly ID",
            "title": "Id",
            "type": "string"
          }
        },
        "required": [
          "id",
          "acknowledged",
          "acknowledged_at"
        ],
        "title": "ZoneAnomalyAcknowledgeResponse",
        "type": "object"
      },
      "ZoneAnomalyListResponse": {
        "description": "Response schema for zone anomaly list endpoint.",
        "example": {
          "items": [
            {
              "acknowledged": false,
              "actual_value": 1.0,
              "anomaly_type": "unusual_time",
              "camera_id": "front_door",
              "created_at": "2025-01-24T03:15:00Z",
              "description": "Activity detected in Front Door at 03:15.",
              "detection_id": 12345,
              "deviation": 3.5,
              "expected_value": 0.1,
              "id": "123e4567-e89b-12d3-a456-426614174000",
              "severity": "warning",
              "thumbnail_url": "/api/detections/12345/image",
              "timestamp": "2025-01-24T03:15:00Z",
              "title": "Unusual activity at 03:15",
              "updated_at": "2025-01-24T03:15:00Z",
              "zone_id": "456e7890-e89b-12d3-a456-426614174001"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of anomalies",
            "items": {
              "$ref": "#/components/schemas/ZoneAnomalyResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "ZoneAnomalyListResponse",
        "type": "object"
      },
      "ZoneAnomalyResponse": {
        "description": "Response schema for a single zone anomaly.",
        "example": {
          "acknowledged": false,
          "actual_value": 1.0,
          "anomaly_type": "unusual_time",
          "camera_id": "front_door",
          "created_at": "2025-01-24T03:15:00Z",
          "description": "Activity detected in Front Door at 03:15 when typical activity is 0.1.",
          "detection_id": 12345,
          "deviation": 3.5,
          "expected_value": 0.1,
          "id": "123e4567-e89b-12d3-a456-426614174000",
          "severity": "warning",
          "thumbnail_url": "/api/detections/12345/image",
          "timestamp": "2025-01-24T03:15:00Z",
          "title": "Unusual activity at 03:15",
          "updated_at": "2025-01-24T03:15:00Z",
          "zone_id": "456e7890-e89b-12d3-a456-426614174001"
        },
        "properties": {
          "acknowledged": {
            "description": "Whether the anomaly has been acknowledged",
            "title": "Acknowledged",
            "type": "boolean"
          },
          "acknowledged_at": {
            "anyOf": [
              {
                "format": "date-time",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "When the anomaly was acknowledged",
            "title": "Acknowledged At"
          },
          "acknowledged_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Who acknowledged the anomaly",
            "title": "Acknowledged By"
          },
          "actual_value": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Actual observed value",
            "title": "Actual Value"
          },
          "anomaly_type": {
            "description": "Type of anomaly detected",
            "title": "Anomaly Type",
            "type": "string"
          },
          "camera_id": {
            "description": "Camera ID associated with the zone",
            "title": "Camera Id",
            "type": "string"
          },
          "created_at": {
            "description": "When the record was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Detailed description of the anomaly",
            "title": "Description"
          },
          "detection_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Related detection ID if applicable",
            "title": "Detection Id"
          },
          "deviation": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Statistical deviation from baseline",
            "title": "Deviation"
          },
          "expected_value": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "description": "Expected value from baseline",
            "title": "Expected Value"
          },
          "id": {
            "description": "Unique identifier for the anomaly",
            "title": "Id",
            "type": "string"
          },
          "severity": {
            "description": "Severity level of the anomaly",
            "title": "Severity",
            "type": "string"
          },
          "thumbnail_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "URL to thumbnail image for visual context",
            "title": "Thumbnail Url"
          },
          "timestamp": {
            "description": "When the anomaly occurred",
            "format": "date-time",
            "title": "Timestamp",
            "type": "string"
          },
          "title": {
            "description": "Human-readable title",
            "title": "Title",
            "type": "string"
          },
          "updated_at": {
            "description": "When the record was last updated",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "zone_id": {
            "description": "Zone ID where anomaly was detected",
            "title": "Zone Id",
            "type": "string"
          }
        },
        "required": [
          "id",
          "zone_id",
          "camera_id",
          "anomaly_type",
          "severity",
          "title",
          "acknowledged",
          "timestamp",
          "created_at",
          "updated_at"
        ],
        "title": "ZoneAnomalyResponse",
        "type": "object"
      },
      "ZoneCreate": {
        "description": "Schema for creating a new zone.",
        "example": {
          "color": "#3B82F6",
          "coordinates": [
            [
              0.1,
              0.2
            ],
            [
              0.3,
              0.2
            ],
            [
              0.3,
              0.8
            ],
            [
              0.1,
              0.8
            ]
          ],
          "enabled": true,
          "name": "Front Door",
          "priority": 1,
          "shape": "rectangle",
          "zone_type": "entry_point"
        },
        "properties": {
          "color": {
            "default": "#3B82F6",
            "description": "Hex color for UI display",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "title": "Color",
            "type": "string"
          },
          "coordinates": {
            "description": "Array of normalized [x, y] points (0-1 range)",
            "items": {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            "minItems": 3,
            "title": "Coordinates",
            "type": "array"
          },
          "enabled": {
            "default": true,
            "description": "Whether zone is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "name": {
            "description": "Zone name",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "priority": {
            "default": 0,
            "description": "Priority for overlapping zones (higher = more important)",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Priority",
            "type": "integer"
          },
          "shape": {
            "$ref": "#/components/schemas/CameraZoneShape",
            "default": "rectangle",
            "description": "Shape of the zone"
          },
          "zone_type": {
            "$ref": "#/components/schemas/CameraZoneType",
            "default": "other",
            "description": "Type of zone"
          }
        },
        "required": [
          "name",
          "coordinates"
        ],
        "title": "ZoneCreate",
        "type": "object"
      },
      "ZoneHouseholdConfigCreate": {
        "description": "Schema for creating a zone household configuration.\n\nUsed when initially configuring household linkage for a zone.",
        "example": {
          "access_schedules": [
            {
              "cron_expression": "0 9-17 * * 1-5",
              "description": "Weekday daytime access",
              "member_ids": [
                4,
                5
              ]
            }
          ],
          "allowed_member_ids": [
            2,
            3
          ],
          "allowed_vehicle_ids": [
            1,
            2
          ],
          "owner_id": 1
        },
        "properties": {
          "access_schedules": {
            "description": "Time-based access schedules for specific members",
            "items": {
              "$ref": "#/components/schemas/AccessSchedule"
            },
            "title": "Access Schedules",
            "type": "array"
          },
          "allowed_member_ids": {
            "description": "IDs of household members allowed in this zone (partial trust)",
            "items": {
              "type": "integer"
            },
            "title": "Allowed Member Ids",
            "type": "array"
          },
          "allowed_vehicle_ids": {
            "description": "IDs of registered vehicles allowed in this zone (partial trust)",
            "items": {
              "type": "integer"
            },
            "title": "Allowed Vehicle Ids",
            "type": "array"
          },
          "owner_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the household member who owns this zone (full trust)",
            "title": "Owner Id"
          }
        },
        "title": "ZoneHouseholdConfigCreate",
        "type": "object"
      },
      "ZoneHouseholdConfigResponse": {
        "description": "Schema for zone household configuration response.",
        "example": {
          "access_schedules": [
            {
              "cron_expression": "0 9-17 * * 1-5",
              "description": "Weekday access",
              "member_ids": [
                4
              ]
            }
          ],
          "allowed_member_ids": [
            2,
            3
          ],
          "allowed_vehicle_ids": [
            1
          ],
          "created_at": "2026-01-21T10:00:00Z",
          "id": 1,
          "owner_id": 1,
          "updated_at": "2026-01-21T12:00:00Z",
          "zone_id": "550e8400-e29b-41d4-a716-446655440000"
        },
        "properties": {
          "access_schedules": {
            "description": "Time-based access schedules",
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "title": "Access Schedules",
            "type": "array"
          },
          "allowed_member_ids": {
            "description": "IDs of household members allowed in this zone",
            "items": {
              "type": "integer"
            },
            "title": "Allowed Member Ids",
            "type": "array"
          },
          "allowed_vehicle_ids": {
            "description": "IDs of registered vehicles allowed in this zone",
            "items": {
              "type": "integer"
            },
            "title": "Allowed Vehicle Ids",
            "type": "array"
          },
          "created_at": {
            "description": "When the configuration was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "id": {
            "description": "Configuration ID",
            "title": "Id",
            "type": "integer"
          },
          "owner_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the zone owner (household member with full trust)",
            "title": "Owner Id"
          },
          "updated_at": {
            "description": "When the configuration was last updated",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "zone_id": {
            "description": "ID of the zone this configuration applies to",
            "title": "Zone Id",
            "type": "string"
          }
        },
        "required": [
          "id",
          "zone_id",
          "allowed_member_ids",
          "allowed_vehicle_ids",
          "access_schedules",
          "created_at",
          "updated_at"
        ],
        "title": "ZoneHouseholdConfigResponse",
        "type": "object"
      },
      "ZoneHouseholdConfigUpdate": {
        "description": "Schema for updating a zone household configuration.\n\nAll fields are optional - only provided fields will be updated.",
        "example": {
          "allowed_member_ids": [
            3,
            4,
            5
          ],
          "owner_id": 2
        },
        "properties": {
          "access_schedules": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/AccessSchedule"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time-based access schedules for specific members",
            "title": "Access Schedules"
          },
          "allowed_member_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "integer"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "IDs of household members allowed in this zone",
            "title": "Allowed Member Ids"
          },
          "allowed_vehicle_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "integer"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "IDs of registered vehicles allowed in this zone",
            "title": "Allowed Vehicle Ids"
          },
          "owner_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the household member who owns this zone",
            "title": "Owner Id"
          }
        },
        "title": "ZoneHouseholdConfigUpdate",
        "type": "object"
      },
      "ZoneListResponse": {
        "description": "Schema for zone list response.",
        "example": {
          "items": [
            {
              "camera_id": "front_door",
              "color": "#3B82F6",
              "coordinates": [
                [
                  0.1,
                  0.2
                ],
                [
                  0.3,
                  0.2
                ],
                [
                  0.3,
                  0.8
                ],
                [
                  0.1,
                  0.8
                ]
              ],
              "created_at": "2025-12-23T10:00:00Z",
              "enabled": true,
              "id": "123e4567-e89b-12d3-a456-426614174000",
              "name": "Front Door",
              "priority": 1,
              "shape": "rectangle",
              "updated_at": "2025-12-23T12:00:00Z",
              "zone_type": "entry_point"
            }
          ],
          "pagination": {
            "has_more": false,
            "limit": 50,
            "offset": 0,
            "total": 1
          }
        },
        "properties": {
          "items": {
            "description": "List of zones",
            "items": {
              "$ref": "#/components/schemas/ZoneResponse"
            },
            "title": "Items",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMeta",
            "description": "Pagination metadata"
          }
        },
        "required": [
          "items",
          "pagination"
        ],
        "title": "ZoneListResponse",
        "type": "object"
      },
      "ZoneResponse": {
        "description": "Schema for zone response.",
        "example": {
          "camera_id": "front_door",
          "color": "#3B82F6",
          "coordinates": [
            [
              0.1,
              0.2
            ],
            [
              0.3,
              0.2
            ],
            [
              0.3,
              0.8
            ],
            [
              0.1,
              0.8
            ]
          ],
          "created_at": "2025-12-23T10:00:00Z",
          "enabled": true,
          "id": "123e4567-e89b-12d3-a456-426614174000",
          "name": "Front Door",
          "priority": 1,
          "shape": "rectangle",
          "updated_at": "2025-12-23T12:00:00Z",
          "zone_type": "entry_point"
        },
        "properties": {
          "camera_id": {
            "description": "Camera ID this zone belongs to",
            "title": "Camera Id",
            "type": "string"
          },
          "color": {
            "description": "Hex color for UI display",
            "title": "Color",
            "type": "string"
          },
          "coordinates": {
            "description": "Array of normalized [x, y] points (0-1 range)",
            "items": {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            "title": "Coordinates",
            "type": "array"
          },
          "created_at": {
            "description": "Timestamp when zone was created",
            "format": "date-time",
            "title": "Created At",
            "type": "string"
          },
          "enabled": {
            "description": "Whether zone is active",
            "title": "Enabled",
            "type": "boolean"
          },
          "id": {
            "description": "Zone UUID",
            "title": "Id",
            "type": "string"
          },
          "name": {
            "description": "Zone name",
            "title": "Name",
            "type": "string"
          },
          "priority": {
            "description": "Priority for overlapping zones",
            "title": "Priority",
            "type": "integer"
          },
          "shape": {
            "$ref": "#/components/schemas/CameraZoneShape",
            "description": "Shape of the zone"
          },
          "updated_at": {
            "description": "Timestamp when zone was last updated",
            "format": "date-time",
            "title": "Updated At",
            "type": "string"
          },
          "zone_type": {
            "$ref": "#/components/schemas/CameraZoneType",
            "description": "Type of zone"
          }
        },
        "required": [
          "id",
          "camera_id",
          "name",
          "zone_type",
          "coordinates",
          "shape",
          "color",
          "enabled",
          "priority",
          "created_at",
          "updated_at"
        ],
        "title": "ZoneResponse",
        "type": "object"
      },
      "ZoneUpdate": {
        "description": "Schema for updating an existing zone.",
        "example": {
          "enabled": false,
          "name": "Front Door - Updated"
        },
        "properties": {
          "color": {
            "anyOf": [
              {
                "pattern": "^#[0-9A-Fa-f]{6}$",
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Hex color for UI display",
            "title": "Color"
          },
          "coordinates": {
            "anyOf": [
              {
                "items": {
                  "items": {
                    "type": "number"
                  },
                  "type": "array"
                },
                "minItems": 3,
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "description": "Array of normalized [x, y] points (0-1 range)",
            "title": "Coordinates"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether zone is active",
            "title": "Enabled"
          },
          "name": {
            "anyOf": [
              {
                "maxLength": 255,
                "minLength": 1,
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "description": "Zone name",
            "title": "Name"
          },
          "priority": {
            "anyOf": [
              {
                "maximum": 100.0,
                "minimum": 0.0,
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "description": "Priority for overlapping zones (higher = more important)",
            "title": "Priority"
          },
          "shape": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CameraZoneShape"
              },
              {
                "type": "null"
              }
            ],
            "description": "Shape of the zone"
          },
          "zone_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CameraZoneType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Type of zone"
          }
        },
        "title": "ZoneUpdate",
        "type": "object"
      }
    }
  },
  "info": {
    "description": "AI-powered home security monitoring system",
    "title": "Home Security Intelligence API",
    "version": "0.1.0"
  },
  "openapi": "3.1.0",
  "paths": {
    "/": {
      "get": {
        "description": "Health check endpoint.",
        "operationId": "root",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Root",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Root"
      }
    },
    "/api/action-events": {
      "get": {
        "description": "List action events with optional filtering and pagination.\n\nArgs:\n    camera_id: Filter by camera ID\n    track_id: Filter by track ID\n    action: Filter by action label (exact match)\n    is_suspicious: Filter by suspicious flag\n    min_confidence: Filter by minimum confidence score\n    start_time: Filter by timestamp >= start_time\n    end_time: Filter by timestamp <= end_time\n    limit: Maximum number of results to return\n    offset: Number of results to skip for pagination\n    db: Database session\n\nReturns:\n    ActionEventListResponse with events and pagination info",
        "operationId": "action-events_list_action_events",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by track ID",
            "in": "query",
            "name": "track_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by track ID",
              "title": "Track Id"
            }
          },
          {
            "description": "Filter by action label",
            "in": "query",
            "name": "action",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by action label",
              "title": "Action"
            }
          },
          {
            "description": "Filter by suspicious flag",
            "in": "query",
            "name": "is_suspicious",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by suspicious flag",
              "title": "Is Suspicious"
            }
          },
          {
            "description": "Filter by minimum confidence",
            "in": "query",
            "name": "min_confidence",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by minimum confidence",
              "title": "Min Confidence"
            }
          },
          {
            "description": "Filter by start time",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start time",
              "title": "Start Time"
            }
          },
          {
            "description": "Filter by end time",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end time",
              "title": "End Time"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActionEventListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Action Events",
        "tags": [
          "action-events"
        ]
      },
      "post": {
        "description": "Create a new action event manually.\n\nThis endpoint allows creating action events without running analysis,\nuseful for importing results from external systems or testing.\n\nArgs:\n    event_data: Action event data\n    db: Database session\n\nReturns:\n    Created ActionEventResponse",
        "operationId": "action-events_create_action_event",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActionEventCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActionEventResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Create Action Event",
        "tags": [
          "action-events"
        ]
      }
    },
    "/api/action-events/analyze": {
      "post": {
        "description": "Trigger action analysis on a set of video frames.\n\nThis endpoint loads frames from disk, runs X-CLIP classification,\nand optionally saves the result to the database.\n\nThe X-CLIP model analyzes frame sequences to detect security-relevant\nactions like walking, running, climbing, loitering, etc.\n\nArgs:\n    request: Analysis request with frame paths and options\n    db: Database session\n\nReturns:\n    ActionAnalyzeResponse with detected action and scores\n\nRaises:\n    HTTPException: 400 if no valid frames, 503 if model unavailable",
        "operationId": "action-events_analyze_action",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActionAnalyzeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActionAnalyzeResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid request (no valid frames)"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "X-CLIP model unavailable"
          }
        },
        "summary": "Analyze Action",
        "tags": [
          "action-events"
        ]
      }
    },
    "/api/action-events/camera/{camera_id}": {
      "get": {
        "description": "Get action events for a specific camera.\n\nConvenience endpoint for camera-specific queries.\n\nArgs:\n    camera_id: Camera ID to filter by\n    start_time: Filter by timestamp >= start_time\n    end_time: Filter by timestamp <= end_time\n    limit: Maximum number of results to return\n    offset: Number of results to skip for pagination\n    db: Database session\n\nReturns:\n    ActionEventListResponse with events and pagination info",
        "operationId": "action-events_get_camera_action_events",
        "parameters": [
          {
            "description": "Camera ID",
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "description": "Camera ID",
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Filter by start time",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start time",
              "title": "Start Time"
            }
          },
          {
            "description": "Filter by end time",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end time",
              "title": "End Time"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActionEventListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Camera Action Events",
        "tags": [
          "action-events"
        ]
      }
    },
    "/api/action-events/suspicious": {
      "get": {
        "description": "List suspicious action events only.\n\nReturns action events where is_suspicious=True, along with\ncounts of suspicious vs total events.\n\nArgs:\n    camera_id: Filter by camera ID\n    min_confidence: Filter by minimum confidence score\n    start_time: Filter by timestamp >= start_time\n    end_time: Filter by timestamp <= end_time\n    limit: Maximum number of results to return\n    offset: Number of results to skip for pagination\n    db: Database session\n\nReturns:\n    SuspiciousActionsResponse with suspicious events and counts",
        "operationId": "action-events_list_suspicious_actions",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by minimum confidence",
            "in": "query",
            "name": "min_confidence",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by minimum confidence",
              "title": "Min Confidence"
            }
          },
          {
            "description": "Filter by start time",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start time",
              "title": "Start Time"
            }
          },
          {
            "description": "Filter by end time",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end time",
              "title": "End Time"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuspiciousActionsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Suspicious Actions",
        "tags": [
          "action-events"
        ]
      }
    },
    "/api/action-events/{event_id}": {
      "delete": {
        "description": "Delete an action event.\n\nArgs:\n    event_id: Action event ID to delete\n    db: Database session\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "action-events_delete_action_event",
        "parameters": [
          {
            "description": "Action event ID",
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "description": "Action event ID",
              "minimum": 1,
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "404": {
            "description": "Action event not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Delete Action Event",
        "tags": [
          "action-events"
        ]
      },
      "get": {
        "description": "Get a specific action event by ID.\n\nArgs:\n    event_id: Action event ID\n    db: Database session\n\nReturns:\n    ActionEventResponse\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "action-events_get_action_event",
        "parameters": [
          {
            "description": "Action event ID",
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "description": "Action event ID",
              "minimum": 1,
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActionEventResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Action event not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Action Event",
        "tags": [
          "action-events"
        ]
      }
    },
    "/api/admin/cleanup/orphans": {
      "post": {
        "description": "Manually trigger orphaned file cleanup.\n\nScans camera upload directories for files that have no corresponding\ndatabase records and optionally deletes them.\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\n\nSafety features:\n- dry_run=True by default (no actual deletions)\n- min_age_hours threshold prevents deleting files being processed\n- max_delete_gb limits total deletion per run\n\nArgs:\n    request: Cleanup configuration (dry_run, min_age_hours, max_delete_gb)\n    http_request: FastAPI request for audit logging\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of cleanup operation with statistics",
        "operationId": "admin_cleanup_orphans",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OrphanCleanupRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrphanCleanupResponse"
                }
              }
            },
            "description": "Orphan cleanup completed successfully"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Cleanup Orphans",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/admin/maintenance/clear-cache": {
      "post": {
        "description": "Clear all cached data from Redis.\n\nInvalidates all cache entries including:\n- Events cache\n- Cameras cache\n- System status cache\n- Stats cache\n- Detections cache\n- Alerts cache\n- Summaries cache\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\n\nArgs:\n    http_request: FastAPI request for audit logging\n    db: Database session for audit logging\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of cache clear operation",
        "operationId": "admin_clear_cache",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClearCacheResponse"
                }
              }
            },
            "description": "Cache cleared successfully"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Clear Cache",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/admin/maintenance/flush-queues": {
      "post": {
        "description": "Flush all processing queues in Redis.\n\nClears the following queues:\n- Detection queue (incoming detection jobs)\n- Analysis queue (LLM analysis jobs)\n- DLQ detection queue (failed detection jobs)\n- DLQ analysis queue (failed analysis jobs)\n\nWARNING: This will discard any pending items in the queues.\nItems will need to be reprocessed from scratch.\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\n\nArgs:\n    http_request: FastAPI request for audit logging\n    db: Database session for audit logging\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of queue flush operation",
        "operationId": "admin_flush_queues",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FlushQueuesResponse"
                }
              }
            },
            "description": "Queues flushed successfully"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Flush Queues",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/admin/seed/cameras": {
      "post": {
        "description": "Seed test cameras into the database.\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\n\nArgs:\n    request: Seed configuration (count, clear_existing, create_folders)\n    http_request: FastAPI request for audit logging\n    db: Database session\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of seeded cameras",
        "operationId": "admin_seed_cameras",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedCamerasRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedCamerasResponse"
                }
              }
            },
            "description": "Cameras created successfully"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Seed Cameras",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/admin/seed/clear": {
      "delete": {
        "description": "Clear all seeded data (cameras, events, detections).\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\nRequires JSON body confirmation to prevent accidental data deletion:\n{\"confirm\": \"DELETE_ALL_DATA\"}\n\nArgs:\n    body: Request body with confirmation string\n    request: FastAPI request for audit logging\n    db: Database session\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of cleared data counts\n\nRaises:\n    HTTPException: 400 if confirmation string is incorrect",
        "operationId": "admin_clear_seeded_data",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClearDataRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClearDataResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Confirmation required"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Clear Seeded Data",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/admin/seed/events": {
      "post": {
        "description": "Seed mock events and detections into the database.\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\nRequires cameras to exist first.\n\nArgs:\n    request: Seed configuration (count, clear_existing)\n    http_request: FastAPI request for audit logging\n    db: Database session\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of seeded events and detections",
        "operationId": "admin_seed_events",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedEventsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedEventsResponse"
                }
              }
            },
            "description": "Events and detections created successfully"
          },
          "400": {
            "description": "Bad request - No cameras found"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Seed Events",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/admin/seed/pipeline-latency": {
      "post": {
        "description": "Seed the pipeline latency tracker with mock historical data.\n\nThis populates the in-memory PipelineLatencyTracker with realistic\nlatency samples for UI testing and development. Data is distributed\nacross the specified time span with realistic variance.\n\nSECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.\nIf ADMIN_API_KEY is set, requires X-Admin-API-Key header.\n\nTypical latency ranges (ms):\n- watch_to_detect: 50-200ms (file processing + YOLO26 inference)\n- detect_to_batch: 10-50ms (detection aggregation)\n- batch_to_analyze: 5000-15000ms (Nemotron LLM analysis)\n- total_pipeline: 5100-15300ms (end-to-end)\n\nArgs:\n    request: Configuration for sample generation\n    http_request: FastAPI request for audit logging\n    db: Database session for audit logging\n    _admin: Admin access validation (via dependency)\n\nReturns:\n    Summary of seeded latency data",
        "operationId": "admin_seed_pipeline_latency",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedPipelineLatencyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedPipelineLatencyResponse"
                }
              }
            },
            "description": "Pipeline latency data seeded successfully"
          },
          "401": {
            "description": "Unauthorized - Admin API key required"
          },
          "403": {
            "description": "Forbidden - Debug mode or admin not enabled"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Seed Pipeline Latency",
        "tags": [
          "admin"
        ]
      }
    },
    "/api/ai-audit/batch": {
      "post": {
        "description": "Trigger batch audit processing for multiple events.\n\nThis endpoint returns immediately with a job ID that can be used to\ntrack progress via GET /api/ai-audit/batch/{job_id}. Events are\nprocessed asynchronously in the background.\n\nArgs:\n    request: Batch audit request with filtering criteria\n    background_tasks: FastAPI background tasks\n    db: Database session\n    job_tracker: Job tracker for progress tracking\n\nReturns:\n    BatchAuditJobResponse with job ID for tracking progress",
        "operationId": "ai-audit_trigger_batch_audit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchAuditRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchAuditJobResponse"
                }
              }
            },
            "description": "Batch audit job created successfully"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Trigger Batch Audit",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/batch/{job_id}": {
      "get": {
        "description": "Get the status of a batch audit job.\n\nProvides progress information for an ongoing or completed batch audit,\nincluding the number of events processed and any errors.\n\nArgs:\n    job_id: The job ID returned by trigger_batch_audit\n    job_tracker: Job tracker for retrieving job status\n\nReturns:\n    BatchAuditJobStatusResponse with current progress\n\nRaises:\n    HTTPException: 404 if job not found",
        "operationId": "ai-audit_get_batch_audit_status",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchAuditJobStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Job not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Batch Audit Status",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/events/{event_id}": {
      "get": {
        "description": "Get audit information for a specific event.\n\nRetrieves the AI pipeline audit record for the given event, including\nmodel contributions, quality scores, and prompt improvement suggestions.\n\nArgs:\n    event_id: The ID of the event to get audit for\n    db: Database session\n\nReturns:\n    EventAuditResponse containing full audit details\n\nRaises:\n    HTTPException: 404 if event or audit not found",
        "operationId": "ai-audit_get_event_audit",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventAuditResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Event or audit not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Event Audit",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/events/{event_id}/evaluate": {
      "post": {
        "description": "Trigger full evaluation for a specific event's audit.\n\nRuns the complete self-evaluation pipeline (self-critique, rubric scoring,\nconsistency check, prompt improvement) for the given event.\n\nArgs:\n    event_id: The ID of the event to evaluate\n    request: HTTP request for audit logging\n    force: If True, re-evaluate even if already evaluated\n    db: Database session\n\nReturns:\n    EventAuditResponse with updated evaluation results\n\nRaises:\n    HTTPException: 404 if event or audit not found",
        "operationId": "ai-audit_evaluate_event",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Force re-evaluation even if already evaluated",
            "in": "query",
            "name": "force",
            "required": false,
            "schema": {
              "default": false,
              "description": "Force re-evaluation even if already evaluated",
              "title": "Force",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventAuditResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Event or audit not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Evaluate Event",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/leaderboard": {
      "get": {
        "description": "Get model leaderboard ranked by contribution rate.\n\nReturns a ranked list of AI models by their contribution rate,\nalong with quality correlation data.\n\nArgs:\n    days: Number of days to include (1-90, default 7)\n    db: Database session\n\nReturns:\n    LeaderboardResponse with ranked model entries",
        "operationId": "ai-audit_get_model_leaderboard",
        "parameters": [
          {
            "description": "Number of days to include",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "default": 7,
              "description": "Number of days to include",
              "maximum": 90,
              "minimum": 1,
              "title": "Days",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Model Leaderboard",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/recommendations": {
      "get": {
        "description": "Get aggregated prompt improvement recommendations.\n\nAnalyzes all audits to produce actionable recommendations for\nimproving the AI pipeline prompt templates.\n\nArgs:\n    days: Number of days to analyze (1-90, default 7)\n    db: Database session\n\nReturns:\n    RecommendationsResponse with prioritized recommendations",
        "operationId": "ai-audit_get_recommendations",
        "parameters": [
          {
            "description": "Number of days to include",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "default": 7,
              "description": "Number of days to include",
              "maximum": 90,
              "minimum": 1,
              "title": "Days",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecommendationsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Recommendations",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/ai-audit/stats": {
      "get": {
        "description": "Get aggregate AI audit statistics.\n\nReturns aggregate statistics including total events, quality scores,\nmodel contribution rates, and audit trends over the specified period.\n\nArgs:\n    days: Number of days to include in statistics (1-90, default 7)\n    camera_id: Optional camera ID to filter stats\n    db: Database session\n\nReturns:\n    AuditStatsResponse with aggregate statistics",
        "operationId": "ai-audit_get_audit_stats",
        "parameters": [
          {
            "description": "Number of days to include",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "default": 7,
              "description": "Number of days to include",
              "maximum": 90,
              "minimum": 1,
              "title": "Days",
              "type": "integer"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Audit Stats",
        "tags": [
          "ai-audit"
        ]
      }
    },
    "/api/alerts/rules": {
      "get": {
        "description": "List all alert rules with optional filtering and pagination.\n\nArgs:\n    enabled: Filter by enabled status\n    severity: Filter by severity level (low, medium, high, critical)\n    limit: Maximum number of results to return\n    offset: Number of results to skip for pagination\n    db: Database session\n\nReturns:\n    AlertRuleListResponse with rules and pagination info",
        "operationId": "alert-rules_list_rules",
        "parameters": [
          {
            "description": "Filter by enabled status",
            "in": "query",
            "name": "enabled",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by enabled status",
              "title": "Enabled"
            }
          },
          {
            "description": "Filter by severity level",
            "in": "query",
            "name": "severity",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by severity level",
              "title": "Severity"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Rules",
        "tags": [
          "alert-rules"
        ]
      },
      "post": {
        "description": "Create a new alert rule.\n\nArgs:\n    rule_data: Rule creation data\n    db: Database session\n    cache: Cache service for cache invalidation (NEM-1952)\n\nReturns:\n    Created AlertRule",
        "operationId": "alert-rules_create_rule",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AlertRuleCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Create Rule",
        "tags": [
          "alert-rules"
        ]
      }
    },
    "/api/alerts/rules/{rule_id}": {
      "delete": {
        "description": "Delete an alert rule.\n\nArgs:\n    rule_id: Rule UUID\n    db: Database session\n    cache: Cache service for cache invalidation (NEM-1952)\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "alert-rules_delete_rule",
        "parameters": [
          {
            "in": "path",
            "name": "rule_id",
            "required": true,
            "schema": {
              "title": "Rule Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert rule not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Delete Rule",
        "tags": [
          "alert-rules"
        ]
      },
      "get": {
        "description": "Get a specific alert rule by ID.\n\nArgs:\n    rule_id: Rule UUID\n    db: Database session\n\nReturns:\n    AlertRule\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "alert-rules_get_rule",
        "parameters": [
          {
            "in": "path",
            "name": "rule_id",
            "required": true,
            "schema": {
              "title": "Rule Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert rule not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Rule",
        "tags": [
          "alert-rules"
        ]
      },
      "put": {
        "description": "Update an existing alert rule.\n\nArgs:\n    rule_id: Rule UUID\n    rule_data: Rule update data\n    db: Database session\n    cache: Cache service for cache invalidation (NEM-1952)\n\nReturns:\n    Updated AlertRule\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "alert-rules_update_rule",
        "parameters": [
          {
            "in": "path",
            "name": "rule_id",
            "required": true,
            "schema": {
              "title": "Rule Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AlertRuleUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertRuleResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Rule",
        "tags": [
          "alert-rules"
        ]
      }
    },
    "/api/alerts/rules/{rule_id}/test": {
      "post": {
        "description": "Test a rule against historical events.\n\nThis endpoint allows testing rule configuration without actually\ncreating alerts. Useful for validating rules before enabling them.\n\nArgs:\n    rule_id: Rule UUID\n    test_data: Test configuration (event IDs, time override)\n    db: Database session\n    engine: AlertRuleEngine injected via Depends()\n\nReturns:\n    RuleTestResponse with per-event match results\n\nRaises:\n    HTTPException: 404 if rule not found",
        "operationId": "alert-rules_test_rule",
        "parameters": [
          {
            "in": "path",
            "name": "rule_id",
            "required": true,
            "schema": {
              "title": "Rule Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RuleTestRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RuleTestResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert rule not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Test Rule",
        "tags": [
          "alert-rules"
        ]
      }
    },
    "/api/alerts/{alert_id}/acknowledge": {
      "post": {
        "description": "Acknowledge an alert.\n\nMarks an alert as acknowledged and broadcasts the state change via WebSocket.\nOnly alerts with status PENDING or DELIVERED can be acknowledged.\n\nUses optimistic locking to prevent race conditions when multiple requests\nattempt to modify the same alert concurrently. If a concurrent modification\nis detected, returns HTTP 409 Conflict.\n\nNEM-2582: WebSocket broadcast now uses background task with retry logic\nto ensure delivery without blocking the main request.\n\nArgs:\n    alert_id: Alert UUID\n    background_tasks: FastAPI background tasks for non-blocking broadcast\n    db: Database session\n\nReturns:\n    Updated AlertResponse\n\nRaises:\n    HTTPException: 404 if alert not found, 409 if alert cannot be acknowledged\n                  or if concurrent modification detected",
        "operationId": "alerts_acknowledge_alert",
        "parameters": [
          {
            "in": "path",
            "name": "alert_id",
            "required": true,
            "schema": {
              "title": "Alert Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert not found"
          },
          "409": {
            "description": "Alert cannot be acknowledged (wrong status or concurrent modification)"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Acknowledge Alert",
        "tags": [
          "alerts"
        ]
      }
    },
    "/api/alerts/{alert_id}/dismiss": {
      "post": {
        "description": "Dismiss an alert.\n\nMarks an alert as dismissed and broadcasts the state change via WebSocket.\nOnly alerts with status PENDING, DELIVERED, or ACKNOWLEDGED can be dismissed.\n\nUses optimistic locking to prevent race conditions when multiple requests\nattempt to modify the same alert concurrently. If a concurrent modification\nis detected, returns HTTP 409 Conflict.\n\nNEM-2582: WebSocket broadcast now uses background task with retry logic\nto ensure delivery without blocking the main request.\n\nArgs:\n    alert_id: Alert UUID\n    background_tasks: FastAPI background tasks for non-blocking broadcast\n    db: Database session\n\nReturns:\n    Updated AlertResponse\n\nRaises:\n    HTTPException: 404 if alert not found, 409 if alert cannot be dismissed\n                  or if concurrent modification detected",
        "operationId": "alerts_dismiss_alert",
        "parameters": [
          {
            "in": "path",
            "name": "alert_id",
            "required": true,
            "schema": {
              "title": "Alert Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Alert not found"
          },
          "409": {
            "description": "Alert cannot be dismissed (wrong status or concurrent modification)"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Dismiss Alert",
        "tags": [
          "alerts"
        ]
      }
    },
    "/api/analytics-zones/line-zones": {
      "post": {
        "description": "Create a new line zone for a camera.\n\nLine zones are virtual tripwires that detect and count objects\ncrossing from one side to the other. They are defined by start\nand end coordinates (in pixels).\n\nArgs:\n    data: Line zone creation data including camera_id and coordinates.\n    db: Database session.\n\nReturns:\n    The created LineZone with initial counts set to zero.\n\nRaises:\n    HTTPException: 404 if camera not found.",
        "operationId": "analytics-zones_create_line_zone",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LineZoneCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineZoneResponse"
                }
              }
            },
            "description": "Line zone created successfully"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create a new line zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/line-zones/camera/{camera_id}": {
      "get": {
        "description": "Get all line zones for a camera.\n\nArgs:\n    camera_id: ID of the camera to get zones for.\n    db: Database session.\n\nReturns:\n    List of LineZone objects for the camera.\n\nRaises:\n    HTTPException: 404 if camera not found.",
        "operationId": "analytics-zones_get_line_zones_by_camera",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineZoneListResponse"
                }
              }
            },
            "description": "Line zones retrieved successfully"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get all line zones for a camera",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/line-zones/{zone_id}": {
      "delete": {
        "description": "Delete a line zone.\n\nArgs:\n    zone_id: ID of the line zone to delete.\n    db: Database session.\n\nRaises:\n    HTTPException: 404 if line zone not found.",
        "operationId": "analytics-zones_delete_line_zone",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Line zone deleted successfully"
          },
          "404": {
            "description": "Line zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete a line zone",
        "tags": [
          "analytics-zones"
        ]
      },
      "get": {
        "description": "Get a line zone by ID.\n\nArgs:\n    zone_id: The unique identifier of the line zone.\n    db: Database session.\n\nReturns:\n    The LineZone with current crossing counts.\n\nRaises:\n    HTTPException: 404 if line zone not found.",
        "operationId": "analytics-zones_get_line_zone",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineZoneResponse"
                }
              }
            },
            "description": "Line zone retrieved successfully"
          },
          "404": {
            "description": "Line zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get a line zone by ID",
        "tags": [
          "analytics-zones"
        ]
      },
      "patch": {
        "description": "Update a line zone.\n\nOnly the fields present in the request body are updated.\n\nArgs:\n    zone_id: ID of the line zone to update.\n    data: Update data with optional fields.\n    db: Database session.\n\nReturns:\n    The updated LineZone.\n\nRaises:\n    HTTPException: 404 if line zone not found.",
        "operationId": "analytics-zones_update_line_zone",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LineZoneUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineZoneResponse"
                }
              }
            },
            "description": "Line zone updated successfully"
          },
          "404": {
            "description": "Line zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update a line zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/line-zones/{zone_id}/reset-counts": {
      "post": {
        "description": "Reset crossing counts for a line zone.\n\nSets both in_count and out_count to zero.\n\nArgs:\n    zone_id: ID of the line zone.\n    db: Database session.\n\nReturns:\n    The LineZone with reset counts.\n\nRaises:\n    HTTPException: 404 if line zone not found.",
        "operationId": "analytics-zones_reset_line_zone_counts",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LineZoneResponse"
                }
              }
            },
            "description": "Counts reset successfully"
          },
          "404": {
            "description": "Line zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Reset crossing counts for a line zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/polygon-zones": {
      "post": {
        "description": "Create a new polygon zone for a camera.\n\nPolygon zones monitor activity within defined areas.\nSupports various zone types for different monitoring scenarios.\n\nArgs:\n    data: Polygon zone creation data including camera_id and polygon.\n    db: Database session.\n\nReturns:\n    The created PolygonZone with initial count set to zero.\n\nRaises:\n    HTTPException: 404 if camera not found.",
        "operationId": "analytics-zones_create_polygon_zone",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PolygonZoneCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolygonZoneResponse"
                }
              }
            },
            "description": "Polygon zone created successfully"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create a new polygon zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/polygon-zones/camera/{camera_id}": {
      "get": {
        "description": "Get all polygon zones for a camera.\n\nArgs:\n    camera_id: ID of the camera to get zones for.\n    db: Database session.\n    active_only: If True, only return zones where is_active=True.\n        Defaults to True.\n\nReturns:\n    List of PolygonZone objects for the camera.\n\nRaises:\n    HTTPException: 404 if camera not found.",
        "operationId": "analytics-zones_get_polygon_zones_by_camera",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "If True, only return active zones. If False, return all zones.",
            "in": "query",
            "name": "active_only",
            "required": false,
            "schema": {
              "default": true,
              "description": "If True, only return active zones. If False, return all zones.",
              "title": "Active Only",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolygonZoneListResponse"
                }
              }
            },
            "description": "Polygon zones retrieved successfully"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get all polygon zones for a camera",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/polygon-zones/{zone_id}": {
      "delete": {
        "description": "Delete a polygon zone.\n\nArgs:\n    zone_id: ID of the polygon zone to delete.\n    db: Database session.\n\nRaises:\n    HTTPException: 404 if polygon zone not found.",
        "operationId": "analytics-zones_delete_polygon_zone",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Polygon zone deleted successfully"
          },
          "404": {
            "description": "Polygon zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete a polygon zone",
        "tags": [
          "analytics-zones"
        ]
      },
      "get": {
        "description": "Get a polygon zone by ID.\n\nArgs:\n    zone_id: The unique identifier of the polygon zone.\n    db: Database session.\n\nReturns:\n    The PolygonZone with current object count.\n\nRaises:\n    HTTPException: 404 if polygon zone not found.",
        "operationId": "analytics-zones_get_polygon_zone",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolygonZoneResponse"
                }
              }
            },
            "description": "Polygon zone retrieved successfully"
          },
          "404": {
            "description": "Polygon zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get a polygon zone by ID",
        "tags": [
          "analytics-zones"
        ]
      },
      "patch": {
        "description": "Update a polygon zone.\n\nOnly the fields present in the request body are updated.\n\nArgs:\n    zone_id: ID of the polygon zone to update.\n    data: Update data with optional fields.\n    db: Database session.\n\nReturns:\n    The updated PolygonZone.\n\nRaises:\n    HTTPException: 404 if polygon zone not found.",
        "operationId": "analytics-zones_update_polygon_zone",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PolygonZoneUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolygonZoneResponse"
                }
              }
            },
            "description": "Polygon zone updated successfully"
          },
          "404": {
            "description": "Polygon zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update a polygon zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/polygon-zones/{zone_id}/check-loitering": {
      "post": {
        "description": "Check for loitering in a polygon zone.\n\nIdentifies objects that have been dwelling in the zone longer than\nthe specified threshold. Returns alerts for all objects exceeding\nthe threshold, marking them as triggered in the database.\n\nArgs:\n    zone_id: ID of the polygon zone.\n    request: Loitering check request with threshold.\n    db: Database session.\n\nReturns:\n    Loitering alerts for objects exceeding the threshold.\n\nRaises:\n    HTTPException: 404 if polygon zone not found.",
        "operationId": "analytics-zones_check_loitering",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoiteringCheckRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LoiteringCheckResponse"
                }
              }
            },
            "description": "Loitering check completed successfully"
          },
          "404": {
            "description": "Polygon zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Check for loitering in a polygon zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/polygon-zones/{zone_id}/dwell-history": {
      "get": {
        "description": "Get historical dwell time records for a polygon zone.\n\nReturns all dwell time records that overlap with the specified time window.\nBy default, retrieves the last 24 hours of data.\n\nArgs:\n    zone_id: ID of the polygon zone.\n    db: Database session.\n    start_time: Start of the time window (defaults to 24 hours ago).\n    end_time: End of the time window (defaults to now).\n    include_active: Whether to include currently active records.\n\nReturns:\n    Historical dwell time records.\n\nRaises:\n    HTTPException: 404 if polygon zone not found.",
        "operationId": "analytics-zones_get_dwell_history",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          },
          {
            "description": "Start of time window (defaults to 24 hours ago)",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Start of time window (defaults to 24 hours ago)",
              "title": "Start Time"
            }
          },
          {
            "description": "End of time window (defaults to now)",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "End of time window (defaults to now)",
              "title": "End Time"
            }
          },
          {
            "description": "Whether to include currently active dwellers",
            "in": "query",
            "name": "include_active",
            "required": false,
            "schema": {
              "default": true,
              "description": "Whether to include currently active dwellers",
              "title": "Include Active",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DwellHistoryResponse"
                }
              }
            },
            "description": "Dwell history retrieved successfully"
          },
          "404": {
            "description": "Polygon zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get dwell time history for a polygon zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/polygon-zones/{zone_id}/dwell-statistics": {
      "get": {
        "description": "Get dwell time statistics for a polygon zone.\n\nReturns aggregated statistics including average, min, max dwell times\nand the number of loitering alerts triggered in the time window.\n\nArgs:\n    zone_id: ID of the polygon zone.\n    db: Database session.\n    start_time: Start of the statistics window (defaults to 24 hours ago).\n    end_time: End of the statistics window (defaults to now).\n\nReturns:\n    Dwell time statistics for the zone.\n\nRaises:\n    HTTPException: 404 if polygon zone not found.",
        "operationId": "analytics-zones_get_dwell_statistics",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          },
          {
            "description": "Start of statistics window (defaults to 24 hours ago)",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Start of statistics window (defaults to 24 hours ago)",
              "title": "Start Time"
            }
          },
          {
            "description": "End of statistics window (defaults to now)",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "End of statistics window (defaults to now)",
              "title": "End Time"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DwellStatisticsResponse"
                }
              }
            },
            "description": "Dwell statistics retrieved successfully"
          },
          "404": {
            "description": "Polygon zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get dwell time statistics for a polygon zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/polygon-zones/{zone_id}/dwellers": {
      "get": {
        "description": "Get all objects currently dwelling in a polygon zone.\n\nReturns objects that have entered the zone but have not yet exited.\nEach object includes the current dwell time calculated at request time.\n\nArgs:\n    zone_id: ID of the polygon zone.\n    db: Database session.\n\nReturns:\n    List of active dwellers with current dwell times.\n\nRaises:\n    HTTPException: 404 if polygon zone not found.",
        "operationId": "analytics-zones_get_active_dwellers",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActiveDwellersListResponse"
                }
              }
            },
            "description": "Active dwellers retrieved successfully"
          },
          "404": {
            "description": "Polygon zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get active dwellers in a polygon zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics-zones/polygon-zones/{zone_id}/toggle-active": {
      "post": {
        "description": "Toggle the active status of a polygon zone.\n\nToggles is_active between True and False.\n\nArgs:\n    zone_id: ID of the polygon zone.\n    db: Database session.\n\nReturns:\n    The PolygonZone with updated active status.\n\nRaises:\n    HTTPException: 404 if polygon zone not found.",
        "operationId": "analytics-zones_toggle_polygon_zone_active",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolygonZoneResponse"
                }
              }
            },
            "description": "Active status toggled successfully"
          },
          "404": {
            "description": "Polygon zone not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Toggle the active status of a polygon zone",
        "tags": [
          "analytics-zones"
        ]
      }
    },
    "/api/analytics/camera-uptime": {
      "get": {
        "description": "Get uptime percentage per camera.\n\nReturns uptime percentage and detection count for each camera.\nUptime is calculated based on the number of days with at least one detection\ndivided by the total days in the date range.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    db: Database session\n\nReturns:\n    CameraUptimeResponse with per-camera uptime data\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "analytics_get_camera_uptime",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraUptimeResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Camera Uptime",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/analytics/detection-trends": {
      "get": {
        "description": "Get detection counts aggregated by day.\n\nReturns daily detection counts for the specified date range.\nCreates one data point per day even if there are no detections.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    db: Database session\n\nReturns:\n    DetectionTrendsResponse with daily detection counts\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "analytics_get_detection_trends",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionTrendsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Detection Trends",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/analytics/object-distribution": {
      "get": {
        "description": "Get detection counts by object type.\n\nReturns detection counts grouped by object type with percentages.\nOnly includes detections with non-null object_type.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    db: Database session\n\nReturns:\n    ObjectDistributionResponse with object type counts and percentages\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "analytics_get_object_distribution",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectDistributionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Object Distribution",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/analytics/risk-history": {
      "get": {
        "description": "Get risk score distribution over time.\n\nReturns daily counts of events grouped by risk level (low, medium, high, critical).\nCreates one data point per day even if there are no events.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    db: Database session\n\nReturns:\n    RiskHistoryResponse with daily risk level counts\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "analytics_get_risk_history",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RiskHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Risk History",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/analytics/risk-score-distribution": {
      "get": {
        "description": "Get risk score distribution as a histogram.\n\nReturns counts of events grouped into score buckets (e.g., 0-10, 10-20, ..., 90-100).\nOnly includes events with non-null risk_score.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    bucket_size: Size of each bucket (default 10 for buckets 0-10, 10-20, etc.)\n    db: Database session\n\nReturns:\n    RiskScoreDistributionResponse with histogram buckets\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "analytics_get_risk_score_distribution",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          },
          {
            "description": "Size of each score bucket (default: 10)",
            "in": "query",
            "name": "bucket_size",
            "required": false,
            "schema": {
              "default": 10,
              "description": "Size of each score bucket (default: 10)",
              "maximum": 50,
              "minimum": 1,
              "title": "Bucket Size",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RiskScoreDistributionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range or bucket size"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Risk Score Distribution",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/analytics/risk-score-trends": {
      "get": {
        "description": "Get average risk score trends over time.\n\nReturns daily average risk scores for the specified date range.\nCreates one data point per day even if there are no events.\n\nArgs:\n    start_date: Start date (inclusive)\n    end_date: End date (inclusive)\n    db: Database session\n\nReturns:\n    RiskScoreTrendsResponse with daily average scores and event counts\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "analytics_get_risk_score_trends",
        "parameters": [
          {
            "description": "Start date for analytics (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for analytics (ISO format)",
              "format": "date",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for analytics (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for analytics (ISO format)",
              "format": "date",
              "title": "End Date",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RiskScoreTrendsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Risk Score Trends",
        "tags": [
          "analytics"
        ]
      }
    },
    "/api/audit": {
      "get": {
        "description": "List audit logs with optional filtering and cursor-based pagination.\n\nThis endpoint is intended for admin use to review security-sensitive operations.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\n**Performance Note:** Total count queries are expensive for large datasets. By default,\nthe total count is not calculated (returns 0). Use `include_total_count=true` only when\nthe total count is needed (e.g., for displaying \"X of Y results\" in UI). For pagination,\n`has_more` and `next_cursor` provide sufficient information.\n\nArgs:\n    action: Optional action type to filter by\n    resource_type: Optional resource type to filter by\n    resource_id: Optional specific resource ID to filter by\n    actor: Optional actor to filter by\n    status_filter: Optional status to filter by (success/failure)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    limit: Maximum number of results to return (1-1000, default 100)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    include_total_count: Whether to calculate total count (default False for performance)\n    db: Database session\n\nReturns:\n    AuditLogListResponse containing filtered logs and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid",
        "operationId": "audit_list_audit_logs",
        "parameters": [
          {
            "description": "Filter by action type",
            "in": "query",
            "name": "action",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by action type",
              "title": "Action"
            }
          },
          {
            "description": "Filter by resource type",
            "in": "query",
            "name": "resource_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by resource type",
              "title": "Resource Type"
            }
          },
          {
            "description": "Filter by resource ID",
            "in": "query",
            "name": "resource_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by resource ID",
              "title": "Resource Id"
            }
          },
          {
            "description": "Filter by actor",
            "in": "query",
            "name": "actor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by actor",
              "title": "Actor"
            }
          },
          {
            "description": "Filter by status (success/failure)",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by status (success/failure)",
              "title": "Status"
            }
          },
          {
            "description": "Filter from date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter from date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter to date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter to date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Page size",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 100,
              "description": "Page size",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip (deprecated, use cursor)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor from previous response",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            }
          },
          {
            "description": "Include total count in response. Defaults to False for performance. Total count queries are expensive for large datasets. For cursor-based pagination, has_more and next_cursor provide sufficient information without the total count.",
            "in": "query",
            "name": "include_total_count",
            "required": false,
            "schema": {
              "default": false,
              "description": "Include total count in response. Defaults to False for performance. Total count queries are expensive for large datasets. For cursor-based pagination, has_more and next_cursor provide sufficient information without the total count.",
              "title": "Include Total Count",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditLogListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid date range or cursor"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Audit Logs",
        "tags": [
          "audit"
        ]
      }
    },
    "/api/audit/stats": {
      "get": {
        "description": "Get audit log statistics for dashboard.\n\nReturns aggregated statistics about audit logs including:\n- Total log count\n- Logs today\n- Breakdown by action type\n- Breakdown by resource type\n- Breakdown by status\n- Recently active actors\n\nThis endpoint is optimized to use a single aggregation query for counts\n(total, today, by_action, by_resource_type, by_status) plus one query\nfor recent actors, reducing database round-trips from 6 to 2.\n\nArgs:\n    db: Database session\n\nReturns:\n    AuditLogStats with aggregated statistics",
        "operationId": "audit_get_audit_stats",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditLogStats"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid date range"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Audit Stats",
        "tags": [
          "audit"
        ]
      }
    },
    "/api/audit/{audit_id}": {
      "get": {
        "description": "Get a specific audit log entry by ID.\n\nArgs:\n    audit_id: Audit log ID\n    db: Database session\n\nReturns:\n    AuditLog record\n\nRaises:\n    HTTPException: 404 if audit log not found",
        "operationId": "audit_get_audit_log",
        "parameters": [
          {
            "in": "path",
            "name": "audit_id",
            "required": true,
            "schema": {
              "title": "Audit Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditLogResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Audit log not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Audit Log",
        "tags": [
          "audit"
        ]
      }
    },
    "/api/calibration": {
      "get": {
        "description": "Get the current user's calibration settings.\n\nReturns the calibration thresholds for the default user.\nIf no calibration exists, one is automatically created with default values.\n\nReturns:\n    CalibrationResponse with current threshold settings",
        "operationId": "calibration_get_calibration",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserCalibrationResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Calibration",
        "tags": [
          "calibration"
        ]
      },
      "patch": {
        "description": "Partially update calibration thresholds.\n\nAllows partial updates - only provided fields will be changed.\nValidates that threshold ordering is maintained (low < medium < high).\n\nArgs:\n    update_data: Fields to update (partial updates supported)\n    db: Database session\n\nReturns:\n    Updated CalibrationResponse\n\nRaises:\n    HTTPException: 422 if threshold ordering would be violated",
        "operationId": "calibration_patch_calibration",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserCalibrationUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserCalibrationResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error (invalid threshold ordering)"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Patch Calibration",
        "tags": [
          "calibration"
        ]
      },
      "put": {
        "description": "Update calibration thresholds (full replacement semantics).\n\nAllows partial updates - only provided fields will be changed.\nValidates that threshold ordering is maintained (low < medium < high).\n\nNote: For REST semantics, use PATCH for partial updates. This PUT endpoint\nis kept for backward compatibility and behaves identically to PATCH.\n\nArgs:\n    update_data: Fields to update (partial updates supported)\n    db: Database session\n\nReturns:\n    Updated CalibrationResponse\n\nRaises:\n    HTTPException: 422 if threshold ordering would be violated",
        "operationId": "calibration_update_calibration",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserCalibrationUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserCalibrationResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error (invalid threshold ordering)"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Calibration",
        "tags": [
          "calibration"
        ]
      }
    },
    "/api/calibration/defaults": {
      "get": {
        "description": "Get default calibration threshold values.\n\nReturns the default values used when creating new calibrations\nor when resetting to defaults. This endpoint is useful for\ndisplaying defaults in the UI or documentation.\n\nReturns:\n    CalibrationDefaultsResponse with default threshold values",
        "operationId": "calibration_get_calibration_defaults",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CalibrationDefaultsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Calibration Defaults",
        "tags": [
          "calibration"
        ]
      }
    },
    "/api/calibration/reset": {
      "post": {
        "description": "Reset calibration to default thresholds.\n\nResets all thresholds to their default values:\n- low_threshold: 30\n- medium_threshold: 60\n- high_threshold: 85\n- decay_factor: 0.1\n\nNote: Feedback counts (correct_count, false_positive_count, missed_threat_count,\nseverity_wrong_count) are NOT reset by this operation.\n\nReturns:\n    CalibrationResetResponse with success message and reset calibration data",
        "operationId": "calibration_reset_calibration",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CalibrationResetResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Reset Calibration",
        "tags": [
          "calibration"
        ]
      }
    },
    "/api/cameras": {
      "get": {
        "description": "List all cameras with optional status filter.\n\nUses Redis cache with cache-aside pattern to improve performance\nand generate cache hit metrics.\n\nSparse Fieldsets (NEM-1434):\nUse the `fields` parameter to request only specific fields in the response,\nreducing payload size. Example: ?fields=id,name,status\n\nArgs:\n    status_filter: Optional status to filter cameras by (online, offline, error)\n    fields: Comma-separated list of fields to include (sparse fieldsets)\n    db: Database session\n    cache: Cache service injected via FastAPI DI\n\nReturns:\n    CameraListResponse containing list of cameras and total count\n\nRaises:\n    HTTPException: 400 if invalid fields are requested",
        "operationId": "cameras_list_cameras",
        "parameters": [
          {
            "description": "Filter by camera status",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera status",
              "title": "Status"
            }
          },
          {
            "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, name, folder_path, status, created_at, last_seen_at",
            "in": "query",
            "name": "fields",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, name, folder_path, status, created_at, last_seen_at",
              "title": "Fields"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Cameras",
        "tags": [
          "cameras"
        ]
      },
      "post": {
        "description": "Create a new camera.\n\nArgs:\n    camera_data: Camera creation data\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    Created camera object with generated ID\n\nRaises:\n    HTTPException: 409 if camera with same name or folder_path already exists",
        "operationId": "cameras_create_camera",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Camera",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/deleted": {
      "get": {
        "description": "List all soft-deleted cameras for trash view.\n\nReturns cameras that have been soft-deleted (deleted_at is not null),\nordered by deleted_at descending (most recently deleted first).\n\nThis endpoint enables a \"trash\" view where users can see deleted cameras\nand optionally restore them.\n\nArgs:\n    db: Database session\n\nReturns:\n    DeletedCamerasListResponse containing list of deleted cameras and count",
        "operationId": "cameras_list_deleted_cameras",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeletedCamerasListResponse"
                }
              }
            },
            "description": "List of soft-deleted cameras"
          }
        },
        "summary": "List all soft-deleted cameras",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/validation/paths": {
      "get": {
        "description": "Validate all camera folder paths against the configured base path.\n\nThis endpoint checks each camera's folder_path to determine:\n1. Whether the path is under the configured FOSCAM_BASE_PATH\n2. Whether the directory exists on disk\n3. Whether the directory contains any images or video files\n\nNEM-2446: Video files (.mkv, .mp4, etc.) are now valid for snapshot\nextraction, so cameras with only video files pass validation.\n\nUse this to diagnose cameras that show \"No snapshot available\" errors.\n\nReturns:\n    CameraPathValidationResponse with validation results for all cameras",
        "operationId": "cameras_validate_camera_paths",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraPathValidationResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Validate Camera Paths",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}": {
      "delete": {
        "description": "Delete a camera.\n\nThis operation cascades to all related detections and events.\n\nArgs:\n    camera_id: Normalized camera ID (e.g., \"front_door\", \"backyard\")\n    request: FastAPI request for audit logging\n    db: Database session\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "cameras_delete_camera",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Camera",
        "tags": [
          "cameras"
        ]
      },
      "get": {
        "description": "Get a specific camera by ID.\n\nArgs:\n    camera_id: Normalized camera ID (e.g., \"front_door\", \"backyard\")\n    db: Database session\n\nReturns:\n    CameraResponse with camera data\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "cameras_get_camera",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera",
        "tags": [
          "cameras"
        ]
      },
      "patch": {
        "description": "Update an existing camera.\n\nArgs:\n    camera_id: Normalized camera ID (e.g., \"front_door\", \"backyard\")\n    camera_data: Camera update data (all fields optional)\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    Updated camera object\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "cameras_update_camera",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Camera",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/baseline": {
      "get": {
        "description": "Get baseline activity data for a camera.\n\nReturns comprehensive baseline statistics including:\n- Hourly activity patterns (0-23 hours)\n- Daily patterns (by day of week)\n- Object-specific baselines\n- Current deviation from baseline\n\nArgs:\n    camera_id: ID of the camera\n    db: Database session\n    baseline_service: BaselineService injected via Depends()\n\nReturns:\n    BaselineSummaryResponse with all baseline data\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "cameras_get_camera_baseline",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BaselineSummaryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Baseline",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/baseline/activity": {
      "get": {
        "description": "Get raw activity baseline data for a camera.\n\nReturns up to 168 entries (24 hours x 7 days) representing the full\nweekly activity heatmap. Each entry contains the average count and\nsample count for that hour/day combination.\n\nArgs:\n    camera_id: ID of the camera\n    db: Database session\n    baseline_service: BaselineService injected via Depends()\n\nReturns:\n    ActivityBaselineResponse with entries for the heatmap\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "cameras_get_camera_activity_baseline",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActivityBaselineResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Activity Baseline",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/baseline/anomalies": {
      "get": {
        "description": "Get recent anomaly events for a camera.\n\nReturns a list of anomaly events detected within the specified time period.\nAnomalies are detections that significantly deviate from the established\nbaseline activity patterns.\n\nArgs:\n    camera_id: ID of the camera\n    days: Number of days to look back (default: 7, max: 90)\n    db: Database session\n    baseline_service: BaselineService injected via Depends()\n\nReturns:\n    AnomalyListResponse with list of anomaly events\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "cameras_get_camera_baseline_anomalies",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Number of days to look back",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "default": 7,
              "description": "Number of days to look back",
              "maximum": 90,
              "minimum": 1,
              "title": "Days",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnomalyListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Baseline Anomalies",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/baseline/classes": {
      "get": {
        "description": "Get class frequency baseline data for a camera.\n\nReturns baseline entries grouped by object class and hour, showing\nthe frequency of each object type at different times of day.\n\nArgs:\n    camera_id: ID of the camera\n    db: Database session\n    baseline_service: BaselineService injected via Depends()\n\nReturns:\n    ClassBaselineResponse with entries for each class/hour combination\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "cameras_get_camera_class_baseline",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClassBaselineResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Class Baseline",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/restore": {
      "post": {
        "description": "Restore a soft-deleted camera.\n\nClears the deleted_at timestamp on a soft-deleted camera, making it\nvisible again in normal queries.\n\nArgs:\n    camera_id: ID of the camera to restore\n    db: Database session\n    cache: Cache service for invalidation\n\nReturns:\n    CameraResponse with the restored camera data\n\nRaises:\n    HTTPException: 404 if camera not found\n    HTTPException: 400 if camera is not deleted (nothing to restore)",
        "operationId": "cameras_restore_camera",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraResponse"
                }
              }
            },
            "description": "Camera restored successfully"
          },
          "400": {
            "description": "Camera is not deleted"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Restore a soft-deleted camera",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/scene-changes": {
      "get": {
        "description": "Get scene changes for a camera with cursor-based pagination.\n\nReturns a list of detected scene changes that may indicate camera\ntampering, angle changes, or blocked views. Uses cursor-based pagination\nfor efficient navigation through large datasets.\n\nArgs:\n    camera_id: ID of the camera\n    acknowledged: Filter by acknowledgement status (None = all)\n    limit: Maximum number of results (default: 50, max: 100)\n    cursor: Cursor for pagination (detected_at timestamp from previous response)\n    db: Database session\n\nReturns:\n    SceneChangeListResponse with list of scene changes and pagination info\n\nRaises:\n    HTTPException: 404 if camera not found",
        "operationId": "cameras_get_camera_scene_changes",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Filter by acknowledgement status",
            "in": "query",
            "name": "acknowledged",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by acknowledgement status",
              "title": "Acknowledged"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Cursor for pagination (detected_at timestamp)",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Cursor for pagination (detected_at timestamp)",
              "title": "Cursor"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneChangeListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Camera Scene Changes",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/scene-changes/{scene_change_id}/acknowledge": {
      "post": {
        "description": "Acknowledge a scene change alert.\n\nMarks a scene change as acknowledged to indicate it has been reviewed.\n\nArgs:\n    camera_id: ID of the camera\n    scene_change_id: ID of the scene change to acknowledge\n    request: FastAPI request for audit logging\n    db: Database session\n\nReturns:\n    SceneChangeAcknowledgeResponse confirming acknowledgement\n\nRaises:\n    HTTPException: 404 if camera or scene change not found",
        "operationId": "cameras_acknowledge_scene_change",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "scene_change_id",
            "required": true,
            "schema": {
              "title": "Scene Change Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneChangeAcknowledgeResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Acknowledge Scene Change",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/snapshot": {
      "get": {
        "description": "Return the latest image for a camera (best-effort snapshot).\n\nThis endpoint is exempt from API key authentication because:\n1. It serves static image content accessed directly by browsers via <img> tags\n2. It has its own security controls (path traversal protection, file type allowlist)\n3. It has rate limiting to prevent abuse\n\nThis endpoint uses the camera's configured `folder_path` and returns the most recently\nmodified image file under that directory.\n\nNEM-2446: Now supports video-only cameras by extracting and caching frames.",
        "operationId": "cameras_get_camera_snapshot",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Snapshot served successfully"
          },
          "404": {
            "description": "Camera or snapshot not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Get Camera Snapshot",
        "tags": [
          "cameras"
        ]
      }
    },
    "/api/cameras/{camera_id}/zones": {
      "get": {
        "description": "List all zones for a camera with optional filtering.\n\nArgs:\n    camera_id: ID of the camera\n    db: Database session\n    enabled: Optional filter for enabled/disabled zones\n\nReturns:\n    ZoneListResponse containing list of zones and total count",
        "operationId": "zones_list_zones",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Filter by enabled status",
            "in": "query",
            "name": "enabled",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by enabled status",
              "title": "Enabled"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Zones",
        "tags": [
          "zones"
        ]
      },
      "post": {
        "description": "Create a new zone for a camera.\n\nArgs:\n    camera_id: ID of the camera\n    zone_data: Zone creation data\n    db: Database session\n\nReturns:\n    Created zone object with generated ID",
        "operationId": "zones_create_zone",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZoneCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Zone",
        "tags": [
          "zones"
        ]
      }
    },
    "/api/cameras/{camera_id}/zones/{zone_id}": {
      "delete": {
        "description": "Delete a zone.\n\nArgs:\n    camera_id: ID of the camera\n    zone_id: ID of the zone to delete\n    db: Database session\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "zones_delete_zone",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Zone",
        "tags": [
          "zones"
        ]
      },
      "get": {
        "description": "Get a specific zone by ID.\n\nArgs:\n    camera_id: ID of the camera\n    zone_id: ID of the zone\n    db: Database session\n\nReturns:\n    CameraZone object\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "zones_get_zone",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Zone",
        "tags": [
          "zones"
        ]
      },
      "put": {
        "description": "Update an existing zone.\n\nArgs:\n    camera_id: ID of the camera\n    zone_id: ID of the zone to update\n    zone_data: Zone update data (all fields optional)\n    db: Database session\n\nReturns:\n    Updated zone object\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "zones_update_zone",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZoneUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Zone",
        "tags": [
          "zones"
        ]
      }
    },
    "/api/debug/circuit-breakers": {
      "get": {
        "description": "Get all circuit breaker states.\n\nReturns the current state and metrics for all registered circuit breakers,\nincluding failure counts, success counts, and configuration.\n\nNEM-1642: Debug endpoint for circuit breaker diagnostics",
        "operationId": "debug_get_circuit_breakers",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebugCircuitBreakersResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Circuit Breakers",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/config": {
      "get": {
        "description": "Get current configuration with sensitive values redacted.\n\nReturns all configuration settings with passwords, API keys, and other\nsensitive values replaced with [REDACTED]. URLs containing passwords\nwill have only the password portion redacted, preserving the structure.\n\nNEM-1642: Debug endpoint for configuration inspection",
        "operationId": "debug_get_config",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebugConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Config",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/log-level": {
      "get": {
        "description": "Get current log level.\n\nNEM-1471: Log level inspection endpoint",
        "operationId": "debug_get_log_level",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogLevelResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Log Level",
        "tags": [
          "debug"
        ]
      },
      "post": {
        "description": "Set log level at runtime for debugging.\n\nAllows changing the log level without restarting the application.\nUseful for temporarily enabling DEBUG logging to investigate issues.\n\nNEM-1471: Log level runtime override\n\nArgs:\n    request: Log level request with new level\n\nReturns:\n    Current and previous log level\n\nRaises:\n    HTTPException: If the log level is invalid",
        "operationId": "debug_set_log_level",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LogLevelRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogLevelResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid log level"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Set Log Level",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/memory": {
      "get": {
        "description": "Get detailed memory statistics for debugging memory issues.\n\nReturns process memory usage, garbage collector stats, and the top\nobject types consuming memory. Useful for detecting memory leaks.\n\nArgs:\n    top_n: Number of top object types to return (default: 20)\n    force_gc: Force garbage collection before measuring (default: False)\n\nReturns:\n    Detailed memory statistics",
        "operationId": "debug_get_memory_stats",
        "parameters": [
          {
            "in": "query",
            "name": "top_n",
            "required": false,
            "schema": {
              "default": 20,
              "title": "Top N",
              "type": "integer"
            }
          },
          {
            "in": "query",
            "name": "force_gc",
            "required": false,
            "schema": {
              "default": false,
              "title": "Force Gc",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MemoryStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Memory Stats",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/memory/gc": {
      "post": {
        "description": "Trigger garbage collection and return stats.\n\nForces a full garbage collection cycle and returns the number of\nobjects collected. Useful for testing if memory can be reclaimed.\n\nReturns:\n    GC collection statistics",
        "operationId": "debug_trigger_gc",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": true,
                  "title": "Response Debug Trigger Gc",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Trigger Gc",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/memory/tracemalloc/start": {
      "post": {
        "description": "Start tracemalloc memory tracing.\n\nEnables detailed memory allocation tracking. This adds some overhead\nbut allows tracking where memory is being allocated.\n\nArgs:\n    nframes: Number of stack frames to capture (default: 25)\n\nReturns:\n    Status of tracemalloc",
        "operationId": "debug_start_tracemalloc",
        "parameters": [
          {
            "in": "query",
            "name": "nframes",
            "required": false,
            "schema": {
              "default": 25,
              "title": "Nframes",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": true,
                  "title": "Response Debug Start Tracemalloc",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Start Tracemalloc",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/memory/tracemalloc/stop": {
      "post": {
        "description": "Stop tracemalloc memory tracing.\n\nStops memory allocation tracking and clears the trace data.\n\nReturns:\n    Final memory statistics before stopping",
        "operationId": "debug_stop_tracemalloc",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": true,
                  "title": "Response Debug Stop Tracemalloc",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Stop Tracemalloc",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/pipeline-errors": {
      "get": {
        "description": "Get recent pipeline errors from the AI analysis pipeline.\n\nRetrieves errors stored in Redis for debugging pipeline issues.\nSupports optional filtering by component and error type.\n\nArgs:\n    limit: Maximum number of errors to return (default: 10, max: 100)\n    component: Optional filter by component (e.g., \"detector\", \"analyzer\")\n    error_type: Optional filter by error type (e.g., \"connection_error\")\n\nReturns:\n    List of recent pipeline errors with metadata\n\nNEM-2485: Pipeline errors retrieval endpoint for Debug API",
        "operationId": "debug_get_pipeline_errors",
        "parameters": [
          {
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 10,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "in": "query",
            "name": "component",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Component"
            }
          },
          {
            "in": "query",
            "name": "error_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Error Type"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineErrorsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Pipeline Errors",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/pipeline-state": {
      "get": {
        "description": "Get current state of the AI processing pipeline.\n\nReturns queue depths, worker status, and recent errors for debugging\npipeline issues and monitoring system health.\n\nArgs:\n    error_limit: Maximum number of recent errors to return (default: 10, max: 100)\n\nNEM-1470: Debug endpoint for pipeline state inspection\nNEM-2485: Complete pipeline errors retrieval implementation",
        "operationId": "debug_get_pipeline_state",
        "parameters": [
          {
            "in": "query",
            "name": "error_limit",
            "required": false,
            "schema": {
              "default": 10,
              "title": "Error Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineStateResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Pipeline State",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/profile/start": {
      "post": {
        "description": "Start performance profiling.\n\nBegins collecting profiling data for performance analysis.\nProfile data is saved to disk when stop is called.\n\nNEM-1644: Debug endpoint for performance profiling\n\nReturns:\n    Profiling start status",
        "operationId": "debug_start_profiling",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProfileStartResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Start Profiling",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/profile/stats": {
      "get": {
        "description": "Get current profiling statistics.\n\nReturns the current profiling state and statistics from the last\ncompleted profiling session.\n\nNEM-1644: Debug endpoint for performance profiling\n\nReturns:\n    Profiling status and statistics",
        "operationId": "debug_get_profile_stats",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProfileStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Profile Stats",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/profile/stop": {
      "post": {
        "description": "Stop performance profiling and save results.\n\nStops the profiler and saves the profile data to a .prof file.\nThe file can be analyzed with snakeviz or py-spy.\n\nNEM-1644: Debug endpoint for performance profiling\n\nReturns:\n    Profiling stop status with path to saved profile",
        "operationId": "debug_stop_profiling",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProfileStopResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Stop Profiling",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/recordings": {
      "get": {
        "description": "List available request recordings.\n\nReturns a list of recorded requests, sorted by timestamp (newest first).\nUse the recording_id to replay a specific request.\n\nNEM-1646: Request recording and replay for debugging\n\nArgs:\n    limit: Maximum number of recordings to return (default: 50)\n\nReturns:\n    List of recordings with metadata",
        "operationId": "debug_list_recordings",
        "parameters": [
          {
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecordingsListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Recordings",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/recordings/{recording_id}": {
      "delete": {
        "description": "Delete a specific recording.\n\nNEM-1646: Request recording management\n\nArgs:\n    recording_id: ID of the recording to delete\n\nReturns:\n    Confirmation message\n\nRaises:\n    HTTPException: 404 if recording not found",
        "operationId": "debug_delete_recording",
        "parameters": [
          {
            "in": "path",
            "name": "recording_id",
            "required": true,
            "schema": {
              "title": "Recording Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Debug Delete Recording",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Recording",
        "tags": [
          "debug"
        ]
      },
      "get": {
        "description": "Get details of a specific recording.\n\nReturns the full recording data including headers, body, and response.\n\nNEM-1646: Request recording and replay for debugging\n\nArgs:\n    recording_id: ID of the recording to retrieve\n\nReturns:\n    Full recording data\n\nRaises:\n    HTTPException: 404 if recording not found",
        "operationId": "debug_get_recording",
        "parameters": [
          {
            "in": "path",
            "name": "recording_id",
            "required": true,
            "schema": {
              "title": "Recording Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": true,
                  "title": "Response Debug Get Recording",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Recording",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/redis/info": {
      "get": {
        "description": "Get Redis connection stats and pub/sub channel information.\n\nReturns Redis server info, memory usage, connection stats, and\nactive pub/sub channels with their subscriber counts.\n\nNEM-1642: Debug endpoint for Redis diagnostics",
        "operationId": "debug_get_redis_info",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RedisInfoResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Redis Info",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/replay/{recording_id}": {
      "post": {
        "description": "Replay a recorded request for debugging.\n\nReconstructs the original request from the recording and executes it\nagainst the current application. This is useful for:\n- Reproducing production issues locally\n- Testing fixes for error scenarios\n- Debugging intermittent failures\n\nSECURITY: This endpoint is only available when debug=True and requires\nthe request to pass through the debug mode gate.\n\nNEM-1646: Request recording and replay for debugging\n\nArgs:\n    recording_id: ID of the recording to replay\n\nReturns:\n    Replay response with original and new status codes\n\nRaises:\n    HTTPException: 404 if recording not found",
        "operationId": "debug_replay_request",
        "parameters": [
          {
            "in": "path",
            "name": "recording_id",
            "required": true,
            "schema": {
              "title": "Recording Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReplayResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Replay Request",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/debug/websocket/connections": {
      "get": {
        "description": "Get active WebSocket connection states.\n\nReturns connection counts and health status for both the event broadcaster\n(security event stream) and system broadcaster (system status stream).\n\nNEM-1642: Debug endpoint for WebSocket diagnostics",
        "operationId": "debug_get_websocket_connections",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketConnectionsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Not found - Debug mode disabled"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Websocket Connections",
        "tags": [
          "debug"
        ]
      }
    },
    "/api/detections": {
      "get": {
        "description": "List detections with optional filtering and cursor-based pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\nSparse Fieldsets (NEM-1434):\nUse the `fields` parameter to request only specific fields in the response,\nreducing payload size. Example: ?fields=id,camera_id,object_type,confidence\n\nArgs:\n    camera_id: Optional camera ID to filter by\n    object_type: Optional object type to filter by (person, car, etc.)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    min_confidence: Optional minimum confidence score (0-1)\n    limit: Maximum number of results to return (1-100, default 50)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    fields: Comma-separated list of fields to include (sparse fieldsets)\n    db: Database session\n\nReturns:\n    DetectionListResponse containing filtered detections and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid\n    HTTPException: 400 if invalid fields are requested",
        "operationId": "detections_list_detections",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by object type",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by object type",
              "title": "Object Type"
            }
          },
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Minimum confidence score",
            "in": "query",
            "name": "min_confidence",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Minimum confidence score",
              "title": "Min Confidence"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip (deprecated, use cursor)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor from previous response",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            }
          },
          {
            "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, file_path, file_type, detected_at, object_type, confidence, bbox_x, bbox_y, bbox_width, bbox_height, thumbnail_path, media_type, duration, video_codec, video_width, video_height, enrichment_data",
            "in": "query",
            "name": "fields",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, file_path, file_type, detected_at, object_type, confidence, bbox_x, bbox_y, bbox_width, bbox_height, thumbnail_path, media_type, duration, video_codec, video_width, video_height, enrichment_data",
              "title": "Fields"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Detections",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/bulk": {
      "delete": {
        "description": "Delete multiple detections in a single request.\n\nSupports partial success - some deletions may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nNote: Detection deletion is always hard delete as detections are raw data\nand soft-delete is not supported.\n\nRate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).\n\nArgs:\n    request: Bulk delete request with up to 100 detection IDs\n    db: Database session\n    cache: Cache service for invalidation (NEM-1951)\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "detections_bulk_delete_detections",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetectionBulkDeleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          },
          "429": {
            "description": "Rate limit exceeded"
          }
        },
        "summary": "Bulk delete detections",
        "tags": [
          "detections"
        ]
      },
      "patch": {
        "description": "Update multiple detections in a single request.\n\nSupports partial success - some updates may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).\n\nArgs:\n    request: Bulk update request with up to 100 detection updates\n    db: Database session\n    cache: Cache service for invalidation (NEM-1951)\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "detections_bulk_update_detections",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetectionBulkUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          },
          "429": {
            "description": "Rate limit exceeded"
          }
        },
        "summary": "Bulk update detections",
        "tags": [
          "detections"
        ]
      },
      "post": {
        "description": "Create multiple detections in a single request.\n\nSupports partial success - some detections may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).\n\nArgs:\n    request: Bulk create request with up to 100 detections\n    db: Database session\n    cache: Cache service for invalidation (NEM-1951)\n\nReturns:\n    DetectionBulkCreateResponse with per-item results",
        "operationId": "detections_bulk_create_detections",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetectionBulkCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionBulkCreateResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          },
          "429": {
            "description": "Rate limit exceeded"
          }
        },
        "summary": "Bulk create detections",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/export": {
      "get": {
        "description": "Export detections as CSV or JSON file for external analysis.\n\nSupports content negotiation via HTTP Accept header:\n- `Accept: text/csv` or `Accept: application/csv` - CSV format (default)\n- `Accept: application/json` - JSON format\n\nThis endpoint is rate-limited to 10 requests per minute per client IP.\n\nExports detections with the following fields:\n- Detection ID, camera name, detection timestamp\n- Object type, confidence score\n- Bounding box coordinates (x, y, width, height)\n- File path, media type\n\nArgs:\n    request: FastAPI request object (includes Accept header for format selection)\n    camera_id: Optional camera ID to filter by\n    object_type: Optional object type to filter by (person, vehicle, animal, etc.)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    min_confidence: Optional minimum confidence threshold (0.0-1.0)\n    db: Database session\n    _rate_limit: Rate limiter dependency\n\nReturns:\n    StreamingResponse with CSV or JSON Response containing exported detections\n\nRaises:\n    HTTPException: 429 if rate limit exceeded\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "detections_export_detections",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by object type",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by object type",
              "title": "Object Type"
            }
          },
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Minimum confidence threshold",
            "in": "query",
            "name": "min_confidence",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Minimum confidence threshold",
              "title": "Min Confidence"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "example": [
                  {
                    "camera_name": "Front Door",
                    "detection_id": 1
                  }
                ],
                "schema": {
                  "items": {
                    "type": "object"
                  },
                  "type": "array"
                }
              },
              "text/csv": {
                "example": "detection_id,camera_name,detected_at,...",
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              }
            },
            "description": "Exported detections file"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Rate limit exceeded"
          }
        },
        "summary": "Export Detections",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/labels": {
      "get": {
        "description": "Get all unique detection labels with counts.",
        "operationId": "detections_list_detection_labels",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionLabelsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List Detection Labels",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/search": {
      "get": {
        "description": "Search detections using full-text search.",
        "operationId": "detections_search_detections",
        "parameters": [
          {
            "in": "query",
            "name": "q",
            "required": true,
            "schema": {
              "minLength": 1,
              "title": "Q",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "labels",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Labels"
            }
          },
          {
            "in": "query",
            "name": "min_confidence",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Min Confidence"
            }
          },
          {
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Camera Id"
            }
          },
          {
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Start Date"
            }
          },
          {
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "End Date"
            }
          },
          {
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionSearchResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Search Detections",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/stats": {
      "get": {
        "description": "Get aggregate detection statistics including class distribution and trends.\n\nReturns:\n- Total detection count\n- Detection counts grouped by object class (person, car, truck, etc.)\n- Average confidence score across all detections\n- Detection trends for the last 7 days (for Grafana time series)\n\nUsed by the AI Performance page to display detection class distribution charts\nand by the Grafana Analytics dashboard for detection trend visualization.\n\nOptimized to use a single query with window functions instead of 3 separate queries\n(NEM-1321). The query combines:\n- Per-class counts via GROUP BY\n- Total count via SUM(COUNT(*)) OVER() window function\n- Per-class avg confidence, then combined using weighted average formula\n\nArgs:\n    camera_id: Optional camera ID filter (for camera-specific stats)\n    db: Database session\n\nReturns:\n    DetectionStatsResponse with aggregate detection statistics and trends",
        "operationId": "detections_get_detection_stats",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Detection Stats",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}": {
      "get": {
        "description": "Get a specific detection by ID.\n\nArgs:\n    detection_id: Detection ID\n    db: Database session\n\nReturns:\n    Detection object\n\nRaises:\n    HTTPException: 404 if detection not found",
        "operationId": "detections_get_detection",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Detection",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/enrichment": {
      "get": {
        "description": "Get structured enrichment data for a detection.\n\nReturns results from the 18+ vision models run during the enrichment pipeline:\n- License plate detection and OCR\n- Face detection\n- Vehicle classification and damage detection\n- Clothing analysis (FashionCLIP and SegFormer)\n- Violence detection\n- Image quality assessment\n- Pet classification\n\nArgs:\n    detection_id: Detection ID\n    db: Database session\n\nReturns:\n    EnrichmentResponse with structured vision model results\n\nRaises:\n    HTTPException: 404 if detection not found",
        "operationId": "detections_get_detection_enrichment",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EnrichmentResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Detection Enrichment",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/image": {
      "get": {
        "description": "Get detection image with bounding box overlay, or full-size original.\n\nThis endpoint is exempt from API key authentication because:\n1. It serves static image content accessed directly by browsers via <img> tags\n2. Detection IDs are not predictable (integer IDs require prior knowledge)\n3. It has rate limiting to prevent abuse\n\nBy default, returns the thumbnail image with bounding box drawn around the\ndetected object. If thumbnail doesn't exist, generates it on the fly from\nthe source image or video.\n\nFor video detections, extracts a frame from the video using ffmpeg.\n\nWhen full=true is passed, returns the original source image without any\nbounding box overlay. This is used for the full-size image lightbox viewer.\nNote: For video detections with full=true, returns the first frame as an image.\n\nArgs:\n    detection_id: Detection ID\n    full: If true, return the original full-size image instead of thumbnail\n    db: Database session\n    thumbnail_generator: ThumbnailGenerator injected via Depends()\n    video_processor: VideoProcessor injected via Depends() for video detections\n\nReturns:\n    JPEG image (thumbnail with bounding box, or full-size original)\n\nRaises:\n    HTTPException: 404 if detection not found or image file doesn't exist\n    HTTPException: 500 if image generation fails",
        "operationId": "detections_get_detection_image",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          },
          {
            "description": "Return full-size original image instead of thumbnail",
            "in": "query",
            "name": "full",
            "required": false,
            "schema": {
              "default": false,
              "description": "Return full-size original image instead of thumbnail",
              "title": "Full",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Image served successfully"
          },
          "404": {
            "description": "Detection or image not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Failed to generate thumbnail"
          }
        },
        "summary": "Get Detection Image",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/thumbnail": {
      "get": {
        "description": "Serve the cropped thumbnail image with bounding box overlay.",
        "operationId": "detections_get_detection_thumbnail",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "image/jpeg": {},
              "image/png": {}
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Detection or thumbnail not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Failed to generate thumbnail"
          }
        },
        "summary": "Get detection thumbnail",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/video": {
      "get": {
        "description": "Stream detection video with HTTP Range request support and transcoding.\n\nThis endpoint is exempt from API key authentication because:\n1. It serves video content accessed directly by browsers via <video> tags\n2. Detection IDs are not predictable (integer IDs require prior knowledge)\n3. It has rate limiting to prevent abuse\n\nNEM-2681: Videos are automatically transcoded to browser-compatible H.264/MP4\nformat. Transcoded videos are cached to avoid re-transcoding on subsequent\nrequests. Videos that are already browser-compatible (H.264 MP4) are served\ndirectly without transcoding.\n\nSupports partial content requests for video seeking and efficient playback.\nReturns 206 Partial Content for range requests, 200 OK for full content.\n\nArgs:\n    detection_id: Detection ID\n    range_header: HTTP Range header for partial content requests\n    db: Database session\n    transcoding_service: Service for transcoding videos to browser-compatible format\n\nReturns:\n    StreamingResponse with browser-compatible video content\n\nRaises:\n    HTTPException: 400 if detection is not a video\n    HTTPException: 404 if detection not found or video file not found\n    HTTPException: 416 if range is not satisfiable\n    HTTPException: 500 if transcoding fails",
        "operationId": "detections_stream_detection_video",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          },
          {
            "in": "header",
            "name": "Range",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Range"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Full video content"
          },
          "206": {
            "description": "Partial video content (range request)"
          },
          "400": {
            "description": "Detection is not a video"
          },
          "404": {
            "description": "Detection or video file not found"
          },
          "416": {
            "description": "Range not satisfiable"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Transcoding failed"
          }
        },
        "summary": "Stream Detection Video",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/detections/{detection_id}/video/thumbnail": {
      "get": {
        "description": "Get thumbnail frame from a video detection.\n\nThis endpoint is exempt from API key authentication because:\n1. It serves static image content accessed directly by browsers via <img> tags\n2. Detection IDs are not predictable (integer IDs require prior knowledge)\n3. It has rate limiting to prevent abuse\n\nExtracts and returns a thumbnail frame from the video. If thumbnail\ndoesn't exist, generates it on the fly using ffmpeg.\n\nArgs:\n    detection_id: Detection ID\n    db: Database session\n    video_processor: VideoProcessor injected via Depends()\n\nReturns:\n    JPEG thumbnail image\n\nRaises:\n    HTTPException: 404 if detection not found or not a video\n    HTTPException: 500 if thumbnail generation fails",
        "operationId": "detections_get_video_thumbnail",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Thumbnail served successfully"
          },
          "400": {
            "description": "Detection is not a video"
          },
          "404": {
            "description": "Detection or video not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          },
          "500": {
            "description": "Failed to generate thumbnail"
          }
        },
        "summary": "Get Video Thumbnail",
        "tags": [
          "detections"
        ]
      }
    },
    "/api/dlq/jobs/{queue_name}": {
      "get": {
        "description": "List jobs in a specific dead-letter queue with enriched error context.\n\nReturns jobs in the specified DLQ without removing them.\nUse pagination parameters to control the result set.\n\nEach job includes enriched error context (NEM-1474):\n- error_type: Exception class name for categorization\n- stack_trace: Truncated stack trace for debugging\n- http_status: HTTP status code (for network errors)\n- response_body: Truncated AI service response\n- retry_delays: Delays applied between retry attempts\n- context: System state snapshot at failure time\n\nArgs:\n    queue_name: Name of the DLQ (detection or analysis)\n    start: Start index for pagination\n    limit: Maximum number of jobs to return\n    redis: Redis client\n\nReturns:\n    DLQJobsResponse with list of jobs including error context (NEM-2178 pagination envelope)",
        "operationId": "dlq_get_dlq_jobs",
        "parameters": [
          {
            "in": "path",
            "name": "queue_name",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "description": "Start index (0-based)",
            "in": "query",
            "name": "start",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Start index (0-based)",
              "minimum": 0,
              "title": "Start",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of jobs to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 100,
              "description": "Maximum number of jobs to return",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQJobsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Dlq Jobs",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/dlq/requeue-all/{queue_name}": {
      "post": {
        "description": "Requeue all jobs from a DLQ back to their original processing queue.\n\nRemoves all jobs from the specified DLQ and adds them back to the\noriginal processing queue for retry. Limited to settings.max_requeue_iterations\nto prevent resource exhaustion.\n\nArgs:\n    queue_name: Name of the DLQ (detection or analysis)\n    redis: Redis client\n\nReturns:\n    DLQRequeueResponse with operation result and count",
        "operationId": "dlq_requeue_all_dlq_jobs",
        "parameters": [
          {
            "in": "path",
            "name": "queue_name",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "in": "query",
            "name": "api_key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Api Key"
            }
          },
          {
            "in": "header",
            "name": "X-API-Key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQRequeueResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Requeue All Dlq Jobs",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/dlq/requeue/{queue_name}": {
      "post": {
        "description": "Requeue the oldest job from a DLQ back to its original processing queue.\n\nRemoves the oldest job from the specified DLQ and adds it back to the\noriginal processing queue for retry.\n\nArgs:\n    queue_name: Name of the DLQ (detection or analysis)\n    redis: Redis client\n\nReturns:\n    DLQRequeueResponse with operation result",
        "operationId": "dlq_requeue_dlq_job",
        "parameters": [
          {
            "in": "path",
            "name": "queue_name",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "in": "query",
            "name": "api_key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Api Key"
            }
          },
          {
            "in": "header",
            "name": "X-API-Key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQRequeueResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Requeue Dlq Job",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/dlq/stats": {
      "get": {
        "description": "Get dead-letter queue statistics.\n\nReturns the number of jobs in each DLQ and the total count.\n\nReturns:\n    DLQStatsResponse with queue counts",
        "operationId": "dlq_get_dlq_stats",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Dlq Stats",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/dlq/{queue_name}": {
      "delete": {
        "description": "Clear all jobs from a dead-letter queue.\n\nWARNING: This permanently removes all jobs from the specified DLQ.\nUse with caution.\n\nArgs:\n    queue_name: Name of the DLQ to clear\n    redis: Redis client\n\nReturns:\n    DLQClearResponse with operation result",
        "operationId": "dlq_clear_dlq",
        "parameters": [
          {
            "in": "path",
            "name": "queue_name",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DLQName"
            }
          },
          {
            "in": "query",
            "name": "api_key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Api Key"
            }
          },
          {
            "in": "header",
            "name": "X-API-Key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DLQClearResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Clear Dlq",
        "tags": [
          "dlq"
        ]
      }
    },
    "/api/entities": {
      "get": {
        "description": "List tracked entities with optional filtering.\n\nReturns a paginated list of entities from PostgreSQL. Entities are\ntracked via re-identification and stored in the database.\n\nArgs:\n    entity_type: Filter by entity type ('person' or 'vehicle')\n    camera_id: Filter by camera ID\n    since: Filter entities seen since this timestamp\n    limit: Maximum number of results (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    entity_repo: Entity repository dependency for PostgreSQL queries\n\nReturns:\n    EntityListResponse with filtered entities and pagination info",
        "operationId": "entities_list_entities",
        "parameters": [
          {
            "description": "Filter by entity type: 'person' or 'vehicle'",
            "in": "query",
            "name": "entity_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/EntityTypeFilter"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by entity type: 'person' or 'vehicle'",
              "title": "Entity Type"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter entities seen since this time",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter entities seen since this time",
              "title": "Since"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Entities",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/matches/{detection_id}": {
      "get": {
        "description": "Find entities matching a specific detection's embedding.\n\nSearches for entities similar to the specified detection's embedding\nacross all cameras. Used to show re-ID matches in the EventDetailModal.\n\nNOTE: This endpoint continues to use Redis for real-time similarity matching.\n\nArgs:\n    detection_id: Detection ID to find matches for\n    entity_type: Type of entity to search ('person' or 'vehicle')\n    threshold: Minimum cosine similarity threshold (default 0.85)\n    reid_service: Re-identification service dependency\n\nReturns:\n    EntityMatchResponse with matching entities sorted by similarity\n\nRaises:\n    HTTPException: 404 if detection embedding not found, 503 if Redis unavailable",
        "operationId": "entities_get_entity_matches",
        "parameters": [
          {
            "in": "path",
            "name": "detection_id",
            "required": true,
            "schema": {
              "title": "Detection Id",
              "type": "string"
            }
          },
          {
            "description": "Type of entity to search for matches",
            "in": "query",
            "name": "entity_type",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/EntityTypeFilter",
              "default": "person",
              "description": "Type of entity to search for matches"
            }
          },
          {
            "description": "Minimum similarity threshold for matches",
            "in": "query",
            "name": "threshold",
            "required": false,
            "schema": {
              "default": 0.85,
              "description": "Minimum similarity threshold for matches",
              "maximum": 1.0,
              "minimum": 0.0,
              "title": "Threshold",
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityMatchResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Detection not found or no embedding stored"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Redis service unavailable"
          }
        },
        "summary": "Get Entity Matches",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/stats": {
      "get": {
        "description": "Get aggregated entity statistics.\n\nReturns statistics about tracked entities including counts by type,\ncamera, and repeat visitors.\n\nArgs:\n    since: Filter entities seen since this timestamp\n    until: Filter entities seen until this timestamp\n    entity_repo: Entity repository dependency\n\nReturns:\n    EntityStatsResponse with aggregated statistics",
        "operationId": "entities_get_entity_stats",
        "parameters": [
          {
            "description": "Filter entities seen since this time",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter entities seen since this time",
              "title": "Since"
            }
          },
          {
            "description": "Filter entities seen until this time",
            "in": "query",
            "name": "until",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter entities seen until this time",
              "title": "Until"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Entity Stats",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/trusted": {
      "get": {
        "description": "List all trusted entities.\n\nReturns a paginated list of entities that have been marked as trusted.\nTrusted entities are those that have been classified as known/safe,\nsuch as family members, regular visitors, or delivery personnel.\n\nArgs:\n    entity_type: Filter by entity type ('person' or 'vehicle')\n    limit: Maximum number of results (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    entity_repo: Entity repository dependency for PostgreSQL queries\n\nReturns:\n    TrustedEntityListResponse with filtered trusted entities and pagination info",
        "operationId": "entities_list_trusted_entities",
        "parameters": [
          {
            "description": "Filter by entity type: 'person' or 'vehicle'",
            "in": "query",
            "name": "entity_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/EntityTypeFilter"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by entity type: 'person' or 'vehicle'",
              "title": "Entity Type"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TrustedEntityListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Trusted Entities",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/untrusted": {
      "get": {
        "description": "List all untrusted entities.\n\nReturns a paginated list of entities that have been marked as untrusted.\nUntrusted entities are those that have been classified as unknown or suspicious,\nrequiring additional monitoring.\n\nArgs:\n    entity_type: Filter by entity type ('person' or 'vehicle')\n    limit: Maximum number of results (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    entity_repo: Entity repository dependency for PostgreSQL queries\n\nReturns:\n    TrustedEntityListResponse with filtered untrusted entities and pagination info",
        "operationId": "entities_list_untrusted_entities",
        "parameters": [
          {
            "description": "Filter by entity type: 'person' or 'vehicle'",
            "in": "query",
            "name": "entity_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/EntityTypeFilter"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by entity type: 'person' or 'vehicle'",
              "title": "Entity Type"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TrustedEntityListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Untrusted Entities",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/v2": {
      "get": {
        "description": "List tracked entities with historical query support.\n\nReturns a paginated list of entities from Redis (hot cache) and/or\nPostgreSQL (historical data). Use the source parameter to control\nwhich backend to query.\n\nArgs:\n    entity_type: Filter by entity type ('person' or 'vehicle')\n    camera_id: Filter by camera ID\n    since: Filter entities seen since this timestamp\n    until: Filter entities seen until this timestamp\n    source: Data source ('redis', 'postgres', 'both') - default 'both'\n    limit: Maximum number of results (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    reid_service: Re-identification service dependency\n    hybrid_storage: Hybrid storage service dependency\n\nReturns:\n    EntityListResponse with filtered entities and pagination info",
        "operationId": "entities_list_entities_v2",
        "parameters": [
          {
            "description": "Filter by entity type: 'person' or 'vehicle'",
            "in": "query",
            "name": "entity_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/EntityTypeFilter"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by entity type: 'person' or 'vehicle'",
              "title": "Entity Type"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter entities seen since this time",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter entities seen since this time",
              "title": "Since"
            }
          },
          {
            "description": "Filter entities seen until this time",
            "in": "query",
            "name": "until",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter entities seen until this time",
              "title": "Until"
            }
          },
          {
            "description": "Data source: 'redis', 'postgres', or 'both'",
            "in": "query",
            "name": "source",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/SourceFilter",
              "default": "both",
              "description": "Data source: 'redis', 'postgres', or 'both'"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List Entities V2",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/v2/{entity_id}": {
      "get": {
        "description": "Get detailed information about a specific entity from PostgreSQL.\n\nReturns the canonical PostgreSQL entity record with full history.\nFor real-time Redis entities, use the original /api/entities/{entity_id} endpoint.\n\nArgs:\n    entity_id: UUID of the entity\n    hybrid_storage: Hybrid storage service dependency\n\nReturns:\n    EntityDetail with full entity information\n\nRaises:\n    HTTPException: 404 if entity not found",
        "operationId": "entities_get_entity_v2",
        "parameters": [
          {
            "in": "path",
            "name": "entity_id",
            "required": true,
            "schema": {
              "format": "uuid",
              "title": "Entity Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityDetail"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Entity not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Entity V2",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/v2/{entity_id}/detections": {
      "get": {
        "description": "List all detections linked to an entity.\n\nReturns paginated detections associated with the specified entity.\n\nArgs:\n    entity_id: UUID of the entity\n    limit: Maximum number of results (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    entity_repo: Entity repository dependency\n\nReturns:\n    EntityDetectionsResponse with linked detections and pagination info\n\nRaises:\n    HTTPException: 404 if entity not found",
        "operationId": "entities_get_entity_detections",
        "parameters": [
          {
            "in": "path",
            "name": "entity_id",
            "required": true,
            "schema": {
              "format": "uuid",
              "title": "Entity Id",
              "type": "string"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityDetectionsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Entity not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Entity Detections",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/{entity_id}": {
      "get": {
        "description": "Get detailed information about a specific entity.\n\nReturns the entity's summary information along with all recorded appearances\nfrom PostgreSQL.\n\nArgs:\n    entity_id: UUID of the entity\n    entity_repo: Entity repository dependency for PostgreSQL queries\n\nReturns:\n    EntityDetail with full entity information\n\nRaises:\n    HTTPException: 404 if entity not found",
        "operationId": "entities_get_entity",
        "parameters": [
          {
            "in": "path",
            "name": "entity_id",
            "required": true,
            "schema": {
              "format": "uuid",
              "title": "Entity Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityDetail"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Entity not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Entity",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/{entity_id}/history": {
      "get": {
        "description": "Get the appearance timeline for a specific entity.\n\nReturns a chronological list of all appearances for the entity\nacross all cameras from PostgreSQL.\n\nArgs:\n    entity_id: UUID of the entity\n    entity_repo: Entity repository dependency for PostgreSQL queries\n\nReturns:\n    EntityHistoryResponse with appearance timeline\n\nRaises:\n    HTTPException: 404 if entity not found",
        "operationId": "entities_get_entity_history",
        "parameters": [
          {
            "in": "path",
            "name": "entity_id",
            "required": true,
            "schema": {
              "format": "uuid",
              "title": "Entity Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Entity not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Entity History",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/entities/{entity_id}/trust": {
      "patch": {
        "description": "Update an entity's trust classification status.\n\nAllows marking entities as trusted (known/safe), untrusted (suspicious),\nor unclassified (default). Includes optional notes for documenting\nthe classification decision.\n\nArgs:\n    entity_id: UUID of the entity to update\n    trust_update: Trust status update request containing trust_status and optional notes\n    entity_repo: Entity repository dependency for PostgreSQL queries\n\nReturns:\n    EntityTrustResponse with updated trust information\n\nRaises:\n    HTTPException: 404 if entity not found",
        "operationId": "entities_update_entity_trust",
        "parameters": [
          {
            "in": "path",
            "name": "entity_id",
            "required": true,
            "schema": {
              "format": "uuid",
              "title": "Entity Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityTrustUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityTrustResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Entity not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Entity Trust",
        "tags": [
          "entities"
        ]
      }
    },
    "/api/events": {
      "get": {
        "description": "List events with optional filtering and cursor-based pagination.\n\nSupports both cursor-based pagination (recommended) and offset pagination (deprecated).\nCursor-based pagination offers better performance for large datasets.\n\nBy default, soft-deleted events (events with deleted_at set) are excluded from results.\nUse include_deleted=true to include them.\n\nSparse Fieldsets (NEM-1434):\nUse the `fields` parameter to request only specific fields in the response,\nreducing payload size. Example: ?fields=id,camera_id,risk_level,summary,reviewed\n\nArgs:\n    camera_id: Optional camera ID to filter by\n    risk_level: Optional risk level to filter by (low, medium, high, critical)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    reviewed: Optional filter by reviewed status\n    object_type: Optional object type to filter by (person, vehicle, animal, etc.)\n    limit: Maximum number of results to return (1-100, default 50)\n    offset: Number of results to skip (deprecated, use cursor instead)\n    cursor: Pagination cursor from previous response's next_cursor field\n    fields: Comma-separated list of fields to include (sparse fieldsets)\n    include_deleted: Include soft-deleted events in results (default False)\n    db: Database session\n\nReturns:\n    EventListResponse containing filtered events and pagination info\n\nRaises:\n    HTTPException: 400 if start_date is after end_date\n    HTTPException: 400 if cursor is invalid\n    HTTPException: 400 if invalid fields are requested",
        "operationId": "events_list_events",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by risk level (low, medium, high, critical)",
            "in": "query",
            "name": "risk_level",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by risk level (low, medium, high, critical)",
              "title": "Risk Level"
            }
          },
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Filter by reviewed status",
            "in": "query",
            "name": "reviewed",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by reviewed status",
              "title": "Reviewed"
            }
          },
          {
            "description": "Filter by detected object type",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by detected object type",
              "title": "Object Type"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip (deprecated, use cursor)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor from previous response",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            }
          },
          {
            "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, started_at, ended_at, risk_score, risk_level, summary, reasoning, reviewed, detection_count, detection_ids, thumbnail_url",
            "in": "query",
            "name": "fields",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, started_at, ended_at, risk_score, risk_level, summary, reasoning, reviewed, detection_count, detection_ids, thumbnail_url",
              "title": "Fields"
            }
          },
          {
            "description": "Include soft-deleted events in results. Default is False to hide deleted events.",
            "in": "query",
            "name": "include_deleted",
            "required": false,
            "schema": {
              "default": false,
              "description": "Include soft-deleted events in results. Default is False to hide deleted events.",
              "title": "Include Deleted",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Events",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/analyze/{batch_id}/stream": {
      "get": {
        "description": "Stream LLM analysis progress for a batch via Server-Sent Events (NEM-1665).\n\nThis endpoint provides progressive LLM response updates during long inference\ntimes, allowing the frontend to display partial results and show typing\nindicators while the analysis is in progress.\n\nEvent Types:\n- progress: Partial LLM response chunk with accumulated_text\n- complete: Final event with risk assessment and event_id\n- error: Error information with error_code and recoverable flag\n\nArgs:\n    batch_id: Batch identifier to analyze\n    camera_id: Optional camera ID (uses Redis lookup if not provided)\n    detection_ids: Optional comma-separated detection IDs\n    analyzer: NemotronAnalyzer injected via Depends()\n\nReturns:\n    StreamingResponse with SSE event stream (text/event-stream)\n\nExample SSE output:\n    data: {\"event_type\": \"progress\", \"content\": \"Based on\", \"accumulated_text\": \"Based on\"}\n\n    data: {\"event_type\": \"progress\", \"content\": \" the\", \"accumulated_text\": \"Based on the\"}\n\n    data: {\"event_type\": \"complete\", \"event_id\": 123, \"risk_score\": 75, ...}",
        "operationId": "events_analyze_batch_streaming",
        "parameters": [
          {
            "in": "path",
            "name": "batch_id",
            "required": true,
            "schema": {
              "title": "Batch Id",
              "type": "string"
            }
          },
          {
            "description": "Camera ID for the batch",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Camera ID for the batch",
              "title": "Camera Id"
            }
          },
          {
            "description": "Comma-separated detection IDs (optional)",
            "in": "query",
            "name": "detection_ids",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated detection IDs (optional)",
              "title": "Detection Ids"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Analyze Batch Streaming",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/bulk": {
      "delete": {
        "description": "Delete multiple events in a single request.\n\nSupports partial success - some deletions may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nBy default uses soft delete (sets deleted_at timestamp) with cascade to\nrelated detections. Use soft_delete=false for permanent deletion.\nUse cascade=false to only delete the event without affecting detections.\n\nRate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).\n\nArgs:\n    request: Bulk delete request with up to 100 event IDs\n    db: Database session\n    cache: Cache service for invalidation\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "events_bulk_delete_events",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventBulkDeleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          },
          "429": {
            "description": "Rate limit exceeded"
          }
        },
        "summary": "Bulk delete events",
        "tags": [
          "events"
        ]
      },
      "patch": {
        "description": "Update multiple events in a single request.\n\nSupports partial success - some updates may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).\n\nArgs:\n    request: Bulk update request with up to 100 event updates\n    db: Database session\n\nReturns:\n    BulkOperationResponse with per-item results",
        "operationId": "events_bulk_update_events",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventBulkUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkOperationResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          },
          "429": {
            "description": "Rate limit exceeded"
          }
        },
        "summary": "Bulk update events",
        "tags": [
          "events"
        ]
      },
      "post": {
        "description": "Create multiple events in a single request.\n\nSupports partial success - some events may succeed while others fail.\nReturns HTTP 207 Multi-Status with per-item results.\n\nRate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).\n\nArgs:\n    request: Bulk create request with up to 100 events\n    db: Database session\n\nReturns:\n    EventBulkCreateResponse with per-item results",
        "operationId": "events_bulk_create_events",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventBulkCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "207": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventBulkCreateResponse"
                }
              }
            },
            "description": "Multi-status response with per-item results"
          },
          "400": {
            "description": "Invalid request format"
          },
          "422": {
            "description": "Validation error"
          },
          "429": {
            "description": "Rate limit exceeded"
          }
        },
        "summary": "Bulk create events",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/clusters": {
      "get": {
        "description": "Cluster events by temporal proximity (NEM-3620).\n\nGroups events that occur within a specified time window into clusters.\nEvents from the same camera within `time_window_minutes` are grouped together.\nEvents from different cameras within 2 minutes are also grouped (cross-camera clusters).\n\nClustering algorithm:\n1. Sort all events by timestamp\n2. For each event, check if it fits in an existing cluster:\n   - Same camera: within time_window_minutes of cluster end\n   - Different camera: within 2 minutes of cluster end (correlating activity)\n3. If no matching cluster, start a new potential cluster\n4. Only return clusters with >= min_cluster_size events\n\nUses read replica for linear scalability (NEM-3392).\n\nArgs:\n    start_date: Start of time range to analyze (required)\n    end_date: End of time range to analyze (required)\n    camera_id: Optional filter to only cluster events from specific camera\n    time_window_minutes: Time window for same-camera clustering (1-60, default 5)\n    min_cluster_size: Minimum events to form a cluster (2-100, default 2)\n    db: Database session (read replica)\n\nReturns:\n    EventClustersResponse with clusters and unclustered event count\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "events_get_event_clusters",
        "parameters": [
          {
            "description": "Start date for clustering (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": true,
            "schema": {
              "description": "Start date for clustering (ISO format)",
              "format": "date-time",
              "title": "Start Date",
              "type": "string"
            }
          },
          {
            "description": "End date for clustering (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": true,
            "schema": {
              "description": "End date for clustering (ISO format)",
              "format": "date-time",
              "title": "End Date",
              "type": "string"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Time window in minutes for clustering events (default: 5)",
            "in": "query",
            "name": "time_window_minutes",
            "required": false,
            "schema": {
              "default": 5,
              "description": "Time window in minutes for clustering events (default: 5)",
              "maximum": 60,
              "minimum": 1,
              "title": "Time Window Minutes",
              "type": "integer"
            }
          },
          {
            "description": "Minimum events required to form a cluster (default: 2)",
            "in": "query",
            "name": "min_cluster_size",
            "required": false,
            "schema": {
              "default": 2,
              "description": "Minimum events required to form a cluster (default: 2)",
              "maximum": 100,
              "minimum": 2,
              "title": "Min Cluster Size",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventClustersResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event Clusters",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/deleted": {
      "get": {
        "description": "List all soft-deleted events for trash view.\n\nReturns events that have been soft-deleted (deleted_at is not null),\nordered by deleted_at descending (most recently deleted first).\n\nThis endpoint enables a \"trash\" view where users can see deleted events\nand optionally restore them.\n\nArgs:\n    db: Database session\n\nReturns:\n    DeletedEventsListResponse containing list of deleted events and count",
        "operationId": "events_list_deleted_events",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeletedEventsListResponse"
                }
              }
            },
            "description": "List of soft-deleted events"
          }
        },
        "summary": "List all soft-deleted events",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/export": {
      "get": {
        "description": "Export events as CSV, JSON, or Excel file for external analysis or record-keeping.\n\nSupports content negotiation via HTTP Accept header:\n- `Accept: text/csv` or `Accept: application/csv` - CSV format (default)\n- `Accept: application/json` - JSON format\n- `Accept: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet` - Excel (XLSX)\n- `Accept: application/vnd.ms-excel` or `Accept: application/xlsx` - Excel (XLSX)\n\nThis endpoint is rate-limited to 10 requests per minute per client IP\nto prevent abuse and protect against data exfiltration attacks.\n\nExports events with the following fields:\n- Event ID, camera name, timestamps\n- Risk score, risk level, summary\n- Detection count, reviewed status\n\nArgs:\n    request: FastAPI request object (includes Accept header for format selection)\n    camera_id: Optional camera ID to filter by\n    risk_level: Optional risk level to filter by (low, medium, high, critical)\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    reviewed: Optional filter by reviewed status\n    db: Database session\n    _rate_limit: Rate limiter dependency (10 req/min, no burst)\n\nReturns:\n    StreamingResponse with CSV, JSON Response, or Excel Response\n\nRaises:\n    HTTPException: 429 if rate limit exceeded\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "events_export_events",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by risk level (low, medium, high, critical)",
            "in": "query",
            "name": "risk_level",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by risk level (low, medium, high, critical)",
              "title": "Risk Level"
            }
          },
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Filter by reviewed status",
            "in": "query",
            "name": "reviewed",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by reviewed status",
              "title": "Reviewed"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "example": [
                  {
                    "camera_name": "Front Door",
                    "event_id": 1
                  }
                ],
                "schema": {
                  "items": {
                    "type": "object"
                  },
                  "type": "array"
                }
              },
              "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              },
              "text/csv": {
                "example": "event_id,camera_name,started_at,...",
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              }
            },
            "description": "Exported events file"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Rate limit exceeded"
          }
        },
        "summary": "Export Events",
        "tags": [
          "events"
        ]
      },
      "post": {
        "description": "Start a background export job for events. Returns a job ID that can be used to track progress via GET /api/jobs/{job_id}.",
        "operationId": "jobs_start_export_job",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportJobRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportJobStartResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Start export job",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/events/search": {
      "get": {
        "description": "Search events using full-text search.\n\nUses read replica for linear scalability (NEM-3392).\n\nThis endpoint provides PostgreSQL full-text search across event summaries,\nreasoning, object types, and camera names.\n\nSearch Query Syntax:\n- Basic words: \"person vehicle\" (implicit AND)\n- Phrase search: '\"suspicious person\"' (exact phrase)\n- Boolean OR: \"person OR animal\"\n- Boolean NOT: \"person NOT cat\"\n- Boolean AND: \"person AND vehicle\" (explicit)\n\nArgs:\n    q: Search query string (required)\n    camera_id: Optional comma-separated camera IDs to filter by\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    severity: Optional comma-separated risk levels (low, medium, high, critical)\n    risk_level: Alias for severity - accepts same format\n    object_type: Optional comma-separated object types (person, vehicle, animal)\n    reviewed: Optional filter by reviewed status\n    limit: Maximum number of results to return (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    db: Database session\n\nReturns:\n    SearchResponse with ranked results and pagination info\n\nRaises:\n    HTTPException: 400 if any severity value is invalid\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "events_search_events_endpoint",
        "parameters": [
          {
            "description": "Search query string",
            "in": "query",
            "name": "q",
            "required": true,
            "schema": {
              "description": "Search query string",
              "minLength": 1,
              "title": "Q",
              "type": "string"
            }
          },
          {
            "description": "Filter by camera ID (comma-separated for multiple)",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID (comma-separated for multiple)",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Filter by risk levels (comma-separated: low,medium,high,critical)",
            "in": "query",
            "name": "severity",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by risk levels (comma-separated: low,medium,high,critical)",
              "title": "Severity"
            }
          },
          {
            "description": "Alias for severity - filter by risk levels (comma-separated: low,medium,high,critical)",
            "in": "query",
            "name": "risk_level",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Alias for severity - filter by risk levels (comma-separated: low,medium,high,critical)",
              "title": "Risk Level"
            }
          },
          {
            "description": "Filter by object types (comma-separated: person,vehicle,animal)",
            "in": "query",
            "name": "object_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by object types (comma-separated: person,vehicle,animal)",
              "title": "Object Type"
            }
          },
          {
            "description": "Filter by reviewed status",
            "in": "query",
            "name": "reviewed",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by reviewed status",
              "title": "Reviewed"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Search Events Endpoint",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/stats": {
      "get": {
        "description": "Get aggregated event statistics.\n\nReturns statistics about events including:\n- Total event count\n- Events grouped by risk level (critical, high, medium, low)\n- Events grouped by camera with camera names\n\nUses Redis cache with cache-aside pattern to improve performance\nand generate cache hit metrics.\n\nArgs:\n    start_date: Optional start date for date range filter\n    end_date: Optional end date for date range filter\n    camera_id: Optional camera ID filter (for camera-specific stats)\n    db: Database session\n    cache: Cache service injected via FastAPI DI\n\nReturns:\n    EventStatsResponse with aggregated statistics\n\nRaises:\n    HTTPException: 400 if start_date is after end_date",
        "operationId": "events_get_event_stats",
        "parameters": [
          {
            "description": "Filter by start date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by start date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter by end date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by end date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event Stats",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/timeline-summary": {
      "get": {
        "description": "Get timeline summary data for the timeline scrubber visualization (NEM-2932).\n\nReturns event data bucketed by time periods for visualization.\nEach bucket includes:\n- Timestamp (start of the bucket)\n- Event count\n- Maximum risk score in that bucket\n\nBucket sizes based on zoom level:\n- hour: 5-minute buckets (12 buckets per hour)\n- day: 1-hour buckets (24 buckets per day)\n- week: 1-day buckets (7 buckets per week)\n\nArgs:\n    start_date: Start of timeline range (defaults based on bucket_size)\n    end_date: End of timeline range (defaults to now)\n    bucket_size: Zoom level - \"hour\", \"day\", or \"week\"\n    camera_id: Optional camera filter\n    db: Database session\n    cache: Cache service\n\nReturns:\n    TimelineSummaryResponse with bucketed event data",
        "operationId": "events_get_timeline_summary",
        "parameters": [
          {
            "description": "Start of timeline range (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Start of timeline range (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "End of timeline range (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "End of timeline range (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Zoom level determining bucket size (hour, day, week)",
            "in": "query",
            "name": "bucket_size",
            "required": false,
            "schema": {
              "default": "day",
              "description": "Zoom level determining bucket size (hour, day, week)",
              "pattern": "^(hour|day|week)$",
              "title": "Bucket Size",
              "type": "string"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TimelineSummaryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Timeline Summary",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}": {
      "delete": {
        "description": "Soft delete a single event with optional cascade to related detections.\n\nBy default, cascade=True soft deletes all related detections using the same\ntimestamp as the event. This enables cascade restore by matching timestamps.\n\nArgs:\n    event_id: ID of the event to delete\n    cascade: If True, cascade soft delete to related detections\n    db: Database session\n    cache: Cache service for invalidation\n\nRaises:\n    HTTPException: 404 if event not found, 409 if already deleted",
        "operationId": "events_delete_event",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Cascade soft delete to related detections",
            "in": "query",
            "name": "cascade",
            "required": false,
            "schema": {
              "default": true,
              "description": "Cascade soft delete to related detections",
              "title": "Cascade",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Event deleted successfully"
          },
          "404": {
            "description": "Event not found"
          },
          "409": {
            "description": "Event already deleted"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Soft delete a single event",
        "tags": [
          "events"
        ]
      },
      "get": {
        "description": "Get a specific event by ID with HATEOAS links.\n\nArgs:\n    event_id: Event ID\n    request: FastAPI request object for building HATEOAS links\n    db: Database session\n\nReturns:\n    Event object with detection count and HATEOAS links\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "events_get_event",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event",
        "tags": [
          "events"
        ]
      },
      "patch": {
        "description": "Update an event (mark as reviewed).\n\nSupports optimistic locking (NEM-3625): Include the `version` field from the\nevent response to prevent concurrent modification conflicts. If the version\ndoesn't match, returns HTTP 409 Conflict with the current version.\n\nArgs:\n    event_id: Event ID\n    update_data: Update data (reviewed, notes, snooze_until, version)\n    request: FastAPI request for audit logging\n    db: Database session\n    cache: Cache service for cache invalidation (NEM-1938)\n\nReturns:\n    Updated event object with new version\n\nRaises:\n    HTTPException: 404 if event not found\n    HTTPException: 409 if version mismatch (concurrent modification)",
        "operationId": "events_update_event",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "409": {
            "content": {
              "application/json": {
                "example": {
                  "current_version": 3,
                  "detail": "Event was modified by another request. Please refresh and retry."
                }
              }
            },
            "description": "Conflict - event was modified by another request (optimistic locking)"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Event",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/clip": {
      "get": {
        "description": "Get clip information for a specific event.\n\nReturns information about whether a video clip is available for the event,\nand if so, provides the URL to access it along with metadata.\n\nArgs:\n    event_id: Event ID\n    db: Database session\n\nReturns:\n    ClipInfoResponse with clip availability and metadata\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "events_get_event_clip",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClipInfoResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event Clip",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/clip/generate": {
      "post": {
        "description": "Trigger video clip generation for an event.\n\nIf a clip already exists and force=False, returns the existing clip info.\nIf force=True, regenerates the clip even if one exists.\n\nClip generation uses detection images to create a video sequence, or\nextracts from existing video if available.\n\nArgs:\n    event_id: Event ID\n    request: Clip generation parameters\n    db: Database session\n    clip_generator: ClipGenerator injected via Depends()\n\nReturns:\n    ClipGenerateResponse with generation status and clip info\n\nRaises:\n    HTTPException: 404 if event not found\n    HTTPException: 400 if event has no detections to generate clip from",
        "operationId": "events_generate_event_clip",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClipGenerateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClipGenerateResponse"
                }
              }
            },
            "description": "Clip already exists"
          },
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClipGenerateResponse"
                }
              }
            },
            "description": "Clip created successfully"
          },
          "400": {
            "description": "Cannot generate clip - event has no detections"
          },
          "404": {
            "description": "Event not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Generate Event Clip",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/detections": {
      "get": {
        "description": "Get detections for a specific event.\n\nNEM-3629: Supports ordering by EventDetection.created_at to show detection\norder within the event (first, second, etc.). When using order_detections_by=created_at,\nthe association_created_at field will be populated in each detection response.\n\nArgs:\n    event_id: Event ID\n    limit: Maximum number of results to return (1-1000, default 50)\n    offset: Number of results to skip for pagination (default 0)\n    order_detections_by: Order by 'detected_at' (default) or 'created_at'\n    db: Database session\n\nReturns:\n    DetectionListResponse containing detections for the event\n\nRaises:\n    HTTPException: 404 if event not found\n    HTTPException: 400 if invalid order_detections_by value",
        "operationId": "events_get_event_detections",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Order detections by: 'detected_at' (detection timestamp, default) or 'created_at' (when associated with event - shows detection sequence in event)",
            "in": "query",
            "name": "order_detections_by",
            "required": false,
            "schema": {
              "default": "detected_at",
              "description": "Order detections by: 'detected_at' (detection timestamp, default) or 'created_at' (when associated with event - shows detection sequence in event)",
              "title": "Order Detections By",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetectionListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event Detections",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/enrichments": {
      "get": {
        "description": "Get enrichment data for detections in an event with pagination.\n\nReturns structured vision model results from the enrichment pipeline for\neach detection in the event. Results include:\n- License plate detection and OCR\n- Face detection\n- Vehicle classification and damage detection\n- Clothing analysis (FashionCLIP and SegFormer)\n- Violence detection\n- Image quality assessment\n- Pet classification\n\nArgs:\n    event_id: Event ID\n    limit: Maximum number of enrichments to return (1-200, default 50)\n    offset: Number of enrichments to skip (default 0)\n    db: Database session\n\nReturns:\n    EventEnrichmentsResponse with enrichment data for each detection and pagination metadata\n\nRaises:\n    HTTPException: 404 if event not found",
        "operationId": "events_get_event_enrichments",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of enrichments to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of enrichments to return",
              "maximum": 200,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of enrichments to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of enrichments to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventEnrichmentsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Event Enrichments",
        "tags": [
          "events"
        ]
      }
    },
    "/api/events/{event_id}/restore": {
      "post": {
        "description": "Restore a soft-deleted event with optional cascade to related detections.\n\nWhen cascade=True, this restores detections that were deleted at the same\ntimestamp as the event, indicating they were cascade-deleted together.\n\nArgs:\n    event_id: ID of the event to restore\n    cascade: If True, cascade restore to related detections\n    db: Database session\n    cache: Cache service for invalidation\n\nReturns:\n    The restored event as EventResponse\n\nRaises:\n    HTTPException: 404 if event not found, 409 if not deleted",
        "operationId": "events_restore_event",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          },
          {
            "description": "Cascade restore to related detections",
            "in": "query",
            "name": "cascade",
            "required": false,
            "schema": {
              "default": true,
              "description": "Cascade restore to related detections",
              "title": "Cascade",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventResponse"
                }
              }
            },
            "description": "Event restored successfully"
          },
          "404": {
            "description": "Event not found"
          },
          "409": {
            "description": "Event is not deleted"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Restore a soft-deleted event",
        "tags": [
          "events"
        ]
      }
    },
    "/api/exports": {
      "get": {
        "description": "List recent export jobs with optional filtering by status.",
        "operationId": "exports_list_exports",
        "parameters": [
          {
            "description": "Filter by job status",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ExportJobStatusEnum"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by job status",
              "title": "Status"
            }
          },
          {
            "description": "Maximum number of jobs to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of jobs to return",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of jobs to skip (for pagination)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of jobs to skip (for pagination)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportJobListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List export jobs",
        "tags": [
          "exports"
        ]
      },
      "post": {
        "description": "Start a new background export job. Returns a job ID that can be used to track progress via GET /api/exports/{job_id}.",
        "operationId": "exports_start_export",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportJobCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportJobStartResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Start export job",
        "tags": [
          "exports"
        ]
      }
    },
    "/api/exports/{job_id}": {
      "delete": {
        "description": "Cancel a pending or running export job. Completed or failed jobs cannot be cancelled.",
        "operationId": "exports_cancel_export",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportJobCancelResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Export job not found"
          },
          "409": {
            "description": "Job cannot be cancelled (already completed or failed)"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Cancel export job",
        "tags": [
          "exports"
        ]
      },
      "get": {
        "description": "Get the current status and progress of an export job.",
        "operationId": "exports_get_export_status",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportJobResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Export job not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get export status",
        "tags": [
          "exports"
        ]
      }
    },
    "/api/exports/{job_id}/download": {
      "get": {
        "description": "Download the completed export file.",
        "operationId": "exports_download_export",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Export not yet complete"
          },
          "404": {
            "description": "Export job or file not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Download export file",
        "tags": [
          "exports"
        ]
      }
    },
    "/api/exports/{job_id}/download/info": {
      "get": {
        "description": "Get metadata about the export file for download.",
        "operationId": "exports_get_download_info",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportDownloadResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Export job not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get download info",
        "tags": [
          "exports"
        ]
      }
    },
    "/api/face-events": {
      "get": {
        "description": "List face detection events with optional filters.\n\nArgs:\n    camera_id: Filter by camera ID (optional)\n    start_time: Filter events after this time (optional)\n    end_time: Filter events before this time (optional)\n    unknown_only: If True, only return unknown faces\n    limit: Maximum events to return (default: 100, max: 1000)\n    offset: Number of events to skip for pagination\n    session: Database session\n\nReturns:\n    FaceDetectionEventListResponse with events and total count",
        "operationId": "face-recognition_list_face_events",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter events after this time",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter events after this time",
              "title": "Start Time"
            }
          },
          {
            "description": "Filter events before this time",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter events before this time",
              "title": "End Time"
            }
          },
          {
            "description": "Only return unknown faces",
            "in": "query",
            "name": "unknown_only",
            "required": false,
            "schema": {
              "default": false,
              "description": "Only return unknown faces",
              "title": "Unknown Only",
              "type": "boolean"
            }
          },
          {
            "description": "Maximum events to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 100,
              "description": "Maximum events to return",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of events to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of events to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FaceDetectionEventListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Face Events",
        "tags": [
          "face-recognition"
        ]
      }
    },
    "/api/face-events/match": {
      "post": {
        "description": "Match a face embedding against known persons.\n\nCompares the provided 512-dimensional embedding against all stored\nembeddings and returns the best match if above the threshold.\n\nArgs:\n    data: Match request with embedding and optional threshold\n    session: Database session\n\nReturns:\n    FaceMatchResponse with match results\n\nRaises:\n    HTTPException: 400 if embedding is invalid",
        "operationId": "face-recognition_match_face",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FaceMatchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FaceMatchResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Match Face",
        "tags": [
          "face-recognition"
        ]
      }
    },
    "/api/face-events/unknown": {
      "get": {
        "description": "Get unknown stranger alerts.\n\nReturns face detection events where no known person was matched.\nOnly includes faces with quality score above the threshold.\n\nArgs:\n    start_time: Filter events after this time (optional)\n    end_time: Filter events before this time (optional)\n    min_quality: Minimum quality score for reliable detections\n    limit: Maximum events to return\n    session: Database session\n\nReturns:\n    UnknownStrangerListResponse with unknown face detections",
        "operationId": "face-recognition_get_unknown_strangers",
        "parameters": [
          {
            "description": "Filter events after this time",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter events after this time",
              "title": "Start Time"
            }
          },
          {
            "description": "Filter events before this time",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter events before this time",
              "title": "End Time"
            }
          },
          {
            "description": "Minimum quality score",
            "in": "query",
            "name": "min_quality",
            "required": false,
            "schema": {
              "default": 0.3,
              "description": "Minimum quality score",
              "maximum": 1.0,
              "minimum": 0.0,
              "title": "Min Quality",
              "type": "number"
            }
          },
          {
            "description": "Maximum events to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 100,
              "description": "Maximum events to return",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnknownStrangerListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Unknown Strangers",
        "tags": [
          "face-recognition"
        ]
      }
    },
    "/api/feedback": {
      "post": {
        "description": "Submit feedback for an event.\n\nAllows users to mark events as false positives, missed detections,\nwrong severity, or correctly classified. Only one feedback per event\nis allowed (enforced by unique constraint).\n\nThis feedback is used to calibrate personalized risk thresholds\nand improve the AI model's accuracy over time.\n\nArgs:\n    feedback_data: Feedback details including event_id and feedback_type\n    db: Database session\n\nReturns:\n    The created feedback record\n\nRaises:\n    HTTPException: 404 if event not found\n    HTTPException: 409 if feedback already exists for this event",
        "operationId": "feedback_create_feedback",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventFeedbackCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventFeedbackResponse"
                }
              }
            },
            "description": "Feedback created successfully"
          },
          "404": {
            "description": "Event not found"
          },
          "409": {
            "description": "Feedback already exists for this event"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Submit event feedback",
        "tags": [
          "feedback"
        ]
      }
    },
    "/api/feedback/event/{event_id}": {
      "get": {
        "description": "Get feedback for a specific event.\n\nArgs:\n    event_id: The event ID to get feedback for\n    db: Database session\n\nReturns:\n    The feedback record for the event\n\nRaises:\n    HTTPException: 404 if no feedback exists for the event",
        "operationId": "feedback_get_event_feedback",
        "parameters": [
          {
            "in": "path",
            "name": "event_id",
            "required": true,
            "schema": {
              "title": "Event Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventFeedbackResponse"
                }
              }
            },
            "description": "Feedback found"
          },
          "404": {
            "description": "No feedback found for this event"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Get feedback for an event",
        "tags": [
          "feedback"
        ]
      }
    },
    "/api/feedback/stats": {
      "get": {
        "description": "Get aggregate feedback statistics.\n\nReturns counts of feedback grouped by:\n- Feedback type (false_positive, missed_detection, wrong_severity, correct)\n- Camera ID\n\nThis data is useful for:\n- Identifying cameras with high false positive rates\n- Calibrating risk thresholds per camera\n- Tracking model accuracy over time\n\nArgs:\n    db: Database session\n\nReturns:\n    Aggregate statistics including total count and breakdowns",
        "operationId": "feedback_get_feedback_stats",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeedbackStatsResponse"
                }
              }
            },
            "description": "Statistics retrieved successfully"
          }
        },
        "summary": "Get feedback statistics",
        "tags": [
          "feedback"
        ]
      }
    },
    "/api/health/ai-services": {
      "get": {
        "description": "Get a unified view of all AI service health including circuit breaker states,\nerror rates, latency metrics, and queue depths.\n\nThe response includes:\n- **overall_status**: healthy/degraded/critical based on service availability\n- **services**: Individual health status for each AI service (yolo26, nemotron, florence, clip, enrichment)\n- **queues**: Current depth of detection and analysis queues with DLQ counts\n\nHTTP Status Codes:\n- **200**: All services operational or system is degraded but functional\n- **503**: Critical services (yolo26, nemotron) are unhealthy",
        "operationId": "health_get_ai_services_health",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AIServicesHealthResponse"
                }
              }
            },
            "description": "AI services health status returned"
          },
          "503": {
            "description": "Critical AI services are unhealthy"
          }
        },
        "summary": "Get Unified AI Services Health Status",
        "tags": [
          "health"
        ]
      }
    },
    "/api/heatmaps/camera/{camera_id}": {
      "get": {
        "description": "Get the current heatmap image for a camera.\n\nReturns a heatmap visualization based on the current in-memory accumulator\nfor the specified camera. If no accumulator exists, returns an empty heatmap.\n\nArgs:\n    camera_id: ID of the camera.\n    resolution: Requested resolution (for metadata).\n    output_width: Width of the output image in pixels.\n    output_height: Height of the output image in pixels.\n    colormap: Matplotlib colormap name.\n    db: Database session.\n\nReturns:\n    HeatmapResponse with base64-encoded image and metadata.\n\nRaises:\n    HTTPException: 404 if camera not found.",
        "operationId": "heatmaps_get_current_heatmap",
        "parameters": [
          {
            "description": "Camera ID",
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "description": "Camera ID",
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Heatmap resolution",
            "in": "query",
            "name": "resolution",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/HeatmapResolution",
              "default": "hourly",
              "description": "Heatmap resolution"
            }
          },
          {
            "description": "Output image width",
            "in": "query",
            "name": "output_width",
            "required": false,
            "schema": {
              "default": 640,
              "description": "Output image width",
              "maximum": 4096,
              "minimum": 100,
              "title": "Output Width",
              "type": "integer"
            }
          },
          {
            "description": "Output image height",
            "in": "query",
            "name": "output_height",
            "required": false,
            "schema": {
              "default": 480,
              "description": "Output image height",
              "maximum": 4096,
              "minimum": 100,
              "title": "Output Height",
              "type": "integer"
            }
          },
          {
            "description": "Colormap name (e.g., jet, hot, viridis)",
            "in": "query",
            "name": "colormap",
            "required": false,
            "schema": {
              "default": "jet",
              "description": "Colormap name (e.g., jet, hot, viridis)",
              "title": "Colormap",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HeatmapResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Current Heatmap",
        "tags": [
          "heatmaps"
        ]
      }
    },
    "/api/heatmaps/camera/{camera_id}/accumulator": {
      "delete": {
        "description": "Reset the heatmap accumulator for a camera.\n\nClears all accumulated detection data from memory. This does not\naffect saved heatmap records in the database.\n\nArgs:\n    camera_id: ID of the camera.\n    db: Database session.\n\nReturns:\n    Dictionary with reset status.\n\nRaises:\n    HTTPException: 404 if camera not found.",
        "operationId": "heatmaps_reset_heatmap_accumulator",
        "parameters": [
          {
            "description": "Camera ID",
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "description": "Camera ID",
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": true,
                  "title": "Response Heatmaps Reset Heatmap Accumulator",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Reset Heatmap Accumulator",
        "tags": [
          "heatmaps"
        ]
      }
    },
    "/api/heatmaps/camera/{camera_id}/history": {
      "get": {
        "description": "Get historical heatmap metadata for a camera.\n\nReturns a list of heatmap metadata records for the specified time range.\nDoes not include the full heatmap images - use the individual heatmap\nendpoint to retrieve specific images.\n\nArgs:\n    camera_id: ID of the camera.\n    start_time: Start of the time range.\n    end_time: End of the time range.\n    resolution: Optional filter by resolution level.\n    limit: Maximum number of records to return.\n    offset: Number of records to skip.\n    db: Database session.\n\nReturns:\n    HeatmapListResponse with metadata records and total count.\n\nRaises:\n    HTTPException: 400 if start_time is after end_time.\n    HTTPException: 404 if camera not found.",
        "operationId": "heatmaps_get_heatmap_history",
        "parameters": [
          {
            "description": "Camera ID",
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "description": "Camera ID",
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Start of the time range (ISO format)",
            "in": "query",
            "name": "start_time",
            "required": true,
            "schema": {
              "description": "Start of the time range (ISO format)",
              "format": "date-time",
              "title": "Start Time",
              "type": "string"
            }
          },
          {
            "description": "End of the time range (ISO format)",
            "in": "query",
            "name": "end_time",
            "required": true,
            "schema": {
              "description": "End of the time range (ISO format)",
              "format": "date-time",
              "title": "End Time",
              "type": "string"
            }
          },
          {
            "description": "Filter by resolution level",
            "in": "query",
            "name": "resolution",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/HeatmapResolution"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by resolution level",
              "title": "Resolution"
            }
          },
          {
            "description": "Maximum number of records to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of records to return",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of records to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of records to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HeatmapListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Heatmap History",
        "tags": [
          "heatmaps"
        ]
      }
    },
    "/api/heatmaps/camera/{camera_id}/merged": {
      "get": {
        "description": "Get a merged heatmap from multiple records in a time range.\n\nCombines all heatmap data in the specified time range into a single\nvisualization, showing activity patterns across the entire period.\n\nArgs:\n    camera_id: ID of the camera.\n    start_time: Start of the time range.\n    end_time: End of the time range.\n    resolution: Optional filter by resolution level.\n    db: Database session.\n\nReturns:\n    HeatmapResponse with merged heatmap image.\n\nRaises:\n    HTTPException: 400 if start_time is after end_time.\n    HTTPException: 404 if camera not found or no data in range.",
        "operationId": "heatmaps_get_merged_heatmap",
        "parameters": [
          {
            "description": "Camera ID",
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "description": "Camera ID",
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Start of the time range (ISO format)",
            "in": "query",
            "name": "start_time",
            "required": true,
            "schema": {
              "description": "Start of the time range (ISO format)",
              "format": "date-time",
              "title": "Start Time",
              "type": "string"
            }
          },
          {
            "description": "End of the time range (ISO format)",
            "in": "query",
            "name": "end_time",
            "required": true,
            "schema": {
              "description": "End of the time range (ISO format)",
              "format": "date-time",
              "title": "End Time",
              "type": "string"
            }
          },
          {
            "description": "Filter by resolution level",
            "in": "query",
            "name": "resolution",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/HeatmapResolution"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by resolution level",
              "title": "Resolution"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HeatmapResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid date range"
          },
          "404": {
            "description": "Camera not found or no heatmap data"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Merged Heatmap",
        "tags": [
          "heatmaps"
        ]
      }
    },
    "/api/heatmaps/camera/{camera_id}/snapshot": {
      "post": {
        "description": "Force save the current heatmap accumulator to the database.\n\nManually triggers a snapshot of the current in-memory heatmap data\nfor the specified camera. Useful for debugging or manual data capture.\n\nArgs:\n    camera_id: ID of the camera.\n    request: Snapshot request with resolution.\n    db: Database session.\n\nReturns:\n    HeatmapSnapshotResponse with save status.\n\nRaises:\n    HTTPException: 404 if camera not found.",
        "operationId": "heatmaps_save_heatmap_snapshot",
        "parameters": [
          {
            "description": "Camera ID",
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "description": "Camera ID",
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HeatmapSnapshotRequest",
                "default": {
                  "resolution": "hourly"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HeatmapSnapshotResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Save Heatmap Snapshot",
        "tags": [
          "heatmaps"
        ]
      }
    },
    "/api/heatmaps/camera/{camera_id}/stats": {
      "get": {
        "description": "Get statistics about the current heatmap accumulator for a camera.\n\nReturns information about the in-memory accumulator including total\ndetections, dimensions, and intensity statistics.\n\nArgs:\n    camera_id: ID of the camera.\n    db: Database session.\n\nReturns:\n    Dictionary with accumulator statistics.\n\nRaises:\n    HTTPException: 404 if camera not found.",
        "operationId": "heatmaps_get_heatmap_stats",
        "parameters": [
          {
            "description": "Camera ID",
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "description": "Camera ID",
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": true,
                  "title": "Response Heatmaps Get Heatmap Stats",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Heatmap Stats",
        "tags": [
          "heatmaps"
        ]
      }
    },
    "/api/household/members": {
      "get": {
        "description": "List all household members.\n\nReturns all registered household members ordered by name.\n\nArgs:\n    session: Database session\n\nReturns:\n    List of HouseholdMember objects",
        "operationId": "household_list_members",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/HouseholdMemberResponse"
                  },
                  "title": "Response Household List Members",
                  "type": "array"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List Members",
        "tags": [
          "household"
        ]
      },
      "post": {
        "description": "Create a new household member.\n\nArgs:\n    member: Member creation data\n    session: Database session\n\nReturns:\n    Created HouseholdMember object",
        "operationId": "household_create_member",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HouseholdMemberCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HouseholdMemberResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Member",
        "tags": [
          "household"
        ]
      }
    },
    "/api/household/members/{member_id}": {
      "delete": {
        "description": "Delete a household member.\n\nThis will also delete all associated person embeddings (cascade).\n\nArgs:\n    member_id: ID of the member to delete\n    session: Database session\n\nRaises:\n    HTTPException: 404 if member not found",
        "operationId": "household_delete_member",
        "parameters": [
          {
            "in": "path",
            "name": "member_id",
            "required": true,
            "schema": {
              "title": "Member Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Member",
        "tags": [
          "household"
        ]
      },
      "get": {
        "description": "Get a specific household member by ID.\n\nArgs:\n    member_id: ID of the member to retrieve\n    session: Database session\n\nReturns:\n    HouseholdMember object\n\nRaises:\n    HTTPException: 404 if member not found",
        "operationId": "household_get_member",
        "parameters": [
          {
            "in": "path",
            "name": "member_id",
            "required": true,
            "schema": {
              "title": "Member Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HouseholdMemberResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Member",
        "tags": [
          "household"
        ]
      },
      "patch": {
        "description": "Update an existing household member.\n\nArgs:\n    member_id: ID of the member to update\n    updates: Member update data (all fields optional)\n    session: Database session\n\nReturns:\n    Updated HouseholdMember object\n\nRaises:\n    HTTPException: 404 if member not found",
        "operationId": "household_update_member",
        "parameters": [
          {
            "in": "path",
            "name": "member_id",
            "required": true,
            "schema": {
              "title": "Member Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HouseholdMemberUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HouseholdMemberResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Member",
        "tags": [
          "household"
        ]
      }
    },
    "/api/household/members/{member_id}/embeddings": {
      "post": {
        "description": "Add a person embedding from an event to a household member.\n\nThis endpoint allows linking a person detection embedding from an event\nto a household member for future re-identification. The embedding data\nis extracted from the event's detection.\n\nArgs:\n    member_id: ID of the household member\n    request: Request containing event_id and confidence\n    session: Database session\n\nReturns:\n    Created PersonEmbedding object\n\nRaises:\n    HTTPException: 404 if member not found\n    HTTPException: 404 if event not found\n    HTTPException: 400 if event has no embedding data",
        "operationId": "household_add_embedding_from_event",
        "parameters": [
          {
            "in": "path",
            "name": "member_id",
            "required": true,
            "schema": {
              "title": "Member Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddEmbeddingRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PersonEmbeddingResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Add Embedding From Event",
        "tags": [
          "household"
        ]
      }
    },
    "/api/household/vehicles": {
      "get": {
        "description": "List all registered vehicles.\n\nReturns all registered vehicles ordered by description.\n\nArgs:\n    session: Database session\n\nReturns:\n    List of RegisteredVehicle objects",
        "operationId": "household_list_vehicles",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/RegisteredVehicleResponse"
                  },
                  "title": "Response Household List Vehicles",
                  "type": "array"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List Vehicles",
        "tags": [
          "household"
        ]
      },
      "post": {
        "description": "Create a new registered vehicle.\n\nArgs:\n    vehicle: Vehicle creation data\n    session: Database session\n\nReturns:\n    Created RegisteredVehicle object\n\nRaises:\n    HTTPException: 404 if owner_id is specified but owner doesn't exist",
        "operationId": "household_create_vehicle",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisteredVehicleCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredVehicleResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Vehicle",
        "tags": [
          "household"
        ]
      }
    },
    "/api/household/vehicles/{vehicle_id}": {
      "delete": {
        "description": "Delete a registered vehicle.\n\nArgs:\n    vehicle_id: ID of the vehicle to delete\n    session: Database session\n\nRaises:\n    HTTPException: 404 if vehicle not found",
        "operationId": "household_delete_vehicle",
        "parameters": [
          {
            "in": "path",
            "name": "vehicle_id",
            "required": true,
            "schema": {
              "title": "Vehicle Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Vehicle",
        "tags": [
          "household"
        ]
      },
      "get": {
        "description": "Get a specific registered vehicle by ID.\n\nArgs:\n    vehicle_id: ID of the vehicle to retrieve\n    session: Database session\n\nReturns:\n    RegisteredVehicle object\n\nRaises:\n    HTTPException: 404 if vehicle not found",
        "operationId": "household_get_vehicle",
        "parameters": [
          {
            "in": "path",
            "name": "vehicle_id",
            "required": true,
            "schema": {
              "title": "Vehicle Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredVehicleResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Vehicle",
        "tags": [
          "household"
        ]
      },
      "patch": {
        "description": "Update an existing registered vehicle.\n\nArgs:\n    vehicle_id: ID of the vehicle to update\n    updates: Vehicle update data (all fields optional)\n    session: Database session\n\nReturns:\n    Updated RegisteredVehicle object\n\nRaises:\n    HTTPException: 404 if vehicle not found\n    HTTPException: 404 if owner_id is specified but owner doesn't exist",
        "operationId": "household_update_vehicle",
        "parameters": [
          {
            "in": "path",
            "name": "vehicle_id",
            "required": true,
            "schema": {
              "title": "Vehicle Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisteredVehicleUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredVehicleResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Vehicle",
        "tags": [
          "household"
        ]
      }
    },
    "/api/jobs": {
      "get": {
        "description": "List all background jobs with optional filtering by type and status.",
        "operationId": "jobs_list_jobs",
        "parameters": [
          {
            "description": "Filter by job type (e.g., 'export', 'cleanup')",
            "in": "query",
            "name": "job_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by job type (e.g., 'export', 'cleanup')",
              "title": "Job Type"
            }
          },
          {
            "description": "Filter by job status",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/JobStatusEnum"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by job status",
              "title": "Status"
            }
          },
          {
            "description": "Maximum number of jobs to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of jobs to return",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of jobs to skip (for pagination)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of jobs to skip (for pagination)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List all jobs",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/bulk-cancel": {
      "post": {
        "description": "Cancel multiple jobs at once. Returns counts of successful and failed cancellations.",
        "operationId": "jobs_bulk_cancel_jobs",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkCancelRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkCancelResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Bulk cancel jobs",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/search": {
      "get": {
        "description": "Search and filter jobs with advanced query capabilities. Supports free text search, filtering by status/type/timestamps/duration, and returns aggregation data for faceted filtering. NEM-2392: Advanced job search endpoint.",
        "operationId": "jobs_search_jobs",
        "parameters": [
          {
            "description": "Free text search across job type, error message, and metadata",
            "in": "query",
            "name": "q",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Free text search across job type, error message, and metadata",
              "title": "Q"
            }
          },
          {
            "description": "Comma-separated status values to filter (e.g., 'running,pending')",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated status values to filter (e.g., 'running,pending')",
              "title": "Status"
            }
          },
          {
            "description": "Comma-separated job types to filter (e.g., 'export,cleanup')",
            "in": "query",
            "name": "job_type",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comma-separated job types to filter (e.g., 'export,cleanup')",
              "title": "Job Type"
            }
          },
          {
            "description": "Queue name filter (reserved for future use)",
            "in": "query",
            "name": "queue",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Queue name filter (reserved for future use)",
              "title": "Queue"
            }
          },
          {
            "description": "Filter jobs created after this ISO timestamp",
            "in": "query",
            "name": "created_after",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter jobs created after this ISO timestamp",
              "title": "Created After"
            }
          },
          {
            "description": "Filter jobs created before this ISO timestamp",
            "in": "query",
            "name": "created_before",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter jobs created before this ISO timestamp",
              "title": "Created Before"
            }
          },
          {
            "description": "Filter jobs completed after this ISO timestamp",
            "in": "query",
            "name": "completed_after",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter jobs completed after this ISO timestamp",
              "title": "Completed After"
            }
          },
          {
            "description": "Filter jobs completed before this ISO timestamp",
            "in": "query",
            "name": "completed_before",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter jobs completed before this ISO timestamp",
              "title": "Completed Before"
            }
          },
          {
            "description": "If true, only jobs with errors; if false, only jobs without errors",
            "in": "query",
            "name": "has_error",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If true, only jobs with errors; if false, only jobs without errors",
              "title": "Has Error"
            }
          },
          {
            "description": "Minimum job duration in seconds (only completed jobs)",
            "in": "query",
            "name": "min_duration",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "minimum": 0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Minimum job duration in seconds (only completed jobs)",
              "title": "Min Duration"
            }
          },
          {
            "description": "Maximum job duration in seconds (only completed jobs)",
            "in": "query",
            "name": "max_duration",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "minimum": 0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Maximum job duration in seconds (only completed jobs)",
              "title": "Max Duration"
            }
          },
          {
            "description": "Maximum number of jobs to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of jobs to return",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of jobs to skip (for pagination)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of jobs to skip (for pagination)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Field to sort by (created_at, started_at, completed_at, progress, job_type, status)",
            "in": "query",
            "name": "sort",
            "required": false,
            "schema": {
              "default": "created_at",
              "description": "Field to sort by (created_at, started_at, completed_at, progress, job_type, status)",
              "title": "Sort",
              "type": "string"
            }
          },
          {
            "description": "Sort direction (asc or desc)",
            "in": "query",
            "name": "order",
            "required": false,
            "schema": {
              "default": "desc",
              "description": "Sort direction (asc or desc)",
              "title": "Order",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobSearchResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Search and filter jobs",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/stats": {
      "get": {
        "description": "Get aggregate statistics about jobs including counts by status, counts by type, and timing information.",
        "operationId": "jobs_get_job_stats",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get job statistics",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/types": {
      "get": {
        "description": "List all available job types that can be created.",
        "operationId": "jobs_list_job_types",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobTypesResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List available job types",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/{job_id}": {
      "delete": {
        "description": "Cancel or abort a job based on its current state. Queued jobs will be cancelled, running jobs will be aborted.",
        "operationId": "jobs_delete_job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobCancelResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Job cannot be cancelled or aborted"
          },
          "404": {
            "description": "Job not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Cancel or abort a job",
        "tags": [
          "jobs"
        ]
      },
      "get": {
        "description": "Get the current status and progress of a background job.",
        "operationId": "jobs_get_job_status",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Job not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get job status",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/{job_id}/abort": {
      "post": {
        "description": "Abort a running background job by sending a signal to the worker. Only jobs with status 'running' can be aborted. Queued jobs should use the /cancel endpoint instead.",
        "operationId": "jobs_abort_job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobAbortResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Job is not running (use cancel for queued jobs)"
          },
          "404": {
            "description": "Job not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Abort a running job",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/{job_id}/cancel": {
      "post": {
        "description": "Request cancellation of a background job. Jobs that are already completed or failed cannot be cancelled.",
        "operationId": "jobs_cancel_job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobCancelResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Job not found"
          },
          "409": {
            "description": "Job cannot be cancelled (already completed or failed)"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Cancel a job",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/{job_id}/detail": {
      "get": {
        "description": "Get detailed information about a specific job including full progress history, timing information, retry details, and execution metadata. NEM-2390: Provides comprehensive job status for monitoring and debugging.",
        "operationId": "jobs_get_job_detail",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobDetailResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Job not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get detailed job information",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/{job_id}/history": {
      "get": {
        "description": "Retrieve complete job execution history including state transitions, retry attempts, and execution timeline. Provides audit trail for debugging and compliance purposes. NEM-2396.",
        "operationId": "jobs_get_job_history",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Job not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get job history",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/jobs/{job_id}/logs": {
      "get": {
        "description": "Retrieve execution logs for a job with optional filtering by level and time range. Useful for debugging and monitoring job execution. NEM-2396.",
        "operationId": "jobs_get_job_logs",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "required": true,
            "schema": {
              "title": "Job Id",
              "type": "string"
            }
          },
          {
            "description": "Minimum log level to return (DEBUG, INFO, WARNING, ERROR)",
            "in": "query",
            "name": "level",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Minimum log level to return (DEBUG, INFO, WARNING, ERROR)",
              "title": "Level"
            }
          },
          {
            "description": "Return logs from this timestamp onwards (ISO format)",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Return logs from this timestamp onwards (ISO format)",
              "title": "Since"
            }
          },
          {
            "description": "Maximum number of log entries to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 1000,
              "description": "Maximum number of log entries to return",
              "maximum": 10000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobLogsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Job not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get job logs",
        "tags": [
          "jobs"
        ]
      }
    },
    "/api/known-persons": {
      "get": {
        "description": "List all known persons.\n\nReturns all registered known persons with their embedding counts.\nOptionally filter to only household members.\n\nArgs:\n    household_only: If True, only return household members\n    session: Database session\n\nReturns:\n    KnownPersonListResponse with list of persons and total count",
        "operationId": "face-recognition_list_known_persons",
        "parameters": [
          {
            "description": "Filter to household members only",
            "in": "query",
            "name": "household_only",
            "required": false,
            "schema": {
              "default": false,
              "description": "Filter to household members only",
              "title": "Household Only",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KnownPersonListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Known Persons",
        "tags": [
          "face-recognition"
        ]
      },
      "post": {
        "description": "Create a new known person.\n\nArgs:\n    data: Person creation data\n    session: Database session\n\nReturns:\n    Created KnownPersonResponse",
        "operationId": "face-recognition_create_known_person",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KnownPersonCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KnownPersonResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Known Person",
        "tags": [
          "face-recognition"
        ]
      }
    },
    "/api/known-persons/{person_id}": {
      "delete": {
        "description": "Delete a known person and all associated embeddings.\n\nArgs:\n    person_id: ID of the person to delete\n    session: Database session\n\nRaises:\n    HTTPException: 404 if person not found",
        "operationId": "face-recognition_delete_known_person",
        "parameters": [
          {
            "in": "path",
            "name": "person_id",
            "required": true,
            "schema": {
              "title": "Person Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Known Person",
        "tags": [
          "face-recognition"
        ]
      },
      "get": {
        "description": "Get a known person by ID.\n\nArgs:\n    person_id: ID of the person\n    session: Database session\n\nReturns:\n    KnownPersonResponse\n\nRaises:\n    HTTPException: 404 if person not found",
        "operationId": "face-recognition_get_known_person",
        "parameters": [
          {
            "in": "path",
            "name": "person_id",
            "required": true,
            "schema": {
              "title": "Person Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KnownPersonResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Known Person",
        "tags": [
          "face-recognition"
        ]
      },
      "patch": {
        "description": "Update a known person.\n\nArgs:\n    person_id: ID of the person to update\n    data: Update data (all fields optional)\n    session: Database session\n\nReturns:\n    Updated KnownPersonResponse\n\nRaises:\n    HTTPException: 404 if person not found",
        "operationId": "face-recognition_update_known_person",
        "parameters": [
          {
            "in": "path",
            "name": "person_id",
            "required": true,
            "schema": {
              "title": "Person Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KnownPersonUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KnownPersonResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Known Person",
        "tags": [
          "face-recognition"
        ]
      }
    },
    "/api/known-persons/{person_id}/embeddings": {
      "get": {
        "description": "List all face embeddings for a person.\n\nArgs:\n    person_id: ID of the person\n    session: Database session\n\nReturns:\n    List of FaceEmbeddingResponse\n\nRaises:\n    HTTPException: 404 if person not found",
        "operationId": "face-recognition_list_person_embeddings",
        "parameters": [
          {
            "in": "path",
            "name": "person_id",
            "required": true,
            "schema": {
              "title": "Person Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/FaceEmbeddingResponse"
                  },
                  "title": "Response Face-Recognition List Person Embeddings",
                  "type": "array"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Person Embeddings",
        "tags": [
          "face-recognition"
        ]
      },
      "post": {
        "description": "Add a face embedding for a known person.\n\nThe embedding should be a 512-dimensional ArcFace embedding vector.\n\nArgs:\n    person_id: ID of the person\n    data: Embedding data with 512-dim vector\n    session: Database session\n\nReturns:\n    Created FaceEmbeddingResponse\n\nRaises:\n    HTTPException: 404 if person not found\n    HTTPException: 400 if embedding is invalid",
        "operationId": "face-recognition_add_face_embedding",
        "parameters": [
          {
            "in": "path",
            "name": "person_id",
            "required": true,
            "schema": {
              "title": "Person Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FaceEmbeddingCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FaceEmbeddingResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Add Face Embedding",
        "tags": [
          "face-recognition"
        ]
      }
    },
    "/api/known-persons/{person_id}/embeddings/{embedding_id}": {
      "delete": {
        "description": "Delete a face embedding.\n\nArgs:\n    person_id: ID of the person (for URL consistency)\n    embedding_id: ID of the embedding to delete\n    session: Database session\n\nRaises:\n    HTTPException: 404 if embedding not found",
        "operationId": "face-recognition_delete_face_embedding",
        "parameters": [
          {
            "in": "path",
            "name": "person_id",
            "required": true,
            "schema": {
              "title": "Person Id",
              "type": "integer"
            }
          },
          {
            "in": "path",
            "name": "embedding_id",
            "required": true,
            "schema": {
              "title": "Embedding Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Face Embedding",
        "tags": [
          "face-recognition"
        ]
      }
    },
    "/api/logs": {
      "get": {
        "description": "Query logs with optional filtering by level, component, source, and date range.",
        "operationId": "logs_list_logs",
        "parameters": [
          {
            "description": "Filter by log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
            "in": "query",
            "name": "level",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
              "title": "Level"
            }
          },
          {
            "description": "Filter by component (partial match)",
            "in": "query",
            "name": "component",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by component (partial match)",
              "title": "Component"
            }
          },
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter by source (backend, frontend)",
            "in": "query",
            "name": "source",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by source (backend, frontend)",
              "title": "Source"
            }
          },
          {
            "description": "Full-text search on message content",
            "in": "query",
            "name": "search",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Full-text search on message content",
              "title": "Search"
            }
          },
          {
            "description": "Filter from date (ISO format)",
            "in": "query",
            "name": "start_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter from date (ISO format)",
              "title": "Start Date"
            }
          },
          {
            "description": "Filter to date (ISO format)",
            "in": "query",
            "name": "end_date",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter to date (ISO format)",
              "title": "End Date"
            }
          },
          {
            "description": "Page size",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 100,
              "description": "Page size",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip (deprecated, use cursor)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip (deprecated, use cursor)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          },
          {
            "description": "Pagination cursor from previous response",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Pagination cursor from previous response",
              "title": "Cursor"
            }
          },
          {
            "description": "Include total count in response. Defaults to False for performance.",
            "in": "query",
            "name": "include_total_count",
            "required": false,
            "schema": {
              "default": false,
              "description": "Include total count in response. Defaults to False for performance.",
              "title": "Include Total Count",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogsListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid date range or cursor"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List logs with optional filtering",
        "tags": [
          "logs"
        ]
      }
    },
    "/api/logs/frontend": {
      "post": {
        "description": "Receive a single log entry from the frontend for structured logging.",
        "operationId": "logs_ingest_frontend_log",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FrontendLogEntry"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FrontendLogResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Ingest single frontend log",
        "tags": [
          "logs"
        ]
      }
    },
    "/api/logs/frontend/batch": {
      "post": {
        "description": "Receive a batch of log entries from the frontend for structured logging.",
        "operationId": "logs_ingest_frontend_logs_batch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FrontendLogBatchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FrontendLogResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Ingest batch of frontend logs",
        "tags": [
          "logs"
        ]
      }
    },
    "/api/logs/stats": {
      "get": {
        "description": "Get aggregated log statistics for the dashboard.",
        "operationId": "logs_get_log_stats",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogStats"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get log statistics",
        "tags": [
          "logs"
        ]
      }
    },
    "/api/media/cameras/{camera_id}/{filename}": {
      "get": {
        "description": "Serve camera images or videos from Foscam storage.\n\nArgs:\n    camera_id: The camera identifier (directory name)\n    filename: The file to serve (can include subdirectories)\n\nReturns:\n    FileResponse with appropriate content-type header\n\nRaises:\n    HTTPException: 403 for invalid paths, 404 for missing files",
        "operationId": "media_serve_camera_file",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "title": "Filename",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File served successfully"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "Access denied"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "File not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Serve Camera File",
        "tags": [
          "media"
        ]
      }
    },
    "/api/media/clips/{filename}": {
      "get": {
        "description": "Serve event video clips.\n\nClips are generated by the ClipGenerator service and stored in the\nconfigured clips directory.\n\nArgs:\n    filename: The clip filename (e.g., \"123_clip.mp4\")\n    clip_generator: ClipGenerator injected via Depends()\n\nReturns:\n    FileResponse with appropriate content-type header\n\nRaises:\n    HTTPException: 403 for invalid paths, 404 for missing files",
        "operationId": "media_serve_clip",
        "parameters": [
          {
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "title": "Filename",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Clip served successfully"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "Access denied"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "File not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Serve Clip",
        "tags": [
          "media"
        ]
      }
    },
    "/api/media/thumbnails/{filename}": {
      "get": {
        "description": "Serve detection thumbnail images.\n\nArgs:\n    filename: The thumbnail filename\n\nReturns:\n    FileResponse with appropriate content-type header\n\nRaises:\n    HTTPException: 403 for invalid paths, 404 for missing files",
        "operationId": "media_serve_thumbnail",
        "parameters": [
          {
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "title": "Filename",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Thumbnail served successfully"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "Access denied"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "File not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Serve Thumbnail",
        "tags": [
          "media"
        ]
      }
    },
    "/api/media/{path}": {
      "get": {
        "description": "Compatibility route: serve media via design-spec-style /api/media/{path}.\n\nThis preserves the stricter behavior of the new routes:\n- Path traversal protection\n- Allowed file type allowlist\n- Must remain under configured base directories\n\nMapping rules:\n- `cameras/<camera_id>/<filename...>` -> camera media\n- `thumbnails/<filename>` -> thumbnails\n- `detections/<id>` -> detection images",
        "operationId": "media_serve_media_compat",
        "parameters": [
          {
            "in": "path",
            "name": "path",
            "required": true,
            "schema": {
              "title": "Path",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File served successfully"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "Access denied"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaErrorResponse"
                }
              }
            },
            "description": "File not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "429": {
            "description": "Too many requests"
          }
        },
        "summary": "Serve Media Compat",
        "tags": [
          "media"
        ]
      }
    },
    "/api/metrics": {
      "get": {
        "description": "Return Prometheus metrics in exposition format.\n\nThis endpoint returns all registered metrics in the standard\nPrometheus exposition format for scraping.\n\nReturns:\n    Response with text/plain content type containing metrics",
        "operationId": "metrics_metrics",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "description": "Prometheus metrics in exposition format"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Metrics",
        "tags": [
          "metrics"
        ]
      }
    },
    "/api/notification-preferences/": {
      "get": {
        "description": "Get global notification preferences.\n\nReturns the global notification settings including:\n- Whether notifications are enabled\n- Notification sound selection\n- Risk level filters (which risk levels trigger notifications)\n\nReturns:\n    NotificationPreferencesResponse with current preferences",
        "operationId": "notification-preferences_get_notification_preferences",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationPreferencesResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Notification Preferences",
        "tags": [
          "notification-preferences"
        ]
      },
      "put": {
        "description": "Update global notification preferences.\n\nArgs:\n    update: Preferences update data\n\nReturns:\n    NotificationPreferencesResponse with updated preferences\n\nRaises:\n    HTTPException: 400 if sound value is invalid",
        "operationId": "notification-preferences_update_notification_preferences",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NotificationPreferencesUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationPreferencesResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid sound or risk level value"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Notification Preferences",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification-preferences/cameras": {
      "get": {
        "description": "Get all camera notification settings.\n\nReturns:\n    CameraNotificationSettingsListResponse with all camera settings",
        "operationId": "notification-preferences_get_all_camera_settings",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraNotificationSettingsListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get All Camera Settings",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification-preferences/cameras/{camera_id}": {
      "get": {
        "description": "Get notification setting for a specific camera.\n\nArgs:\n    camera_id: Camera ID\n\nReturns:\n    CameraNotificationSettingResponse for the camera\n\nRaises:\n    HTTPException: 404 if setting not found",
        "operationId": "notification-preferences_get_camera_setting",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraNotificationSettingResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Camera notification setting not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Camera Setting",
        "tags": [
          "notification-preferences"
        ]
      },
      "put": {
        "description": "Update or create notification setting for a camera.\n\nArgs:\n    camera_id: Camera ID\n    update: Setting update data\n\nReturns:\n    CameraNotificationSettingResponse with updated setting\n\nRaises:\n    HTTPException: 404 if camera doesn't exist",
        "operationId": "notification-preferences_update_camera_setting",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraNotificationSettingUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraNotificationSettingResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Camera not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Camera Setting",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification-preferences/quiet-hours": {
      "get": {
        "description": "Get all quiet hours periods.\n\nReturns:\n    QuietHoursPeriodsListResponse with all quiet periods",
        "operationId": "notification-preferences_get_quiet_hours",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuietHoursPeriodsListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Quiet Hours",
        "tags": [
          "notification-preferences"
        ]
      },
      "post": {
        "description": "Create a new quiet hours period.\n\nArgs:\n    period: Quiet hours period data\n\nReturns:\n    QuietHoursPeriodResponse with created period\n\nRaises:\n    HTTPException: 400 if start_time equals end_time (zero-length period)\n\nNote:\n    Periods can span midnight (e.g., 22:00 to 06:00).\n    If start_time > end_time, the period wraps to the next day.",
        "operationId": "notification-preferences_create_quiet_hours_period",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QuietHoursPeriodCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuietHoursPeriodResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid time range"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Create Quiet Hours Period",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification-preferences/quiet-hours/{period_id}": {
      "delete": {
        "description": "Delete a quiet hours period.\n\nArgs:\n    period_id: Period UUID\n\nRaises:\n    HTTPException: 404 if period not found",
        "operationId": "notification-preferences_delete_quiet_hours_period",
        "parameters": [
          {
            "in": "path",
            "name": "period_id",
            "required": true,
            "schema": {
              "title": "Period Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "404": {
            "description": "Quiet hours period not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Delete Quiet Hours Period",
        "tags": [
          "notification-preferences"
        ]
      }
    },
    "/api/notification/config": {
      "get": {
        "description": "Get notification configuration status.\n\nReturns the current notification configuration including:\n- Whether notifications are enabled\n- Which channels are configured (email, webhook, push)\n- SMTP host and port (if configured)\n- Default webhook URL (if configured)\n- Default email recipients\n\nNote: Sensitive fields like SMTP password are NOT returned.\n\nReturns:\n    NotificationConfigResponse with current notification settings",
        "operationId": "notification_get_notification_config",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Notification Config",
        "tags": [
          "notification"
        ]
      },
      "patch": {
        "description": "Update notification configuration.\n\nAllows enabling/disabling SMTP and webhook channels, and updating their settings.\nOnly specified fields will be updated; others remain unchanged.\n\nArgs:\n    config_update: Partial configuration update with optional fields\n\nReturns:\n    NotificationConfigUpdateResponse with the updated configuration",
        "operationId": "notification_update_notification_config",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NotificationConfigUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationConfigUpdateResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Notification Config",
        "tags": [
          "notification"
        ]
      }
    },
    "/api/notification/history": {
      "get": {
        "description": "Get notification delivery history with optional filters.\n\nReturns paginated notification delivery records with optional filtering\nby alert ID, channel type, and success status.\n\nNote: This endpoint returns the structure for notification history.\nA future enhancement will persist delivery records to the database\nand return actual history data.\n\nArgs:\n    alert_id: Optional alert ID to filter by\n    channel: Optional notification channel to filter by\n    success: Optional success status to filter by\n    limit: Maximum number of results to return (1-100, default 50)\n    offset: Number of results to skip for pagination (default 0)\n\nReturns:\n    NotificationHistoryResponse with delivery history entries",
        "operationId": "notification_get_notification_history",
        "parameters": [
          {
            "description": "Filter by alert ID",
            "in": "query",
            "name": "alert_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by alert ID",
              "title": "Alert Id"
            }
          },
          {
            "description": "Filter by channel",
            "in": "query",
            "name": "channel",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/NotificationChannel"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by channel",
              "title": "Channel"
            }
          },
          {
            "description": "Filter by success status",
            "in": "query",
            "name": "success",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by success status",
              "title": "Success"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotificationHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Notification History",
        "tags": [
          "notification"
        ]
      }
    },
    "/api/notification/test": {
      "post": {
        "description": "Test notification delivery for a specific channel.\n\nSends a test notification to verify the configuration is working.\nFor email, sends a test email to the specified recipients or default recipients.\nFor webhook, sends a test payload to the specified URL or default URL.\n\nArgs:\n    test_request: Test notification request with channel and optional overrides\n\nReturns:\n    TestNotificationResponse with test result",
        "operationId": "notification_test_notification",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookTestNotificationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestNotificationResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Test Notification",
        "tags": [
          "notification"
        ]
      }
    },
    "/api/outbound-webhooks": {
      "get": {
        "description": "List all outbound webhook configurations with optional filtering.",
        "operationId": "outbound-webhooks_list_webhooks",
        "parameters": [
          {
            "description": "Filter to only return enabled webhooks",
            "in": "query",
            "name": "enabled_only",
            "required": false,
            "schema": {
              "default": false,
              "description": "Filter to only return enabled webhooks",
              "title": "Enabled Only",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List webhooks",
        "tags": [
          "outbound-webhooks"
        ]
      },
      "post": {
        "description": "Create a new outbound webhook configuration. The webhook will be triggered when subscribed events occur in the system.",
        "operationId": "outbound-webhooks_create_webhook",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Create webhook",
        "tags": [
          "outbound-webhooks"
        ]
      }
    },
    "/api/outbound-webhooks/deliveries/{delivery_id}": {
      "get": {
        "description": "Get detailed information about a specific webhook delivery attempt.",
        "operationId": "outbound-webhooks_get_delivery",
        "parameters": [
          {
            "in": "path",
            "name": "delivery_id",
            "required": true,
            "schema": {
              "title": "Delivery Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookDeliveryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Delivery not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get delivery details",
        "tags": [
          "outbound-webhooks"
        ]
      }
    },
    "/api/outbound-webhooks/deliveries/{delivery_id}/retry": {
      "post": {
        "description": "Manually retry a failed webhook delivery. Creates a new delivery attempt for the same event and webhook configuration.",
        "operationId": "outbound-webhooks_retry_delivery",
        "parameters": [
          {
            "in": "path",
            "name": "delivery_id",
            "required": true,
            "schema": {
              "title": "Delivery Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookDeliveryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Delivery not found"
          },
          "409": {
            "description": "Delivery cannot be retried (not in failed state)"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Retry failed delivery",
        "tags": [
          "outbound-webhooks"
        ]
      }
    },
    "/api/outbound-webhooks/health": {
      "get": {
        "description": "Get aggregated health metrics for all outbound webhooks, including success rates and delivery statistics over the last 24 hours.",
        "operationId": "outbound-webhooks_get_webhook_health",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookHealthSummary"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get webhook health summary",
        "tags": [
          "outbound-webhooks"
        ]
      }
    },
    "/api/outbound-webhooks/{webhook_id}": {
      "delete": {
        "description": "Delete an outbound webhook configuration. This will also delete all associated delivery history.",
        "operationId": "outbound-webhooks_delete_webhook",
        "parameters": [
          {
            "in": "path",
            "name": "webhook_id",
            "required": true,
            "schema": {
              "title": "Webhook Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "404": {
            "description": "Webhook not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Delete webhook",
        "tags": [
          "outbound-webhooks"
        ]
      },
      "get": {
        "description": "Get a specific outbound webhook configuration by ID.",
        "operationId": "outbound-webhooks_get_webhook",
        "parameters": [
          {
            "in": "path",
            "name": "webhook_id",
            "required": true,
            "schema": {
              "title": "Webhook Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Webhook not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get webhook",
        "tags": [
          "outbound-webhooks"
        ]
      },
      "patch": {
        "description": "Update an existing outbound webhook configuration.",
        "operationId": "outbound-webhooks_update_webhook",
        "parameters": [
          {
            "in": "path",
            "name": "webhook_id",
            "required": true,
            "schema": {
              "title": "Webhook Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Webhook not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update webhook",
        "tags": [
          "outbound-webhooks"
        ]
      }
    },
    "/api/outbound-webhooks/{webhook_id}/deliveries": {
      "get": {
        "description": "List delivery history for a specific webhook with pagination.",
        "operationId": "outbound-webhooks_list_deliveries",
        "parameters": [
          {
            "in": "path",
            "name": "webhook_id",
            "required": true,
            "schema": {
              "title": "Webhook Id",
              "type": "string"
            }
          },
          {
            "description": "Maximum number of deliveries to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of deliveries to return",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of deliveries to skip (for pagination)",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of deliveries to skip (for pagination)",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookDeliveryListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Webhook not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "List deliveries",
        "tags": [
          "outbound-webhooks"
        ]
      }
    },
    "/api/outbound-webhooks/{webhook_id}/disable": {
      "post": {
        "description": "Disable a webhook so it will stop receiving events.",
        "operationId": "outbound-webhooks_disable_webhook",
        "parameters": [
          {
            "in": "path",
            "name": "webhook_id",
            "required": true,
            "schema": {
              "title": "Webhook Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Webhook not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Disable webhook",
        "tags": [
          "outbound-webhooks"
        ]
      }
    },
    "/api/outbound-webhooks/{webhook_id}/enable": {
      "post": {
        "description": "Enable a disabled webhook so it will receive events.",
        "operationId": "outbound-webhooks_enable_webhook",
        "parameters": [
          {
            "in": "path",
            "name": "webhook_id",
            "required": true,
            "schema": {
              "title": "Webhook Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Webhook not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Enable webhook",
        "tags": [
          "outbound-webhooks"
        ]
      }
    },
    "/api/outbound-webhooks/{webhook_id}/test": {
      "post": {
        "description": "Test a webhook by sending a sample payload. This does not create a delivery record and is useful for validating webhook configuration.",
        "operationId": "outbound-webhooks_test_webhook",
        "parameters": [
          {
            "in": "path",
            "name": "webhook_id",
            "required": true,
            "schema": {
              "title": "Webhook Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookTestRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookTestResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Webhook not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Test webhook",
        "tags": [
          "outbound-webhooks"
        ]
      }
    },
    "/api/plate-reads": {
      "get": {
        "description": "List plate reads with optional filters.\n\nReturns a paginated list of plate recognition results with optional\nfiltering by camera, time range, and confidence threshold.\n\nArgs:\n    db: Database session.\n    camera_id: Optional filter by camera ID.\n    start_time: Optional start time filter (ISO format).\n    end_time: Optional end time filter (ISO format).\n    min_confidence: Optional minimum OCR confidence filter (0-1).\n    page: Page number (1-indexed, default 1).\n    page_size: Number of items per page (1-100, default 50).\n\nReturns:\n    PlateReadListResponse with paginated plate reads.\n\nExample:\n    GET /api/plate-reads?camera_id=driveway&page=1&page_size=25",
        "operationId": "plate-reads_list_plate_reads",
        "parameters": [
          {
            "description": "Filter by camera ID",
            "in": "query",
            "name": "camera_id",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by camera ID",
              "title": "Camera Id"
            }
          },
          {
            "description": "Filter reads after this time (ISO format)",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter reads after this time (ISO format)",
              "title": "Start Time"
            }
          },
          {
            "description": "Filter reads before this time (ISO format)",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter reads before this time (ISO format)",
              "title": "End Time"
            }
          },
          {
            "description": "Minimum OCR confidence filter",
            "in": "query",
            "name": "min_confidence",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Minimum OCR confidence filter",
              "title": "Min Confidence"
            }
          },
          {
            "description": "Page number (1-indexed)",
            "in": "query",
            "name": "page",
            "required": false,
            "schema": {
              "default": 1,
              "description": "Page number (1-indexed)",
              "minimum": 1,
              "title": "Page",
              "type": "integer"
            }
          },
          {
            "description": "Number of items per page",
            "in": "query",
            "name": "page_size",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Number of items per page",
              "maximum": 100,
              "minimum": 1,
              "title": "Page Size",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PlateReadListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Plate Reads",
        "tags": [
          "plate-reads"
        ]
      },
      "post": {
        "description": "Create a new plate read record.\n\nUsed for manual entry or importing plate reads from external ALPR\nsystems. For automatic recognition from images, use POST /recognize.\n\nArgs:\n    data: PlateReadCreate schema with plate data.\n    db: Database session.\n\nReturns:\n    PlateReadResponse with the created record.\n\nExample:\n    POST /api/plate-reads\n    {\n        \"camera_id\": \"driveway\",\n        \"timestamp\": \"2026-01-26T14:30:00Z\",\n        \"plate_text\": \"ABC1234\",\n        \"raw_text\": \"ABC-1234\",\n        \"detection_confidence\": 0.95,\n        \"ocr_confidence\": 0.92,\n        \"bbox\": [100.0, 200.0, 250.0, 240.0],\n        \"image_quality_score\": 0.85,\n        \"is_enhanced\": false,\n        \"is_blurry\": false\n    }",
        "operationId": "plate-reads_create_plate_read",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PlateReadCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PlateReadResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Plate Read",
        "tags": [
          "plate-reads"
        ]
      }
    },
    "/api/plate-reads/camera/{camera_id}": {
      "get": {
        "description": "Get plate reads for a specific camera.\n\nReturns a paginated list of plate reads from the specified camera\nwith optional time range filtering.\n\nArgs:\n    camera_id: ID of the camera to get reads for.\n    db: Database session.\n    start_time: Optional start time filter (ISO format).\n    end_time: Optional end time filter (ISO format).\n    page: Page number (1-indexed, default 1).\n    page_size: Number of items per page (1-100, default 50).\n\nReturns:\n    PlateReadListResponse with camera's plate reads.\n\nExample:\n    GET /api/plate-reads/camera/driveway?page=1&page_size=25",
        "operationId": "plate-reads_get_reads_by_camera",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Filter reads after this time (ISO format)",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter reads after this time (ISO format)",
              "title": "Start Time"
            }
          },
          {
            "description": "Filter reads before this time (ISO format)",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter reads before this time (ISO format)",
              "title": "End Time"
            }
          },
          {
            "description": "Page number (1-indexed)",
            "in": "query",
            "name": "page",
            "required": false,
            "schema": {
              "default": 1,
              "description": "Page number (1-indexed)",
              "minimum": 1,
              "title": "Page",
              "type": "integer"
            }
          },
          {
            "description": "Number of items per page",
            "in": "query",
            "name": "page_size",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Number of items per page",
              "maximum": 100,
              "minimum": 1,
              "title": "Page Size",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PlateReadListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Reads By Camera",
        "tags": [
          "plate-reads"
        ]
      }
    },
    "/api/plate-reads/recognize": {
      "post": {
        "description": "Recognize plate text from an uploaded image.\n\nProcesses the image through PaddleOCR to extract plate text.\nOptionally stores the result in the database.\n\nThe image should be base64-encoded JPEG or PNG data, optionally\nprefixed with a data URL scheme (e.g., \"data:image/jpeg;base64,\").\n\nArgs:\n    request: PlateRecognizeRequest with image data.\n    db: Database session.\n    store: Whether to store the result (default true).\n\nReturns:\n    PlateRecognizeResponse with recognition results.\n\nRaises:\n    HTTPException: 400 if image decoding fails.\n    HTTPException: 500 if OCR processing fails.\n\nExample:\n    POST /api/plate-reads/recognize?store=true\n    {\n        \"camera_id\": \"driveway\",\n        \"image_base64\": \"data:image/jpeg;base64,/9j/4AAQSkZ...\",\n        \"detection_bbox\": [100.0, 200.0, 250.0, 240.0],\n        \"detection_confidence\": 0.95\n    }",
        "operationId": "plate-reads_recognize_plate",
        "parameters": [
          {
            "description": "Whether to store the result in database",
            "in": "query",
            "name": "store",
            "required": false,
            "schema": {
              "default": true,
              "description": "Whether to store the result in database",
              "title": "Store",
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PlateRecognizeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PlateRecognizeResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Recognize Plate",
        "tags": [
          "plate-reads"
        ]
      }
    },
    "/api/plate-reads/search": {
      "get": {
        "description": "Search plate reads by plate text.\n\nSearches for plate reads matching the given text. By default performs\na partial match (LIKE %text%). Set exact=true for exact matches only.\n\nArgs:\n    db: Database session.\n    text: Plate text to search for (required).\n    exact: If true, match exactly; if false, partial match (default).\n    page: Page number (1-indexed, default 1).\n    page_size: Number of items per page (1-100, default 50).\n\nReturns:\n    PlateReadListResponse with matching plate reads.\n\nExample:\n    GET /api/plate-reads/search?text=ABC&exact=false\n    GET /api/plate-reads/search?text=ABC1234&exact=true",
        "operationId": "plate-reads_search_by_plate_text",
        "parameters": [
          {
            "description": "Plate text to search for",
            "in": "query",
            "name": "text",
            "required": true,
            "schema": {
              "description": "Plate text to search for",
              "minLength": 1,
              "title": "Text",
              "type": "string"
            }
          },
          {
            "description": "If true, match exactly; otherwise partial match",
            "in": "query",
            "name": "exact",
            "required": false,
            "schema": {
              "default": false,
              "description": "If true, match exactly; otherwise partial match",
              "title": "Exact",
              "type": "boolean"
            }
          },
          {
            "description": "Page number (1-indexed)",
            "in": "query",
            "name": "page",
            "required": false,
            "schema": {
              "default": 1,
              "description": "Page number (1-indexed)",
              "minimum": 1,
              "title": "Page",
              "type": "integer"
            }
          },
          {
            "description": "Number of items per page",
            "in": "query",
            "name": "page_size",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Number of items per page",
              "maximum": 100,
              "minimum": 1,
              "title": "Page Size",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PlateReadListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Search By Plate Text",
        "tags": [
          "plate-reads"
        ]
      }
    },
    "/api/plate-reads/statistics": {
      "get": {
        "description": "Get plate recognition statistics.\n\nReturns aggregate statistics for ALPR system health monitoring,\nincluding total reads, average confidence, and recent activity.\n\nArgs:\n    db: Database session.\n\nReturns:\n    PlateStatisticsResponse with recognition metrics.\n\nExample:\n    GET /api/plate-reads/statistics",
        "operationId": "plate-reads_get_statistics",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PlateStatisticsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Statistics",
        "tags": [
          "plate-reads"
        ]
      }
    },
    "/api/plate-reads/{plate_read_id}": {
      "get": {
        "description": "Get a single plate read by ID.\n\nRetrieves full details of a specific plate read record.\n\nArgs:\n    plate_read_id: Database ID of the plate read.\n    db: Database session.\n\nReturns:\n    PlateReadResponse with the plate read details.\n\nRaises:\n    HTTPException: 404 if plate read not found.\n\nExample:\n    GET /api/plate-reads/123",
        "operationId": "plate-reads_get_plate_read",
        "parameters": [
          {
            "in": "path",
            "name": "plate_read_id",
            "required": true,
            "schema": {
              "title": "Plate Read Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PlateReadResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Plate Read",
        "tags": [
          "plate-reads"
        ]
      }
    },
    "/api/prompts": {
      "get": {
        "description": "Fetch current prompt configurations for all AI models.\n\nReturns the active prompt/configuration for each supported model:\n- nemotron: System prompt for risk analysis\n- florence2: Scene analysis queries\n- yolo_world: Custom object classes and confidence threshold\n- xclip: Action recognition classes\n- fashion_clip: Clothing categories",
        "operationId": "prompts_get_all_prompts",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AllPromptsResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get All Prompts",
        "tags": [
          "prompts"
        ]
      }
    },
    "/api/prompts/export": {
      "get": {
        "description": "Export all prompt configurations as JSON.\n\nReturns a complete export of all model configurations suitable for\nbackup, sharing, or importing into another instance.",
        "operationId": "prompts_export_prompts",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptsExportResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Export Prompts",
        "tags": [
          "prompts"
        ]
      }
    },
    "/api/prompts/history": {
      "get": {
        "description": "Get version history for prompt configurations.\n\nReturns a list of all prompt versions, optionally filtered by model.",
        "operationId": "prompts_get_prompt_history",
        "parameters": [
          {
            "description": "Filter by specific model",
            "in": "query",
            "name": "model",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/AIModelEnum"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by specific model",
              "title": "Model"
            }
          },
          {
            "description": "Maximum results to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum results to return",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Offset for pagination",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Offset for pagination",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Prompt History",
        "tags": [
          "prompts"
        ]
      }
    },
    "/api/prompts/history/{version_id}": {
      "post": {
        "description": "Restore a specific prompt version.\n\nCreates a new version with the configuration from the specified version,\nmaking it the active configuration.",
        "operationId": "prompts_restore_prompt_version",
        "parameters": [
          {
            "in": "path",
            "name": "version_id",
            "required": true,
            "schema": {
              "title": "Version Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptRestoreResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Version not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Restore Prompt Version",
        "tags": [
          "prompts"
        ]
      }
    },
    "/api/prompts/import": {
      "post": {
        "description": "Import prompt configurations from JSON.\n\nValidates and imports configurations for each model, creating new\nversions for each imported configuration.",
        "operationId": "prompts_import_prompts",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptsImportRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptsImportResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Import Prompts",
        "tags": [
          "prompts"
        ]
      }
    },
    "/api/prompts/import/preview": {
      "post": {
        "description": "Preview import changes without applying them.\n\nValidates the import data and computes diffs against current configurations.",
        "operationId": "prompts_preview_import_prompts",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptsImportPreviewRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptsImportPreviewResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Preview Import Prompts",
        "tags": [
          "prompts"
        ]
      }
    },
    "/api/prompts/test": {
      "post": {
        "description": "Test a modified prompt configuration against an event or image.\n\nRuns inference with the modified configuration and compares results\nwith the original configuration.\n\nRate Limited:\n    This endpoint is rate limited to 10 requests per minute per client\n    with a burst allowance of 3. This protects the AI services from abuse\n    since prompt testing runs LLM inference which is computationally expensive.\n\nReturns 429 Too Many Requests if rate limit is exceeded.",
        "operationId": "prompts_test_prompt",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptTestRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptTestResult"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error - Invalid configuration"
          },
          "429": {
            "description": "Too many requests - Rate limit exceeded"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Test Prompt",
        "tags": [
          "prompts"
        ]
      }
    },
    "/api/prompts/test-prompt": {
      "post": {
        "description": "Test a custom prompt against an existing event for A/B testing.\n\nThis endpoint allows testing a custom prompt without persisting results.\nIt's designed for the Prompt Playground A/B testing feature where users\ncan experiment with different prompts and compare results.\n\nThe endpoint:\n1. Fetches the event with its detections\n2. Builds context from the event data\n3. Calls the AI model with the custom prompt (or mocks if service unavailable)\n4. Returns results WITHOUT saving to database\n\nRate Limited:\n    This endpoint is rate limited to 10 requests per minute per client\n    with a burst allowance of 3. This protects the AI services from abuse\n    since prompt testing runs LLM inference which is computationally expensive.\n\nArgs:\n    request: Test request containing event_id, custom_prompt, and optional\n             parameters (temperature, max_tokens, model)\n    db: Database session\n\nReturns:\n    CustomTestPromptResponse with risk analysis results\n\nRaises:\n    HTTPException: 404 if event not found\n    HTTPException: 400 if prompt is invalid (empty or too long)\n    HTTPException: 429 if rate limit is exceeded\n    HTTPException: 503 if AI service is unavailable\n    HTTPException: 408 if request times out (>60s)",
        "operationId": "prompts_test_custom_prompt",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CustomTestPromptRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CustomTestPromptResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Invalid or too long prompt"
          },
          "404": {
            "description": "Event not found"
          },
          "408": {
            "description": "Request timeout"
          },
          "422": {
            "description": "Validation error"
          },
          "429": {
            "description": "Too many requests - Rate limit exceeded"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "AI service unavailable"
          }
        },
        "summary": "Test Custom Prompt",
        "tags": [
          "prompts"
        ]
      }
    },
    "/api/prompts/{model}": {
      "get": {
        "description": "Fetch prompt configuration for a specific AI model.",
        "operationId": "prompts_get_prompt_for_model",
        "parameters": [
          {
            "in": "path",
            "name": "model",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/AIModelEnum"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelPromptConfig"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Model configuration not found"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Prompt For Model",
        "tags": [
          "prompts"
        ]
      },
      "put": {
        "description": "Update prompt configuration for a specific AI model.\n\nCreates a new version of the configuration while preserving history.\nValidates the configuration structure before saving.\n\nSupports optimistic locking via expected_version in the request body.\nIf expected_version is provided and doesn't match the current version,\nreturns 409 Conflict to indicate concurrent modification.",
        "operationId": "prompts_update_prompt_for_model",
        "parameters": [
          {
            "in": "path",
            "name": "model",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/AIModelEnum"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelPromptConfig"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Model not found"
          },
          "409": {
            "description": "Conflict - Concurrent modification detected"
          },
          "422": {
            "description": "Validation error - Invalid configuration"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Prompt For Model",
        "tags": [
          "prompts"
        ]
      }
    },
    "/api/queues/status": {
      "get": {
        "description": "Get the status of all job queues including depth, processing rate, and health.\n\n**Queues Monitored:**\n- `detection`: Object detection jobs from camera uploads\n- `ai_analysis`: LLM risk analysis jobs for batched detections\n- `dlq`: Dead-letter queue for failed jobs\n\n**Health Status:**\n- `healthy`: Queue depth below warning threshold, wait times acceptable\n- `warning`: Queue depth approaching limits or wait times elevated\n- `critical`: Queue depth exceeds limits or oldest job waiting too long\n\n**Thresholds:**\nEach queue has configurable thresholds:\n- `depth_warning`: Queue depth that triggers warning status\n- `depth_critical`: Queue depth that triggers critical status\n- `max_wait_seconds`: Maximum acceptable wait time for oldest job",
        "operationId": "queues_get_queues_status",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "example": {
                  "queues": [
                    {
                      "depth": 15,
                      "name": "ai_analysis",
                      "oldest_job": {
                        "id": "job_12345",
                        "queued_at": "2025-12-23T10:30:00.000000",
                        "wait_seconds": 45.2
                      },
                      "running": 2,
                      "status": "healthy",
                      "throughput": {
                        "avg_processing_seconds": 4.8,
                        "jobs_per_minute": 12.5
                      },
                      "workers": 4
                    }
                  ],
                  "summary": {
                    "overall_status": "healthy",
                    "total_queued": 15,
                    "total_running": 2,
                    "total_workers": 4
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/QueuesStatusResponse"
                }
              }
            },
            "description": "Queue status retrieved successfully"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get queue status",
        "tags": [
          "queues"
        ]
      }
    },
    "/api/rum": {
      "post": {
        "description": "Receive Core Web Vitals metrics from the frontend for Real User Monitoring.",
        "operationId": "rum_ingest_rum_metrics",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RUMBatchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RUMIngestResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Ingest RUM metrics",
        "tags": [
          "rum"
        ]
      }
    },
    "/api/scheduled-reports": {
      "get": {
        "description": "Get a list of all scheduled reports with their configurations.",
        "operationId": "scheduled-reports_list_scheduled_reports",
        "parameters": [
          {
            "in": "query",
            "name": "enabled",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Enabled"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduledReportListResponse"
                }
              }
            },
            "description": "List of scheduled reports"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List all scheduled reports",
        "tags": [
          "scheduled-reports"
        ]
      },
      "post": {
        "description": "Create a new scheduled report with the specified configuration. Reports can be daily, weekly, or monthly, and can be delivered via email.",
        "operationId": "scheduled-reports_create_scheduled_report",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ScheduledReportCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduledReportResponse"
                }
              }
            },
            "description": "Scheduled report created successfully"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Create a scheduled report",
        "tags": [
          "scheduled-reports"
        ]
      }
    },
    "/api/scheduled-reports/{report_id}": {
      "delete": {
        "description": "Delete a scheduled report by ID.",
        "operationId": "scheduled-reports_delete_scheduled_report",
        "parameters": [
          {
            "in": "path",
            "name": "report_id",
            "required": true,
            "schema": {
              "title": "Report Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Scheduled report deleted successfully"
          },
          "404": {
            "description": "Scheduled report not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete a scheduled report",
        "tags": [
          "scheduled-reports"
        ]
      },
      "get": {
        "description": "Get details of a specific scheduled report by ID.",
        "operationId": "scheduled-reports_get_scheduled_report",
        "parameters": [
          {
            "in": "path",
            "name": "report_id",
            "required": true,
            "schema": {
              "title": "Report Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduledReportResponse"
                }
              }
            },
            "description": "Scheduled report details"
          },
          "404": {
            "description": "Scheduled report not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get a scheduled report",
        "tags": [
          "scheduled-reports"
        ]
      },
      "put": {
        "description": "Update an existing scheduled report configuration. All fields are optional - only provided fields will be updated.",
        "operationId": "scheduled-reports_update_scheduled_report",
        "parameters": [
          {
            "in": "path",
            "name": "report_id",
            "required": true,
            "schema": {
              "title": "Report Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ScheduledReportUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduledReportResponse"
                }
              }
            },
            "description": "Scheduled report updated successfully"
          },
          "404": {
            "description": "Scheduled report not found"
          },
          "422": {
            "description": "Validation error"
          }
        },
        "summary": "Update a scheduled report",
        "tags": [
          "scheduled-reports"
        ]
      }
    },
    "/api/scheduled-reports/{report_id}/run": {
      "post": {
        "description": "Manually trigger a scheduled report to run immediately, regardless of its schedule.",
        "operationId": "scheduled-reports_run_scheduled_report",
        "parameters": [
          {
            "in": "path",
            "name": "report_id",
            "required": true,
            "schema": {
              "title": "Report Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduledReportRunResponse"
                }
              }
            },
            "description": "Report run initiated"
          },
          "404": {
            "description": "Scheduled report not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Manually trigger a report",
        "tags": [
          "scheduled-reports"
        ]
      }
    },
    "/api/summaries/daily": {
      "get": {
        "description": "Get the latest daily summary.\n\nReturns the most recent daily summary, which covers high/critical events\nsince midnight today. Returns null if no daily summary exists.\n\nThis endpoint is useful when you only need the daily summary without\nthe overhead of fetching the hourly summary as well.\n\nReturns:\n    SummaryResponse with daily summary, or null if none exists",
        "operationId": "summaries_get_daily_summary",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "example": {
                  "content": "Today has seen minimal high-priority activity...",
                  "event_count": 1,
                  "generated_at": "2026-01-18T14:55:00Z",
                  "id": 2,
                  "window_end": "2026-01-18T15:00:00Z",
                  "window_start": "2026-01-18T00:00:00Z"
                },
                "schema": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/SummaryResponse"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "title": "Response Summaries Get Daily Summary"
                }
              }
            },
            "description": "Latest daily summary or null if none exists"
          }
        },
        "summary": "Get Daily Summary",
        "tags": [
          "summaries"
        ]
      }
    },
    "/api/summaries/hourly": {
      "get": {
        "description": "Get the latest hourly summary.\n\nReturns the most recent hourly summary, which covers high/critical events\nfrom the past 60 minutes. Returns null if no hourly summary exists.\n\nThis endpoint is useful when you only need the hourly summary without\nthe overhead of fetching the daily summary as well.\n\nReturns:\n    SummaryResponse with hourly summary, or null if none exists",
        "operationId": "summaries_get_hourly_summary",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "example": {
                  "content": "Over the past hour, one critical event occurred...",
                  "event_count": 1,
                  "generated_at": "2026-01-18T14:55:00Z",
                  "id": 1,
                  "window_end": "2026-01-18T15:00:00Z",
                  "window_start": "2026-01-18T14:00:00Z"
                },
                "schema": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/SummaryResponse"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "title": "Response Summaries Get Hourly Summary"
                }
              }
            },
            "description": "Latest hourly summary or null if none exists"
          }
        },
        "summary": "Get Hourly Summary",
        "tags": [
          "summaries"
        ]
      }
    },
    "/api/summaries/latest": {
      "get": {
        "description": "Get the latest hourly and daily summaries.\n\nReturns both the most recent hourly summary (covering the past 60 minutes)\nand the most recent daily summary (covering since midnight today).\n\nEither `hourly` or `daily` can be null if no summary exists yet for that\ntime period. This can happen when:\n- The system was just started\n- No high/critical events have occurred\n\nResponse is cached in Redis with a 5-minute TTL to match the summary\ngeneration frequency. Cache is invalidated when new summaries are generated.\n\nReturns:\n    LatestSummariesResponse with hourly and daily summaries (or nulls)",
        "operationId": "summaries_get_latest_summaries",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "example": {
                  "daily": {
                    "content": "Today has seen...",
                    "event_count": 1,
                    "generated_at": "2026-01-18T14:55:00Z",
                    "id": 2,
                    "window_end": "2026-01-18T15:00:00Z",
                    "window_start": "2026-01-18T00:00:00Z"
                  },
                  "hourly": {
                    "content": "Over the past hour...",
                    "event_count": 1,
                    "generated_at": "2026-01-18T14:55:00Z",
                    "id": 1,
                    "window_end": "2026-01-18T15:00:00Z",
                    "window_start": "2026-01-18T14:00:00Z"
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/LatestSummariesResponse"
                }
              }
            },
            "description": "Latest hourly and daily summaries"
          }
        },
        "summary": "Get Latest Summaries",
        "tags": [
          "summaries"
        ]
      }
    },
    "/api/system/ai-services": {
      "get": {
        "description": "Returns all AI services with their VRAM requirements.",
        "operationId": "gpu-config_list_ai_services",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AiServicesResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List available AI services",
        "tags": [
          "gpu-config"
        ]
      }
    },
    "/api/system/anomaly-config": {
      "get": {
        "description": "Get current anomaly detection configuration.\n\nReturns the current settings for the baseline service including:\n- threshold_stdev: Number of standard deviations for anomaly detection\n- min_samples: Minimum samples required before anomaly detection is reliable\n- decay_factor: Exponential decay factor for EWMA (weights recent observations)\n- window_days: Rolling window size in days for baseline calculations\n\nArgs:\n    service: BaselineService injected via Depends()\n\nReturns:\n    AnomalyConfig with current anomaly detection settings",
        "operationId": "system_get_anomaly_config",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnomalyConfig"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Get Anomaly Config",
        "tags": [
          "system"
        ]
      },
      "patch": {
        "description": "Update anomaly detection configuration.\n\nAllows updating the anomaly detection thresholds:\n- threshold_stdev: Number of standard deviations for anomaly detection\n- min_samples: Minimum samples required before anomaly detection is reliable\n\nNote: decay_factor and window_days are not configurable at runtime\nas they affect historical data calculations.\n\nRequires API key authentication.\n\nArgs:\n    config_update: Configuration values to update (only provided values are changed)\n    request: HTTP request for audit logging\n    db: Database session\n    service: BaselineService injected via Depends()\n\nReturns:\n    AnomalyConfig with updated settings",
        "operationId": "system_update_anomaly_config",
        "parameters": [
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AnomalyConfigUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnomalyConfig"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Update Anomaly Config",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/circuit-breakers": {
      "get": {
        "description": "Get status of all circuit breakers in the system.\n\nReturns the current state and metrics for each circuit breaker,\nwhich protect external services from cascading failures.\n\nCircuit breakers can be in one of three states:\n- CLOSED: Normal operation, calls pass through\n- OPEN: Service failing, calls rejected immediately\n- HALF_OPEN: Testing recovery, limited calls allowed\n\nReturns:\n    CircuitBreakersResponse with status of all circuit breakers",
        "operationId": "system_get_circuit_breakers",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CircuitBreakersResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Circuit Breakers",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/circuit-breakers/{name}/reset": {
      "post": {
        "description": "Reset a specific circuit breaker to CLOSED state.\n\nThis manually resets a circuit breaker, clearing failure counts\nand returning it to normal operation. Use this to recover from\ntransient failures or after fixing an underlying issue.\n\nRequires API key authentication when api_key_enabled is True.\n\nArgs:\n    name: Name of the circuit breaker to reset\n\nReturns:\n    CircuitBreakerResetResponse with reset confirmation\n\nRaises:\n    HTTPException 400: If name is invalid (empty, too long, or contains invalid characters)\n    HTTPException 404: If circuit breaker not found",
        "operationId": "system_reset_circuit_breaker",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          },
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CircuitBreakerResetResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Reset Circuit Breaker",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/cleanup": {
      "post": {
        "description": "Trigger manual data cleanup based on retention settings.\n\nRequires API key authentication when api_key_enabled is True in settings.\nProvide the API key via X-API-Key header.\n\nThis endpoint runs the CleanupService to delete old data according to\nthe configured retention period. It deletes:\n- Events older than retention period\n- Detections older than retention period\n- GPU stats older than retention period\n- Logs older than log retention period\n- Associated thumbnail files\n- Optionally original image files (if delete_images is enabled)\n\nThe cleanup respects the current retention_days setting from the system\nconfiguration. To change the retention period before running cleanup,\nuse PATCH /api/system/config first.\n\nArgs:\n    dry_run: If True, calculate and return what would be deleted without\n             actually performing the deletion. Useful for verification\n             before destructive operations.\n\nReturns:\n    CleanupResponse with statistics about the cleanup operation.\n    When dry_run=True, the counts represent what would be deleted.",
        "operationId": "system_trigger_cleanup",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "required": false,
            "schema": {
              "default": false,
              "title": "Dry Run",
              "type": "boolean"
            }
          },
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Trigger Cleanup",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/cleanup/orphaned-files": {
      "post": {
        "description": "Find and clean up orphaned files (files on disk not referenced in database).\n\nRequires API key authentication when api_key_enabled is True in settings.\nProvide the API key via X-API-Key header.\n\nThis endpoint scans storage directories for files that are not referenced\nin the database and optionally deletes them to reclaim disk space.\n\nStorage directories scanned:\n- Thumbnails directory (video_thumbnails_dir setting)\n- Clips directory (clips_directory setting)\n\nDatabase tables checked for file references:\n- Detection.file_path (source images)\n- Detection.thumbnail_path (thumbnails)\n- Event.clip_path (generated clips)\n\n**Safety Features:**\n- dry_run=True by default to prevent accidental deletion\n- Progress tracking via job system\n- Detailed reporting of orphaned files\n\nArgs:\n    dry_run: If True, calculate and return what would be deleted without\n             actually performing the deletion. Default is True for safety.\n             Set to False to actually delete orphaned files.\n\nReturns:\n    OrphanedFileCleanupResponse with statistics about orphaned files.\n    When dry_run=True, shows what would be deleted.\n    When dry_run=False, shows what was deleted.",
        "operationId": "system_run_orphaned_file_cleanup",
        "parameters": [
          {
            "description": "If True, only report what would be deleted without deleting. Default is True for safety.",
            "in": "query",
            "name": "dry_run",
            "required": false,
            "schema": {
              "default": true,
              "description": "If True, only report what would be deleted without deleting. Default is True for safety.",
              "title": "Dry Run",
              "type": "boolean"
            }
          },
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrphanedFileCleanupResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Run Orphaned File Cleanup",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/cleanup/status": {
      "get": {
        "description": "Get current status of the cleanup service.\n\nReturns information about the automated cleanup service including:\n- Whether the service is running\n- Current retention settings\n- Next scheduled cleanup time\n\nReturns:\n    CleanupStatusResponse with cleanup service status",
        "operationId": "system_get_cleanup_status",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Cleanup Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/config": {
      "get": {
        "description": "Get public configuration settings.\n\nReturns non-sensitive application configuration values.\nDoes NOT expose database URLs, API keys, or other secrets.\n\nNote: The detection_confidence_threshold field is deprecated.\nUse /api/v1/settings detection.confidence_threshold instead.\n\nReturns:\n    ConfigResponse with public configuration settings",
        "operationId": "system_get_config",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Config",
        "tags": [
          "system"
        ]
      },
      "patch": {
        "description": "Patch processing-related configuration and persist runtime overrides.\n\nRequires API key authentication when api_key_enabled is True in settings.\nProvide the API key via X-API-Key header.\n\nNote: The detection_confidence_threshold field is deprecated.\nUse PATCH /api/v1/settings with detection.confidence_threshold instead.\n\nNotes:\n- This updates a runtime override env file (see `HSI_RUNTIME_ENV_PATH`) and clears the\n  settings cache so subsequent `get_settings()` calls observe the new values.",
        "operationId": "system_patch_config",
        "parameters": [
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfigUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized - API key required"
          },
          "422": {
            "description": "Validation error"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Patch Config",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/gpu": {
      "get": {
        "description": "Get current GPU statistics.\n\nReturns the most recent GPU statistics including:\n- GPU name\n- GPU utilization percentage\n- Memory usage (used/total)\n- Temperature\n- Power usage\n- Inference FPS\n\nResults are cached for HEALTH_CACHE_TTL_SECONDS (default 5 seconds) to reduce\ndatabase load from frequent polling. GPU stats only update every 5 seconds anyway.\n\nReturns:\n    GPUStatsResponse with GPU statistics (null values if unavailable)",
        "operationId": "system_get_gpu_stats",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GPUStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Gpu Stats",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/gpu-config": {
      "get": {
        "description": "Returns current GPU assignment strategy and service-to-GPU mappings.",
        "operationId": "gpu-config_get_gpu_config",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GpuConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "Failed to load configuration"
          }
        },
        "summary": "Get GPU configuration",
        "tags": [
          "gpu-config"
        ]
      },
      "put": {
        "description": "Updates GPU assignments. Does not apply changes - use /apply endpoint.",
        "operationId": "gpu-config_update_gpu_config",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GpuConfigUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GpuConfigUpdateResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid configuration"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Failed to save configuration"
          }
        },
        "summary": "Update GPU configuration",
        "tags": [
          "gpu-config"
        ]
      }
    },
    "/api/system/gpu-config/apply": {
      "post": {
        "description": "Applies current config and restarts affected services.",
        "operationId": "gpu-config_apply_gpu_config",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GpuApplyResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "409": {
            "description": "Apply operation already in progress"
          },
          "500": {
            "description": "Failed to apply configuration"
          }
        },
        "summary": "Apply GPU configuration",
        "tags": [
          "gpu-config"
        ]
      }
    },
    "/api/system/gpu-config/detect": {
      "post": {
        "description": "Triggers a fresh GPU scan and updates the database.",
        "operationId": "gpu-config_detect_gpus",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GpuDevicesResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "GPU detection failed"
          }
        },
        "summary": "Re-detect GPUs",
        "tags": [
          "gpu-config"
        ]
      }
    },
    "/api/system/gpu-config/preview": {
      "get": {
        "description": "Preview what assignments would result from a given strategy.",
        "operationId": "gpu-config_preview_gpu_config",
        "parameters": [
          {
            "description": "Assignment strategy to preview",
            "in": "query",
            "name": "strategy",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GpuAssignmentStrategy",
              "description": "Assignment strategy to preview"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GpuConfigPreviewResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Invalid strategy"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Preview generation failed"
          }
        },
        "summary": "Preview auto-assignment",
        "tags": [
          "gpu-config"
        ]
      }
    },
    "/api/system/gpu-config/services": {
      "get": {
        "description": "Returns health status of all AI services including GPU assignments.",
        "operationId": "gpu-config_get_service_health",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceHealthResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get AI service health status",
        "tags": [
          "gpu-config"
        ]
      }
    },
    "/api/system/gpu-config/status": {
      "get": {
        "description": "Returns current status of GPU configuration apply operation.",
        "operationId": "gpu-config_get_gpu_config_status",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GpuConfigStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get apply operation status",
        "tags": [
          "gpu-config"
        ]
      }
    },
    "/api/system/gpu/history": {
      "get": {
        "description": "Get recent GPU stats samples as a time-series.\n\nReturns GPU stats in standard pagination envelope format (NEM-2178):\n- items: GPU stats samples (renamed from 'samples')\n- pagination: Standard pagination metadata\n\nArgs:\n    since: Optional lower bound for recorded_at (ISO datetime)\n    limit: Maximum number of samples to return (default 300, max 5000)\n    db: Database session",
        "operationId": "system_get_gpu_stats_history",
        "parameters": [
          {
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Since"
            }
          },
          {
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 300,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GPUStatsHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Gpu Stats History",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/gpus": {
      "get": {
        "description": "Returns all GPUs detected on the system with hardware specs and utilization.",
        "operationId": "gpu-config_list_gpus",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GpuDevicesResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "500": {
            "description": "GPU detection failed"
          }
        },
        "summary": "List detected GPUs",
        "tags": [
          "gpu-config"
        ]
      }
    },
    "/api/system/health": {
      "get": {
        "description": "Get detailed system health check.\n\nChecks the health of all system components:\n- Database connectivity\n- Redis connectivity\n- AI services status\n\nHealth checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).\nIf a health check times out, the service is marked as unhealthy.\n\nResults are cached for HEALTH_CACHE_TTL_SECONDS (default 5 seconds) to reduce\nload from frequent health probes. Cached responses are returned immediately\nwithout re-checking services.\n\nReturns:\n    HealthResponse with overall status and individual service statuses.\n    HTTP 200 if healthy, 503 if degraded or unhealthy.",
        "operationId": "system_get_health",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Health",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/health/full": {
      "get": {
        "description": "Get comprehensive health status for all system components.",
        "operationId": "system_get_full_health",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FullHealthResponse"
                }
              }
            },
            "description": "System is healthy"
          },
          "503": {
            "description": "One or more critical services are unhealthy"
          }
        },
        "summary": "Get Full System Health Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/health/ready": {
      "get": {
        "description": "Kubernetes-style readiness probe endpoint with detailed information.\n\nThis endpoint indicates whether the application is ready to receive\ntraffic and process uploads. It checks all critical dependencies:\n- Database connectivity (critical)\n- Redis connectivity (required for queue processing)\n- AI services availability\n- Background worker status\n\nNote: The canonical readiness probe is GET /ready at the root level.\nThis endpoint provides the same readiness check but with detailed\nservice and worker status information.\n\nUsed by Kubernetes/Docker to determine if traffic should be routed to this instance.\nIf this endpoint returns not_ready, the instance should not receive new requests.\n\nHealth checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).\nIf a health check times out, the service is marked as unhealthy.\n\nResults are cached for HEALTH_CACHE_TTL_SECONDS (default 5 seconds) to reduce\nload from frequent readiness probes.\n\nReturns:\n    ReadinessResponse with overall readiness status and detailed checks.\n    HTTP 200 if ready, 503 if degraded or not ready.",
        "operationId": "system_get_readiness",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReadinessResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Readiness",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/health/websocket": {
      "get": {
        "description": "Get health status of WebSocket broadcasters and their circuit breakers.\n\nReturns the current state of circuit breakers for:\n- Event broadcaster: Handles real-time security event distribution\n- System broadcaster: Handles system status updates (GPU, cameras, queues)\n\nCircuit breakers protect the system from cascading failures by:\n- Opening after repeated connection failures\n- Blocking recovery attempts while open to allow stabilization\n- Gradually testing recovery in half-open state\n\nCircuit breaker states:\n- closed: Normal operation, WebSocket events flowing normally\n- open: Failures detected, events may be delayed or unavailable\n- half_open: Testing recovery, limited operations allowed\n\nReturns:\n    WebSocketHealthResponse with circuit breaker status for both broadcasters",
        "operationId": "system_get_websocket_health",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebSocketHealthResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Websocket Health",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/model-zoo/latency/history": {
      "get": {
        "description": "Get latency history for a specific Model Zoo model.\n\nReturns time-series latency data for the dropdown-controlled chart.\nEach bucket contains aggregated statistics (avg, p50, p95).\n\nArgs:\n    model: Model name to get history for\n    since: Number of minutes of history to return (default 60)\n    bucket_seconds: Size of each time bucket in seconds (default 60)\n\nReturns:\n    ModelLatencyHistoryResponse with chronologically ordered snapshots\n\nRaises:\n    HTTPException: 404 if model not found in registry",
        "operationId": "system_get_model_zoo_latency_history",
        "parameters": [
          {
            "description": "Model name to get latency history for (e.g., 'yolo11-license-plate')",
            "in": "query",
            "name": "model",
            "required": true,
            "schema": {
              "description": "Model name to get latency history for (e.g., 'yolo11-license-plate')",
              "title": "Model",
              "type": "string"
            }
          },
          {
            "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "default": 60,
              "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
              "maximum": 1440,
              "minimum": 1,
              "title": "Since",
              "type": "integer"
            }
          },
          {
            "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
            "in": "query",
            "name": "bucket_seconds",
            "required": false,
            "schema": {
              "default": 60,
              "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
              "maximum": 3600,
              "minimum": 10,
              "title": "Bucket Seconds",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelLatencyHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Model Zoo Latency History",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/model-zoo/status": {
      "get": {
        "description": "Get status information for all Model Zoo models.\n\nReturns status information for all 18 Model Zoo models, including:\n- Current status (loaded, unloaded, disabled)\n- VRAM usage when loaded\n- Last usage timestamp (derived from EventAudit records, None if DB unavailable)\n- Category grouping for UI display\n\nThis endpoint is optimized for the compact status card display\nin the AI Performance page.\n\nArgs:\n    db: Optional database session for querying EventAudit last used timestamps\n\nReturns:\n    ModelZooStatusResponse with all model statuses",
        "operationId": "system_get_model_zoo_status",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelZooStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Model Zoo Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/models": {
      "get": {
        "description": "Get the current status of all models in the Model Zoo.\n\nReturns comprehensive information about all AI models available in the system,\nincluding their VRAM requirements, loading status, and configuration.\n\n**VRAM Budget**: The Model Zoo has a dedicated VRAM budget of 1650 MB,\nseparate from the YOLO26v2 detector and Nemotron LLM allocations.\n\n**Loading Strategy**: Models are loaded sequentially (one at a time) to\nprevent VRAM fragmentation and ensure stable operation.\n\n**Model Categories**:\n- detection: Object detection models (YOLO variants)\n- recognition: Face and license plate recognition\n- ocr: Optical character recognition\n- embedding: Visual embedding models (CLIP)\n- depth-estimation: Depth estimation models\n- pose: Human pose estimation\n\nReturns:\n    ModelRegistryResponse with VRAM stats and all model statuses",
        "operationId": "system_get_models",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelRegistryResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Model Zoo Registry",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/models/{model_name}": {
      "get": {
        "description": "Get detailed status information for a specific model.\n\nArgs:\n    model_name: Unique identifier of the model (e.g., 'yolo11-license-plate')\n\nReturns:\n    ModelStatusResponse with detailed model information\n\nRaises:\n    HTTPException: 404 if model not found in registry",
        "operationId": "system_get_model",
        "parameters": [
          {
            "in": "path",
            "name": "model_name",
            "required": true,
            "schema": {
              "title": "Model Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Model Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/monitoring/health": {
      "get": {
        "description": "Get comprehensive monitoring stack health status.\n\nChecks the health of the monitoring infrastructure including:\n- Prometheus server reachability\n- Scrape target status (UP/DOWN counts by job)\n- Exporter status (redis-exporter, json-exporter, blackbox-exporter)\n- Metrics collection status\n\nThis endpoint provides operators with a quick view of monitoring\nstack health without needing to access the Prometheus UI directly.\n\nReturns:\n    MonitoringHealthResponse with full monitoring stack status.\n    The 'healthy' field is True if Prometheus is reachable and\n    the majority of critical targets are up.",
        "operationId": "system_get_monitoring_health",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitoringHealthResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Monitoring Health",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/monitoring/targets": {
      "get": {
        "description": "Get detailed status of all Prometheus scrape targets.\n\nReturns complete information about every target Prometheus is\nconfigured to scrape, including:\n- Job and instance identifiers\n- Health status (up/down)\n- All labels associated with the target\n- Last scrape timestamp and duration\n- Any scrape errors\n\nThis endpoint is useful for debugging specific target issues\nor getting a comprehensive view of all monitored endpoints.\n\nReturns:\n    MonitoringTargetsResponse with detailed target information.\n\nRaises:\n    HTTPException: 503 if Prometheus is unreachable",
        "operationId": "system_get_monitoring_targets",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitoringTargetsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Monitoring Targets",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/performance": {
      "get": {
        "description": "Get current system performance metrics.\n\nCollects and returns real-time metrics from all system components:\n- GPU: Utilization, VRAM usage, temperature, power consumption\n- AI Models: YOLO26v2 and Nemotron status and resource usage\n- Inference: Latency percentiles and throughput metrics\n- Databases: PostgreSQL and Redis connection status and performance\n- Host: CPU, RAM, and disk usage\n- Containers: Health status of all running containers\n- Alerts: Active performance alerts when thresholds are exceeded\n\nThis endpoint powers the System Performance Dashboard and provides\na comprehensive snapshot of system health at the time of the request.\n\nReturns:\n    PerformanceUpdate with all available metrics. Fields may be None\n    if a particular metric source is unavailable.\n\nRaises:\n    HTTPException: 503 if performance collector is not initialized\n    HTTPException: 500 if metric collection fails",
        "operationId": "system_get_performance_metrics",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PerformanceUpdate"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Performance Metrics",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/performance/history": {
      "get": {
        "description": "Get historical system performance metrics.\n\nReturns historical performance snapshots for time-series visualization.\nThe data is sampled based on the requested time range to provide\napproximately 60 data points for each range:\n\n- 5m: All snapshots from the last 5 minutes (every 5s = 60 points max)\n- 15m: Sampled snapshots from last 15 minutes (every 15s = 60 points max)\n- 60m: Sampled snapshots from last 60 minutes (every 60s = 60 points max)\n\nThis endpoint enables the System Performance Dashboard to display\nhistorical trends and patterns in system metrics.\n\nArgs:\n    time_range: Time range for history (5m, 15m, or 60m). Defaults to 5m.\n\nReturns:\n    PerformanceHistoryResponse containing:\n    - snapshots: List of PerformanceUpdate objects in chronological order\n    - time_range: The requested time range\n    - count: Number of snapshots returned",
        "operationId": "system_get_performance_history",
        "parameters": [
          {
            "in": "query",
            "name": "time_range",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/TimeRange",
              "default": "5m"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PerformanceHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Performance History",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/pipeline": {
      "get": {
        "description": "Get combined status of all pipeline operations.\n\nReturns real-time visibility into the AI processing pipeline:\n\n**FileWatcher**: Monitors camera directories for new uploads\n- running: Whether the watcher is active\n- camera_root: Directory being watched\n- pending_tasks: Files waiting for debounce completion\n- observer_type: Filesystem observer type (native/polling)\n\n**BatchAggregator**: Groups detections into time-based batches\n- active_batches: Number of batches being aggregated\n- batches: Details of each active batch\n- batch_window_seconds: Configured window timeout\n- idle_timeout_seconds: Configured idle timeout\n\n**DegradationManager**: Handles graceful degradation\n- mode: Current degradation mode (normal/degraded/minimal/offline)\n- is_degraded: Whether system is in any degraded state\n- services: Health status of registered services\n- available_features: Features available in current mode\n\nReturns:\n    PipelineStatusResponse with status of all pipeline services",
        "operationId": "system_get_pipeline_status",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Pipeline Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/pipeline-latency": {
      "get": {
        "description": "Get pipeline latency metrics with percentiles.\n\nReturns latency statistics for each stage transition in the AI pipeline:\n- watch_to_detect: Time from file watcher detecting image to YOLO26 processing start\n- detect_to_batch: Time from detection completion to batch aggregation\n- batch_to_analyze: Time from batch completion to Nemotron analysis start\n- total_pipeline: Total end-to-end processing time\n\nEach stage includes:\n- avg_ms: Average latency in milliseconds\n- min_ms: Minimum latency\n- max_ms: Maximum latency\n- p50_ms: 50th percentile (median)\n- p95_ms: 95th percentile\n- p99_ms: 99th percentile\n- sample_count: Number of samples used\n\nArgs:\n    window_minutes: Time window for statistics calculation (default 60 minutes)\n\nReturns:\n    PipelineLatencyResponse with latency statistics for each stage",
        "operationId": "system_get_pipeline_latency",
        "parameters": [
          {
            "in": "query",
            "name": "window_minutes",
            "required": false,
            "schema": {
              "default": 60,
              "title": "Window Minutes",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineLatencyResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Pipeline Latency",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/pipeline-latency/history": {
      "get": {
        "description": "Get pipeline latency history for time-series visualization.\n\nReturns latency data grouped into time buckets for charting.\nEach bucket contains aggregated statistics for all pipeline stages.\n\nArgs:\n    since: Number of minutes of history to return (1-1440, default 60)\n    bucket_seconds: Size of each time bucket in seconds (10-3600, default 60)\n\nReturns:\n    PipelineLatencyHistoryResponse with chronologically ordered snapshots",
        "operationId": "system_get_pipeline_latency_history",
        "parameters": [
          {
            "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "default": 60,
              "description": "Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours)",
              "maximum": 1440,
              "minimum": 1,
              "title": "Since",
              "type": "integer"
            }
          },
          {
            "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
            "in": "query",
            "name": "bucket_seconds",
            "required": false,
            "schema": {
              "default": 60,
              "description": "Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour)",
              "maximum": 3600,
              "minimum": 10,
              "title": "Bucket Seconds",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineLatencyHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Pipeline Latency History",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/services": {
      "get": {
        "description": "Get status of all managed services.\n\nArgs:\n    category: Optional filter by category (infrastructure, ai, monitoring)\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    List of services with status and category summaries.",
        "operationId": "services_list_services",
        "parameters": [
          {
            "in": "query",
            "name": "category",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ServiceCategory"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Category"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServicesResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "List Services",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/services/{name}/disable": {
      "post": {
        "description": "Manually disable a service.\n\nPrevents self-healing restarts.\n\nArgs:\n    name: Service name to disable\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found",
        "operationId": "services_disable_service",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Service not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "Disable Service",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/services/{name}/enable": {
      "post": {
        "description": "Re-enable a disabled service.\n\nResets failure count and allows self-healing to resume.\n\nArgs:\n    name: Service name to enable\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found",
        "operationId": "services_enable_service",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "404": {
            "description": "Service not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "Enable Service",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/services/{name}/restart": {
      "post": {
        "description": "Manually restart a service.\n\nResets failure count (manual restart is intentional).\n\nArgs:\n    name: Service name to restart\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found, 400 if service is disabled",
        "operationId": "services_restart_service",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Service is disabled"
          },
          "404": {
            "description": "Service not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "Restart Service",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/services/{name}/start": {
      "post": {
        "description": "Start a stopped service container.\n\nArgs:\n    name: Service name to start\n    orchestrator: Container orchestrator instance (injected)\n\nReturns:\n    Action result with updated service information\n\nRaises:\n    HTTPException: 404 if service not found,\n                   400 if service is already running or disabled",
        "operationId": "services_start_service",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "title": "Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceActionResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad request - Service already running or disabled"
          },
          "404": {
            "description": "Service not found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Container orchestrator not available"
          }
        },
        "summary": "Start Service",
        "tags": [
          "services"
        ]
      }
    },
    "/api/system/severity": {
      "get": {
        "description": "Get severity level definitions and thresholds.\n\nReturns complete information about the severity taxonomy including:\n- All severity level definitions (LOW, MEDIUM, HIGH, CRITICAL)\n- Risk score thresholds for each level\n- Color codes for UI display\n- Human-readable labels and descriptions\n\nThis endpoint is useful for frontends to:\n- Display severity information consistently\n- Show severity legends in the UI\n- Validate severity-related user inputs\n- Map risk scores to severity levels client-side\n\nReturns:\n    SeverityMetadataResponse with all severity definitions and current thresholds",
        "operationId": "system_get_severity_metadata",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeverityMetadataResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Severity Metadata",
        "tags": [
          "system"
        ]
      },
      "put": {
        "description": "Update severity threshold configuration.\n\nUpdates the risk score thresholds for severity levels. The thresholds\ndefine how risk scores (0-100) are mapped to severity levels:\n- LOW: 0 to low_max\n- MEDIUM: low_max+1 to medium_max\n- HIGH: medium_max+1 to high_max\n- CRITICAL: high_max+1 to 100\n\nRequires API key authentication when api_key_enabled is True in settings.\nProvide the API key via X-API-Key header.\n\nValidation:\n- Thresholds must be strictly ordered: low_max < medium_max < high_max\n- All thresholds must be between 1 and 99\n- This ensures contiguous, non-overlapping ranges covering 0-100\n\nNote: Changes only affect new events. Existing events retain their\noriginal severity assignment.\n\nArgs:\n    update: New threshold values\n\nReturns:\n    SeverityMetadataResponse with updated definitions and thresholds\n\nRaises:\n    HTTPException 400: If thresholds are not strictly ordered",
        "operationId": "system_update_severity_thresholds",
        "parameters": [
          {
            "in": "header",
            "name": "x-api-key",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "X-Api-Key"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeverityThresholdsUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeverityMetadataResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Severity Thresholds",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/stats": {
      "get": {
        "description": "Get system statistics.\n\nReturns aggregate statistics about the system:\n- Total number of cameras\n- Total number of events\n- Total number of detections\n- Application uptime\n\nResults are cached for HEALTH_CACHE_TTL_SECONDS (default 5 seconds) to reduce\ndatabase load from three sequential COUNT queries.\n\nReturns:\n    SystemStatsResponse with system statistics",
        "operationId": "system_get_stats",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SystemStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Stats",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/storage": {
      "get": {
        "description": "Get storage statistics and disk usage metrics.\n\nReturns detailed storage usage information including:\n- Overall disk usage (used/total/free)\n- Storage breakdown by category (thumbnails, images, clips)\n- Database record counts (events, detections, GPU stats, logs)\n\nThis endpoint helps operators:\n- Monitor available storage space\n- Understand storage distribution across data types\n- Plan cleanup operations\n- Track database growth\n\nReturns:\n    StorageStatsResponse with comprehensive storage metrics",
        "operationId": "system_get_storage_stats",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageStatsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Storage Stats",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/supervisor": {
      "get": {
        "description": "Get status of the Worker Supervisor and all supervised workers.\n\nThe Worker Supervisor monitors pipeline worker tasks and automatically\nrestarts them with exponential backoff when they crash.\n\nReturns:\n    WorkerSupervisorStatusResponse with:\n    - running: Whether the supervisor is active\n    - worker_count: Number of registered workers\n    - workers: Detailed status of each supervised worker including:\n      - status: running/stopped/crashed/restarting/failed\n      - restart_count: Number of restart attempts\n      - last_started_at/last_crashed_at: Timestamps\n      - error: Last error message if crashed\n\nUse this endpoint to monitor worker health and identify workers that\nare repeatedly crashing or have exceeded their restart limit.",
        "operationId": "system_get_supervisor_status",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkerSupervisorStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Supervisor Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/supervisor/reset/{worker_name}": {
      "post": {
        "description": "Reset a failed worker's restart count to allow new restart attempts.\n\nWhen a worker exceeds its max restart limit, it enters FAILED status\nand won't be restarted. Use this endpoint to reset the worker's\nrestart count and transition it back to STOPPED status, allowing\nthe supervisor to attempt restarts again.\n\nArgs:\n    worker_name: Name of the worker to reset\n\nReturns:\n    Dictionary with success status and message\n\nRaises:\n    HTTPException 404: Worker not found\n    HTTPException 503: Supervisor not initialized",
        "operationId": "system_reset_worker",
        "parameters": [
          {
            "in": "path",
            "name": "worker_name",
            "required": true,
            "schema": {
              "title": "Worker Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "boolean"
                      }
                    ]
                  },
                  "title": "Response System Reset Worker",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Reset Worker",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/supervisor/restart-history": {
      "get": {
        "description": "Get paginated history of worker restart events.\n\nReturns a list of restart events including both automatic restarts\n(triggered by crashes) and manual restarts.\n\nArgs:\n    worker_name: Optional filter by worker name\n    limit: Maximum number of events to return (default 50, max 100)\n    offset: Number of events to skip for pagination\n\nReturns:\n    RestartHistoryResponse with events and pagination metadata",
        "operationId": "system_get_restart_history",
        "parameters": [
          {
            "description": "Filter by worker name",
            "in": "query",
            "name": "worker_name",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by worker name",
              "title": "Worker Name"
            }
          },
          {
            "description": "Maximum number of events to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of events to return",
              "maximum": 100,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of events to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of events to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RestartHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Restart History",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/supervisor/status": {
      "get": {
        "description": "Get full status of the Worker Supervisor and all supervised workers.\n\nThis endpoint is an alias for GET /supervisor but with a clearer path\nthat matches the API convention for status endpoints.\n\nReturns:\n    WorkerSupervisorStatusResponse with:\n    - running: Whether the supervisor is active\n    - worker_count: Number of registered workers\n    - workers: Detailed status of each supervised worker\n    - timestamp: When the status was queried",
        "operationId": "system_get_supervisor_full_status",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkerSupervisorStatusResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Supervisor Full Status",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/supervisor/workers/{worker_name}/restart": {
      "post": {
        "description": "Manually restart a supervised worker.\n\nThis stops the worker if running and starts it again with reset state.\n\nArgs:\n    worker_name: Name of the worker to restart (e.g., file_watcher, detector)\n\nReturns:\n    WorkerControlResponse with success status and message\n\nRaises:\n    HTTPException 400: Invalid worker name format\n    HTTPException 404: Worker not found\n    HTTPException 503: Supervisor not initialized",
        "operationId": "system_restart_supervisor_worker",
        "parameters": [
          {
            "in": "path",
            "name": "worker_name",
            "required": true,
            "schema": {
              "title": "Worker Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkerControlResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Restart Supervisor Worker",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/supervisor/workers/{worker_name}/start": {
      "post": {
        "description": "Manually start a stopped supervised worker.\n\nThis starts a worker that was previously stopped. If the worker\nis already running, this is a no-op and returns success.\n\nArgs:\n    worker_name: Name of the worker to start\n\nReturns:\n    WorkerControlResponse with success status and message\n\nRaises:\n    HTTPException 400: Invalid worker name format\n    HTTPException 404: Worker not found\n    HTTPException 503: Supervisor not initialized",
        "operationId": "system_start_supervisor_worker",
        "parameters": [
          {
            "in": "path",
            "name": "worker_name",
            "required": true,
            "schema": {
              "title": "Worker Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkerControlResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Start Supervisor Worker",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/supervisor/workers/{worker_name}/stop": {
      "post": {
        "description": "Manually stop a supervised worker.\n\nThis stops the worker's task. The worker will remain registered\nbut will not be automatically restarted by the supervisor.\n\nArgs:\n    worker_name: Name of the worker to stop\n\nReturns:\n    WorkerControlResponse with success status and message\n\nRaises:\n    HTTPException 400: Invalid worker name format\n    HTTPException 404: Worker not found\n    HTTPException 503: Supervisor not initialized",
        "operationId": "system_stop_supervisor_worker",
        "parameters": [
          {
            "in": "path",
            "name": "worker_name",
            "required": true,
            "schema": {
              "title": "Worker Name",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkerControlResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Stop Supervisor Worker",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/telemetry": {
      "get": {
        "description": "Get pipeline telemetry data.\n\nReturns real-time metrics about the AI processing pipeline:\n- Queue depths: Items waiting in detection and analysis queues\n- Stage latencies: Processing time statistics for each pipeline stage\n\nThis endpoint helps operators:\n- Monitor pipeline health and throughput\n- Identify bottlenecks and backlogs\n- Debug pipeline stalls\n- Track performance trends\n\nReturns:\n    TelemetryResponse with queue depths and latency statistics",
        "operationId": "system_get_telemetry",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TelemetryResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get Telemetry",
        "tags": [
          "system"
        ]
      }
    },
    "/api/system/websocket/events": {
      "get": {
        "description": "List all available WebSocket event types with schemas.\n\nReturns the complete registry of WebSocket event types supported by the system,\nincluding their descriptions, payload schemas, and example payloads. This\nendpoint enables frontend developers and API consumers to discover and\nunderstand all available real-time event types.\n\nEvent types follow a hierarchical naming convention: {domain}.{action}\nFor example: detection.new, event.created, camera.status_changed\n\nChannels group related events:\n- detections: AI detection pipeline events\n- events: Security event lifecycle events\n- alerts: Alert notifications and state changes\n- cameras: Camera status and configuration changes\n- jobs: Background job lifecycle events\n- system: System health and status events\n\nNote: Some event types are marked as deprecated with suggested replacements.\nThese remain available for backward compatibility but should be avoided in\nnew implementations.\n\nReturns:\n    EventRegistryResponse containing:\n    - event_types: List of all event types with schemas and examples\n    - channels: List of available WebSocket channels\n    - total_count: Total number of event types\n    - deprecated_count: Number of deprecated event types",
        "operationId": "system_list_websocket_event_types",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventRegistryResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List Websocket Event Types",
        "tags": [
          "system"
        ]
      }
    },
    "/api/tracks/camera/{camera_id}": {
      "get": {
        "description": "Get paginated list of tracks for a camera.\n\nReturns a list of tracks observed on a specific camera with optional\nfiltering by time range and object class. Results are ordered by\nfirst_seen timestamp (newest first).\n\nArgs:\n    camera_id: ID of the camera to query tracks for.\n    db: Database session.\n    start_time: Optional start time filter (inclusive, ISO format).\n    end_time: Optional end time filter (inclusive, ISO format).\n    object_class: Optional filter by object class (e.g., 'person', 'car').\n    page: Page number (1-indexed, default 1).\n    page_size: Number of items per page (1-100, default 50).\n\nReturns:\n    TrackListResponse with paginated tracks and total count.\n\nExample:\n    GET /api/tracks/camera/front_door?object_class=person&page=1&page_size=25\n    Returns first 25 person tracks from front_door camera.",
        "operationId": "tracks_get_tracks_by_camera",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "description": "Filter tracks starting after this time (ISO format)",
            "in": "query",
            "name": "start_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter tracks starting after this time (ISO format)",
              "title": "Start Time"
            }
          },
          {
            "description": "Filter tracks starting before this time (ISO format)",
            "in": "query",
            "name": "end_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter tracks starting before this time (ISO format)",
              "title": "End Time"
            }
          },
          {
            "description": "Filter by object class (e.g., 'person', 'car')",
            "in": "query",
            "name": "object_class",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by object class (e.g., 'person', 'car')",
              "title": "Object Class"
            }
          },
          {
            "description": "Page number (1-indexed)",
            "in": "query",
            "name": "page",
            "required": false,
            "schema": {
              "default": 1,
              "description": "Page number (1-indexed)",
              "minimum": 1,
              "title": "Page",
              "type": "integer"
            }
          },
          {
            "description": "Number of items per page",
            "in": "query",
            "name": "page_size",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Number of items per page",
              "maximum": 100,
              "minimum": 1,
              "title": "Page Size",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TrackListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Tracks By Camera",
        "tags": [
          "tracks"
        ]
      }
    },
    "/api/tracks/{camera_id}/{track_id}": {
      "get": {
        "description": "Get full track history with trajectory and metrics.\n\nReturns the complete trajectory data and computed movement metrics\nfor a specific track, suitable for visualization and analysis.\n\nArgs:\n    camera_id: ID of the camera where the track was observed.\n    track_id: Tracker-assigned track ID (unique per camera session).\n    db: Database session.\n\nReturns:\n    TrackHistoryResponse with full trajectory and movement metrics.\n\nRaises:\n    HTTPException: 404 if track not found.\n\nExample:\n    GET /api/tracks/front_door/42\n    Returns trajectory points and metrics for track 42 on front_door camera.",
        "operationId": "tracks_get_track_history",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "track_id",
            "required": true,
            "schema": {
              "title": "Track Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TrackHistoryResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Track History",
        "tags": [
          "tracks"
        ]
      }
    },
    "/api/tracks/{camera_id}/{track_id}/trajectory": {
      "get": {
        "description": "Get just the trajectory points for a track.\n\nReturns only the position data (x, y, timestamp) for efficient\ntrajectory plotting without full track metadata.\n\nArgs:\n    camera_id: ID of the camera where the track was observed.\n    track_id: Tracker-assigned track ID (unique per camera session).\n    db: Database session.\n    limit: Maximum number of trajectory points to return (default 100, max 1000).\n        Returns the most recent points if trajectory exceeds limit.\n\nReturns:\n    List of TrajectoryPoint objects ordered by timestamp.\n\nRaises:\n    HTTPException: 404 if track not found.\n\nExample:\n    GET /api/tracks/front_door/42/trajectory?limit=50\n    Returns up to 50 most recent trajectory points.",
        "operationId": "tracks_get_track_trajectory",
        "parameters": [
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "track_id",
            "required": true,
            "schema": {
              "title": "Track Id",
              "type": "integer"
            }
          },
          {
            "description": "Maximum number of trajectory points",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 100,
              "description": "Maximum number of trajectory points",
              "maximum": 1000,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/TrajectoryPoint"
                  },
                  "title": "Response Tracks Get Track Trajectory",
                  "type": "array"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Track Trajectory",
        "tags": [
          "tracks"
        ]
      }
    },
    "/api/v1/alertmanager/webhook": {
      "post": {
        "description": "Receive webhook notifications from Alertmanager.\n\nThis endpoint receives alerts from Prometheus Alertmanager and:\n1. Stores each alert in the database for history tracking\n2. Broadcasts each alert via WebSocket for real-time frontend updates\n3. Returns acknowledgment to Alertmanager\n\nThe alerts are infrastructure alerts (GPU memory, pipeline health, etc.)\nwhich are stored for history and displayed alongside security alerts.\n\nArgs:\n    payload: Alertmanager webhook payload containing alert details\n    db: Database session (injected)\n    redis_client: Redis client for WebSocket broadcasting (optional)\n\nReturns:\n    AlertmanagerWebhookResponse with processing status",
        "operationId": "alertmanager_receive_alertmanager_webhook",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AlertmanagerWebhook"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertmanagerWebhookResponse"
                }
              }
            },
            "description": "Webhook received and processed"
          },
          "422": {
            "description": "Invalid payload format"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Receive Alertmanager Webhook",
        "tags": [
          "alertmanager"
        ]
      }
    },
    "/api/v1/areas/{area_id}": {
      "delete": {
        "description": "Delete an area.\n\nThis will unlink all cameras associated with this area (cameras themselves\nare not deleted, only the association).\n\nArgs:\n    area_id: ID of the area to delete\n    session: Database session\n\nRaises:\n    HTTPException: 404 if area not found",
        "operationId": "areas_delete_area",
        "parameters": [
          {
            "in": "path",
            "name": "area_id",
            "required": true,
            "schema": {
              "title": "Area Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Area",
        "tags": [
          "areas"
        ]
      },
      "get": {
        "description": "Get a specific area by ID.\n\nArgs:\n    area_id: ID of the area to retrieve\n    session: Database session\n\nReturns:\n    Area object\n\nRaises:\n    HTTPException: 404 if area not found",
        "operationId": "areas_get_area",
        "parameters": [
          {
            "in": "path",
            "name": "area_id",
            "required": true,
            "schema": {
              "title": "Area Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AreaResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Area",
        "tags": [
          "areas"
        ]
      },
      "patch": {
        "description": "Update an existing area.\n\nArgs:\n    area_id: ID of the area to update\n    updates: Area update data (all fields optional)\n    session: Database session\n\nReturns:\n    Updated Area object\n\nRaises:\n    HTTPException: 404 if area not found\n    HTTPException: 409 if new name conflicts with existing area in same property",
        "operationId": "areas_update_area",
        "parameters": [
          {
            "in": "path",
            "name": "area_id",
            "required": true,
            "schema": {
              "title": "Area Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AreaUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AreaResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Area",
        "tags": [
          "areas"
        ]
      }
    },
    "/api/v1/areas/{area_id}/cameras": {
      "get": {
        "description": "List all cameras linked to an area.\n\nArgs:\n    area_id: ID of the area\n    session: Database session\n\nReturns:\n    AreaCamerasResponse with list of cameras and count\n\nRaises:\n    HTTPException: 404 if area not found",
        "operationId": "areas_list_area_cameras",
        "parameters": [
          {
            "in": "path",
            "name": "area_id",
            "required": true,
            "schema": {
              "title": "Area Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AreaCamerasResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Area Cameras",
        "tags": [
          "areas"
        ]
      },
      "post": {
        "description": "Link a camera to an area.\n\nCreates a many-to-many relationship between the area and camera.\nA camera can be linked to multiple areas, and an area can have multiple cameras.\n\nArgs:\n    area_id: ID of the area\n    link_request: Contains the camera_id to link\n    session: Database session\n\nReturns:\n    CameraLinkResponse confirming the link\n\nRaises:\n    HTTPException: 404 if area or camera not found\n    HTTPException: 409 if camera is already linked to this area",
        "operationId": "areas_link_camera_to_area",
        "parameters": [
          {
            "in": "path",
            "name": "area_id",
            "required": true,
            "schema": {
              "title": "Area Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CameraLinkRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraLinkResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Link Camera To Area",
        "tags": [
          "areas"
        ]
      }
    },
    "/api/v1/areas/{area_id}/cameras/{camera_id}": {
      "delete": {
        "description": "Unlink a camera from an area.\n\nRemoves the many-to-many relationship between the area and camera.\nNeither the area nor the camera is deleted.\n\nArgs:\n    area_id: ID of the area\n    camera_id: ID of the camera to unlink\n    session: Database session\n\nReturns:\n    CameraLinkResponse confirming the unlink\n\nRaises:\n    HTTPException: 404 if area or camera not found\n    HTTPException: 404 if camera is not linked to this area",
        "operationId": "areas_unlink_camera_from_area",
        "parameters": [
          {
            "in": "path",
            "name": "area_id",
            "required": true,
            "schema": {
              "title": "Area Id",
              "type": "integer"
            }
          },
          {
            "in": "path",
            "name": "camera_id",
            "required": true,
            "schema": {
              "title": "Camera Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CameraLinkResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Unlink Camera From Area",
        "tags": [
          "areas"
        ]
      }
    },
    "/api/v1/households": {
      "get": {
        "description": "List all households.\n\nReturns all households in the system ordered by name.\n\nArgs:\n    session: Database session\n\nReturns:\n    HouseholdListResponse with list of households and total count",
        "operationId": "households_list_households",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HouseholdListResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List Households",
        "tags": [
          "households"
        ]
      },
      "post": {
        "description": "Create a new household.\n\nArgs:\n    household_data: Household creation data\n    session: Database session\n\nReturns:\n    Created Household object\n\nRaises:\n    HTTPException: 409 if household with same name already exists",
        "operationId": "households_create_household",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HouseholdCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HouseholdResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Household",
        "tags": [
          "households"
        ]
      }
    },
    "/api/v1/households/{household_id}": {
      "delete": {
        "description": "Delete a household.\n\nThis will cascade delete all related properties, areas, and unlink\nassociated members and vehicles.\n\nArgs:\n    household_id: ID of the household to delete\n    session: Database session\n\nRaises:\n    HTTPException: 404 if household not found",
        "operationId": "households_delete_household",
        "parameters": [
          {
            "in": "path",
            "name": "household_id",
            "required": true,
            "schema": {
              "title": "Household Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Household",
        "tags": [
          "households"
        ]
      },
      "get": {
        "description": "Get a specific household by ID.\n\nArgs:\n    household_id: ID of the household to retrieve\n    session: Database session\n\nReturns:\n    Household object\n\nRaises:\n    HTTPException: 404 if household not found",
        "operationId": "households_get_household",
        "parameters": [
          {
            "in": "path",
            "name": "household_id",
            "required": true,
            "schema": {
              "title": "Household Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HouseholdResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Household",
        "tags": [
          "households"
        ]
      },
      "patch": {
        "description": "Update an existing household.\n\nArgs:\n    household_id: ID of the household to update\n    updates: Household update data (all fields optional)\n    session: Database session\n\nReturns:\n    Updated Household object\n\nRaises:\n    HTTPException: 404 if household not found\n    HTTPException: 409 if new name conflicts with existing household",
        "operationId": "households_update_household",
        "parameters": [
          {
            "in": "path",
            "name": "household_id",
            "required": true,
            "schema": {
              "title": "Household Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HouseholdUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HouseholdResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Household",
        "tags": [
          "households"
        ]
      }
    },
    "/api/v1/households/{household_id}/properties": {
      "get": {
        "description": "List all properties for a household.\n\nArgs:\n    household_id: ID of the household\n    session: Database session\n\nReturns:\n    PropertyListResponse with list of properties and total count\n\nRaises:\n    HTTPException: 404 if household not found",
        "operationId": "households_list_household_properties",
        "parameters": [
          {
            "in": "path",
            "name": "household_id",
            "required": true,
            "schema": {
              "title": "Household Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PropertyListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Household Properties",
        "tags": [
          "households"
        ]
      },
      "post": {
        "description": "Create a new property under a household.\n\nArgs:\n    household_id: ID of the household that owns this property\n    property_data: Property creation data\n    session: Database session\n\nReturns:\n    Created Property object\n\nRaises:\n    HTTPException: 404 if household not found\n    HTTPException: 409 if property with same name already exists for this household",
        "operationId": "households_create_property",
        "parameters": [
          {
            "in": "path",
            "name": "household_id",
            "required": true,
            "schema": {
              "title": "Household Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PropertyCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PropertyResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Property",
        "tags": [
          "households"
        ]
      }
    },
    "/api/v1/properties/{property_id}": {
      "delete": {
        "description": "Delete a property.\n\nThis will cascade delete all related areas and unlink associated cameras.\n\nArgs:\n    property_id: ID of the property to delete\n    session: Database session\n\nRaises:\n    HTTPException: 404 if property not found",
        "operationId": "properties_delete_property",
        "parameters": [
          {
            "in": "path",
            "name": "property_id",
            "required": true,
            "schema": {
              "title": "Property Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Property",
        "tags": [
          "properties"
        ]
      },
      "get": {
        "description": "Get a specific property by ID.\n\nArgs:\n    property_id: ID of the property to retrieve\n    session: Database session\n\nReturns:\n    Property object\n\nRaises:\n    HTTPException: 404 if property not found",
        "operationId": "properties_get_property",
        "parameters": [
          {
            "in": "path",
            "name": "property_id",
            "required": true,
            "schema": {
              "title": "Property Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PropertyResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Property",
        "tags": [
          "properties"
        ]
      },
      "patch": {
        "description": "Update an existing property.\n\nArgs:\n    property_id: ID of the property to update\n    updates: Property update data (all fields optional)\n    session: Database session\n\nReturns:\n    Updated Property object\n\nRaises:\n    HTTPException: 404 if property not found\n    HTTPException: 409 if new name conflicts with existing property in same household",
        "operationId": "properties_update_property",
        "parameters": [
          {
            "in": "path",
            "name": "property_id",
            "required": true,
            "schema": {
              "title": "Property Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PropertyUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PropertyResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update Property",
        "tags": [
          "properties"
        ]
      }
    },
    "/api/v1/properties/{property_id}/areas": {
      "get": {
        "description": "List all areas for a property.\n\nArgs:\n    property_id: ID of the property\n    session: Database session\n\nReturns:\n    AreaListResponse with list of areas and total count\n\nRaises:\n    HTTPException: 404 if property not found",
        "operationId": "properties_list_property_areas",
        "parameters": [
          {
            "in": "path",
            "name": "property_id",
            "required": true,
            "schema": {
              "title": "Property Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AreaListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Property Areas",
        "tags": [
          "properties"
        ]
      },
      "post": {
        "description": "Create a new area under a property.\n\nArgs:\n    property_id: ID of the property that owns this area\n    area_data: Area creation data\n    session: Database session\n\nReturns:\n    Created Area object\n\nRaises:\n    HTTPException: 404 if property not found\n    HTTPException: 409 if area with same name already exists for this property",
        "operationId": "properties_create_area",
        "parameters": [
          {
            "in": "path",
            "name": "property_id",
            "required": true,
            "schema": {
              "title": "Property Id",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AreaCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AreaResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Create Area",
        "tags": [
          "properties"
        ]
      }
    },
    "/api/v1/settings": {
      "get": {
        "description": "Returns user-configurable settings grouped by category. These settings control detection thresholds, batch processing, severity levels, feature toggles, rate limiting, queue management, and data retention policies.",
        "operationId": "settings_get_user_settings",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SettingsResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Get current system settings",
        "tags": [
          "settings"
        ]
      },
      "patch": {
        "description": "Update system settings at runtime without server restart. Changes are written to data/runtime.env and take effect immediately. All fields are optional - only provided fields will be updated.",
        "operationId": "settings_update_settings",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SettingsUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SettingsResponse"
                }
              }
            },
            "description": "Settings updated successfully"
          },
          "422": {
            "description": "Validation error (e.g., invalid severity ordering)"
          },
          "500": {
            "description": "Failed to write settings to runtime.env"
          }
        },
        "summary": "Update runtime settings",
        "tags": [
          "settings"
        ]
      }
    },
    "/api/v1/system-settings": {
      "get": {
        "description": "List all system settings.\n\nReturns all key-value pairs from the SystemSetting table, ordered by key.\n\nReturns:\n    SystemSettingListResponse with all settings",
        "operationId": "system-settings_list_system_settings",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SystemSettingListResponse"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "List System Settings",
        "tags": [
          "system-settings"
        ]
      }
    },
    "/api/v1/system-settings/{key}": {
      "delete": {
        "description": "Delete a system setting.\n\nArgs:\n    key: Setting key to delete\n    db: Database session\n\nRaises:\n    HTTPException: 404 if setting not found",
        "operationId": "system-settings_delete_system_setting",
        "parameters": [
          {
            "in": "path",
            "name": "key",
            "required": true,
            "schema": {
              "title": "Key",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete System Setting",
        "tags": [
          "system-settings"
        ]
      },
      "get": {
        "description": "Get a specific system setting by key.\n\nArgs:\n    key: Setting key to retrieve\n    db: Database session\n\nReturns:\n    SystemSettingResponse with the setting value\n\nRaises:\n    HTTPException: 404 if setting not found",
        "operationId": "system-settings_get_system_setting",
        "parameters": [
          {
            "in": "path",
            "name": "key",
            "required": true,
            "schema": {
              "title": "Key",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SystemSettingResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get System Setting",
        "tags": [
          "system-settings"
        ]
      },
      "patch": {
        "description": "Update or create a system setting.\n\nIf the setting exists, updates its value. If it doesn't exist, creates it.\nThis is an upsert operation.\n\nArgs:\n    key: Setting key to update or create\n    update: New value for the setting\n    db: Database session\n\nReturns:\n    SystemSettingResponse with the updated setting\n\nRaises:\n    HTTPException: 400 if key format is invalid",
        "operationId": "system-settings_update_system_setting",
        "parameters": [
          {
            "in": "path",
            "name": "key",
            "required": true,
            "schema": {
              "title": "Key",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SystemSettingUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SystemSettingResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Update System Setting",
        "tags": [
          "system-settings"
        ]
      }
    },
    "/api/webhooks/alerts": {
      "post": {
        "description": "Receive webhook notifications from Alertmanager.\n\nThis endpoint receives alerts from Prometheus Alertmanager and:\n1. Logs the alert for observability\n2. Broadcasts to WebSocket clients for real-time frontend updates\n3. Returns acknowledgment to Alertmanager\n\nThe alerts are infrastructure alerts (GPU memory, pipeline health, etc.)\nwhich are separate from AI-generated security alerts.\n\nArgs:\n    payload: Alertmanager webhook payload containing alert details\n    background_tasks: FastAPI background tasks for async processing\n\nReturns:\n    WebhookProcessingResponse with processing status",
        "operationId": "webhooks_receive_alertmanager_webhook",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AlertmanagerWebhookPayload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookProcessingResponse"
                }
              }
            },
            "description": "Webhook received and processed"
          },
          "422": {
            "description": "Invalid payload format"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Receive Alertmanager Webhook",
        "tags": [
          "webhooks"
        ]
      }
    },
    "/api/zones/anomalies": {
      "get": {
        "description": "List all zone anomalies across all zones.\n\nReturns a paginated list of anomalies with optional filtering by severity,\nacknowledgment status, and time range.\n\nArgs:\n    severity: Filter by one or more severity levels (info, warning, critical)\n    unacknowledged_only: If True, only return unacknowledged anomalies\n    since: Start time for the query (defaults to 24 hours ago)\n    until: End time for the query (defaults to now)\n    limit: Maximum number of results to return\n    offset: Number of results to skip for pagination\n    db: Database session\n\nReturns:\n    ZoneAnomalyListResponse with list of anomalies and pagination info",
        "operationId": "zone-anomalies_list_all_anomalies",
        "parameters": [
          {
            "description": "Filter by severity level(s)",
            "in": "query",
            "name": "severity",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by severity level(s)",
              "title": "Severity"
            }
          },
          {
            "description": "Only return unacknowledged anomalies",
            "in": "query",
            "name": "unacknowledged_only",
            "required": false,
            "schema": {
              "default": false,
              "description": "Only return unacknowledged anomalies",
              "title": "Unacknowledged Only",
              "type": "boolean"
            }
          },
          {
            "description": "Filter anomalies from this time (ISO 8601)",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter anomalies from this time (ISO 8601)",
              "title": "Since"
            }
          },
          {
            "description": "Filter anomalies until this time (ISO 8601)",
            "in": "query",
            "name": "until",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter anomalies until this time (ISO 8601)",
              "title": "Until"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 500,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneAnomalyListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List All Anomalies",
        "tags": [
          "zone-anomalies"
        ]
      }
    },
    "/api/zones/anomalies/{anomaly_id}/acknowledge": {
      "post": {
        "description": "Acknowledge a zone anomaly.\n\nMarks the specified anomaly as acknowledged, indicating that a user\nhas reviewed and acknowledged the alert.\n\nArgs:\n    anomaly_id: The anomaly ID to acknowledge\n    db: Database session\n\nReturns:\n    ZoneAnomalyAcknowledgeResponse with updated acknowledgment status\n\nRaises:\n    HTTPException: 404 if anomaly not found",
        "operationId": "zone-anomalies_acknowledge_anomaly",
        "parameters": [
          {
            "in": "path",
            "name": "anomaly_id",
            "required": true,
            "schema": {
              "title": "Anomaly Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneAnomalyAcknowledgeResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Acknowledge Anomaly",
        "tags": [
          "zone-anomalies"
        ]
      }
    },
    "/api/zones/member/{member_id}/zones": {
      "get": {
        "description": "Get all zones where a household member has trust.\n\nReturns zones where the member is:\n- The owner (full trust)\n- In the allowed members list (partial trust)\n- In any access schedule (potential monitor trust)\n\nArgs:\n    member_id: ID of the household member\n    db: Database session\n\nReturns:\n    List of zones with trust information",
        "operationId": "zone-household_get_member_zones",
        "parameters": [
          {
            "in": "path",
            "name": "member_id",
            "required": true,
            "schema": {
              "title": "Member Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "additionalProperties": true,
                    "type": "object"
                  },
                  "title": "Response Zone-Household Get Member Zones",
                  "type": "array"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Member Zones",
        "tags": [
          "zone-household"
        ]
      }
    },
    "/api/zones/vehicle/{vehicle_id}/zones": {
      "get": {
        "description": "Get all zones where a vehicle has trust.\n\nReturns zones where the vehicle is in the allowed vehicles list.\n\nArgs:\n    vehicle_id: ID of the registered vehicle\n    db: Database session\n\nReturns:\n    List of zones with trust information",
        "operationId": "zone-household_get_vehicle_zones",
        "parameters": [
          {
            "in": "path",
            "name": "vehicle_id",
            "required": true,
            "schema": {
              "title": "Vehicle Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "additionalProperties": true,
                    "type": "object"
                  },
                  "title": "Response Zone-Household Get Vehicle Zones",
                  "type": "array"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Vehicle Zones",
        "tags": [
          "zone-household"
        ]
      }
    },
    "/api/zones/{zone_id}/anomalies": {
      "get": {
        "description": "List anomalies for a specific zone.\n\nReturns a paginated list of anomalies for the specified zone with optional\nfiltering by severity, acknowledgment status, and time range.\n\nArgs:\n    zone_id: The zone ID to fetch anomalies for\n    severity: Filter by one or more severity levels (info, warning, critical)\n    unacknowledged_only: If True, only return unacknowledged anomalies\n    since: Start time for the query (defaults to 24 hours ago)\n    until: End time for the query (defaults to now)\n    limit: Maximum number of results to return\n    offset: Number of results to skip for pagination\n    db: Database session\n\nReturns:\n    ZoneAnomalyListResponse with list of anomalies and pagination info",
        "operationId": "zone-anomalies_list_zone_anomalies",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          },
          {
            "description": "Filter by severity level(s)",
            "in": "query",
            "name": "severity",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by severity level(s)",
              "title": "Severity"
            }
          },
          {
            "description": "Only return unacknowledged anomalies",
            "in": "query",
            "name": "unacknowledged_only",
            "required": false,
            "schema": {
              "default": false,
              "description": "Only return unacknowledged anomalies",
              "title": "Unacknowledged Only",
              "type": "boolean"
            }
          },
          {
            "description": "Filter anomalies from this time (ISO 8601)",
            "in": "query",
            "name": "since",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter anomalies from this time (ISO 8601)",
              "title": "Since"
            }
          },
          {
            "description": "Filter anomalies until this time (ISO 8601)",
            "in": "query",
            "name": "until",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter anomalies until this time (ISO 8601)",
              "title": "Until"
            }
          },
          {
            "description": "Maximum number of results",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "default": 50,
              "description": "Maximum number of results",
              "maximum": 500,
              "minimum": 1,
              "title": "Limit",
              "type": "integer"
            }
          },
          {
            "description": "Number of results to skip",
            "in": "query",
            "name": "offset",
            "required": false,
            "schema": {
              "default": 0,
              "description": "Number of results to skip",
              "minimum": 0,
              "title": "Offset",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneAnomalyListResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "List Zone Anomalies",
        "tags": [
          "zone-anomalies"
        ]
      }
    },
    "/api/zones/{zone_id}/household": {
      "delete": {
        "description": "Delete the household configuration for a zone.\n\nRemoves all household linkage for this zone, including owner,\nallowed members, allowed vehicles, and access schedules.\n\nArgs:\n    zone_id: ID of the zone\n    db: Database session\n\nRaises:\n    HTTPException: 404 if zone not found\n    HTTPException: 404 if config not found",
        "operationId": "zone-household_delete_zone_household_config",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Delete Zone Household Config",
        "tags": [
          "zone-household"
        ]
      },
      "get": {
        "description": "Get the household configuration for a zone.\n\nReturns the household configuration if one exists, or null if the zone\nhas no household linkage configured.\n\nArgs:\n    zone_id: ID of the zone\n    db: Database session\n\nReturns:\n    ZoneHouseholdConfigResponse if config exists, None otherwise\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "zone-household_get_zone_household_config",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/ZoneHouseholdConfigResponse"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "title": "Response Zone-Household Get Zone Household Config"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Get Zone Household Config",
        "tags": [
          "zone-household"
        ]
      },
      "patch": {
        "description": "Partially update the household configuration for a zone.\n\nOnly updates the fields that are provided in the request body.\nUnlike PUT, this endpoint requires an existing configuration.\n\nArgs:\n    zone_id: ID of the zone\n    config_data: Household configuration update data\n    db: Database session\n\nReturns:\n    Updated ZoneHouseholdConfigResponse\n\nRaises:\n    HTTPException: 404 if zone not found\n    HTTPException: 404 if config not found\n    HTTPException: 404 if owner_id references non-existent member",
        "operationId": "zone-household_patch_zone_household_config",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZoneHouseholdConfigUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneHouseholdConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Patch Zone Household Config",
        "tags": [
          "zone-household"
        ]
      },
      "put": {
        "description": "Create or update the household configuration for a zone.\n\nIf a configuration already exists for this zone, it will be updated.\nOtherwise, a new configuration will be created.\n\nArgs:\n    zone_id: ID of the zone\n    config_data: Household configuration data\n    db: Database session\n\nReturns:\n    Created or updated ZoneHouseholdConfigResponse\n\nRaises:\n    HTTPException: 404 if zone not found\n    HTTPException: 404 if owner_id references non-existent member",
        "operationId": "zone-household_upsert_zone_household_config",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZoneHouseholdConfigCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneHouseholdConfigResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Upsert Zone Household Config",
        "tags": [
          "zone-household"
        ]
      }
    },
    "/api/zones/{zone_id}/household/trust/{entity_type}/{entity_id}": {
      "get": {
        "description": "Check the trust level of an entity in a zone.\n\nEvaluates the trust level based on:\n1. Zone ownership (full trust)\n2. Allowed members/vehicles list (partial trust)\n3. Time-based access schedules (monitor trust)\n4. No configuration (none)\n\nArgs:\n    zone_id: ID of the zone\n    entity_type: Type of entity (\"member\" or \"vehicle\")\n    entity_id: ID of the entity to check\n    at_time: Optional time for schedule checking (defaults to now)\n    db: Database session\n\nReturns:\n    TrustCheckResponse with trust level and reason\n\nRaises:\n    HTTPException: 404 if zone not found",
        "operationId": "zone-household_check_entity_trust",
        "parameters": [
          {
            "in": "path",
            "name": "zone_id",
            "required": true,
            "schema": {
              "title": "Zone Id",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "entity_type",
            "required": true,
            "schema": {
              "enum": [
                "member",
                "vehicle"
              ],
              "title": "Entity Type",
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "entity_id",
            "required": true,
            "schema": {
              "title": "Entity Id",
              "type": "integer"
            }
          },
          {
            "description": "Time to check access for (ISO 8601 format, defaults to current time)",
            "in": "query",
            "name": "at_time",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Time to check access for (ISO 8601 format, defaults to current time)",
              "title": "At Time"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TrustCheckResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            },
            "description": "Validation Error"
          }
        },
        "summary": "Check Entity Trust",
        "tags": [
          "zone-household"
        ]
      }
    },
    "/health": {
      "get": {
        "description": "Simple liveness health check endpoint (canonical liveness probe).\n\nThis endpoint indicates whether the process is running and able to\nrespond to HTTP requests. It always returns 200 with status \"alive\"\nif the process is up.\n\nThis is the canonical liveness probe endpoint. Use this for:\n- Docker HEALTHCHECK liveness checks\n- Kubernetes liveness probes\n- Simple \"is the server up?\" monitoring\n\nFor detailed health information, use:\n- GET /api/system/health - Detailed health check with service status\n- GET /ready - Readiness probe (checks dependencies)\n\nReturns:\n    LivenessResponse with status \"alive\".",
        "operationId": "health",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Health",
                  "type": "object"
                }
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Health"
      }
    },
    "/ready": {
      "get": {
        "description": "Simple readiness health check endpoint (canonical readiness probe).\n\nThis endpoint indicates whether the application is ready to receive\ntraffic and process requests. It checks critical dependencies:\n- Database connectivity\n- Redis connectivity\n- Critical pipeline workers\n\nThis is the canonical readiness probe endpoint. Use this for:\n- Docker HEALTHCHECK readiness checks\n- Kubernetes readiness probes\n- Load balancer health checks\n\nFor detailed readiness information with service breakdown, use:\n- GET /api/system/health/ready - Full readiness response with details\n\nReturns:\n    SimpleReadinessResponse with ready bool and status. HTTP 200 if ready, 503 if not.",
        "operationId": "ready",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "description": "Successful Response"
          }
        },
        "summary": "Ready"
      }
    }
  },
  "servers": [
    {
      "description": "API server",
      "url": "http://localhost:8000"
    }
  ]
}
