"""OpenAPI schema validation contract tests.

This module validates that API responses conform to their documented OpenAPI schemas,
ensuring frontend consumers can rely on consistent API contracts.

**Approach**: Uses the OpenAPI schema generated by FastAPI to validate actual API responses.
This ensures single source of truth (OpenAPI schema) and catches schema drift automatically.

**Critical Endpoints Tested**:
- GET /api/events - Event listing
- GET /api/cameras - Camera listing
- GET /api/detections - Detection listing
- GET /api/system/health - Health check
- GET /api/system/stats - System statistics

**References**:
- OpenAPI 3.1: https://spec.openapis.org/oas/v3.1.0
- FastAPI OpenAPI: https://fastapi.tiangolo.com/advanced/extending-openapi/
"""

from __future__ import annotations

import os
from typing import TYPE_CHECKING
from unittest.mock import AsyncMock, MagicMock

import pytest
from httpx import ASGITransport, AsyncClient

if TYPE_CHECKING:
    from collections.abc import AsyncGenerator


# Set test environment before importing app
os.environ.setdefault(
    "DATABASE_URL",
    "postgresql+asyncpg://postgres:postgres@localhost:5432/security_test",  # pragma: allowlist secret
)
os.environ.setdefault("REDIS_URL", "redis://localhost:6379/15")


# =============================================================================
# Mock Data Factories
# =============================================================================


def create_mock_event(event_id: int = 1) -> MagicMock:
    """Create a mock Event object for testing."""
    from datetime import UTC, datetime

    event = MagicMock()
    event.id = event_id
    event.camera_id = "front_door"
    event.started_at = datetime.now(UTC)
    event.ended_at = datetime.now(UTC)
    event.risk_score = 75
    event.risk_level = "high"
    event.summary = "Person detected at front door"
    event.reasoning = "Motion detected with high confidence"
    event.reviewed = False
    event.notes = None
    event.detection_ids = "[1, 2, 3]"
    event.object_types = "person"
    event.clip_path = None
    event.llm_prompt = None
    return event


def create_mock_camera(camera_id: str = "front_door") -> MagicMock:
    """Create a mock Camera object for testing."""
    from datetime import UTC, datetime

    camera = MagicMock()
    camera.id = camera_id
    camera.name = "Front Door"
    camera.folder_path = f"/cameras/{camera_id}"
    camera.status = "online"
    camera.created_at = datetime.now(UTC)
    camera.last_seen_at = datetime.now(UTC)
    return camera


def create_mock_detection(detection_id: int = 1) -> MagicMock:
    """Create a mock Detection object for testing."""
    from datetime import UTC, datetime

    detection = MagicMock()
    detection.id = detection_id
    detection.camera_id = "front_door"
    detection.detected_at = datetime.now(UTC)
    detection.object_type = "person"
    detection.confidence = 0.95
    detection.bbox_x = 100
    detection.bbox_y = 200
    detection.bbox_width = 150
    detection.bbox_height = 300
    detection.file_path = "/cameras/front_door/image.jpg"
    detection.thumbnail_path = None
    detection.media_type = "image"
    detection.file_type = "image/jpeg"
    detection.enrichment_data = None
    detection.duration = None
    detection.video_codec = None
    detection.video_width = None
    detection.video_height = None
    return detection


# =============================================================================
# Pytest Fixtures
# =============================================================================


@pytest.fixture
def mock_session() -> MagicMock:
    """Create a mock database session for contract tests."""
    session = AsyncMock()
    session.execute = AsyncMock()
    session.commit = AsyncMock()
    session.refresh = AsyncMock()
    return session


@pytest.fixture
def mock_redis() -> AsyncMock:
    """Create a mock Redis client for contract tests."""
    redis = AsyncMock()
    redis.ping = AsyncMock(return_value=True)
    redis.get = AsyncMock(return_value=None)
    redis.set = AsyncMock(return_value=True)
    redis.llen = AsyncMock(return_value=0)
    redis.health_check = AsyncMock(
        return_value={"status": "healthy", "connected": True, "redis_version": "7.0.0"}
    )
    return redis


@pytest.fixture
async def client(mock_session: MagicMock, mock_redis: AsyncMock) -> AsyncGenerator[AsyncClient]:
    """Create async HTTP client with mocked dependencies."""
    from backend.core.database import get_db, get_read_db
    from backend.core.redis import get_redis, get_redis_optional
    from backend.main import app

    # Create mock database dependency
    async def mock_get_db():
        yield mock_session

    # Create mock read database dependency (for read replicas)
    async def mock_get_read_db():
        yield mock_session

    # Create mock Redis dependencies
    async def mock_get_redis():
        return mock_redis

    async def mock_get_redis_optional():
        yield mock_redis

    # Override dependencies at the app level
    app.dependency_overrides[get_db] = mock_get_db
    app.dependency_overrides[get_read_db] = mock_get_read_db
    app.dependency_overrides[get_redis] = mock_get_redis
    app.dependency_overrides[get_redis_optional] = mock_get_redis_optional

    # Override lifespan to skip actual service initialization
    original_lifespan = app.router.lifespan_context

    async def mock_lifespan(_app):
        yield

    app.router.lifespan_context = mock_lifespan

    try:
        transport = ASGITransport(app=app)
        async with AsyncClient(transport=transport, base_url="http://testserver") as client:
            yield client
    finally:
        app.router.lifespan_context = original_lifespan
        app.dependency_overrides.clear()


# =============================================================================
# OpenAPI Schema Validation Tests
# =============================================================================


class TestOpenAPISchemaValidation:
    """Contract tests that validate responses against OpenAPI schema.

    These tests ensure that actual API responses conform to the documented
    OpenAPI schema, providing a contract between backend and frontend.
    """

    @pytest.mark.asyncio
    async def test_events_api_response_schema(self, client: AsyncClient, mock_session: MagicMock):
        """Test GET /api/events response conforms to OpenAPI schema."""
        mock_event = create_mock_event()

        mock_count_result = MagicMock()
        mock_count_result.scalar.return_value = 1

        mock_events_result = MagicMock()
        mock_events_result.scalars.return_value.all.return_value = [mock_event]

        mock_session.execute = AsyncMock(side_effect=[mock_count_result, mock_events_result])

        response = await client.get("/api/events")

        assert response.status_code == 200
        data = response.json()

        # Validate response structure against expected schema
        assert "items" in data
        assert "pagination" in data
        assert "limit" in data["pagination"]
        assert "offset" in data["pagination"]
        assert isinstance(data["items"], list)
        assert isinstance(data["pagination"]["total"], int)
        assert isinstance(data["pagination"]["limit"], int)
        # offset can be None for cursor-based pagination
        assert data["pagination"]["offset"] is None or isinstance(data["pagination"]["offset"], int)

        # Validate pagination defaults
        assert data["pagination"]["limit"] == 50
        # offset=0 may be returned as None due to cursor-based pagination preference
        assert data["pagination"]["offset"] in (0, None)

    @pytest.mark.asyncio
    async def test_cameras_api_response_schema(self, client: AsyncClient, mock_session: MagicMock):
        """Test GET /api/cameras response conforms to OpenAPI schema."""
        mock_camera = create_mock_camera()

        mock_result = MagicMock()
        mock_result.scalars.return_value.all.return_value = [mock_camera]
        mock_session.execute = AsyncMock(return_value=mock_result)

        response = await client.get("/api/cameras")

        assert response.status_code == 200
        data = response.json()

        # Validate response structure
        assert "items" in data
        assert "pagination" in data
        assert isinstance(data["items"], list)
        assert isinstance(data["pagination"]["total"], int)

    @pytest.mark.asyncio
    async def test_detections_api_response_schema(
        self, client: AsyncClient, mock_session: MagicMock
    ):
        """Test GET /api/detections response conforms to OpenAPI schema."""
        mock_detection = create_mock_detection()

        mock_count_result = MagicMock()
        mock_count_result.scalar.return_value = 1

        mock_detections_result = MagicMock()
        mock_detections_result.scalars.return_value.all.return_value = [mock_detection]

        mock_session.execute = AsyncMock(side_effect=[mock_count_result, mock_detections_result])

        response = await client.get("/api/detections")

        assert response.status_code == 200
        data = response.json()

        # Validate response structure
        assert "items" in data
        assert "pagination" in data
        assert "limit" in data["pagination"]
        assert "offset" in data["pagination"]
        assert isinstance(data["items"], list)

    @pytest.mark.asyncio
    async def test_health_api_response_schema(self, client: AsyncClient):
        """Test GET /health response conforms to OpenAPI schema."""
        response = await client.get("/health")

        assert response.status_code == 200
        data = response.json()

        # Validate response structure
        assert "status" in data
        assert data["status"] == "alive"

    @pytest.mark.asyncio
    async def test_system_health_api_response_schema(self, client: AsyncClient):
        """Test GET /api/system/health response conforms to OpenAPI schema."""
        response = await client.get("/api/system/health")

        # Health endpoint may return 200 or 503 based on service status
        assert response.status_code in [200, 503]
        data = response.json()

        # Validate response structure
        assert "status" in data
        assert "services" in data
        assert "timestamp" in data
        assert data["status"] in ["healthy", "degraded", "unhealthy"]
        assert isinstance(data["services"], dict)

    @pytest.mark.asyncio
    async def test_system_stats_api_response_schema(
        self, client: AsyncClient, mock_session: MagicMock
    ):
        """Test GET /api/system/stats response conforms to OpenAPI schema."""
        # Mock database queries for stats
        mock_result = MagicMock()
        mock_result.scalar.return_value = 0
        mock_session.execute = AsyncMock(return_value=mock_result)

        response = await client.get("/api/system/stats")

        assert response.status_code == 200
        data = response.json()

        # Validate response structure
        assert "total_cameras" in data
        assert "total_events" in data
        assert "total_detections" in data
        assert isinstance(data["total_cameras"], int)
        assert isinstance(data["total_events"], int)
        assert isinstance(data["total_detections"], int)


# =============================================================================
# Error Response Schema Tests
# =============================================================================


class TestErrorResponseSchemas:
    """Contract tests for error response formats."""

    @pytest.mark.asyncio
    async def test_404_error_response_schema(self, client: AsyncClient, mock_session: MagicMock):
        """Test 404 errors follow RFC 7807 Problem Details format."""
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = None
        mock_session.execute = AsyncMock(return_value=mock_result)

        response = await client.get("/api/events/999999")

        assert response.status_code == 404
        data = response.json()

        # RFC 7807 Problem Details format
        assert "type" in data
        assert "title" in data
        assert "status" in data
        assert "detail" in data
        assert data["status"] == 404

    @pytest.mark.asyncio
    async def test_422_validation_error_schema(self, client: AsyncClient):
        """Test 422 validation errors follow standardized format."""
        response = await client.get("/api/events", params={"limit": -1})

        assert response.status_code == 422
        data = response.json()

        # Standardized validation error format
        assert "error" in data
        assert "code" in data["error"]
        assert "message" in data["error"]
        assert "errors" in data["error"]
        assert isinstance(data["error"]["errors"], list)
