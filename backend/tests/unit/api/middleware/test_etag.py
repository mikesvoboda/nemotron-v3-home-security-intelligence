"""Unit tests for ETag middleware (NEM-3743).

Tests verify ETag generation, conditional request handling, and response
formatting for HTTP caching support.
"""

from datetime import UTC, datetime
from unittest.mock import MagicMock

from pydantic import BaseModel

from backend.api.middleware.etag import (
    check_etag_match,
    check_if_match,
    etag_response,
    generate_etag,
    generate_etag_from_list,
    generate_etag_from_metadata,
    generate_etag_from_model,
    not_modified_response,
)


class SampleModel(BaseModel):
    """Sample model for testing."""

    id: int
    name: str
    updated_at: datetime | None = None


class TestGenerateEtag:
    """Tests for generate_etag function."""

    def test_generates_strong_etag_by_default(self):
        """Test that strong ETag is generated by default."""
        etag = generate_etag("test content")
        assert etag.startswith('"')
        assert etag.endswith('"')
        assert not etag.startswith('W/"')

    def test_generates_weak_etag_when_requested(self):
        """Test that weak ETag is generated when weak=True."""
        etag = generate_etag("test content", weak=True)
        assert etag.startswith('W/"')
        assert etag.endswith('"')

    def test_same_content_produces_same_etag(self):
        """Test that same content produces identical ETags."""
        content = "test content"
        etag1 = generate_etag(content)
        etag2 = generate_etag(content)
        assert etag1 == etag2

    def test_different_content_produces_different_etag(self):
        """Test that different content produces different ETags."""
        etag1 = generate_etag("content 1")
        etag2 = generate_etag("content 2")
        assert etag1 != etag2

    def test_handles_bytes_input(self):
        """Test that bytes input is handled correctly."""
        etag = generate_etag(b"test content")
        assert etag.startswith('"')
        assert len(etag) == 34  # 32 hex chars + 2 quotes

    def test_etag_format(self):
        """Test that ETag has correct format."""
        etag = generate_etag("test")
        # Should be 32 hex characters in quotes
        inner = etag[1:-1]  # Remove quotes
        assert len(inner) == 32
        assert all(c in "0123456789abcdef" for c in inner)


class TestGenerateEtagFromMetadata:
    """Tests for generate_etag_from_metadata function."""

    def test_generates_etag_with_updated_at(self):
        """Test ETag generation from updated_at timestamp."""
        ts = datetime(2025, 1, 15, 12, 0, 0, tzinfo=UTC)
        etag = generate_etag_from_metadata(123, updated_at=ts)

        assert etag.startswith('W/"')
        assert "123" in etag
        assert str(ts.timestamp()) in etag

    def test_generates_etag_with_version(self):
        """Test ETag generation from version number."""
        etag = generate_etag_from_metadata(123, version=5)

        assert etag.startswith('W/"')
        assert "123" in etag
        assert "v5" in etag

    def test_generates_etag_with_id_only(self):
        """Test ETag generation with just ID (fallback)."""
        etag = generate_etag_from_metadata(123)

        assert etag == 'W/"123"'

    def test_prefers_updated_at_over_version(self):
        """Test that updated_at is preferred when both provided."""
        ts = datetime(2025, 1, 15, 12, 0, 0, tzinfo=UTC)
        etag = generate_etag_from_metadata(123, updated_at=ts, version=5)

        # Should use timestamp, not version
        assert str(ts.timestamp()) in etag
        assert "v5" not in etag

    def test_same_metadata_produces_same_etag(self):
        """Test that same metadata produces identical ETags."""
        ts = datetime(2025, 1, 15, 12, 0, 0, tzinfo=UTC)
        etag1 = generate_etag_from_metadata(123, updated_at=ts)
        etag2 = generate_etag_from_metadata(123, updated_at=ts)
        assert etag1 == etag2


class TestGenerateEtagFromModel:
    """Tests for generate_etag_from_model function."""

    def test_generates_etag_from_pydantic_model(self):
        """Test ETag generation from Pydantic model."""
        model = SampleModel(id=1, name="Test")
        etag = generate_etag_from_model(model)

        assert etag.startswith('W/"')  # Weak by default
        assert len(etag) > 4  # Has content

    def test_different_models_produce_different_etags(self):
        """Test that different models produce different ETags."""
        model1 = SampleModel(id=1, name="First")
        model2 = SampleModel(id=2, name="Second")

        etag1 = generate_etag_from_model(model1)
        etag2 = generate_etag_from_model(model2)

        assert etag1 != etag2

    def test_same_model_produces_same_etag(self):
        """Test that same model data produces identical ETags."""
        model1 = SampleModel(id=1, name="Test")
        model2 = SampleModel(id=1, name="Test")

        etag1 = generate_etag_from_model(model1)
        etag2 = generate_etag_from_model(model2)

        assert etag1 == etag2

    def test_can_generate_strong_etag(self):
        """Test generation of strong ETag from model."""
        model = SampleModel(id=1, name="Test")
        etag = generate_etag_from_model(model, weak=False)

        assert not etag.startswith('W/"')
        assert etag.startswith('"')


class TestGenerateEtagFromList:
    """Tests for generate_etag_from_list function."""

    def test_generates_etag_for_list(self):
        """Test ETag generation for a list of items."""
        items = [
            SampleModel(id=1, name="First"),
            SampleModel(id=2, name="Second"),
        ]
        etag = generate_etag_from_list(items)

        assert etag.startswith('W/"')

    def test_includes_count_in_etag(self):
        """Test that item count affects ETag."""
        items1 = [SampleModel(id=1, name="First")]
        items2 = [SampleModel(id=1, name="First"), SampleModel(id=2, name="Second")]

        etag1 = generate_etag_from_list(items1)
        etag2 = generate_etag_from_list(items2)

        assert etag1 != etag2

    def test_includes_total_in_etag(self):
        """Test that total count affects ETag."""
        items = [SampleModel(id=1, name="First")]

        etag1 = generate_etag_from_list(items, total=10)
        etag2 = generate_etag_from_list(items, total=20)

        assert etag1 != etag2

    def test_handles_empty_list(self):
        """Test ETag generation for empty list."""
        etag = generate_etag_from_list([])
        assert etag.startswith('W/"')

    def test_handles_dict_items(self):
        """Test ETag generation with dict items."""
        items = [{"id": 1, "name": "First"}, {"id": 2, "name": "Second"}]
        etag = generate_etag_from_list(items)
        assert etag.startswith('W/"')


class TestCheckEtagMatch:
    """Tests for check_etag_match function."""

    def _mock_request(self, if_none_match: str | None = None) -> MagicMock:
        """Create a mock request with If-None-Match header."""
        headers = {"if-none-match": if_none_match} if if_none_match else {}
        request = MagicMock()
        request.headers = MagicMock()
        request.headers.get = lambda key, default=None: headers.get(key, default)
        return request

    def test_returns_false_when_no_header(self):
        """Test that False is returned when no If-None-Match header."""
        request = self._mock_request()
        assert check_etag_match(request, '"abc123"') is False

    def test_returns_true_on_exact_match(self):
        """Test that True is returned on exact ETag match."""
        request = self._mock_request('"abc123"')
        assert check_etag_match(request, '"abc123"') is True

    def test_returns_true_on_weak_match(self):
        """Test that weak ETag comparison works."""
        request = self._mock_request('W/"abc123"')
        assert check_etag_match(request, '"abc123"') is True

    def test_returns_true_on_wildcard(self):
        """Test that wildcard (*) matches any ETag."""
        request = self._mock_request("*")
        assert check_etag_match(request, '"any-etag"') is True

    def test_handles_multiple_etags(self):
        """Test matching against multiple ETags in header."""
        request = self._mock_request('"etag1", "etag2", "etag3"')
        assert check_etag_match(request, '"etag2"') is True
        assert check_etag_match(request, '"etag4"') is False

    def test_returns_false_on_no_match(self):
        """Test that False is returned when ETags don't match."""
        request = self._mock_request('"old-etag"')
        assert check_etag_match(request, '"new-etag"') is False


class TestCheckIfMatch:
    """Tests for check_if_match function."""

    def _mock_request(self, if_match: str | None = None) -> MagicMock:
        """Create a mock request with If-Match header."""
        headers = {"if-match": if_match} if if_match else {}
        request = MagicMock()
        request.headers = MagicMock()
        request.headers.get = lambda key, default=None: headers.get(key, default)
        return request

    def test_returns_true_when_no_header(self):
        """Test that True is returned when no If-Match header (proceed)."""
        request = self._mock_request()
        assert check_if_match(request, '"abc123"') is True

    def test_returns_true_on_exact_match(self):
        """Test that True is returned on exact ETag match."""
        request = self._mock_request('"abc123"')
        assert check_if_match(request, '"abc123"') is True

    def test_returns_true_on_wildcard(self):
        """Test that wildcard (*) matches any resource."""
        request = self._mock_request("*")
        assert check_if_match(request, '"any-etag"') is True

    def test_returns_false_on_mismatch(self):
        """Test that False is returned when ETags don't match."""
        request = self._mock_request('"old-etag"')
        assert check_if_match(request, '"new-etag"') is False

    def test_weak_etags_fail_strong_comparison(self):
        """Test that weak ETags fail If-Match (requires strong comparison)."""
        request = self._mock_request('W/"abc123"')
        # If-Match requires strong comparison, weak ETags should fail
        assert check_if_match(request, '"abc123"') is False


class TestEtagResponse:
    """Tests for etag_response function."""

    def test_creates_json_response_with_etag(self):
        """Test that response includes ETag header."""
        model = SampleModel(id=1, name="Test")
        response = etag_response(model, '"test-etag"')

        assert response.headers["ETag"] == '"test-etag"'
        assert response.status_code == 200

    def test_includes_cache_control_header(self):
        """Test that Cache-Control header is set."""
        model = SampleModel(id=1, name="Test")
        response = etag_response(model, '"test-etag"')

        assert "Cache-Control" in response.headers
        assert "must-revalidate" in response.headers["Cache-Control"]

    def test_handles_dict_content(self):
        """Test that dict content is handled."""
        content = {"id": 1, "name": "Test"}
        response = etag_response(content, '"test-etag"')

        assert response.status_code == 200

    def test_custom_status_code(self):
        """Test that custom status code can be set."""
        model = SampleModel(id=1, name="Test")
        response = etag_response(model, '"test-etag"', status_code=201)

        assert response.status_code == 201


class TestNotModifiedResponse:
    """Tests for not_modified_response function."""

    def test_returns_304_status(self):
        """Test that 304 status code is returned."""
        response = not_modified_response('"test-etag"')
        assert response.status_code == 304

    def test_includes_etag_header(self):
        """Test that ETag header is included."""
        response = not_modified_response('"test-etag"')
        assert response.headers["ETag"] == '"test-etag"'

    def test_has_no_body(self):
        """Test that response body is empty."""
        response = not_modified_response('"test-etag"')
        # 304 responses should have no body
        assert response.body == b""
