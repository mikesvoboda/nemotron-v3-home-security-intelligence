/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/admin/seed/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seed Cameras
         * @description Seed test cameras into the database.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *
         *     Args:
         *         request: Seed configuration (count, clear_existing, create_folders)
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of seeded cameras
         */
        post: operations["seed_cameras_api_admin_seed_cameras_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seed Events
         * @description Seed mock events and detections into the database.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *     Requires cameras to exist first.
         *
         *     Args:
         *         request: Seed configuration (count, clear_existing)
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of seeded events and detections
         */
        post: operations["seed_events_api_admin_seed_events_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/clear": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Seeded Data
         * @description Clear all seeded data (cameras, events, detections).
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *     Requires JSON body confirmation to prevent accidental data deletion:
         *     {"confirm": "DELETE_ALL_DATA"}
         *
         *     Args:
         *         body: Request body with confirmation string
         *         request: FastAPI request for audit logging
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of cleared data counts
         *
         *     Raises:
         *         HTTPException: 400 if confirmation string is incorrect
         */
        delete: operations["clear_seeded_data_api_admin_seed_clear_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/events/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Audit
         * @description Get audit information for a specific event.
         *
         *     Retrieves the AI pipeline audit record for the given event, including
         *     model contributions, quality scores, and prompt improvement suggestions.
         *
         *     Args:
         *         event_id: The ID of the event to get audit for
         *         db: Database session
         *
         *     Returns:
         *         EventAuditResponse containing full audit details
         *
         *     Raises:
         *         HTTPException: 404 if event or audit not found
         */
        get: operations["get_event_audit_api_ai_audit_events__event_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/events/{event_id}/evaluate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Evaluate Event
         * @description Trigger full evaluation for a specific event's audit.
         *
         *     Runs the complete self-evaluation pipeline (self-critique, rubric scoring,
         *     consistency check, prompt improvement) for the given event.
         *
         *     Args:
         *         event_id: The ID of the event to evaluate
         *         force: If True, re-evaluate even if already evaluated
         *         db: Database session
         *
         *     Returns:
         *         EventAuditResponse with updated evaluation results
         *
         *     Raises:
         *         HTTPException: 404 if event or audit not found
         */
        post: operations["evaluate_event_api_ai_audit_events__event_id__evaluate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Stats
         * @description Get aggregate AI audit statistics.
         *
         *     Returns aggregate statistics including total events, quality scores,
         *     model contribution rates, and audit trends over the specified period.
         *
         *     Args:
         *         days: Number of days to include in statistics (1-90, default 7)
         *         camera_id: Optional camera ID to filter stats
         *         db: Database session
         *
         *     Returns:
         *         AuditStatsResponse with aggregate statistics
         */
        get: operations["get_audit_stats_api_ai_audit_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/leaderboard": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Leaderboard
         * @description Get model leaderboard ranked by contribution rate.
         *
         *     Returns a ranked list of AI models by their contribution rate,
         *     along with quality correlation data.
         *
         *     Args:
         *         days: Number of days to include (1-90, default 7)
         *         db: Database session
         *
         *     Returns:
         *         LeaderboardResponse with ranked model entries
         */
        get: operations["get_model_leaderboard_api_ai_audit_leaderboard_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/recommendations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Recommendations
         * @description Get aggregated prompt improvement recommendations.
         *
         *     Analyzes all audits to produce actionable recommendations for
         *     improving the AI pipeline prompt templates.
         *
         *     Args:
         *         days: Number of days to analyze (1-90, default 7)
         *         db: Database session
         *
         *     Returns:
         *         RecommendationsResponse with prioritized recommendations
         */
        get: operations["get_recommendations_api_ai_audit_recommendations_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Batch Audit
         * @description Trigger batch audit processing for multiple events.
         *
         *     Queues events for audit processing based on the provided criteria.
         *     Events are processed asynchronously.
         *
         *     Args:
         *         request: Batch audit request with filtering criteria
         *         db: Database session
         *
         *     Returns:
         *         BatchAuditResponse with number of queued events
         */
        post: operations["trigger_batch_audit_api_ai_audit_batch_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Rules
         * @description List all alert rules with optional filtering and pagination.
         *
         *     Args:
         *         enabled: Filter by enabled status
         *         severity: Filter by severity level (low, medium, high, critical)
         *         limit: Maximum number of results to return
         *         offset: Number of results to skip for pagination
         *         db: Database session
         *
         *     Returns:
         *         AlertRuleListResponse with rules and pagination info
         */
        get: operations["list_rules_api_alerts_rules_get"];
        put?: never;
        /**
         * Create Rule
         * @description Create a new alert rule.
         *
         *     Args:
         *         rule_data: Rule creation data
         *         db: Database session
         *
         *     Returns:
         *         Created AlertRule
         */
        post: operations["create_rule_api_alerts_rules_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules/{rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Rule
         * @description Get a specific alert rule by ID.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         db: Database session
         *
         *     Returns:
         *         AlertRule
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        get: operations["get_rule_api_alerts_rules__rule_id__get"];
        /**
         * Update Rule
         * @description Update an existing alert rule.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         rule_data: Rule update data
         *         db: Database session
         *
         *     Returns:
         *         Updated AlertRule
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        put: operations["update_rule_api_alerts_rules__rule_id__put"];
        post?: never;
        /**
         * Delete Rule
         * @description Delete an alert rule.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        delete: operations["delete_rule_api_alerts_rules__rule_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules/{rule_id}/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Rule
         * @description Test a rule against historical events.
         *
         *     This endpoint allows testing rule configuration without actually
         *     creating alerts. Useful for validating rules before enabling them.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         test_data: Test configuration (event IDs, time override)
         *         db: Database session
         *
         *     Returns:
         *         RuleTestResponse with per-event match results
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        post: operations["test_rule_api_alerts_rules__rule_id__test_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Audit Logs
         * @description List audit logs with optional filtering and pagination.
         *
         *     This endpoint is intended for admin use to review security-sensitive operations.
         *
         *     Args:
         *         action: Optional action type to filter by
         *         resource_type: Optional resource type to filter by
         *         resource_id: Optional specific resource ID to filter by
         *         actor: Optional actor to filter by
         *         status_filter: Optional status to filter by (success/failure)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         limit: Maximum number of results to return (1-1000, default 100)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         AuditLogListResponse containing filtered logs and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["list_audit_logs_api_audit_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Stats
         * @description Get audit log statistics for dashboard.
         *
         *     Returns aggregated statistics about audit logs including:
         *     - Total log count
         *     - Logs today
         *     - Breakdown by action type
         *     - Breakdown by resource type
         *     - Breakdown by status
         *     - Recently active actors
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         AuditLogStats with aggregated statistics
         */
        get: operations["get_audit_stats_api_audit_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit/{audit_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Log
         * @description Get a specific audit log entry by ID.
         *
         *     Args:
         *         audit_id: Audit log ID
         *         db: Database session
         *
         *     Returns:
         *         AuditLog record
         *
         *     Raises:
         *         HTTPException: 404 if audit log not found
         */
        get: operations["get_audit_log_api_audit__audit_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Cameras
         * @description List all cameras with optional status filter.
         *
         *     Uses Redis cache with cache-aside pattern to improve performance
         *     and generate cache hit metrics.
         *
         *     Args:
         *         status_filter: Optional status to filter cameras by (online, offline, error)
         *         db: Database session
         *
         *     Returns:
         *         CameraListResponse containing list of cameras and total count
         */
        get: operations["list_cameras_api_cameras_get"];
        put?: never;
        /**
         * Create Camera
         * @description Create a new camera.
         *
         *     Args:
         *         camera_data: Camera creation data
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Created camera object with generated ID
         *
         *     Raises:
         *         HTTPException: 409 if camera with same name or folder_path already exists
         */
        post: operations["create_camera_api_cameras_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera
         * @description Get a specific camera by ID.
         *
         *     Args:
         *         camera_id: UUID of the camera
         *         db: Database session
         *
         *     Returns:
         *         Camera object
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_api_cameras__camera_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Camera
         * @description Delete a camera.
         *
         *     This operation cascades to all related detections and events.
         *
         *     Args:
         *         camera_id: UUID of the camera to delete
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        delete: operations["delete_camera_api_cameras__camera_id__delete"];
        options?: never;
        head?: never;
        /**
         * Update Camera
         * @description Update an existing camera.
         *
         *     Args:
         *         camera_id: UUID of the camera to update
         *         camera_data: Camera update data (all fields optional)
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Updated camera object
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        patch: operations["update_camera_api_cameras__camera_id__patch"];
        trace?: never;
    };
    "/api/cameras/{camera_id}/snapshot": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Snapshot
         * @description Return the latest image for a camera (best-effort snapshot).
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves static image content accessed directly by browsers via <img> tags
         *     2. It has its own security controls (path traversal protection, file type allowlist)
         *     3. It has rate limiting to prevent abuse
         *
         *     This endpoint uses the camera's configured `folder_path` and returns the most recently
         *     modified image file under that directory.
         */
        get: operations["get_camera_snapshot_api_cameras__camera_id__snapshot_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/validation/paths": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Validate Camera Paths
         * @description Validate all camera folder paths against the configured base path.
         *
         *     This endpoint checks each camera's folder_path to determine:
         *     1. Whether the path is under the configured FOSCAM_BASE_PATH
         *     2. Whether the directory exists on disk
         *     3. Whether the directory contains any images
         *
         *     Use this to diagnose cameras that show "No snapshot available" errors.
         *
         *     Returns:
         *         Dictionary with validation results for all cameras
         */
        get: operations["validate_camera_paths_api_cameras_validation_paths_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Baseline
         * @description Get baseline activity data for a camera.
         *
         *     Returns comprehensive baseline statistics including:
         *     - Hourly activity patterns (0-23 hours)
         *     - Daily patterns (by day of week)
         *     - Object-specific baselines
         *     - Current deviation from baseline
         *
         *     Args:
         *         camera_id: ID of the camera
         *         db: Database session
         *
         *     Returns:
         *         BaselineSummaryResponse with all baseline data
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_baseline_api_cameras__camera_id__baseline_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline/anomalies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Baseline Anomalies
         * @description Get recent anomaly events for a camera.
         *
         *     Returns a list of anomaly events detected within the specified time period.
         *     Anomalies are detections that significantly deviate from the established
         *     baseline activity patterns.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         days: Number of days to look back (default: 7, max: 90)
         *         db: Database session
         *
         *     Returns:
         *         AnomalyListResponse with list of anomaly events
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_baseline_anomalies_api_cameras__camera_id__baseline_anomalies_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/scene-changes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Scene Changes
         * @description Get scene changes for a camera.
         *
         *     Returns a list of detected scene changes that may indicate camera
         *     tampering, angle changes, or blocked views.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         acknowledged: Filter by acknowledgement status (None = all)
         *         limit: Maximum number of results (default: 50, max: 1000)
         *         offset: Number of results to skip (default: 0)
         *         db: Database session
         *
         *     Returns:
         *         SceneChangeListResponse with list of scene changes
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_scene_changes_api_cameras__camera_id__scene_changes_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/scene-changes/{scene_change_id}/acknowledge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Acknowledge Scene Change
         * @description Acknowledge a scene change alert.
         *
         *     Marks a scene change as acknowledged to indicate it has been reviewed.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         scene_change_id: ID of the scene change to acknowledge
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         SceneChangeAcknowledgeResponse confirming acknowledgement
         *
         *     Raises:
         *         HTTPException: 404 if camera or scene change not found
         */
        post: operations["acknowledge_scene_change_api_cameras__camera_id__scene_changes__scene_change_id__acknowledge_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Detections
         * @description List detections with optional filtering and pagination.
         *
         *     Args:
         *         camera_id: Optional camera ID to filter by
         *         object_type: Optional object type to filter by (person, car, etc.)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         min_confidence: Optional minimum confidence score (0-1)
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         DetectionListResponse containing filtered detections and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["list_detections_api_detections_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection
         * @description Get a specific detection by ID.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         Detection object
         *
         *     Raises:
         *         HTTPException: 404 if detection not found
         */
        get: operations["get_detection_api_detections__detection_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/enrichment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Enrichment
         * @description Get structured enrichment data for a detection.
         *
         *     Returns results from the 18+ vision models run during the enrichment pipeline:
         *     - License plate detection and OCR
         *     - Face detection
         *     - Vehicle classification and damage detection
         *     - Clothing analysis (FashionCLIP and SegFormer)
         *     - Violence detection
         *     - Image quality assessment
         *     - Pet classification
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         EnrichmentResponse with structured vision model results
         *
         *     Raises:
         *         HTTPException: 404 if detection not found
         */
        get: operations["get_detection_enrichment_api_detections__detection_id__enrichment_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Image
         * @description Get detection image with bounding box overlay.
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves static image content accessed directly by browsers via <img> tags
         *     2. Detection IDs are not predictable (integer IDs require prior knowledge)
         *     3. It has rate limiting to prevent abuse
         *
         *     Returns the thumbnail image with bounding box drawn around the detected object.
         *     If thumbnail doesn't exist, generates it on the fly from the source image.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         JPEG image with bounding box overlay
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or image file doesn't exist
         *         HTTPException: 500 if image generation fails
         */
        get: operations["get_detection_image_api_detections__detection_id__image_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Stream Detection Video
         * @description Stream detection video with HTTP Range request support.
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves video content accessed directly by browsers via <video> tags
         *     2. Detection IDs are not predictable (integer IDs require prior knowledge)
         *     3. It has rate limiting to prevent abuse
         *
         *     Supports partial content requests for video seeking and efficient playback.
         *     Returns 206 Partial Content for range requests, 200 OK for full content.
         *
         *     Args:
         *         detection_id: Detection ID
         *         range_header: HTTP Range header for partial content requests
         *         db: Database session
         *
         *     Returns:
         *         StreamingResponse with video content
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or not a video
         *         HTTPException: 416 if range is not satisfiable
         */
        get: operations["stream_detection_video_api_detections__detection_id__video_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/video/thumbnail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Video Thumbnail
         * @description Get thumbnail frame from a video detection.
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves static image content accessed directly by browsers via <img> tags
         *     2. Detection IDs are not predictable (integer IDs require prior knowledge)
         *     3. It has rate limiting to prevent abuse
         *
         *     Extracts and returns a thumbnail frame from the video. If thumbnail
         *     doesn't exist, generates it on the fly using ffmpeg.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         JPEG thumbnail image
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or not a video
         *         HTTPException: 500 if thumbnail generation fails
         */
        get: operations["get_video_thumbnail_api_detections__detection_id__video_thumbnail_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Dlq Stats
         * @description Get dead-letter queue statistics.
         *
         *     Returns the number of jobs in each DLQ and the total count.
         *
         *     Returns:
         *         DLQStatsResponse with queue counts
         */
        get: operations["get_dlq_stats_api_dlq_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/jobs/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Dlq Jobs
         * @description List jobs in a specific dead-letter queue.
         *
         *     Returns jobs in the specified DLQ without removing them.
         *     Use pagination parameters to control the result set.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         start: Start index for pagination
         *         limit: Maximum number of jobs to return
         *         redis: Redis client
         *
         *     Returns:
         *         DLQJobsResponse with list of jobs
         */
        get: operations["get_dlq_jobs_api_dlq_jobs__queue_name__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/requeue/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Requeue Dlq Job
         * @description Requeue the oldest job from a DLQ back to its original processing queue.
         *
         *     Removes the oldest job from the specified DLQ and adds it back to the
         *     original processing queue for retry.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         redis: Redis client
         *
         *     Returns:
         *         DLQRequeueResponse with operation result
         */
        post: operations["requeue_dlq_job_api_dlq_requeue__queue_name__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/requeue-all/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Requeue All Dlq Jobs
         * @description Requeue all jobs from a DLQ back to their original processing queue.
         *
         *     Removes all jobs from the specified DLQ and adds them back to the
         *     original processing queue for retry. Limited to settings.max_requeue_iterations
         *     to prevent resource exhaustion.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         redis: Redis client
         *
         *     Returns:
         *         DLQRequeueResponse with operation result and count
         */
        post: operations["requeue_all_dlq_jobs_api_dlq_requeue_all__queue_name__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Dlq
         * @description Clear all jobs from a dead-letter queue.
         *
         *     WARNING: This permanently removes all jobs from the specified DLQ.
         *     Use with caution.
         *
         *     Args:
         *         queue_name: Name of the DLQ to clear
         *         redis: Redis client
         *
         *     Returns:
         *         DLQClearResponse with operation result
         */
        delete: operations["clear_dlq_api_dlq__queue_name__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Entities
         * @description List tracked entities with optional filtering.
         *
         *     Returns a paginated list of entities that have been tracked via
         *     re-identification. Entities are grouped by their embedding clusters.
         *
         *     Args:
         *         entity_type: Filter by entity type ('person' or 'vehicle')
         *         camera_id: Filter by camera ID
         *         since: Filter entities seen since this timestamp
         *         limit: Maximum number of results (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         reid_service: Re-identification service dependency
         *
         *     Returns:
         *         EntityListResponse with filtered entities and pagination info
         */
        get: operations["list_entities_api_entities_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/{entity_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity
         * @description Get detailed information about a specific entity.
         *
         *     Returns the entity's summary information along with all recorded appearances.
         *
         *     Args:
         *         entity_id: Unique entity identifier (detection_id)
         *         reid_service: Re-identification service dependency
         *
         *     Returns:
         *         EntityDetail with full entity information
         *
         *     Raises:
         *         HTTPException: 404 if entity not found, 503 if Redis unavailable
         */
        get: operations["get_entity_api_entities__entity_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/{entity_id}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity History
         * @description Get the appearance timeline for a specific entity.
         *
         *     Returns a chronological list of all appearances for the entity
         *     across all cameras.
         *
         *     Args:
         *         entity_id: Unique entity identifier (detection_id)
         *         reid_service: Re-identification service dependency
         *
         *     Returns:
         *         EntityHistoryResponse with appearance timeline
         *
         *     Raises:
         *         HTTPException: 404 if entity not found, 503 if Redis unavailable
         */
        get: operations["get_entity_history_api_entities__entity_id__history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Events
         * @description List events with optional filtering and pagination.
         *
         *     Args:
         *         camera_id: Optional camera ID to filter by
         *         risk_level: Optional risk level to filter by (low, medium, high, critical)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         reviewed: Optional filter by reviewed status
         *         object_type: Optional object type to filter by (person, vehicle, animal, etc.)
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         EventListResponse containing filtered events and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["list_events_api_events_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Stats
         * @description Get aggregated event statistics.
         *
         *     Returns statistics about events including:
         *     - Total event count
         *     - Events grouped by risk level (critical, high, medium, low)
         *     - Events grouped by camera with camera names
         *
         *     Uses Redis cache with cache-aside pattern to improve performance
         *     and generate cache hit metrics.
         *
         *     Args:
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         db: Database session
         *
         *     Returns:
         *         EventStatsResponse with aggregated statistics
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["get_event_stats_api_events_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Events Endpoint
         * @description Search events using full-text search.
         *
         *     This endpoint provides PostgreSQL full-text search across event summaries,
         *     reasoning, object types, and camera names.
         *
         *     Search Query Syntax:
         *     - Basic words: "person vehicle" (implicit AND)
         *     - Phrase search: '"suspicious person"' (exact phrase)
         *     - Boolean OR: "person OR animal"
         *     - Boolean NOT: "person NOT cat"
         *     - Boolean AND: "person AND vehicle" (explicit)
         *
         *     Args:
         *         q: Search query string (required)
         *         camera_id: Optional comma-separated camera IDs to filter by
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         severity: Optional comma-separated risk levels (low, medium, high, critical)
         *         risk_level: Alias for severity - accepts same format
         *         object_type: Optional comma-separated object types (person, vehicle, animal)
         *         reviewed: Optional filter by reviewed status
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         SearchResponse with ranked results and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if any severity value is invalid
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["search_events_endpoint_api_events_search_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export Events
         * @description Export events as CSV file for external analysis or record-keeping.
         *
         *     This endpoint is rate-limited to 10 requests per minute per client IP
         *     to prevent abuse and protect against data exfiltration attacks.
         *
         *     Exports events with the following fields:
         *     - Event ID, camera name, timestamps
         *     - Risk score, risk level, summary
         *     - Detection count, reviewed status
         *
         *     Args:
         *         request: FastAPI request object
         *         camera_id: Optional camera ID to filter by
         *         risk_level: Optional risk level to filter by (low, medium, high, critical)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         reviewed: Optional filter by reviewed status
         *         db: Database session
         *         _rate_limit: Rate limiter dependency (10 req/min, no burst)
         *
         *     Returns:
         *         StreamingResponse with CSV file containing exported events
         *
         *     Raises:
         *         HTTPException: 429 if rate limit exceeded
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["export_events_api_events_export_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event
         * @description Get a specific event by ID.
         *
         *     Args:
         *         event_id: Event ID
         *         db: Database session
         *
         *     Returns:
         *         Event object with detection count
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_api_events__event_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Event
         * @description Update an event (mark as reviewed).
         *
         *     Args:
         *         event_id: Event ID
         *         update_data: Update data (reviewed field)
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Updated event object
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        patch: operations["update_event_api_events__event_id__patch"];
        trace?: never;
    };
    "/api/events/{event_id}/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Detections
         * @description Get detections for a specific event.
         *
         *     Args:
         *         event_id: Event ID
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         DetectionListResponse containing detections for the event
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_detections_api_events__event_id__detections_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/enrichments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Enrichments
         * @description Get enrichment data for all detections in an event.
         *
         *     Returns structured vision model results from the enrichment pipeline for
         *     each detection in the event. Results include:
         *     - License plate detection and OCR
         *     - Face detection
         *     - Vehicle classification and damage detection
         *     - Clothing analysis (FashionCLIP and SegFormer)
         *     - Violence detection
         *     - Image quality assessment
         *     - Pet classification
         *
         *     Args:
         *         event_id: Event ID
         *         db: Database session
         *
         *     Returns:
         *         EventEnrichmentsResponse with enrichment data for each detection
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_enrichments_api_events__event_id__enrichments_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/clip": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Clip
         * @description Get clip information for a specific event.
         *
         *     Returns information about whether a video clip is available for the event,
         *     and if so, provides the URL to access it along with metadata.
         *
         *     Args:
         *         event_id: Event ID
         *         db: Database session
         *
         *     Returns:
         *         ClipInfoResponse with clip availability and metadata
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_clip_api_events__event_id__clip_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/clip/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Event Clip
         * @description Trigger video clip generation for an event.
         *
         *     If a clip already exists and force=False, returns the existing clip info.
         *     If force=True, regenerates the clip even if one exists.
         *
         *     Clip generation uses detection images to create a video sequence, or
         *     extracts from existing video if available.
         *
         *     Args:
         *         event_id: Event ID
         *         request: Clip generation parameters
         *         db: Database session
         *
         *     Returns:
         *         ClipGenerateResponse with generation status and clip info
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         *         HTTPException: 400 if event has no detections to generate clip from
         */
        post: operations["generate_event_clip_api_events__event_id__clip_generate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Logs
         * @description List logs with optional filtering and pagination.
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["list_logs_api_logs_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Log Stats
         * @description Get log statistics for dashboard.
         */
        get: operations["get_log_stats_api_logs_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/{log_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Log
         * @description Get a single log entry by ID.
         */
        get: operations["get_log_api_logs__log_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/frontend": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Frontend Log
         * @description Receive and store a log from the frontend.
         */
        post: operations["create_frontend_log_api_logs_frontend_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Media Compat
         * @description Compatibility route: serve media via design-spec-style /api/media/{path}.
         *
         *     This preserves the stricter behavior of the new routes:
         *     - Path traversal protection
         *     - Allowed file type allowlist
         *     - Must remain under configured base directories
         *
         *     Mapping rules:
         *     - `cameras/<camera_id>/<filename...>`  camera media
         *     - `thumbnails/<filename>`  thumbnails
         *     - `detections/<id>`  detection images
         */
        get: operations["serve_media_compat_api_media__path__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/cameras/{camera_id}/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Camera File
         * @description Serve camera images or videos from Foscam storage.
         *
         *     Args:
         *         camera_id: The camera identifier (directory name)
         *         filename: The file to serve (can include subdirectories)
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["serve_camera_file_api_media_cameras__camera_id___filename__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/thumbnails/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Thumbnail
         * @description Serve detection thumbnail images.
         *
         *     Args:
         *         filename: The thumbnail filename
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["serve_thumbnail_api_media_thumbnails__filename__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/clips/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Clip
         * @description Serve event video clips.
         *
         *     Clips are generated by the ClipGenerator service and stored in the
         *     configured clips directory.
         *
         *     Args:
         *         filename: The clip filename (e.g., "123_clip.mp4")
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["serve_clip_api_media_clips__filename__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Metrics
         * @description Return Prometheus metrics in exposition format.
         *
         *     This endpoint returns all registered metrics in the standard
         *     Prometheus exposition format for scraping.
         *
         *     Returns:
         *         Response with text/plain content type containing metrics
         */
        get: operations["metrics_api_metrics_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Notification Config
         * @description Get notification configuration status.
         *
         *     Returns the current notification configuration including:
         *     - Whether notifications are enabled
         *     - Which channels are configured (email, webhook, push)
         *     - SMTP host and port (if configured)
         *     - Default webhook URL (if configured)
         *     - Default email recipients
         *
         *     Note: Sensitive fields like SMTP password are NOT returned.
         *
         *     Returns:
         *         NotificationConfigResponse with current notification settings
         */
        get: operations["get_notification_config_api_notification_config_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Notification
         * @description Test notification delivery for a specific channel.
         *
         *     Sends a test notification to verify the configuration is working.
         *     For email, sends a test email to the specified recipients or default recipients.
         *     For webhook, sends a test payload to the specified URL or default URL.
         *
         *     Args:
         *         test_request: Test notification request with channel and optional overrides
         *
         *     Returns:
         *         TestNotificationResponse with test result
         */
        post: operations["test_notification_api_notification_test_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Health
         * @description Get detailed system health check.
         *
         *     Checks the health of all system components:
         *     - Database connectivity
         *     - Redis connectivity
         *     - AI services status
         *
         *     Health checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).
         *     If a health check times out, the service is marked as unhealthy.
         *
         *     Returns:
         *         HealthResponse with overall status and individual service statuses.
         *         HTTP 200 if healthy, 503 if degraded or unhealthy.
         */
        get: operations["get_health_api_system_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Readiness
         * @description Kubernetes-style readiness probe endpoint with detailed information.
         *
         *     This endpoint indicates whether the application is ready to receive
         *     traffic and process uploads. It checks all critical dependencies:
         *     - Database connectivity (critical)
         *     - Redis connectivity (required for queue processing)
         *     - AI services availability
         *     - Background worker status
         *
         *     Note: The canonical readiness probe is GET /ready at the root level.
         *     This endpoint provides the same readiness check but with detailed
         *     service and worker status information.
         *
         *     Used by Kubernetes/Docker to determine if traffic should be routed to this instance.
         *     If this endpoint returns not_ready, the instance should not receive new requests.
         *
         *     Health checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).
         *     If a health check times out, the service is marked as unhealthy.
         *
         *     Returns:
         *         ReadinessResponse with overall readiness status and detailed checks.
         *         HTTP 200 if ready, 503 if degraded or not ready.
         */
        get: operations["get_readiness_api_system_health_ready_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/websocket": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Websocket Health
         * @description Get health status of WebSocket broadcasters and their circuit breakers.
         *
         *     Returns the current state of circuit breakers for:
         *     - Event broadcaster: Handles real-time security event distribution
         *     - System broadcaster: Handles system status updates (GPU, cameras, queues)
         *
         *     Circuit breakers protect the system from cascading failures by:
         *     - Opening after repeated connection failures
         *     - Blocking recovery attempts while open to allow stabilization
         *     - Gradually testing recovery in half-open state
         *
         *     Circuit breaker states:
         *     - closed: Normal operation, WebSocket events flowing normally
         *     - open: Failures detected, events may be delayed or unavailable
         *     - half_open: Testing recovery, limited operations allowed
         *
         *     Returns:
         *         WebSocketHealthResponse with circuit breaker status for both broadcasters
         */
        get: operations["get_websocket_health_api_system_health_websocket_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Gpu Stats
         * @description Get current GPU statistics.
         *
         *     Returns the most recent GPU statistics including:
         *     - GPU name
         *     - GPU utilization percentage
         *     - Memory usage (used/total)
         *     - Temperature
         *     - Power usage
         *     - Inference FPS
         *
         *     Returns:
         *         GPUStatsResponse with GPU statistics (null values if unavailable)
         */
        get: operations["get_gpu_stats_api_system_gpu_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Gpu Stats History
         * @description Get recent GPU stats samples as a time-series.
         *
         *     Args:
         *         since: Optional lower bound for recorded_at (ISO datetime)
         *         limit: Maximum number of samples to return (default 300)
         *         db: Database session
         */
        get: operations["get_gpu_stats_history_api_system_gpu_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Config
         * @description Get public configuration settings.
         *
         *     Returns non-sensitive application configuration values.
         *     Does NOT expose database URLs, API keys, or other secrets.
         *
         *     Returns:
         *         ConfigResponse with public configuration settings
         */
        get: operations["get_config_api_system_config_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Patch Config
         * @description Patch processing-related configuration and persist runtime overrides.
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     Notes:
         *     - This updates a runtime override env file (see `HSI_RUNTIME_ENV_PATH`) and clears the
         *       settings cache so subsequent `get_settings()` calls observe the new values.
         */
        patch: operations["patch_config_api_system_config_patch"];
        trace?: never;
    };
    "/api/system/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Stats
         * @description Get system statistics.
         *
         *     Returns aggregate statistics about the system:
         *     - Total number of cameras
         *     - Total number of events
         *     - Total number of detections
         *     - Application uptime
         *
         *     Returns:
         *         SystemStatsResponse with system statistics
         */
        get: operations["get_stats_api_system_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/telemetry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Telemetry
         * @description Get pipeline telemetry data.
         *
         *     Returns real-time metrics about the AI processing pipeline:
         *     - Queue depths: Items waiting in detection and analysis queues
         *     - Stage latencies: Processing time statistics for each pipeline stage
         *
         *     This endpoint helps operators:
         *     - Monitor pipeline health and throughput
         *     - Identify bottlenecks and backlogs
         *     - Debug pipeline stalls
         *     - Track performance trends
         *
         *     Returns:
         *         TelemetryResponse with queue depths and latency statistics
         */
        get: operations["get_telemetry_api_system_telemetry_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline-latency": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Latency
         * @description Get pipeline latency metrics with percentiles.
         *
         *     Returns latency statistics for each stage transition in the AI pipeline:
         *     - watch_to_detect: Time from file watcher detecting image to RT-DETR processing start
         *     - detect_to_batch: Time from detection completion to batch aggregation
         *     - batch_to_analyze: Time from batch completion to Nemotron analysis start
         *     - total_pipeline: Total end-to-end processing time
         *
         *     Each stage includes:
         *     - avg_ms: Average latency in milliseconds
         *     - min_ms: Minimum latency
         *     - max_ms: Maximum latency
         *     - p50_ms: 50th percentile (median)
         *     - p95_ms: 95th percentile
         *     - p99_ms: 99th percentile
         *     - sample_count: Number of samples used
         *
         *     Args:
         *         window_minutes: Time window for statistics calculation (default 60 minutes)
         *
         *     Returns:
         *         PipelineLatencyResponse with latency statistics for each stage
         */
        get: operations["get_pipeline_latency_api_system_pipeline_latency_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline-latency/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Latency History
         * @description Get pipeline latency history for time-series visualization.
         *
         *     Returns latency data grouped into time buckets for charting.
         *     Each bucket contains aggregated statistics for all pipeline stages.
         *
         *     Args:
         *         since: Number of minutes of history to return (1-1440, default 60)
         *         bucket_seconds: Size of each time bucket in seconds (10-3600, default 60)
         *
         *     Returns:
         *         PipelineLatencyHistoryResponse with chronologically ordered snapshots
         */
        get: operations["get_pipeline_latency_history_api_system_pipeline_latency_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/cleanup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Cleanup
         * @description Trigger manual data cleanup based on retention settings.
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     This endpoint runs the CleanupService to delete old data according to
         *     the configured retention period. It deletes:
         *     - Events older than retention period
         *     - Detections older than retention period
         *     - GPU stats older than retention period
         *     - Logs older than log retention period
         *     - Associated thumbnail files
         *     - Optionally original image files (if delete_images is enabled)
         *
         *     The cleanup respects the current retention_days setting from the system
         *     configuration. To change the retention period before running cleanup,
         *     use PATCH /api/system/config first.
         *
         *     Args:
         *         dry_run: If True, calculate and return what would be deleted without
         *                  actually performing the deletion. Useful for verification
         *                  before destructive operations.
         *
         *     Returns:
         *         CleanupResponse with statistics about the cleanup operation.
         *         When dry_run=True, the counts represent what would be deleted.
         */
        post: operations["trigger_cleanup_api_system_cleanup_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/severity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Severity Metadata
         * @description Get severity level definitions and thresholds.
         *
         *     Returns complete information about the severity taxonomy including:
         *     - All severity level definitions (LOW, MEDIUM, HIGH, CRITICAL)
         *     - Risk score thresholds for each level
         *     - Color codes for UI display
         *     - Human-readable labels and descriptions
         *
         *     This endpoint is useful for frontends to:
         *     - Display severity information consistently
         *     - Show severity legends in the UI
         *     - Validate severity-related user inputs
         *     - Map risk scores to severity levels client-side
         *
         *     Returns:
         *         SeverityMetadataResponse with all severity definitions and current thresholds
         */
        get: operations["get_severity_metadata_api_system_severity_get"];
        /**
         * Update Severity Thresholds
         * @description Update severity threshold configuration.
         *
         *     Updates the risk score thresholds for severity levels. The thresholds
         *     define how risk scores (0-100) are mapped to severity levels:
         *     - LOW: 0 to low_max
         *     - MEDIUM: low_max+1 to medium_max
         *     - HIGH: medium_max+1 to high_max
         *     - CRITICAL: high_max+1 to 100
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     Validation:
         *     - Thresholds must be strictly ordered: low_max < medium_max < high_max
         *     - All thresholds must be between 1 and 99
         *     - This ensures contiguous, non-overlapping ranges covering 0-100
         *
         *     Note: Changes only affect new events. Existing events retain their
         *     original severity assignment.
         *
         *     Args:
         *         update: New threshold values
         *
         *     Returns:
         *         SeverityMetadataResponse with updated definitions and thresholds
         *
         *     Raises:
         *         HTTPException 400: If thresholds are not strictly ordered
         */
        put: operations["update_severity_thresholds_api_system_severity_put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/storage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Storage Stats
         * @description Get storage statistics and disk usage metrics.
         *
         *     Returns detailed storage usage information including:
         *     - Overall disk usage (used/total/free)
         *     - Storage breakdown by category (thumbnails, images, clips)
         *     - Database record counts (events, detections, GPU stats, logs)
         *
         *     This endpoint helps operators:
         *     - Monitor available storage space
         *     - Understand storage distribution across data types
         *     - Plan cleanup operations
         *     - Track database growth
         *
         *     Returns:
         *         StorageStatsResponse with comprehensive storage metrics
         */
        get: operations["get_storage_stats_api_system_storage_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/circuit-breakers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Circuit Breakers
         * @description Get status of all circuit breakers in the system.
         *
         *     Returns the current state and metrics for each circuit breaker,
         *     which protect external services from cascading failures.
         *
         *     Circuit breakers can be in one of three states:
         *     - CLOSED: Normal operation, calls pass through
         *     - OPEN: Service failing, calls rejected immediately
         *     - HALF_OPEN: Testing recovery, limited calls allowed
         *
         *     Returns:
         *         CircuitBreakersResponse with status of all circuit breakers
         */
        get: operations["get_circuit_breakers_api_system_circuit_breakers_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/circuit-breakers/{name}/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset Circuit Breaker
         * @description Reset a specific circuit breaker to CLOSED state.
         *
         *     This manually resets a circuit breaker, clearing failure counts
         *     and returning it to normal operation. Use this to recover from
         *     transient failures or after fixing an underlying issue.
         *
         *     Requires API key authentication when api_key_enabled is True.
         *
         *     Args:
         *         name: Name of the circuit breaker to reset
         *
         *     Returns:
         *         CircuitBreakerResetResponse with reset confirmation
         *
         *     Raises:
         *         HTTPException 400: If name is invalid (empty, too long, or contains invalid characters)
         *         HTTPException 404: If circuit breaker not found
         */
        post: operations["reset_circuit_breaker_api_system_circuit_breakers__name__reset_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/cleanup/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Cleanup Status
         * @description Get current status of the cleanup service.
         *
         *     Returns information about the automated cleanup service including:
         *     - Whether the service is running
         *     - Current retention settings
         *     - Next scheduled cleanup time
         *
         *     Returns:
         *         CleanupStatusResponse with cleanup service status
         */
        get: operations["get_cleanup_status_api_system_cleanup_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Status
         * @description Get combined status of all pipeline operations.
         *
         *     Returns real-time visibility into the AI processing pipeline:
         *
         *     **FileWatcher**: Monitors camera directories for new uploads
         *     - running: Whether the watcher is active
         *     - camera_root: Directory being watched
         *     - pending_tasks: Files waiting for debounce completion
         *     - observer_type: Filesystem observer type (native/polling)
         *
         *     **BatchAggregator**: Groups detections into time-based batches
         *     - active_batches: Number of batches being aggregated
         *     - batches: Details of each active batch
         *     - batch_window_seconds: Configured window timeout
         *     - idle_timeout_seconds: Configured idle timeout
         *
         *     **DegradationManager**: Handles graceful degradation
         *     - mode: Current degradation mode (normal/degraded/minimal/offline)
         *     - is_degraded: Whether system is in any degraded state
         *     - services: Health status of registered services
         *     - available_features: Features available in current mode
         *
         *     Returns:
         *         PipelineStatusResponse with status of all pipeline services
         */
        get: operations["get_pipeline_status_api_system_pipeline_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/models": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Zoo Registry
         * @description Get the current status of all models in the Model Zoo.
         *
         *     Returns comprehensive information about all AI models available in the system,
         *     including their VRAM requirements, loading status, and configuration.
         *
         *     **VRAM Budget**: The Model Zoo has a dedicated VRAM budget of 1650 MB,
         *     separate from the RT-DETRv2 detector and Nemotron LLM allocations.
         *
         *     **Loading Strategy**: Models are loaded sequentially (one at a time) to
         *     prevent VRAM fragmentation and ensure stable operation.
         *
         *     **Model Categories**:
         *     - detection: Object detection models (YOLO variants)
         *     - recognition: Face and license plate recognition
         *     - ocr: Optical character recognition
         *     - embedding: Visual embedding models (CLIP)
         *     - depth-estimation: Depth estimation models
         *     - pose: Human pose estimation
         *
         *     Returns:
         *         ModelRegistryResponse with VRAM stats and all model statuses
         */
        get: operations["get_models_api_system_models_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/models/{model_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Status
         * @description Get detailed status information for a specific model.
         *
         *     Args:
         *         model_name: Unique identifier of the model (e.g., 'yolo11-license-plate')
         *
         *     Returns:
         *         ModelStatusResponse with detailed model information
         *
         *     Raises:
         *         HTTPException: 404 if model not found in registry
         */
        get: operations["get_model_api_system_models__model_name__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/model-zoo/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Zoo Status
         * @description Get status information for all Model Zoo models.
         *
         *     Returns status information for all 18 Model Zoo models, including:
         *     - Current status (loaded, unloaded, disabled)
         *     - VRAM usage when loaded
         *     - Last usage timestamp
         *     - Category grouping for UI display
         *
         *     This endpoint is optimized for the compact status card display
         *     in the AI Performance page.
         *
         *     Returns:
         *         ModelZooStatusResponse with all model statuses
         */
        get: operations["get_model_zoo_status_api_system_model_zoo_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/model-zoo/latency/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Zoo Latency History
         * @description Get latency history for a specific Model Zoo model.
         *
         *     Returns time-series latency data for the dropdown-controlled chart.
         *     Each bucket contains aggregated statistics (avg, p50, p95).
         *
         *     Args:
         *         model: Model name to get history for
         *         since: Number of minutes of history to return (default 60)
         *         bucket_seconds: Size of each time bucket in seconds (default 60)
         *
         *     Returns:
         *         ModelLatencyHistoryResponse with chronologically ordered snapshots
         *
         *     Raises:
         *         HTTPException: 404 if model not found in registry
         */
        get: operations["get_model_zoo_latency_history_api_system_model_zoo_latency_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/zones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Zones
         * @description List all zones for a camera with optional filtering.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         enabled: Optional filter for enabled/disabled zones
         *         db: Database session
         *
         *     Returns:
         *         ZoneListResponse containing list of zones and total count
         */
        get: operations["list_zones_api_cameras__camera_id__zones_get"];
        put?: never;
        /**
         * Create Zone
         * @description Create a new zone for a camera.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_data: Zone creation data
         *         db: Database session
         *
         *     Returns:
         *         Created zone object with generated ID
         */
        post: operations["create_zone_api_cameras__camera_id__zones_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/zones/{zone_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Zone
         * @description Get a specific zone by ID.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone
         *         db: Database session
         *
         *     Returns:
         *         Zone object
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        get: operations["get_zone_api_cameras__camera_id__zones__zone_id__get"];
        /**
         * Update Zone
         * @description Update an existing zone.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone to update
         *         zone_data: Zone update data (all fields optional)
         *         db: Database session
         *
         *     Returns:
         *         Updated zone object
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        put: operations["update_zone_api_cameras__camera_id__zones__zone_id__put"];
        post?: never;
        /**
         * Delete Zone
         * @description Delete a zone.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone to delete
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        delete: operations["delete_zone_api_cameras__camera_id__zones__zone_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Root
         * @description Health check endpoint.
         */
        get: operations["root__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health
         * @description Simple liveness health check endpoint (canonical liveness probe).
         *
         *     This endpoint indicates whether the process is running and able to
         *     respond to HTTP requests. It always returns 200 with status "alive"
         *     if the process is up.
         *
         *     This is the canonical liveness probe endpoint. Use this for:
         *     - Docker HEALTHCHECK liveness checks
         *     - Kubernetes liveness probes
         *     - Simple "is the server up?" monitoring
         *
         *     For detailed health information, use:
         *     - GET /api/system/health - Detailed health check with service status
         *     - GET /ready - Readiness probe (checks dependencies)
         *
         *     Returns:
         *         Simple status indicating the server is alive.
         */
        get: operations["health_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Ready
         * @description Simple readiness health check endpoint (canonical readiness probe).
         *
         *     This endpoint indicates whether the application is ready to receive
         *     traffic and process requests. It checks critical dependencies:
         *     - Database connectivity
         *     - Redis connectivity
         *     - Critical pipeline workers
         *
         *     This is the canonical readiness probe endpoint. Use this for:
         *     - Docker HEALTHCHECK readiness checks
         *     - Kubernetes readiness probes
         *     - Load balancer health checks
         *
         *     For detailed readiness information with service breakdown, use:
         *     - GET /api/system/health/ready - Full readiness response with details
         *
         *     Returns:
         *         Simple status indicating readiness. HTTP 200 if ready, 503 if not.
         */
        get: operations["ready_ready_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AlertRuleConditions
         * @description Schema for legacy alert rule conditions (backward compatibility).
         *
         *     New rules should use explicit fields on AlertRuleCreate/AlertRuleUpdate.
         *     This schema is kept for backward compatibility with existing rules.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "object_types": [
         *         "person",
         *         "vehicle"
         *       ],
         *       "risk_threshold": 70,
         *       "time_ranges": [
         *         {
         *           "end": "06:00",
         *           "start": "22:00"
         *         }
         *       ]
         *     }
         */
        AlertRuleConditions: {
            /**
             * Risk Threshold
             * @description Minimum risk score to trigger alert
             */
            risk_threshold?: number | null;
            /**
             * Object Types
             * @description Object types that trigger alerts (e.g., person, vehicle)
             */
            object_types?: string[] | null;
            /**
             * Camera Ids
             * @description Specific camera IDs that trigger alerts
             */
            camera_ids?: string[] | null;
            /**
             * Time Ranges
             * @description Time ranges when alerts are active (start/end in HH:MM format)
             */
            time_ranges?: {
                [key: string]: unknown;
            }[] | null;
        };
        /**
         * AlertRuleCreate
         * @description Schema for creating an alert rule.
         *
         *     All conditions use AND logic - all specified conditions must match for the rule to trigger.
         *     Leave a condition as null/empty to not filter on that criterion.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "channels": [
         *         "pushover",
         *         "webhook"
         *       ],
         *       "cooldown_seconds": 300,
         *       "dedup_key_template": "{camera_id}:{rule_id}",
         *       "description": "High-priority alert for person detection at night",
         *       "enabled": true,
         *       "min_confidence": 0.8,
         *       "name": "Night Intruder Alert",
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_threshold": 70,
         *       "schedule": {
         *         "days": [
         *           "monday",
         *           "tuesday",
         *           "wednesday",
         *           "thursday",
         *           "friday"
         *         ],
         *         "end_time": "06:00",
         *         "start_time": "22:00",
         *         "timezone": "America/New_York"
         *       },
         *       "severity": "critical"
         *     }
         */
        AlertRuleCreate: {
            /**
             * Name
             * @description Rule name
             */
            name: string;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             * @default true
             */
            enabled: boolean;
            /**
             * @description Severity level for triggered alerts
             * @default medium
             */
            severity: components["schemas"]["AlertSeverity"];
            /**
             * Risk Threshold
             * @description Alert when risk_score >= threshold
             */
            risk_threshold?: number | null;
            /**
             * Object Types
             * @description Object types to match (e.g., ['person', 'vehicle'])
             */
            object_types?: string[] | null;
            /**
             * Camera Ids
             * @description Camera IDs to apply rule to (empty = all cameras)
             */
            camera_ids?: string[] | null;
            /**
             * Zone Ids
             * @description Zone IDs to match (empty = any zone)
             */
            zone_ids?: string[] | null;
            /**
             * Min Confidence
             * @description Minimum detection confidence (0.0-1.0)
             */
            min_confidence?: number | null;
            /** @description Time-based conditions (null = always active) */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /** @description Legacy conditions (use explicit fields instead) */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Dedup Key Template
             * @description Template for dedup key. Variables: {camera_id}, {rule_id}, {object_type}
             * @default {camera_id}:{rule_id}
             */
            dedup_key_template: string;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             * @default 300
             */
            cooldown_seconds: number;
            /**
             * Channels
             * @description Notification channels for this rule
             */
            channels?: string[];
        };
        /**
         * AlertRuleListResponse
         * @description Schema for alert rule list response with pagination.
         * @example {
         *       "count": 1,
         *       "limit": 50,
         *       "offset": 0,
         *       "rules": [
         *         {
         *           "channels": [
         *             "pushover"
         *           ],
         *           "conditions": {
         *             "risk_threshold": 70
         *           },
         *           "cooldown_seconds": 300,
         *           "created_at": "2025-12-28T12:00:00Z",
         *           "enabled": true,
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "name": "High Risk Alert",
         *           "updated_at": "2025-12-28T12:00:00Z"
         *         }
         *       ]
         *     }
         */
        AlertRuleListResponse: {
            /**
             * Rules
             * @description List of alert rules
             */
            rules: components["schemas"]["AlertRuleResponse"][];
            /**
             * Count
             * @description Total number of rules
             */
            count: number;
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * AlertRuleResponse
         * @description Schema for alert rule response.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "channels": [
         *         "pushover",
         *         "webhook"
         *       ],
         *       "cooldown_seconds": 300,
         *       "created_at": "2025-12-28T12:00:00Z",
         *       "dedup_key_template": "{camera_id}:{rule_id}",
         *       "description": "High-priority alert for person detection at night",
         *       "enabled": true,
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "min_confidence": 0.8,
         *       "name": "Night Intruder Alert",
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_threshold": 70,
         *       "schedule": {
         *         "days": [
         *           "monday",
         *           "tuesday",
         *           "wednesday",
         *           "thursday",
         *           "friday"
         *         ],
         *         "end_time": "06:00",
         *         "start_time": "22:00",
         *         "timezone": "America/New_York"
         *       },
         *       "severity": "critical",
         *       "updated_at": "2025-12-28T12:00:00Z"
         *     }
         */
        AlertRuleResponse: {
            /**
             * Id
             * @description Alert rule UUID
             */
            id: string;
            /**
             * Name
             * @description Rule name
             */
            name: string;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             */
            enabled: boolean;
            /** @description Severity level */
            severity: components["schemas"]["AlertSeverity"];
            /**
             * Risk Threshold
             * @description Risk score threshold
             */
            risk_threshold?: number | null;
            /**
             * Object Types
             * @description Object types to match
             */
            object_types?: string[] | null;
            /**
             * Camera Ids
             * @description Camera IDs to apply to
             */
            camera_ids?: string[] | null;
            /**
             * Zone Ids
             * @description Zone IDs to match
             */
            zone_ids?: string[] | null;
            /**
             * Min Confidence
             * @description Minimum confidence
             */
            min_confidence?: number | null;
            /** @description Time-based conditions */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /** @description Legacy conditions */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Dedup Key Template
             * @description Template for dedup key
             */
            dedup_key_template: string;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             */
            cooldown_seconds: number;
            /**
             * Channels
             * @description Notification channels
             */
            channels?: string[];
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             * @description Last update timestamp
             */
            updated_at: string;
        };
        /**
         * AlertRuleSchedule
         * @description Schema for alert rule schedule (time-based conditions).
         *
         *     If start_time > end_time, the schedule spans midnight (e.g., 22:00-06:00).
         *     Empty days array means all days. No schedule = always active (vacation mode).
         * @example {
         *       "days": [
         *         "monday",
         *         "tuesday",
         *         "wednesday",
         *         "thursday",
         *         "friday"
         *       ],
         *       "end_time": "06:00",
         *       "start_time": "22:00",
         *       "timezone": "America/New_York"
         *     }
         */
        AlertRuleSchedule: {
            /**
             * Days
             * @description Days of week when rule is active (empty = all days). Values: monday, tuesday, wednesday, thursday, friday, saturday, sunday
             */
            days?: string[] | null;
            /**
             * Start Time
             * @description Start time in HH:MM format
             */
            start_time?: string | null;
            /**
             * End Time
             * @description End time in HH:MM format
             */
            end_time?: string | null;
            /**
             * Timezone
             * @description Timezone for time evaluation
             * @default UTC
             */
            timezone: string;
        };
        /**
         * AlertRuleUpdate
         * @description Schema for updating an alert rule (PATCH).
         *
         *     Only provided fields will be updated. Null values clear the field.
         * @example {
         *       "cooldown_seconds": 600,
         *       "enabled": false,
         *       "risk_threshold": 80
         *     }
         */
        AlertRuleUpdate: {
            /**
             * Name
             * @description Rule name
             */
            name?: string | null;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             */
            enabled?: boolean | null;
            /** @description Severity level */
            severity?: components["schemas"]["AlertSeverity"] | null;
            /**
             * Risk Threshold
             * @description Alert when risk_score >= threshold
             */
            risk_threshold?: number | null;
            /**
             * Object Types
             * @description Object types to match
             */
            object_types?: string[] | null;
            /**
             * Camera Ids
             * @description Camera IDs to apply rule to
             */
            camera_ids?: string[] | null;
            /**
             * Zone Ids
             * @description Zone IDs to match
             */
            zone_ids?: string[] | null;
            /**
             * Min Confidence
             * @description Minimum detection confidence
             */
            min_confidence?: number | null;
            /** @description Time-based conditions */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /** @description Legacy conditions */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Dedup Key Template
             * @description Template for dedup key
             */
            dedup_key_template?: string | null;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             */
            cooldown_seconds?: number | null;
            /**
             * Channels
             * @description Notification channels for this rule
             */
            channels?: string[] | null;
        };
        /**
         * AlertSeverity
         * @description Alert severity levels.
         * @enum {string}
         */
        AlertSeverity: "low" | "medium" | "high" | "critical";
        /**
         * AnomalyEvent
         * @description A single anomaly event detected for a camera.
         * @example {
         *       "anomaly_score": 0.95,
         *       "detection_class": "vehicle",
         *       "expected_frequency": 0.1,
         *       "observed_frequency": 5,
         *       "reason": "Vehicle detected at 2:30 AM when rarely seen at this hour",
         *       "timestamp": "2026-01-03T02:30:00Z"
         *     }
         */
        AnomalyEvent: {
            /**
             * Timestamp
             * Format: date-time
             * @description When the anomaly was detected
             */
            timestamp: string;
            /**
             * Detection Class
             * @description Object class that triggered the anomaly
             */
            detection_class: string;
            /**
             * Anomaly Score
             * @description Anomaly score (0.0-1.0, higher is more anomalous)
             */
            anomaly_score: number;
            /**
             * Expected Frequency
             * @description Expected frequency for this class at this time
             */
            expected_frequency: number;
            /**
             * Observed Frequency
             * @description Observed frequency that triggered the anomaly
             */
            observed_frequency: number;
            /**
             * Reason
             * @description Human-readable explanation of why this is anomalous
             */
            reason: string;
        };
        /**
         * AnomalyListResponse
         * @description Response schema for camera anomaly list endpoint.
         * @example {
         *       "anomalies": [
         *         {
         *           "anomaly_score": 0.95,
         *           "detection_class": "vehicle",
         *           "expected_frequency": 0.1,
         *           "observed_frequency": 5,
         *           "reason": "Vehicle detected at 2:30 AM when rarely seen",
         *           "timestamp": "2026-01-03T02:30:00Z"
         *         }
         *       ],
         *       "camera_id": "front_door",
         *       "count": 1,
         *       "period_days": 7
         *     }
         */
        AnomalyListResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Anomalies
             * @description List of recent anomaly events
             */
            anomalies?: components["schemas"]["AnomalyEvent"][];
            /**
             * Count
             * @description Total number of anomalies returned
             */
            count: number;
            /**
             * Period Days
             * @description Number of days covered by this query
             */
            period_days: number;
        };
        /**
         * AuditLogListResponse
         * @description Schema for paginated audit log response.
         */
        AuditLogListResponse: {
            /**
             * Logs
             * @description List of audit log entries
             */
            logs: components["schemas"]["AuditLogResponse"][];
            /**
             * Count
             * @description Total count matching filters
             */
            count: number;
            /**
             * Limit
             * @description Page size
             */
            limit: number;
            /**
             * Offset
             * @description Page offset
             */
            offset: number;
        };
        /**
         * AuditLogResponse
         * @description Schema for a single audit log entry.
         */
        AuditLogResponse: {
            /**
             * Id
             * @description Audit log entry ID
             */
            id: number;
            /**
             * Timestamp
             * Format: date-time
             * @description When the action occurred
             */
            timestamp: string;
            /**
             * Action
             * @description The action performed
             */
            action: string;
            /**
             * Resource Type
             * @description Type of resource (event, alert, rule, camera, settings)
             */
            resource_type: string;
            /**
             * Resource Id
             * @description ID of the specific resource
             */
            resource_id?: string | null;
            /**
             * Actor
             * @description User or system that performed the action
             */
            actor: string;
            /**
             * Ip Address
             * @description IP address of the client
             */
            ip_address?: string | null;
            /**
             * User Agent
             * @description User agent string of the client
             */
            user_agent?: string | null;
            /**
             * Details
             * @description Action-specific details
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * Status
             * @description Status of the action (success/failure)
             */
            status: string;
        };
        /**
         * AuditLogStats
         * @description Schema for audit log statistics.
         */
        AuditLogStats: {
            /**
             * Total Logs
             * @description Total number of audit logs
             */
            total_logs: number;
            /**
             * Logs Today
             * @description Number of logs today
             */
            logs_today: number;
            /**
             * By Action
             * @description Counts by action type
             */
            by_action: {
                [key: string]: number;
            };
            /**
             * By Resource Type
             * @description Counts by resource type
             */
            by_resource_type: {
                [key: string]: number;
            };
            /**
             * By Status
             * @description Counts by status
             */
            by_status: {
                [key: string]: number;
            };
            /**
             * Recent Actors
             * @description Recently active actors
             */
            recent_actors: string[];
        };
        /**
         * AuditStatsResponse
         * @description Aggregate audit statistics.
         */
        AuditStatsResponse: {
            /** Total Events */
            total_events: number;
            /** Audited Events */
            audited_events: number;
            /** Fully Evaluated Events */
            fully_evaluated_events: number;
            /** Avg Quality Score */
            avg_quality_score: number | null;
            /** Avg Consistency Rate */
            avg_consistency_rate: number | null;
            /** Avg Enrichment Utilization */
            avg_enrichment_utilization: number | null;
            /** Model Contribution Rates */
            model_contribution_rates: {
                [key: string]: number;
            };
            /** Audits By Day */
            audits_by_day: {
                [key: string]: unknown;
            }[];
        };
        /**
         * BaselineSummaryResponse
         * @description Response schema for camera baseline summary endpoint.
         *
         *     Provides comprehensive baseline data for a camera including:
         *     - Hourly activity patterns (0-23 hours)
         *     - Daily patterns (by day of week)
         *     - Object-specific baselines
         *     - Current deviation from baseline
         * @example {
         *       "baseline_established": "2026-01-01T00:00:00Z",
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "current_deviation": {
         *         "contributing_factors": [
         *           "person_count_elevated"
         *         ],
         *         "interpretation": "slightly_above_normal",
         *         "score": 1.8
         *       },
         *       "daily_patterns": {
         *         "monday": {
         *           "avg_detections": 45,
         *           "peak_hour": 17,
         *           "total_samples": 24
         *         }
         *       },
         *       "data_points": 720,
         *       "hourly_patterns": {
         *         "0": {
         *           "avg_detections": 0.5,
         *           "sample_count": 30,
         *           "std_dev": 0.3
         *         },
         *         "17": {
         *           "avg_detections": 5.2,
         *           "sample_count": 30,
         *           "std_dev": 1.1
         *         }
         *       },
         *       "object_baselines": {
         *         "person": {
         *           "avg_hourly": 2.3,
         *           "peak_hour": 17,
         *           "total_detections": 550
         *         }
         *       }
         *     }
         */
        BaselineSummaryResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name: string;
            /**
             * Baseline Established
             * @description When baseline data collection started (null if no data)
             */
            baseline_established?: string | null;
            /**
             * Data Points
             * @description Total number of data points in baseline
             */
            data_points: number;
            /**
             * Hourly Patterns
             * @description Activity patterns by hour (0-23)
             */
            hourly_patterns?: {
                [key: string]: components["schemas"]["HourlyPattern"];
            };
            /**
             * Daily Patterns
             * @description Activity patterns by day of week (monday-sunday)
             */
            daily_patterns?: {
                [key: string]: components["schemas"]["DailyPattern"];
            };
            /**
             * Object Baselines
             * @description Baseline statistics by object type
             */
            object_baselines?: {
                [key: string]: components["schemas"]["ObjectBaseline"];
            };
            /** @description Current deviation from baseline (null if insufficient data) */
            current_deviation?: components["schemas"]["CurrentDeviation"] | null;
        };
        /**
         * BatchAggregatorStatusResponse
         * @description Status information for the BatchAggregator service.
         * @example {
         *       "active_batches": 2,
         *       "batch_window_seconds": 90,
         *       "batches": [
         *         {
         *           "age_seconds": 45.5,
         *           "batch_id": "abc123",
         *           "camera_id": "front_door",
         *           "detection_count": 5,
         *           "last_activity_seconds": 10.2,
         *           "started_at": 1735500000
         *         }
         *       ],
         *       "idle_timeout_seconds": 30
         *     }
         */
        BatchAggregatorStatusResponse: {
            /**
             * Active Batches
             * @description Number of active batches being aggregated
             */
            active_batches: number;
            /**
             * Batches
             * @description Details of active batches
             */
            batches?: components["schemas"]["BatchInfoResponse"][];
            /**
             * Batch Window Seconds
             * @description Configured batch window timeout in seconds
             */
            batch_window_seconds: number;
            /**
             * Idle Timeout Seconds
             * @description Configured idle timeout in seconds
             */
            idle_timeout_seconds: number;
        };
        /**
         * BatchAuditRequest
         * @description Request for batch audit processing.
         */
        BatchAuditRequest: {
            /**
             * Limit
             * @default 100
             */
            limit: number;
            /** Min Risk Score */
            min_risk_score?: number | null;
            /**
             * Force Reevaluate
             * @default false
             */
            force_reevaluate: boolean;
        };
        /**
         * BatchAuditResponse
         * @description Response for batch audit request.
         */
        BatchAuditResponse: {
            /** Queued Count */
            queued_count: number;
            /** Message */
            message: string;
        };
        /**
         * BatchInfoResponse
         * @description Information about an active batch.
         */
        BatchInfoResponse: {
            /**
             * Batch Id
             * @description Unique batch identifier
             */
            batch_id: string;
            /**
             * Camera Id
             * @description Camera ID this batch belongs to
             */
            camera_id: string;
            /**
             * Detection Count
             * @description Number of detections in this batch
             */
            detection_count: number;
            /**
             * Started At
             * @description Batch start time (Unix timestamp)
             */
            started_at: number;
            /**
             * Age Seconds
             * @description Time since batch started in seconds
             */
            age_seconds: number;
            /**
             * Last Activity Seconds
             * @description Time since last activity in seconds
             */
            last_activity_seconds: number;
        };
        /**
         * CameraCreate
         * @description Schema for creating a new camera.
         * @example {
         *       "folder_path": "/export/foscam/front_door",
         *       "name": "Front Door Camera",
         *       "status": "online"
         *     }
         */
        CameraCreate: {
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path: string;
            /**
             * @description Camera status (online, offline, error, unknown)
             * @default online
             */
            status: components["schemas"]["CameraStatus"];
        };
        /**
         * CameraListResponse
         * @description Schema for camera list response.
         * @example {
         *       "cameras": [
         *         {
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "folder_path": "/export/foscam/front_door",
         *           "id": "123e4567-e89b-12d3-a456-426614174000",
         *           "last_seen_at": "2025-12-23T12:00:00Z",
         *           "name": "Front Door Camera",
         *           "status": "online"
         *         }
         *       ],
         *       "count": 1
         *     }
         */
        CameraListResponse: {
            /**
             * Cameras
             * @description List of cameras
             */
            cameras: components["schemas"]["CameraResponse"][];
            /**
             * Count
             * @description Total number of cameras
             */
            count: number;
        };
        /**
         * CameraResponse
         * @description Schema for camera response.
         * @example {
         *       "created_at": "2025-12-23T10:00:00Z",
         *       "folder_path": "/export/foscam/front_door",
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "last_seen_at": "2025-12-23T12:00:00Z",
         *       "name": "Front Door Camera",
         *       "status": "online"
         *     }
         */
        CameraResponse: {
            /**
             * Id
             * @description Camera UUID
             */
            id: string;
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path: string;
            /** @description Camera status (online, offline, error, unknown) */
            status: components["schemas"]["CameraStatus"];
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when camera was created
             */
            created_at: string;
            /**
             * Last Seen At
             * @description Last time camera was active
             */
            last_seen_at?: string | null;
        };
        /**
         * CameraStatus
         * @description Camera status values.
         *
         *     Indicates the operational state of a camera:
         *     - ONLINE: Camera is active and receiving images
         *     - OFFLINE: Camera is not currently active (e.g., disconnected)
         *     - ERROR: Camera is experiencing an error condition
         *     - UNKNOWN: Camera status cannot be determined
         * @enum {string}
         */
        CameraStatus: "online" | "offline" | "error" | "unknown";
        /**
         * CameraUpdate
         * @description Schema for updating an existing camera.
         * @example {
         *       "name": "Front Door Camera - Updated",
         *       "status": "offline"
         *     }
         */
        CameraUpdate: {
            /**
             * Name
             * @description Camera name
             */
            name?: string | null;
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path?: string | null;
            /** @description Camera status (online, offline, error, unknown) */
            status?: components["schemas"]["CameraStatus"] | null;
        };
        /**
         * CircuitBreakerConfigResponse
         * @description Configuration for a circuit breaker.
         */
        CircuitBreakerConfigResponse: {
            /**
             * Failure Threshold
             * @description Number of failures before opening circuit
             */
            failure_threshold: number;
            /**
             * Recovery Timeout
             * @description Seconds to wait before transitioning to half-open
             */
            recovery_timeout: number;
            /**
             * Half Open Max Calls
             * @description Maximum calls allowed in half-open state
             */
            half_open_max_calls: number;
            /**
             * Success Threshold
             * @description Successes needed in half-open to close circuit
             */
            success_threshold: number;
        };
        /**
         * CircuitBreakerResetResponse
         * @description Response for circuit breaker reset operation.
         */
        CircuitBreakerResetResponse: {
            /**
             * Name
             * @description Name of the circuit breaker that was reset
             */
            name: string;
            /** @description State before reset */
            previous_state: components["schemas"]["CircuitBreakerStateEnum"];
            /** @description State after reset (should be closed) */
            new_state: components["schemas"]["CircuitBreakerStateEnum"];
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
        };
        /**
         * CircuitBreakerStateEnum
         * @description Circuit breaker states.
         * @enum {string}
         */
        CircuitBreakerStateEnum: "closed" | "open" | "half_open";
        /**
         * CircuitBreakerStatusResponse
         * @description Status of a single circuit breaker.
         * @example {
         *       "config": {
         *         "failure_threshold": 5,
         *         "half_open_max_calls": 3,
         *         "recovery_timeout": 30,
         *         "success_threshold": 2
         *       },
         *       "failure_count": 0,
         *       "name": "ai_service",
         *       "rejected_calls": 0,
         *       "state": "closed",
         *       "success_count": 0,
         *       "total_calls": 150
         *     }
         */
        CircuitBreakerStatusResponse: {
            /**
             * Name
             * @description Circuit breaker name
             */
            name: string;
            /** @description Current circuit state: closed (normal), open (failing), half_open (testing) */
            state: components["schemas"]["CircuitBreakerStateEnum"];
            /**
             * Failure Count
             * @description Current consecutive failure count
             */
            failure_count: number;
            /**
             * Success Count
             * @description Current consecutive success count (relevant in half-open)
             */
            success_count: number;
            /**
             * Total Calls
             * @description Total calls attempted through this circuit
             */
            total_calls: number;
            /**
             * Rejected Calls
             * @description Calls rejected due to open circuit
             */
            rejected_calls: number;
            /**
             * Last Failure Time
             * @description Monotonic time of last failure (seconds)
             */
            last_failure_time?: number | null;
            /**
             * Opened At
             * @description Monotonic time when circuit opened (seconds)
             */
            opened_at?: number | null;
            /** @description Circuit breaker configuration */
            config: components["schemas"]["CircuitBreakerConfigResponse"];
        };
        /**
         * CircuitBreakersResponse
         * @description Response schema for circuit breakers status endpoint.
         * @example {
         *       "circuit_breakers": {
         *         "rtdetr": {
         *           "config": {
         *             "failure_threshold": 5,
         *             "half_open_max_calls": 3,
         *             "recovery_timeout": 30,
         *             "success_threshold": 2
         *           },
         *           "failure_count": 0,
         *           "name": "rtdetr",
         *           "rejected_calls": 0,
         *           "state": "closed",
         *           "success_count": 0,
         *           "total_calls": 100
         *         }
         *       },
         *       "open_count": 0,
         *       "timestamp": "2025-12-30T10:30:00Z",
         *       "total_count": 2
         *     }
         */
        CircuitBreakersResponse: {
            /**
             * Circuit Breakers
             * @description Status of all circuit breakers keyed by name
             */
            circuit_breakers: {
                [key: string]: components["schemas"]["CircuitBreakerStatusResponse"];
            };
            /**
             * Total Count
             * @description Total number of circuit breakers
             */
            total_count: number;
            /**
             * Open Count
             * @description Number of circuit breakers currently open
             */
            open_count: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * CleanupResponse
         * @description Response schema for data cleanup endpoint.
         *
         *     Returns statistics about the cleanup operation including counts of
         *     deleted records and files. When dry_run is True, the counts represent
         *     what would be deleted without actually deleting.
         * @example {
         *       "detections_deleted": 89,
         *       "dry_run": false,
         *       "events_deleted": 15,
         *       "gpu_stats_deleted": 2880,
         *       "images_deleted": 0,
         *       "logs_deleted": 150,
         *       "retention_days": 30,
         *       "space_reclaimed": 524288000,
         *       "thumbnails_deleted": 89,
         *       "timestamp": "2025-12-27T10:30:00Z"
         *     }
         */
        CleanupResponse: {
            /**
             * Events Deleted
             * @description Number of events deleted (or would be deleted in dry run)
             */
            events_deleted: number;
            /**
             * Detections Deleted
             * @description Number of detections deleted (or would be deleted in dry run)
             */
            detections_deleted: number;
            /**
             * Gpu Stats Deleted
             * @description Number of GPU stat records deleted (or would be deleted in dry run)
             */
            gpu_stats_deleted: number;
            /**
             * Logs Deleted
             * @description Number of log records deleted (or would be deleted in dry run)
             */
            logs_deleted: number;
            /**
             * Thumbnails Deleted
             * @description Number of thumbnail files deleted (or would be deleted in dry run)
             */
            thumbnails_deleted: number;
            /**
             * Images Deleted
             * @description Number of original image files deleted (or would be deleted in dry run)
             */
            images_deleted: number;
            /**
             * Space Reclaimed
             * @description Estimated disk space freed in bytes (or would be freed in dry run)
             */
            space_reclaimed: number;
            /**
             * Retention Days
             * @description Retention period used for cleanup
             */
            retention_days: number;
            /**
             * Dry Run
             * @description Whether this was a dry run (no actual deletion performed)
             * @default false
             */
            dry_run: boolean;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of cleanup operation
             */
            timestamp: string;
        };
        /**
         * CleanupStatusResponse
         * @description Response schema for cleanup service status endpoint.
         * @example {
         *       "cleanup_time": "03:00",
         *       "delete_images": false,
         *       "next_cleanup": "2025-12-31T03:00:00Z",
         *       "retention_days": 30,
         *       "running": true,
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        CleanupStatusResponse: {
            /**
             * Running
             * @description Whether the cleanup service is currently running
             */
            running: boolean;
            /**
             * Retention Days
             * @description Current retention period in days
             */
            retention_days: number;
            /**
             * Cleanup Time
             * @description Scheduled daily cleanup time in HH:MM format
             */
            cleanup_time: string;
            /**
             * Delete Images
             * @description Whether original images are deleted during cleanup
             */
            delete_images: boolean;
            /**
             * Next Cleanup
             * @description ISO timestamp of next scheduled cleanup (null if not running)
             */
            next_cleanup?: string | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * ClearDataRequest
         * @description Request schema for clearing data - requires confirmation.
         */
        ClearDataRequest: {
            /**
             * Confirm
             * @description Must be exactly 'DELETE_ALL_DATA' to confirm deletion
             */
            confirm: string;
        };
        /**
         * ClearDataResponse
         * @description Response schema for clear data endpoint.
         */
        ClearDataResponse: {
            /** Cameras Cleared */
            cameras_cleared: number;
            /** Events Cleared */
            events_cleared: number;
            /** Detections Cleared */
            detections_cleared: number;
        };
        /**
         * ClipGenerateRequest
         * @description Schema for clip generation request (POST /api/events/{event_id}/clip/generate).
         * @example {
         *       "end_offset_seconds": 30,
         *       "force": false,
         *       "start_offset_seconds": -15
         *     }
         */
        ClipGenerateRequest: {
            /**
             * Start Offset Seconds
             * @description Seconds before event start to include (negative value, max -300)
             * @default -15
             */
            start_offset_seconds: number;
            /**
             * End Offset Seconds
             * @description Seconds after event end to include (max 300)
             * @default 30
             */
            end_offset_seconds: number;
            /**
             * Force
             * @description Force regeneration even if clip already exists
             * @default false
             */
            force: boolean;
        };
        /**
         * ClipGenerateResponse
         * @description Schema for clip generation response.
         * @example {
         *       "clip_url": "/api/media/clips/123_clip.mp4",
         *       "event_id": 123,
         *       "generated_at": "2026-01-03T10:30:00Z",
         *       "message": "Clip generated successfully",
         *       "status": "completed"
         *     }
         */
        ClipGenerateResponse: {
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /** @description Status of clip generation */
            status: components["schemas"]["ClipStatus"];
            /**
             * Clip Url
             * @description URL to access the clip (if completed)
             */
            clip_url?: string | null;
            /**
             * Generated At
             * @description Timestamp when the clip was generated
             */
            generated_at?: string | null;
            /**
             * Message
             * @description Status message or error details
             */
            message?: string | null;
        };
        /**
         * ClipInfoResponse
         * @description Schema for clip info response (GET /api/events/{event_id}/clip).
         * @example {
         *       "clip_available": true,
         *       "clip_url": "/api/media/clips/123_clip.mp4",
         *       "duration_seconds": 30,
         *       "event_id": 123,
         *       "file_size_bytes": 5242880,
         *       "generated_at": "2026-01-03T10:30:00Z"
         *     }
         */
        ClipInfoResponse: {
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Clip Available
             * @description Whether a clip is available for this event
             */
            clip_available: boolean;
            /**
             * Clip Url
             * @description URL to access the clip (if available)
             */
            clip_url?: string | null;
            /**
             * Duration Seconds
             * @description Duration of the clip in seconds
             */
            duration_seconds?: number | null;
            /**
             * Generated At
             * @description Timestamp when the clip was generated
             */
            generated_at?: string | null;
            /**
             * File Size Bytes
             * @description File size of the clip in bytes
             */
            file_size_bytes?: number | null;
        };
        /**
         * ClipStatus
         * @description Status of clip generation.
         * @enum {string}
         */
        ClipStatus: "pending" | "completed" | "failed";
        /**
         * ClothingEnrichment
         * @description Clothing classification and segmentation results.
         * @example {
         *       "has_bag": true,
         *       "has_face_covered": false,
         *       "is_service_uniform": false,
         *       "is_suspicious": false,
         *       "lower": "blue jeans",
         *       "upper": "red t-shirt"
         *     }
         */
        ClothingEnrichment: {
            /**
             * Upper
             * @description Upper body clothing description
             */
            upper?: string | null;
            /**
             * Lower
             * @description Lower body clothing description
             */
            lower?: string | null;
            /**
             * Is Suspicious
             * @description Whether clothing is flagged as suspicious
             */
            is_suspicious?: boolean | null;
            /**
             * Is Service Uniform
             * @description Whether wearing service uniform
             */
            is_service_uniform?: boolean | null;
            /**
             * Has Face Covered
             * @description Whether face is covered (hat/sunglasses/mask)
             */
            has_face_covered?: boolean | null;
            /**
             * Has Bag
             * @description Whether person is carrying a bag
             */
            has_bag?: boolean | null;
            /**
             * Clothing Items
             * @description List of detected clothing items
             */
            clothing_items?: string[] | null;
        };
        /**
         * ConfigResponse
         * @description Response schema for configuration endpoint.
         *
         *     Only includes public, non-sensitive configuration values.
         * @example {
         *       "app_name": "Home Security Intelligence",
         *       "batch_idle_timeout_seconds": 30,
         *       "batch_window_seconds": 90,
         *       "detection_confidence_threshold": 0.5,
         *       "grafana_url": "http://localhost:3002",
         *       "retention_days": 30,
         *       "version": "0.1.0"
         *     }
         */
        ConfigResponse: {
            /**
             * App Name
             * @description Application name
             */
            app_name: string;
            /**
             * Version
             * @description Application version
             */
            version: string;
            /**
             * Retention Days
             * @description Number of days to retain events and detections
             */
            retention_days: number;
            /**
             * Batch Window Seconds
             * @description Time window for batch processing detections
             */
            batch_window_seconds: number;
            /**
             * Batch Idle Timeout Seconds
             * @description Idle timeout before processing incomplete batch
             */
            batch_idle_timeout_seconds: number;
            /**
             * Detection Confidence Threshold
             * @description Minimum confidence threshold for detections (0.0-1.0)
             */
            detection_confidence_threshold: number;
            /**
             * Grafana Url
             * @description Grafana dashboard URL for frontend link
             */
            grafana_url: string;
        };
        /**
         * ConfigUpdateRequest
         * @description Request schema for PATCH /api/system/config.
         *
         *     Only supports a subset of processing-related settings.
         */
        ConfigUpdateRequest: {
            /**
             * Retention Days
             * @description Number of days to retain events and detections
             */
            retention_days?: number | null;
            /**
             * Batch Window Seconds
             * @description Time window for batch processing detections
             */
            batch_window_seconds?: number | null;
            /**
             * Batch Idle Timeout Seconds
             * @description Idle timeout before processing incomplete batch
             */
            batch_idle_timeout_seconds?: number | null;
            /**
             * Detection Confidence Threshold
             * @description Minimum confidence threshold for detections (0.0-1.0)
             */
            detection_confidence_threshold?: number | null;
        };
        /**
         * CurrentDeviation
         * @description Current activity deviation from established baseline.
         * @example {
         *       "contributing_factors": [
         *         "person_count_elevated",
         *         "unusual_hour"
         *       ],
         *       "interpretation": "slightly_above_normal",
         *       "score": 1.8
         *     }
         */
        CurrentDeviation: {
            /**
             * Score
             * @description Deviation score (standard deviations from mean, can be negative)
             */
            score: number;
            /** @description Human-readable interpretation of the deviation */
            interpretation: components["schemas"]["DeviationInterpretation"];
            /**
             * Contributing Factors
             * @description Factors contributing to current deviation
             */
            contributing_factors?: string[];
        };
        /**
         * DLQClearResponse
         * @description Response schema for clearing a DLQ.
         * @example {
         *       "message": "Cleared 5 jobs from dlq:detection_queue",
         *       "queue_name": "dlq:detection_queue",
         *       "success": true
         *     }
         */
        DLQClearResponse: {
            /**
             * Success
             * @description Whether the clear operation succeeded
             */
            success: boolean;
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Queue Name
             * @description Name of the cleared queue
             */
            queue_name: string;
        };
        /**
         * DLQJobResponse
         * @description Response schema for a single job in the dead-letter queue.
         * @example {
         *       "attempt_count": 3,
         *       "error": "Connection refused: detector service unavailable",
         *       "first_failed_at": "2025-12-23T10:30:05.000000",
         *       "last_failed_at": "2025-12-23T10:30:15.000000",
         *       "original_job": {
         *         "camera_id": "front_door",
         *         "file_path": "/export/foscam/front_door/image_001.jpg",
         *         "timestamp": "2025-12-23T10:30:00.000000"
         *       },
         *       "queue_name": "detection_queue"
         *     }
         */
        DLQJobResponse: {
            /**
             * Original Job
             * @description Original job payload that failed
             */
            original_job: {
                [key: string]: unknown;
            };
            /**
             * Error
             * @description Error message from the last failure attempt
             */
            error: string;
            /**
             * Attempt Count
             * @description Number of processing attempts made
             */
            attempt_count: number;
            /**
             * First Failed At
             * @description ISO timestamp of the first failure
             */
            first_failed_at: string;
            /**
             * Last Failed At
             * @description ISO timestamp of the last failure
             */
            last_failed_at: string;
            /**
             * Queue Name
             * @description Name of the original queue where the job came from
             */
            queue_name: string;
        };
        /**
         * DLQJobsResponse
         * @description Response schema for listing jobs in a DLQ.
         * @example {
         *       "count": 1,
         *       "jobs": [
         *         {
         *           "attempt_count": 3,
         *           "error": "Connection refused",
         *           "first_failed_at": "2025-12-23T10:30:05.000000",
         *           "last_failed_at": "2025-12-23T10:30:15.000000",
         *           "original_job": {
         *             "camera_id": "front_door",
         *             "file_path": "/export/foscam/front_door/image_001.jpg",
         *             "timestamp": "2025-12-23T10:30:00.000000"
         *           },
         *           "queue_name": "detection_queue"
         *         }
         *       ],
         *       "queue_name": "dlq:detection_queue"
         *     }
         */
        DLQJobsResponse: {
            /**
             * Queue Name
             * @description Name of the dead-letter queue
             */
            queue_name: string;
            /**
             * Jobs
             * @description List of jobs in the queue
             */
            jobs: components["schemas"]["DLQJobResponse"][];
            /**
             * Count
             * @description Number of jobs returned
             */
            count: number;
        };
        /**
         * DLQName
         * @description Available dead-letter queue names.
         * @enum {string}
         */
        DLQName: "dlq:detection_queue" | "dlq:analysis_queue";
        /**
         * DLQRequeueResponse
         * @description Response schema for requeuing a job from DLQ.
         * @example {
         *       "job": {
         *         "camera_id": "front_door",
         *         "file_path": "/export/foscam/front_door/image_001.jpg",
         *         "timestamp": "2025-12-23T10:30:00.000000"
         *       },
         *       "message": "Job requeued from dlq:detection_queue to detection_queue",
         *       "success": true
         *     }
         */
        DLQRequeueResponse: {
            /**
             * Success
             * @description Whether the requeue operation succeeded
             */
            success: boolean;
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Job
             * @description The requeued job data (if successful)
             */
            job?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * DLQStatsResponse
         * @description Response schema for DLQ statistics.
         * @example {
         *       "analysis_queue_count": 1,
         *       "detection_queue_count": 2,
         *       "total_count": 3
         *     }
         */
        DLQStatsResponse: {
            /**
             * Detection Queue Count
             * @description Number of jobs in the detection DLQ
             */
            detection_queue_count: number;
            /**
             * Analysis Queue Count
             * @description Number of jobs in the analysis DLQ
             */
            analysis_queue_count: number;
            /**
             * Total Count
             * @description Total number of jobs across all DLQs
             */
            total_count: number;
        };
        /**
         * DailyPattern
         * @description Activity pattern for a specific day of the week.
         * @example {
         *       "avg_detections": 45,
         *       "peak_hour": 17,
         *       "total_samples": 168
         *     }
         */
        DailyPattern: {
            /**
             * Avg Detections
             * @description Average number of detections for this day
             */
            avg_detections: number;
            /**
             * Peak Hour
             * @description Hour with most activity (0-23)
             */
            peak_hour: number;
            /**
             * Total Samples
             * @description Total samples for this day
             */
            total_samples: number;
        };
        /**
         * DegradationModeEnum
         * @description System degradation modes.
         * @enum {string}
         */
        DegradationModeEnum: "normal" | "degraded" | "minimal" | "offline";
        /**
         * DegradationStatusResponse
         * @description Status information for the DegradationManager service.
         * @example {
         *       "available_features": [
         *         "detection",
         *         "analysis",
         *         "events",
         *         "media"
         *       ],
         *       "fallback_queues": {},
         *       "is_degraded": false,
         *       "memory_queue_size": 0,
         *       "mode": "normal",
         *       "redis_healthy": true,
         *       "services": [
         *         {
         *           "consecutive_failures": 0,
         *           "last_check": 1735500000,
         *           "name": "rtdetr",
         *           "status": "healthy"
         *         }
         *       ]
         *     }
         */
        DegradationStatusResponse: {
            /** @description Current degradation mode */
            mode: components["schemas"]["DegradationModeEnum"];
            /**
             * Is Degraded
             * @description Whether system is in any degraded state
             */
            is_degraded: boolean;
            /**
             * Redis Healthy
             * @description Whether Redis is healthy
             */
            redis_healthy: boolean;
            /**
             * Memory Queue Size
             * @description Number of jobs in in-memory fallback queue
             */
            memory_queue_size: number;
            /**
             * Fallback Queues
             * @description Count of items in disk-based fallback queues by name
             */
            fallback_queues?: {
                [key: string]: number;
            };
            /**
             * Services
             * @description Health status of registered services
             */
            services?: components["schemas"]["ServiceHealthStatusResponse"][];
            /**
             * Available Features
             * @description Features available in current degradation mode
             */
            available_features?: string[];
        };
        /**
         * DepthEnrichment
         * @description Depth estimation results (placeholder for future Depth Anything V2).
         * @example {
         *       "confidence": 0.78,
         *       "estimated_distance_m": 4.2
         *     }
         */
        DepthEnrichment: {
            /**
             * Estimated Distance M
             * @description Estimated distance in meters
             */
            estimated_distance_m?: number | null;
            /**
             * Confidence
             * @description Estimation confidence
             */
            confidence?: number | null;
        };
        /**
         * DetectionListResponse
         * @description Schema for detection list response with pagination.
         * @example {
         *       "count": 1,
         *       "detections": [
         *         {
         *           "bbox_height": 400,
         *           "bbox_width": 200,
         *           "bbox_x": 100,
         *           "bbox_y": 150,
         *           "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *           "confidence": 0.95,
         *           "detected_at": "2025-12-23T12:00:00Z",
         *           "file_path": "/export/foscam/front_door/20251223_120000.jpg",
         *           "file_type": "image/jpeg",
         *           "id": 1,
         *           "object_type": "person",
         *           "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
         *         }
         *       ],
         *       "limit": 50,
         *       "offset": 0
         *     }
         */
        DetectionListResponse: {
            /**
             * Detections
             * @description List of detections
             */
            detections: components["schemas"]["DetectionResponse"][];
            /**
             * Count
             * @description Total number of detections matching filters
             */
            count: number;
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * DetectionResponse
         * @description Schema for detection response.
         * @example {
         *       "bbox_height": 400,
         *       "bbox_width": 200,
         *       "bbox_x": 100,
         *       "bbox_y": 150,
         *       "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *       "confidence": 0.95,
         *       "detected_at": "2025-12-23T12:00:00Z",
         *       "enrichment_data": {
         *         "person": {
         *           "action": "walking",
         *           "carrying": "backpack",
         *           "clothing": "dark jacket",
         *           "confidence": 0.95
         *         },
         *         "vehicle": {
         *           "color": "blue",
         *           "confidence": 0.92,
         *           "damage": [],
         *           "type": "sedan"
         *         }
         *       },
         *       "file_path": "/export/foscam/front_door/20251223_120000.jpg",
         *       "file_type": "image/jpeg",
         *       "id": 1,
         *       "media_type": "image",
         *       "object_type": "person",
         *       "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
         *     }
         */
        DetectionResponse: {
            /**
             * Id
             * @description Detection ID
             */
            id: number;
            /**
             * Camera Id
             * @description Camera UUID
             */
            camera_id: string;
            /**
             * File Path
             * @description Path to source image or video file
             */
            file_path: string;
            /**
             * File Type
             * @description MIME type of source file
             */
            file_type?: string | null;
            /**
             * Detected At
             * Format: date-time
             * @description Timestamp when detection was made
             */
            detected_at: string;
            /**
             * Object Type
             * @description Type of detected object (person, car, etc.)
             */
            object_type?: string | null;
            /**
             * Confidence
             * @description Detection confidence score (0-1)
             */
            confidence?: number | null;
            /**
             * Bbox X
             * @description Bounding box X coordinate
             */
            bbox_x?: number | null;
            /**
             * Bbox Y
             * @description Bounding box Y coordinate
             */
            bbox_y?: number | null;
            /**
             * Bbox Width
             * @description Bounding box width
             */
            bbox_width?: number | null;
            /**
             * Bbox Height
             * @description Bounding box height
             */
            bbox_height?: number | null;
            /**
             * Thumbnail Path
             * @description Path to thumbnail image with bbox overlay
             */
            thumbnail_path?: string | null;
            /**
             * Media Type
             * @description Media type: 'image' or 'video'
             * @default image
             */
            media_type: string | null;
            /**
             * Duration
             * @description Video duration in seconds (video only)
             */
            duration?: number | null;
            /**
             * Video Codec
             * @description Video codec (e.g., h264, hevc)
             */
            video_codec?: string | null;
            /**
             * Video Width
             * @description Video resolution width
             */
            video_width?: number | null;
            /**
             * Video Height
             * @description Video resolution height
             */
            video_height?: number | null;
            /**
             * Enrichment Data
             * @description AI enrichment data including vehicle classification, pet identification, person attributes, license plates, weather, and image quality scores
             */
            enrichment_data?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * DeviationInterpretation
         * @description Interpretation of current deviation from baseline.
         * @enum {string}
         */
        DeviationInterpretation: "far_below_normal" | "below_normal" | "normal" | "slightly_above_normal" | "above_normal" | "far_above_normal";
        /**
         * EnrichmentResponse
         * @description Structured enrichment data for a single detection.
         *
         *     Contains results from all vision models run during the enrichment pipeline.
         * @example {
         *       "clothing": {
         *         "lower": "blue jeans",
         *         "upper": "red t-shirt"
         *       },
         *       "detection_id": 12345,
         *       "enriched_at": "2026-01-03T10:30:00Z",
         *       "errors": [],
         *       "face": {
         *         "confidence": 0.88,
         *         "count": 1,
         *         "detected": true
         *       },
         *       "image_quality": {
         *         "is_blurry": false,
         *         "score": 0.85
         *       },
         *       "license_plate": {
         *         "confidence": 0.92,
         *         "detected": true,
         *         "text": "ABC-1234"
         *       },
         *       "processing_time_ms": 125.5,
         *       "vehicle": {
         *         "color": "silver",
         *         "confidence": 0.91,
         *         "type": "sedan"
         *       },
         *       "violence": {
         *         "detected": false,
         *         "score": 0.12
         *       },
         *       "weather": {
         *         "condition": "clear",
         *         "confidence": 0.95
         *       }
         *     }
         */
        EnrichmentResponse: {
            /**
             * Detection Id
             * @description Detection ID
             */
            detection_id: number;
            /**
             * Enriched At
             * @description Timestamp when enrichment was performed
             */
            enriched_at?: string | null;
            /**
             * License Plate
             * @description License plate detection results
             */
            license_plate?: components["schemas"]["LicensePlateEnrichment"] | {
                [key: string]: unknown;
            };
            /**
             * Face
             * @description Face detection results
             */
            face?: components["schemas"]["FaceEnrichment"] | {
                [key: string]: unknown;
            };
            /**
             * Vehicle
             * @description Vehicle classification results
             */
            vehicle?: components["schemas"]["VehicleEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Clothing
             * @description Clothing analysis results
             */
            clothing?: components["schemas"]["ClothingEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Violence
             * @description Violence detection results
             */
            violence?: components["schemas"]["ViolenceEnrichment"] | {
                [key: string]: unknown;
            };
            /**
             * Weather
             * @description Weather classification results
             */
            weather?: components["schemas"]["WeatherEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Pose
             * @description Pose estimation results
             */
            pose?: components["schemas"]["PoseEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Depth
             * @description Depth estimation results
             */
            depth?: components["schemas"]["DepthEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Image Quality
             * @description Image quality assessment
             */
            image_quality?: components["schemas"]["ImageQualityEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Pet
             * @description Pet classification results
             */
            pet?: components["schemas"]["PetEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Processing Time Ms
             * @description Enrichment processing time in milliseconds
             */
            processing_time_ms?: number | null;
            /**
             * Errors
             * @description Errors encountered during enrichment
             */
            errors?: string[];
        };
        /**
         * EntityAppearance
         * @description Schema for a single entity appearance at a specific time and camera.
         *
         *     Represents one sighting of an entity, including the detection it came from
         *     and additional attributes extracted from the image.
         * @example {
         *       "attributes": {
         *         "carrying": "backpack",
         *         "clothing": "blue jacket"
         *       },
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "detection_id": "det_abc123",
         *       "similarity_score": 0.92,
         *       "thumbnail_url": "/api/detections/123/image",
         *       "timestamp": "2025-12-23T14:30:00Z"
         *     }
         */
        EntityAppearance: {
            /**
             * Detection Id
             * @description Detection ID from original detection
             */
            detection_id: string;
            /**
             * Camera Id
             * @description Camera ID where entity was seen
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name?: string | null;
            /**
             * Timestamp
             * Format: date-time
             * @description When the entity was detected
             */
            timestamp: string;
            /**
             * Thumbnail Url
             * @description URL to thumbnail image of this appearance
             */
            thumbnail_url?: string | null;
            /**
             * Similarity Score
             * @description Similarity score to the entity's reference embedding
             */
            similarity_score?: number | null;
            /**
             * Attributes
             * @description Additional attributes extracted from the detection (clothing, carrying, etc.)
             */
            attributes?: {
                [key: string]: unknown;
            };
        };
        /**
         * EntityDetail
         * @description Schema for detailed entity information including appearance history.
         *
         *     Extends EntitySummary with the full list of appearances.
         * @example {
         *       "appearance_count": 3,
         *       "appearances": [
         *         {
         *           "attributes": {
         *             "clothing": "blue jacket"
         *           },
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_id": "det_001",
         *           "similarity_score": 1,
         *           "thumbnail_url": "/api/detections/1/image",
         *           "timestamp": "2025-12-23T10:00:00Z"
         *         },
         *         {
         *           "attributes": {
         *             "carrying": "bag",
         *             "clothing": "blue jacket"
         *           },
         *           "camera_id": "backyard",
         *           "camera_name": "Backyard",
         *           "detection_id": "det_002",
         *           "similarity_score": 0.94,
         *           "thumbnail_url": "/api/detections/2/image",
         *           "timestamp": "2025-12-23T12:15:00Z"
         *         }
         *       ],
         *       "cameras_seen": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "entity_type": "person",
         *       "first_seen": "2025-12-23T10:00:00Z",
         *       "id": "entity_abc123",
         *       "last_seen": "2025-12-23T14:30:00Z",
         *       "thumbnail_url": "/api/detections/123/image"
         *     }
         */
        EntityDetail: {
            /**
             * Id
             * @description Unique entity identifier
             */
            id: string;
            /**
             * Entity Type
             * @description Type of entity: 'person' or 'vehicle'
             */
            entity_type: string;
            /**
             * First Seen
             * Format: date-time
             * @description Timestamp of first appearance
             */
            first_seen: string;
            /**
             * Last Seen
             * Format: date-time
             * @description Timestamp of most recent appearance
             */
            last_seen: string;
            /**
             * Appearance Count
             * @description Total number of appearances
             */
            appearance_count: number;
            /**
             * Cameras Seen
             * @description List of camera IDs where entity was detected
             */
            cameras_seen?: string[];
            /**
             * Thumbnail Url
             * @description URL to the most recent thumbnail image
             */
            thumbnail_url?: string | null;
            /**
             * Appearances
             * @description List of all appearances for this entity
             */
            appearances?: components["schemas"]["EntityAppearance"][];
        };
        /**
         * EntityHistoryResponse
         * @description Schema for entity appearance history response.
         * @example {
         *       "appearances": [
         *         {
         *           "attributes": {},
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_id": "det_001",
         *           "similarity_score": 1,
         *           "thumbnail_url": "/api/detections/1/image",
         *           "timestamp": "2025-12-23T10:00:00Z"
         *         }
         *       ],
         *       "count": 1,
         *       "entity_id": "entity_abc123",
         *       "entity_type": "person"
         *     }
         */
        EntityHistoryResponse: {
            /**
             * Entity Id
             * @description Entity identifier
             */
            entity_id: string;
            /**
             * Entity Type
             * @description Type of entity
             */
            entity_type: string;
            /**
             * Appearances
             * @description List of appearances in chronological order
             */
            appearances: components["schemas"]["EntityAppearance"][];
            /**
             * Count
             * @description Total number of appearances
             */
            count: number;
        };
        /**
         * EntityListResponse
         * @description Schema for paginated entity list response.
         * @example {
         *       "count": 1,
         *       "entities": [
         *         {
         *           "appearance_count": 5,
         *           "cameras_seen": [
         *             "front_door",
         *             "backyard"
         *           ],
         *           "entity_type": "person",
         *           "first_seen": "2025-12-23T10:00:00Z",
         *           "id": "entity_abc123",
         *           "last_seen": "2025-12-23T14:30:00Z",
         *           "thumbnail_url": "/api/detections/123/image"
         *         }
         *       ],
         *       "limit": 50,
         *       "offset": 0
         *     }
         */
        EntityListResponse: {
            /**
             * Entities
             * @description List of tracked entities
             */
            entities: components["schemas"]["EntitySummary"][];
            /**
             * Count
             * @description Total number of entities matching filters
             */
            count: number;
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * EntitySummary
         * @description Schema for entity summary in list responses.
         *
         *     Provides an overview of a tracked entity without the full appearance history.
         * @example {
         *       "appearance_count": 5,
         *       "cameras_seen": [
         *         "front_door",
         *         "backyard",
         *         "driveway"
         *       ],
         *       "entity_type": "person",
         *       "first_seen": "2025-12-23T10:00:00Z",
         *       "id": "entity_abc123",
         *       "last_seen": "2025-12-23T14:30:00Z",
         *       "thumbnail_url": "/api/detections/123/image"
         *     }
         */
        EntitySummary: {
            /**
             * Id
             * @description Unique entity identifier
             */
            id: string;
            /**
             * Entity Type
             * @description Type of entity: 'person' or 'vehicle'
             */
            entity_type: string;
            /**
             * First Seen
             * Format: date-time
             * @description Timestamp of first appearance
             */
            first_seen: string;
            /**
             * Last Seen
             * Format: date-time
             * @description Timestamp of most recent appearance
             */
            last_seen: string;
            /**
             * Appearance Count
             * @description Total number of appearances
             */
            appearance_count: number;
            /**
             * Cameras Seen
             * @description List of camera IDs where entity was detected
             */
            cameras_seen?: string[];
            /**
             * Thumbnail Url
             * @description URL to the most recent thumbnail image
             */
            thumbnail_url?: string | null;
        };
        /**
         * EventAuditResponse
         * @description Full audit response for a single event.
         */
        EventAuditResponse: {
            /** Id */
            id: number;
            /** Event Id */
            event_id: number;
            /**
             * Audited At
             * Format: date-time
             */
            audited_at: string;
            /** Is Fully Evaluated */
            is_fully_evaluated: boolean;
            contributions: components["schemas"]["ModelContributions"];
            /** Prompt Length */
            prompt_length: number;
            /** Prompt Token Estimate */
            prompt_token_estimate: number;
            /** Enrichment Utilization */
            enrichment_utilization: number;
            scores: components["schemas"]["QualityScores"];
            /** Consistency Risk Score */
            consistency_risk_score?: number | null;
            /** Consistency Diff */
            consistency_diff?: number | null;
            /** Self Eval Critique */
            self_eval_critique?: string | null;
            improvements: components["schemas"]["PromptImprovements"];
        };
        /**
         * EventEnrichmentsResponse
         * @description Enrichment data for all detections in an event.
         * @example {
         *       "count": 2,
         *       "enrichments": [
         *         {
         *           "detection_id": 1,
         *           "enriched_at": "2026-01-03T10:30:00Z",
         *           "face": {
         *             "count": 0,
         *             "detected": false
         *           },
         *           "license_plate": {
         *             "detected": true,
         *             "text": "ABC-1234"
         *           },
         *           "violence": {
         *             "detected": false,
         *             "score": 0
         *           }
         *         },
         *         {
         *           "detection_id": 2,
         *           "enriched_at": "2026-01-03T10:30:05Z",
         *           "face": {
         *             "count": 1,
         *             "detected": true
         *           },
         *           "license_plate": {
         *             "detected": false
         *           },
         *           "violence": {
         *             "detected": false,
         *             "score": 0
         *           }
         *         }
         *       ],
         *       "event_id": 100
         *     }
         */
        EventEnrichmentsResponse: {
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Enrichments
             * @description Enrichment data per detection
             */
            enrichments: components["schemas"]["EnrichmentResponse"][];
            /**
             * Count
             * @description Number of detections with enrichment data
             */
            count: number;
        };
        /**
         * EventListResponse
         * @description Schema for event list response with pagination.
         * @example {
         *       "count": 1,
         *       "events": [
         *         {
         *           "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "llm_prompt": "<|im_start|>system\nYou are a home security risk analyzer...",
         *           "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Person detected near front entrance",
         *           "thumbnail_url": "/api/media/detections/1"
         *         }
         *       ],
         *       "limit": 50,
         *       "offset": 0
         *     }
         */
        EventListResponse: {
            /**
             * Events
             * @description List of events
             */
            events: components["schemas"]["EventResponse"][];
            /**
             * Count
             * @description Total number of events matching filters
             */
            count: number;
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * EventResponse
         * @description Schema for event response.
         * @example {
         *       "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *       "detection_count": 5,
         *       "detection_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "ended_at": "2025-12-23T12:02:30Z",
         *       "id": 1,
         *       "llm_prompt": "<|im_start|>system\nYou are a home security risk analyzer...",
         *       "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
         *       "reviewed": false,
         *       "risk_level": "medium",
         *       "risk_score": 75,
         *       "started_at": "2025-12-23T12:00:00Z",
         *       "summary": "Person detected near front entrance",
         *       "thumbnail_url": "/api/media/detections/1"
         *     }
         */
        EventResponse: {
            /**
             * Id
             * @description Event ID
             */
            id: number;
            /**
             * Camera Id
             * @description Camera UUID
             */
            camera_id: string;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score?: number | null;
            /**
             * Risk Level
             * @description Risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Summary
             * @description LLM-generated event summary
             */
            summary?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning for risk score
             */
            reasoning?: string | null;
            /**
             * Llm Prompt
             * @description Full prompt sent to Nemotron LLM (for debugging/improvement)
             */
            llm_prompt?: string | null;
            /**
             * Reviewed
             * @description Whether event has been reviewed
             * @default false
             */
            reviewed: boolean;
            /**
             * Notes
             * @description User notes for the event
             */
            notes?: string | null;
            /**
             * Detection Count
             * @description Number of detections in this event
             * @default 0
             */
            detection_count: number;
            /**
             * Detection Ids
             * @description List of detection IDs associated with this event
             */
            detection_ids?: number[];
            /**
             * Thumbnail Url
             * @description URL to thumbnail image (first detection's media)
             */
            thumbnail_url?: string | null;
        };
        /**
         * EventStatsResponse
         * @description Schema for aggregated event statistics.
         * @example {
         *       "events_by_camera": [
         *         {
         *           "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *           "camera_name": "Front Door",
         *           "event_count": 30
         *         },
         *         {
         *           "camera_id": "456e7890-e89b-12d3-a456-426614174001",
         *           "camera_name": "Back Door",
         *           "event_count": 14
         *         }
         *       ],
         *       "events_by_risk_level": {
         *         "critical": 2,
         *         "high": 5,
         *         "low": 25,
         *         "medium": 12
         *       },
         *       "total_events": 44
         *     }
         */
        EventStatsResponse: {
            /**
             * Total Events
             * @description Total number of events
             */
            total_events: number;
            /** @description Events grouped by risk level */
            events_by_risk_level: components["schemas"]["EventsByRiskLevel"];
            /**
             * Events By Camera
             * @description Events grouped by camera
             */
            events_by_camera: components["schemas"]["EventsByCamera"][];
        };
        /**
         * EventUpdate
         * @description Schema for updating an event (PATCH).
         * @example {
         *       "notes": "Verified - delivery person",
         *       "reviewed": true
         *     }
         */
        EventUpdate: {
            /**
             * Reviewed
             * @description Mark event as reviewed or not reviewed
             */
            reviewed?: boolean | null;
            /**
             * Notes
             * @description User notes for the event
             */
            notes?: string | null;
        };
        /**
         * EventsByCamera
         * @description Schema for events count by camera.
         * @example {
         *       "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *       "camera_name": "Front Door",
         *       "event_count": 15
         *     }
         */
        EventsByCamera: {
            /**
             * Camera Id
             * @description Camera UUID
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera name
             */
            camera_name: string;
            /**
             * Event Count
             * @description Number of events for this camera
             */
            event_count: number;
        };
        /**
         * EventsByRiskLevel
         * @description Schema for events count by risk level.
         * @example {
         *       "critical": 2,
         *       "high": 5,
         *       "low": 25,
         *       "medium": 12
         *     }
         */
        EventsByRiskLevel: {
            /**
             * Critical
             * @description Number of critical risk events
             * @default 0
             */
            critical: number;
            /**
             * High
             * @description Number of high risk events
             * @default 0
             */
            high: number;
            /**
             * Medium
             * @description Number of medium risk events
             * @default 0
             */
            medium: number;
            /**
             * Low
             * @description Number of low risk events
             * @default 0
             */
            low: number;
        };
        /**
         * FaceEnrichment
         * @description Face detection results.
         * @example {
         *       "confidence": 0.88,
         *       "count": 1,
         *       "detected": true
         *     }
         */
        FaceEnrichment: {
            /**
             * Detected
             * @description Whether faces were detected
             * @default false
             */
            detected: boolean;
            /**
             * Count
             * @description Number of faces detected
             * @default 0
             */
            count: number;
            /**
             * Confidence
             * @description Highest face confidence
             */
            confidence?: number | null;
        };
        /**
         * FileWatcherStatusResponse
         * @description Status information for the FileWatcher service.
         * @example {
         *       "camera_root": "/export/foscam",
         *       "observer_type": "native",
         *       "pending_tasks": 3,
         *       "running": true
         *     }
         */
        FileWatcherStatusResponse: {
            /**
             * Running
             * @description Whether the file watcher is currently running
             */
            running: boolean;
            /**
             * Camera Root
             * @description Root directory being watched for camera uploads
             */
            camera_root: string;
            /**
             * Pending Tasks
             * @description Number of files pending processing (debouncing)
             */
            pending_tasks: number;
            /**
             * Observer Type
             * @description Type of filesystem observer (native or polling)
             */
            observer_type: string;
        };
        /**
         * FrontendLogCreate
         * @description Schema for frontend log submission.
         */
        FrontendLogCreate: {
            /**
             * Level
             * @description Log level
             */
            level: string;
            /**
             * Component
             * @description Frontend component name
             */
            component: string;
            /**
             * Message
             * @description Log message
             */
            message: string;
            /**
             * Extra
             * @description Additional context
             */
            extra?: {
                [key: string]: unknown;
            } | null;
            /**
             * User Agent
             * @description Browser user agent
             */
            user_agent?: string | null;
            /**
             * Url
             * @description Page URL where log occurred
             */
            url?: string | null;
        };
        /**
         * GPUStatsHistoryResponse
         * @description Response schema for GPU stats history endpoint.
         */
        GPUStatsHistoryResponse: {
            /**
             * Samples
             * @description GPU stats samples (chronological order)
             */
            samples: components["schemas"]["GPUStatsSample"][];
            /**
             * Count
             * @description Number of samples returned
             */
            count: number;
            /**
             * Limit
             * @description Applied limit
             */
            limit: number;
        };
        /**
         * GPUStatsResponse
         * @description Response schema for GPU statistics endpoint.
         * @example {
         *       "gpu_name": "NVIDIA RTX A5500",
         *       "inference_fps": 30.5,
         *       "memory_total": 24000,
         *       "memory_used": 12000,
         *       "power_usage": 150,
         *       "temperature": 65,
         *       "utilization": 75.5
         *     }
         */
        GPUStatsResponse: {
            /**
             * Gpu Name
             * @description GPU device name (e.g., 'NVIDIA RTX A5500')
             */
            gpu_name?: string | null;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization?: number | null;
            /**
             * Memory Used
             * @description GPU memory used in MB
             */
            memory_used?: number | null;
            /**
             * Memory Total
             * @description Total GPU memory in MB
             */
            memory_total?: number | null;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature?: number | null;
            /**
             * Power Usage
             * @description GPU power usage in watts
             */
            power_usage?: number | null;
            /**
             * Inference Fps
             * @description Inference frames per second
             */
            inference_fps?: number | null;
        };
        /**
         * GPUStatsSample
         * @description Single time-series sample of GPU statistics.
         */
        GPUStatsSample: {
            /**
             * Recorded At
             * Format: date-time
             * @description When the GPU sample was recorded (UTC)
             */
            recorded_at: string;
            /**
             * Gpu Name
             * @description GPU device name
             */
            gpu_name?: string | null;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization?: number | null;
            /**
             * Memory Used
             * @description GPU memory used in MB
             */
            memory_used?: number | null;
            /**
             * Memory Total
             * @description Total GPU memory in MB
             */
            memory_total?: number | null;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature?: number | null;
            /**
             * Power Usage
             * @description GPU power usage in watts
             */
            power_usage?: number | null;
            /**
             * Inference Fps
             * @description Inference frames per second
             */
            inference_fps?: number | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * HealthResponse
         * @description Response schema for health check endpoint.
         * @example {
         *       "services": {
         *         "ai": {
         *           "message": "AI services operational",
         *           "status": "healthy"
         *         },
         *         "database": {
         *           "message": "Database operational",
         *           "status": "healthy"
         *         },
         *         "redis": {
         *           "details": {
         *             "redis_version": "7.0.0"
         *           },
         *           "message": "Redis connected",
         *           "status": "healthy"
         *         }
         *       },
         *       "status": "healthy",
         *       "timestamp": "2025-12-23T10:30:00"
         *     }
         */
        HealthResponse: {
            /**
             * Status
             * @description Overall system status: healthy, degraded, or unhealthy
             */
            status: string;
            /**
             * Services
             * @description Status of individual services (database, redis, ai)
             */
            services: {
                [key: string]: components["schemas"]["ServiceStatus"];
            };
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of health check
             */
            timestamp: string;
        };
        /**
         * HourlyPattern
         * @description Activity pattern for a specific hour.
         * @example {
         *       "avg_detections": 2.5,
         *       "sample_count": 30,
         *       "std_dev": 0.8
         *     }
         */
        HourlyPattern: {
            /**
             * Avg Detections
             * @description Average number of detections during this hour
             */
            avg_detections: number;
            /**
             * Std Dev
             * @description Standard deviation of detection count
             */
            std_dev: number;
            /**
             * Sample Count
             * @description Number of samples used for this calculation
             */
            sample_count: number;
        };
        /**
         * ImageQualityEnrichment
         * @description Image quality assessment results.
         * @example {
         *       "is_blurry": false,
         *       "is_low_quality": false,
         *       "quality_issues": [],
         *       "score": 0.85
         *     }
         */
        ImageQualityEnrichment: {
            /**
             * Score
             * @description Quality score (0-100)
             */
            score?: number | null;
            /**
             * Is Blurry
             * @description Whether image is blurry
             */
            is_blurry?: boolean | null;
            /**
             * Is Low Quality
             * @description Whether image has low quality
             */
            is_low_quality?: boolean | null;
            /**
             * Quality Issues
             * @description List of detected quality issues
             */
            quality_issues?: string[] | null;
            /**
             * Quality Change Detected
             * @description Whether sudden quality change was detected
             */
            quality_change_detected?: boolean | null;
        };
        /**
         * LatencyHistorySnapshot
         * @description Single time-bucket snapshot of pipeline latency metrics.
         */
        LatencyHistorySnapshot: {
            /**
             * Timestamp
             * @description Bucket start time (ISO format)
             */
            timestamp: string;
            /**
             * Stages
             * @description Latency stats for each pipeline stage (None if no samples)
             */
            stages: {
                [key: string]: components["schemas"]["LatencyHistoryStageStats"] | null;
            };
        };
        /**
         * LatencyHistoryStageStats
         * @description Latency statistics for a single stage in a history snapshot.
         */
        LatencyHistoryStageStats: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms: number;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency
             */
            p50_ms: number;
            /**
             * P95 Ms
             * @description 95th percentile latency
             */
            p95_ms: number;
            /**
             * P99 Ms
             * @description 99th percentile latency
             */
            p99_ms: number;
            /**
             * Sample Count
             * @description Number of samples in this bucket
             */
            sample_count: number;
        };
        /**
         * LeaderboardResponse
         * @description Model leaderboard response.
         */
        LeaderboardResponse: {
            /** Entries */
            entries: components["schemas"]["ModelLeaderboardEntry"][];
            /** Period Days */
            period_days: number;
        };
        /**
         * LicensePlateEnrichment
         * @description License plate detection and OCR results.
         * @example {
         *       "bbox": [
         *         100,
         *         200,
         *         300,
         *         250
         *       ],
         *       "confidence": 0.92,
         *       "detected": true,
         *       "ocr_confidence": 0.88,
         *       "text": "ABC-1234"
         *     }
         */
        LicensePlateEnrichment: {
            /**
             * Detected
             * @description Whether a license plate was detected
             * @default false
             */
            detected: boolean;
            /**
             * Confidence
             * @description Detection confidence
             */
            confidence?: number | null;
            /**
             * Text
             * @description OCR-extracted plate text
             */
            text?: string | null;
            /**
             * Ocr Confidence
             * @description OCR confidence
             */
            ocr_confidence?: number | null;
            /**
             * Bbox
             * @description Bounding box [x1, y1, x2, y2]
             */
            bbox?: number[] | null;
        };
        /**
         * LogEntry
         * @description Schema for a single log entry.
         */
        LogEntry: {
            /**
             * Id
             * @description Log entry ID
             */
            id: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Log timestamp
             */
            timestamp: string;
            /**
             * Level
             * @description Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
             */
            level: string;
            /**
             * Component
             * @description Component/module name
             */
            component: string;
            /**
             * Message
             * @description Log message
             */
            message: string;
            /**
             * Camera Id
             * @description Associated camera ID
             */
            camera_id?: string | null;
            /**
             * Event Id
             * @description Associated event ID
             */
            event_id?: number | null;
            /**
             * Request Id
             * @description Request correlation ID
             */
            request_id?: string | null;
            /**
             * Detection Id
             * @description Associated detection ID
             */
            detection_id?: number | null;
            /**
             * Duration Ms
             * @description Operation duration in milliseconds
             */
            duration_ms?: number | null;
            /**
             * Extra
             * @description Additional structured data
             */
            extra?: {
                [key: string]: unknown;
            } | null;
            /**
             * Source
             * @description Log source (backend, frontend)
             * @default backend
             */
            source: string;
        };
        /**
         * LogStats
         * @description Schema for log statistics (dashboard).
         */
        LogStats: {
            /**
             * Total Today
             * @description Total logs today
             */
            total_today: number;
            /**
             * Errors Today
             * @description Error count today
             */
            errors_today: number;
            /**
             * Warnings Today
             * @description Warning count today
             */
            warnings_today: number;
            /**
             * By Component
             * @description Counts by component
             */
            by_component: {
                [key: string]: number;
            };
            /**
             * By Level
             * @description Counts by level
             */
            by_level: {
                [key: string]: number;
            };
            /**
             * Top Component
             * @description Most active component
             */
            top_component?: string | null;
        };
        /**
         * LogsResponse
         * @description Schema for paginated logs response.
         */
        LogsResponse: {
            /**
             * Logs
             * @description List of log entries
             */
            logs: components["schemas"]["LogEntry"][];
            /**
             * Count
             * @description Total count matching filters
             */
            count: number;
            /**
             * Limit
             * @description Page size
             */
            limit: number;
            /**
             * Offset
             * @description Page offset
             */
            offset: number;
        };
        /**
         * MediaErrorResponse
         * @description Error response for media access failures.
         */
        MediaErrorResponse: {
            /**
             * Error
             * @description Error message describing what went wrong
             */
            error: string;
            /**
             * Path
             * @description The path that was attempted to be accessed
             */
            path: string;
        };
        /**
         * ModelContributions
         * @description Model contribution flags.
         */
        ModelContributions: {
            /**
             * Rtdetr
             * @description RT-DETR object detection
             * @default false
             */
            rtdetr: boolean;
            /**
             * Florence
             * @description Florence-2 vision attributes
             * @default false
             */
            florence: boolean;
            /**
             * Clip
             * @description CLIP embeddings
             * @default false
             */
            clip: boolean;
            /**
             * Violence
             * @description Violence detection
             * @default false
             */
            violence: boolean;
            /**
             * Clothing
             * @description Clothing analysis
             * @default false
             */
            clothing: boolean;
            /**
             * Vehicle
             * @description Vehicle classification
             * @default false
             */
            vehicle: boolean;
            /**
             * Pet
             * @description Pet classification
             * @default false
             */
            pet: boolean;
            /**
             * Weather
             * @description Weather classification
             * @default false
             */
            weather: boolean;
            /**
             * Image Quality
             * @description Image quality assessment
             * @default false
             */
            image_quality: boolean;
            /**
             * Zones
             * @description Zone analysis
             * @default false
             */
            zones: boolean;
            /**
             * Baseline
             * @description Baseline comparison
             * @default false
             */
            baseline: boolean;
            /**
             * Cross Camera
             * @description Cross-camera correlation
             * @default false
             */
            cross_camera: boolean;
        };
        /**
         * ModelLatencyHistoryResponse
         * @description Response schema for Model Zoo latency history endpoint.
         *
         *     Returns time-series latency data for a specific Model Zoo model.
         *     Used to populate the dropdown-controlled latency chart.
         * @example {
         *       "bucket_seconds": 60,
         *       "display_name": "YOLO11 License Plate",
         *       "has_data": true,
         *       "model_name": "yolo11-license-plate",
         *       "snapshots": [
         *         {
         *           "stats": {
         *             "avg_ms": 45,
         *             "p50_ms": 42,
         *             "p95_ms": 68,
         *             "sample_count": 15
         *           },
         *           "timestamp": "2026-01-04T10:00:00+00:00"
         *         }
         *       ],
         *       "timestamp": "2026-01-04T10:30:00Z",
         *       "window_minutes": 60
         *     }
         */
        ModelLatencyHistoryResponse: {
            /**
             * Model Name
             * @description Name of the model this data is for
             */
            model_name: string;
            /**
             * Display Name
             * @description Human-readable display name
             */
            display_name: string;
            /**
             * Snapshots
             * @description Chronologically ordered latency snapshots
             */
            snapshots: components["schemas"]["ModelLatencyHistorySnapshot"][];
            /**
             * Window Minutes
             * @description Time window covered by the history
             */
            window_minutes: number;
            /**
             * Bucket Seconds
             * @description Bucket size for aggregation
             */
            bucket_seconds: number;
            /**
             * Has Data
             * @description Whether any latency data exists for this model
             */
            has_data: boolean;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp when history was retrieved
             */
            timestamp: string;
        };
        /**
         * ModelLatencyHistorySnapshot
         * @description Single time-bucket snapshot of Model Zoo model latency.
         */
        ModelLatencyHistorySnapshot: {
            /**
             * Timestamp
             * @description Bucket start time (ISO format)
             */
            timestamp: string;
            /** @description Latency statistics for this time bucket (None if no data) */
            stats?: components["schemas"]["ModelLatencyStageStats"] | null;
        };
        /**
         * ModelLatencyStageStats
         * @description Latency statistics for a Model Zoo model at a point in time.
         */
        ModelLatencyStageStats: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms: number;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms: number;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms: number;
            /**
             * Sample Count
             * @description Number of samples in this time bucket
             */
            sample_count: number;
        };
        /**
         * ModelLeaderboardEntry
         * @description Single entry in model leaderboard.
         */
        ModelLeaderboardEntry: {
            /** Model Name */
            model_name: string;
            /** Contribution Rate */
            contribution_rate: number;
            /** Quality Correlation */
            quality_correlation: number | null;
            /** Event Count */
            event_count: number;
        };
        /**
         * ModelRegistryResponse
         * @description Response schema for model registry endpoint.
         *
         *     Returns comprehensive information about all models in the Model Zoo
         *     including VRAM budget, current usage, and individual model statuses.
         * @example {
         *       "loading_strategy": "sequential",
         *       "max_concurrent_models": 1,
         *       "models": [],
         *       "vram_available_mb": 1350,
         *       "vram_budget_mb": 1650,
         *       "vram_used_mb": 300
         *     }
         */
        ModelRegistryResponse: {
            /**
             * Vram Budget Mb
             * @description Total VRAM budget available for Model Zoo models (excludes Nemotron and RT-DETRv2)
             */
            vram_budget_mb: number;
            /**
             * Vram Used Mb
             * @description Currently used VRAM by loaded models
             */
            vram_used_mb: number;
            /**
             * Vram Available Mb
             * @description Available VRAM for loading additional models
             */
            vram_available_mb: number;
            /**
             * Models
             * @description List of all models in the registry with their status
             */
            models: components["schemas"]["ModelStatusResponse"][];
            /**
             * Loading Strategy
             * @description Model loading strategy (sequential = one at a time)
             * @default sequential
             */
            loading_strategy: string;
            /**
             * Max Concurrent Models
             * @description Maximum number of models that can be loaded concurrently
             * @default 1
             */
            max_concurrent_models: number;
        };
        /**
         * ModelStatusEnum
         * @description Model loading status.
         * @enum {string}
         */
        ModelStatusEnum: "loaded" | "unloaded" | "disabled" | "loading" | "error";
        /**
         * ModelStatusResponse
         * @description Status information for a single model in the Model Zoo.
         *
         *     Provides detailed information about a model including:
         *     - Identity: name, display_name, category
         *     - Configuration: vram_mb, enabled, available, path
         *     - Runtime status: status, load_count
         * @example {
         *       "available": false,
         *       "category": "detection",
         *       "display_name": "YOLO11 License Plate",
         *       "enabled": true,
         *       "load_count": 0,
         *       "name": "yolo11-license-plate",
         *       "path": "/models/model-zoo/yolo11-license-plate/license-plate-finetune-v1n.pt",
         *       "status": "unloaded",
         *       "vram_mb": 300
         *     }
         */
        ModelStatusResponse: {
            /**
             * Name
             * @description Unique identifier for the model (e.g., 'yolo11-license-plate')
             */
            name: string;
            /**
             * Display Name
             * @description Human-readable display name for the model
             */
            display_name: string;
            /**
             * Vram Mb
             * @description Estimated VRAM usage in megabytes when loaded
             */
            vram_mb: number;
            /** @description Current loading status: loaded, unloaded, disabled, loading, error */
            status: components["schemas"]["ModelStatusEnum"];
            /**
             * Category
             * @description Model category (detection, recognition, ocr, embedding, etc.)
             */
            category: string;
            /**
             * Enabled
             * @description Whether the model is enabled for use
             */
            enabled: boolean;
            /**
             * Available
             * @description Whether the model has been successfully loaded at least once
             */
            available: boolean;
            /**
             * Path
             * @description HuggingFace repo path or local file path for the model
             */
            path: string;
            /**
             * Load Count
             * @description Current reference count for loaded model (0 if not loaded)
             * @default 0
             */
            load_count: number;
        };
        /**
         * ModelZooStatusItem
         * @description Status information for a single Model Zoo model.
         *
         *     Used in the compact status card display for Model Zoo models.
         */
        ModelZooStatusItem: {
            /**
             * Name
             * @description Model identifier (e.g., 'yolo11-license-plate')
             */
            name: string;
            /**
             * Display Name
             * @description Human-readable display name
             */
            display_name: string;
            /**
             * Category
             * @description Model category (detection, classification, segmentation, etc.)
             */
            category: string;
            /** @description Current status: loaded (green), unloaded (gray), disabled (yellow) */
            status: components["schemas"]["ModelStatusEnum"];
            /**
             * Vram Mb
             * @description VRAM usage in megabytes when loaded
             */
            vram_mb: number;
            /**
             * Last Used At
             * @description Timestamp of last model usage (null if never used)
             */
            last_used_at?: string | null;
            /**
             * Enabled
             * @description Whether the model is enabled for use
             */
            enabled: boolean;
        };
        /**
         * ModelZooStatusResponse
         * @description Response schema for Model Zoo status endpoint.
         *
         *     Returns status information for all 18 Model Zoo models organized by category.
         *     Used to populate the compact status cards in the UI.
         * @example {
         *       "disabled_count": 3,
         *       "loaded_count": 0,
         *       "models": [
         *         {
         *           "category": "detection",
         *           "display_name": "YOLO11 License Plate",
         *           "enabled": true,
         *           "name": "yolo11-license-plate",
         *           "status": "unloaded",
         *           "vram_mb": 300
         *         }
         *       ],
         *       "timestamp": "2026-01-04T10:30:00Z",
         *       "total_models": 18,
         *       "vram_budget_mb": 1650,
         *       "vram_used_mb": 0
         *     }
         */
        ModelZooStatusResponse: {
            /**
             * Models
             * @description List of all Model Zoo models with their current status
             */
            models: components["schemas"]["ModelZooStatusItem"][];
            /**
             * Total Models
             * @description Total number of models in the registry
             */
            total_models: number;
            /**
             * Loaded Count
             * @description Number of currently loaded models
             */
            loaded_count: number;
            /**
             * Disabled Count
             * @description Number of disabled models
             */
            disabled_count: number;
            /**
             * Vram Budget Mb
             * @description Total VRAM budget for Model Zoo
             */
            vram_budget_mb: number;
            /**
             * Vram Used Mb
             * @description Currently used VRAM
             */
            vram_used_mb: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * NotificationChannel
         * @description Notification channel types.
         * @enum {string}
         */
        NotificationChannel: "email" | "webhook" | "push";
        /**
         * NotificationConfigResponse
         * @description Schema for notification configuration status.
         * @example {
         *       "available_channels": [
         *         "email",
         *         "webhook"
         *       ],
         *       "default_email_recipients": [
         *         "user@example.com"
         *       ],
         *       "default_webhook_url": "https://example.com/webhook",
         *       "email_configured": true,
         *       "notification_enabled": true,
         *       "push_configured": false,
         *       "smtp_from_address": "alerts@example.com",
         *       "smtp_host": "smtp.example.com",
         *       "smtp_port": 587,
         *       "smtp_use_tls": true,
         *       "webhook_configured": true,
         *       "webhook_timeout_seconds": 30
         *     }
         */
        NotificationConfigResponse: {
            /**
             * Notification Enabled
             * @description Whether notifications are enabled
             */
            notification_enabled: boolean;
            /**
             * Email Configured
             * @description Whether email (SMTP) is configured
             */
            email_configured: boolean;
            /**
             * Webhook Configured
             * @description Whether webhook is configured
             */
            webhook_configured: boolean;
            /**
             * Push Configured
             * @description Whether push notifications are configured
             */
            push_configured: boolean;
            /**
             * Available Channels
             * @description List of channels that are properly configured
             */
            available_channels: components["schemas"]["NotificationChannel"][];
            /**
             * Smtp Host
             * @description Configured SMTP host (if any)
             */
            smtp_host?: string | null;
            /**
             * Smtp Port
             * @description Configured SMTP port
             */
            smtp_port?: number | null;
            /**
             * Smtp From Address
             * @description Configured sender email
             */
            smtp_from_address?: string | null;
            /**
             * Smtp Use Tls
             * @description Whether TLS is enabled for SMTP
             */
            smtp_use_tls?: boolean | null;
            /**
             * Default Webhook Url
             * @description Default webhook URL
             */
            default_webhook_url?: string | null;
            /**
             * Webhook Timeout Seconds
             * @description Webhook request timeout
             */
            webhook_timeout_seconds?: number | null;
            /**
             * Default Email Recipients
             * @description Default email recipients
             */
            default_email_recipients?: string[];
        };
        /**
         * ObjectBaseline
         * @description Baseline statistics for a specific object class.
         * @example {
         *       "avg_hourly": 2.3,
         *       "peak_hour": 17,
         *       "total_detections": 550
         *     }
         */
        ObjectBaseline: {
            /**
             * Avg Hourly
             * @description Average hourly detection count for this object type
             */
            avg_hourly: number;
            /**
             * Peak Hour
             * @description Hour with most detections of this type (0-23)
             */
            peak_hour: number;
            /**
             * Total Detections
             * @description Total detections of this type in the baseline period
             */
            total_detections: number;
        };
        /**
         * PetEnrichment
         * @description Pet classification results for false positive reduction.
         * @example {
         *       "confidence": 0.94,
         *       "detected": true,
         *       "is_household_pet": true,
         *       "type": "dog"
         *     }
         */
        PetEnrichment: {
            /**
             * Detected
             * @description Whether a pet was detected
             * @default false
             */
            detected: boolean;
            /**
             * Type
             * @description Pet type (cat, dog)
             */
            type?: string | null;
            /**
             * Confidence
             * @description Classification confidence
             */
            confidence?: number | null;
            /**
             * Is Household Pet
             * @description Whether classified as household pet
             */
            is_household_pet?: boolean | null;
        };
        /**
         * PipelineLatencies
         * @description Latency statistics for all pipeline stages.
         *
         *     Pipeline stages:
         *     - watch: File watcher detecting new images (file event -> queue)
         *     - detect: RT-DETRv2 object detection (image -> detections)
         *     - batch: Batch aggregation window (detections -> batch)
         *     - analyze: Nemotron LLM risk analysis (batch -> event)
         * @example {
         *       "analyze": {
         *         "avg_ms": 5000,
         *         "max_ms": 15000,
         *         "min_ms": 2000,
         *         "p50_ms": 4500,
         *         "p95_ms": 12000,
         *         "p99_ms": 14000,
         *         "sample_count": 100
         *       },
         *       "batch": {
         *         "avg_ms": 30000,
         *         "max_ms": 90000,
         *         "min_ms": 5000,
         *         "p50_ms": 25000,
         *         "p95_ms": 80000,
         *         "p99_ms": 88000,
         *         "sample_count": 100
         *       },
         *       "detect": {
         *         "avg_ms": 200,
         *         "max_ms": 800,
         *         "min_ms": 100,
         *         "p50_ms": 180,
         *         "p95_ms": 600,
         *         "p99_ms": 750,
         *         "sample_count": 500
         *       },
         *       "watch": {
         *         "avg_ms": 10,
         *         "max_ms": 50,
         *         "min_ms": 5,
         *         "p50_ms": 8,
         *         "p95_ms": 40,
         *         "p99_ms": 48,
         *         "sample_count": 500
         *       }
         *     }
         */
        PipelineLatencies: {
            /** @description File watcher stage latency (file event to queue) */
            watch?: components["schemas"]["StageLatency"] | null;
            /** @description Object detection stage latency (RT-DETRv2 inference) */
            detect?: components["schemas"]["StageLatency"] | null;
            /** @description Batch aggregation window time */
            batch?: components["schemas"]["StageLatency"] | null;
            /** @description LLM analysis stage latency (Nemotron inference) */
            analyze?: components["schemas"]["StageLatency"] | null;
        };
        /**
         * PipelineLatencyHistoryResponse
         * @description Response schema for pipeline latency history endpoint.
         *
         *     Provides time-series latency data for charting and trend analysis.
         *     Each snapshot contains aggregated metrics for a time bucket.
         * @example {
         *       "bucket_seconds": 60,
         *       "snapshots": [
         *         {
         *           "stages": {
         *             "watch_to_detect": {
         *               "avg_ms": 50,
         *               "p50_ms": 45,
         *               "p95_ms": 120,
         *               "p99_ms": 150,
         *               "sample_count": 15
         *             }
         *           },
         *           "timestamp": "2025-12-28T10:00:00+00:00"
         *         }
         *       ],
         *       "timestamp": "2025-12-28T10:30:00Z",
         *       "window_minutes": 60
         *     }
         */
        PipelineLatencyHistoryResponse: {
            /**
             * Snapshots
             * @description Chronologically ordered latency snapshots
             */
            snapshots: components["schemas"]["LatencyHistorySnapshot"][];
            /**
             * Window Minutes
             * @description Time window covered by the history
             */
            window_minutes: number;
            /**
             * Bucket Seconds
             * @description Bucket size for aggregation
             */
            bucket_seconds: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp when history was retrieved
             */
            timestamp: string;
        };
        /**
         * PipelineLatencyResponse
         * @description Response schema for pipeline latency endpoint.
         *
         *     Provides latency metrics for each stage transition in the AI pipeline:
         *     - watch_to_detect: Time from file watcher detecting image to RT-DETR processing start
         *     - detect_to_batch: Time from detection completion to batch aggregation
         *     - batch_to_analyze: Time from batch completion to Nemotron analysis start
         *     - total_pipeline: Total end-to-end processing time
         * @example {
         *       "batch_to_analyze": {
         *         "avg_ms": 5000,
         *         "max_ms": 15000,
         *         "min_ms": 2000,
         *         "p50_ms": 4500,
         *         "p95_ms": 12000,
         *         "p99_ms": 14000,
         *         "sample_count": 100
         *       },
         *       "detect_to_batch": {
         *         "avg_ms": 100,
         *         "max_ms": 500,
         *         "min_ms": 20,
         *         "p50_ms": 80,
         *         "p95_ms": 400,
         *         "p99_ms": 480,
         *         "sample_count": 500
         *       },
         *       "timestamp": "2025-12-28T10:30:00Z",
         *       "total_pipeline": {
         *         "avg_ms": 35000,
         *         "max_ms": 120000,
         *         "min_ms": 10000,
         *         "p50_ms": 30000,
         *         "p95_ms": 100000,
         *         "p99_ms": 110000,
         *         "sample_count": 100
         *       },
         *       "watch_to_detect": {
         *         "avg_ms": 50,
         *         "max_ms": 200,
         *         "min_ms": 10,
         *         "p50_ms": 40,
         *         "p95_ms": 150,
         *         "p99_ms": 180,
         *         "sample_count": 500
         *       },
         *       "window_minutes": 60
         *     }
         */
        PipelineLatencyResponse: {
            /** @description Latency from file detection to RT-DETR processing */
            watch_to_detect?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Latency from detection to batch aggregation */
            detect_to_batch?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Latency from batch to Nemotron analysis */
            batch_to_analyze?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Total end-to-end pipeline latency */
            total_pipeline?: components["schemas"]["PipelineStageLatency"] | null;
            /**
             * Window Minutes
             * @description Time window used for calculating statistics
             */
            window_minutes: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of latency snapshot
             */
            timestamp: string;
        };
        /**
         * PipelineStageLatency
         * @description Latency statistics for a single pipeline transition stage.
         *
         *     Tracks time between pipeline stages:
         *     - watch_to_detect: File detection to RT-DETR processing
         *     - detect_to_batch: Detection to batch aggregation
         *     - batch_to_analyze: Batch to Nemotron analysis
         *     - total_pipeline: End-to-end latency
         * @example {
         *       "avg_ms": 150.5,
         *       "max_ms": 500,
         *       "min_ms": 50,
         *       "p50_ms": 120,
         *       "p95_ms": 400,
         *       "p99_ms": 480,
         *       "sample_count": 100
         *     }
         */
        PipelineStageLatency: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms?: number | null;
            /**
             * Min Ms
             * @description Minimum latency in milliseconds
             */
            min_ms?: number | null;
            /**
             * Max Ms
             * @description Maximum latency in milliseconds
             */
            max_ms?: number | null;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms?: number | null;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms?: number | null;
            /**
             * P99 Ms
             * @description 99th percentile latency in milliseconds
             */
            p99_ms?: number | null;
            /**
             * Sample Count
             * @description Number of samples used to calculate statistics
             */
            sample_count: number;
        };
        /**
         * PipelineStatusResponse
         * @description Combined status of all pipeline operations.
         *
         *     Provides visibility into:
         *     - FileWatcher: Monitoring camera directories for new uploads
         *     - BatchAggregator: Grouping detections into time-based batches
         *     - DegradationManager: Graceful degradation and service health
         * @example {
         *       "batch_aggregator": {
         *         "active_batches": 1,
         *         "batch_window_seconds": 90,
         *         "batches": [],
         *         "idle_timeout_seconds": 30
         *       },
         *       "degradation": {
         *         "available_features": [
         *           "detection",
         *           "analysis",
         *           "events",
         *           "media"
         *         ],
         *         "fallback_queues": {},
         *         "is_degraded": false,
         *         "memory_queue_size": 0,
         *         "mode": "normal",
         *         "redis_healthy": true,
         *         "services": []
         *       },
         *       "file_watcher": {
         *         "camera_root": "/export/foscam",
         *         "observer_type": "native",
         *         "pending_tasks": 0,
         *         "running": true
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        PipelineStatusResponse: {
            /** @description FileWatcher service status (null if not running) */
            file_watcher?: components["schemas"]["FileWatcherStatusResponse"] | null;
            /** @description BatchAggregator service status (null if not running) */
            batch_aggregator?: components["schemas"]["BatchAggregatorStatusResponse"] | null;
            /** @description DegradationManager service status (null if not initialized) */
            degradation?: components["schemas"]["DegradationStatusResponse"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * PoseEnrichment
         * @description Pose estimation results (placeholder for future ViTPose integration).
         * @example {
         *       "action": "walking",
         *       "confidence": 0.82,
         *       "keypoints": [
         *         [
         *           100,
         *           150,
         *           0.9
         *         ],
         *         [
         *           120,
         *           160,
         *           0.85
         *         ]
         *       ]
         *     }
         */
        PoseEnrichment: {
            /**
             * Keypoints
             * @description Body keypoints [[x, y, conf], ...]
             */
            keypoints?: number[][] | null;
            /**
             * Action
             * @description Recognized action (walking, running, etc.)
             */
            action?: string | null;
            /**
             * Confidence
             * @description Action confidence
             */
            confidence?: number | null;
        };
        /**
         * PromptImprovements
         * @description Prompt improvement suggestions from self-evaluation.
         */
        PromptImprovements: {
            /** Missing Context */
            missing_context?: string[];
            /** Confusing Sections */
            confusing_sections?: string[];
            /** Unused Data */
            unused_data?: string[];
            /** Format Suggestions */
            format_suggestions?: string[];
            /** Model Gaps */
            model_gaps?: string[];
        };
        /**
         * QualityScores
         * @description Self-evaluation quality scores (1-5 scale).
         */
        QualityScores: {
            /** Context Usage */
            context_usage?: number | null;
            /** Reasoning Coherence */
            reasoning_coherence?: number | null;
            /** Risk Justification */
            risk_justification?: number | null;
            /** Consistency */
            consistency?: number | null;
            /** Overall */
            overall?: number | null;
        };
        /**
         * QueueDepths
         * @description Queue depth information for pipeline queues.
         * @example {
         *       "analysis_queue": 2,
         *       "detection_queue": 5
         *     }
         */
        QueueDepths: {
            /**
             * Detection Queue
             * @description Number of items in detection queue waiting for RT-DETRv2 processing
             */
            detection_queue: number;
            /**
             * Analysis Queue
             * @description Number of batches in analysis queue waiting for Nemotron LLM analysis
             */
            analysis_queue: number;
        };
        /**
         * ReadinessResponse
         * @description Response schema for readiness probe endpoint.
         *
         *     Readiness probes indicate whether the application is ready to receive
         *     traffic and process requests. This checks all dependencies:
         *     - Database connectivity
         *     - Redis connectivity
         *     - AI services availability
         *     - Background worker status
         * @example {
         *       "ready": true,
         *       "services": {
         *         "ai": {
         *           "message": "AI services operational",
         *           "status": "healthy"
         *         },
         *         "database": {
         *           "message": "Database operational",
         *           "status": "healthy"
         *         },
         *         "redis": {
         *           "details": {
         *             "redis_version": "7.0.0"
         *           },
         *           "message": "Redis connected",
         *           "status": "healthy"
         *         }
         *       },
         *       "status": "ready",
         *       "timestamp": "2025-12-23T10:30:00",
         *       "workers": [
         *         {
         *           "name": "gpu_monitor",
         *           "running": true
         *         },
         *         {
         *           "name": "cleanup_service",
         *           "running": true
         *         }
         *       ]
         *     }
         */
        ReadinessResponse: {
            /**
             * Ready
             * @description Overall readiness status: True if system can process requests
             */
            ready: boolean;
            /**
             * Status
             * @description Status string: 'ready', 'degraded', or 'not_ready'
             */
            status: string;
            /**
             * Services
             * @description Status of infrastructure services (database, redis, ai)
             */
            services: {
                [key: string]: components["schemas"]["ServiceStatus"];
            };
            /**
             * Workers
             * @description Status of background workers
             */
            workers?: components["schemas"]["WorkerStatus"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of readiness check
             */
            timestamp: string;
        };
        /**
         * RecommendationItem
         * @description Single recommendation item.
         */
        RecommendationItem: {
            /** Category */
            category: string;
            /** Suggestion */
            suggestion: string;
            /** Frequency */
            frequency: number;
            /** Priority */
            priority: string;
        };
        /**
         * RecommendationsResponse
         * @description Aggregated recommendations response.
         */
        RecommendationsResponse: {
            /** Recommendations */
            recommendations: components["schemas"]["RecommendationItem"][];
            /** Total Events Analyzed */
            total_events_analyzed: number;
        };
        /**
         * RuleTestEventResult
         * @description Schema for a single event's test result.
         * @example {
         *       "camera_id": "front_door",
         *       "event_id": 123,
         *       "matched_conditions": [
         *         "risk_score >= 70",
         *         "object_type in ['person']"
         *       ],
         *       "matches": true,
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_score": 75,
         *       "started_at": "2025-12-28T22:15:00Z"
         *     }
         */
        RuleTestEventResult: {
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Risk Score
             * @description Event risk score
             */
            risk_score?: number | null;
            /**
             * Object Types
             * @description Detected object types
             */
            object_types?: string[];
            /**
             * Matches
             * @description Whether the rule matched this event
             */
            matches: boolean;
            /**
             * Matched Conditions
             * @description List of conditions that matched
             */
            matched_conditions?: string[];
            /**
             * Started At
             * @description Event start timestamp
             */
            started_at?: string | null;
        };
        /**
         * RuleTestRequest
         * @description Schema for testing a rule against historical events.
         * @example {
         *       "event_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "test_time": "2025-12-28T22:30:00Z"
         *     }
         */
        RuleTestRequest: {
            /**
             * Event Ids
             * @description Specific event IDs to test against. If not provided, tests against recent events.
             */
            event_ids?: number[] | null;
            /**
             * Limit
             * @description Maximum number of recent events to test (if event_ids not provided)
             * @default 10
             */
            limit: number;
            /**
             * Test Time
             * @description Override current time for schedule testing (ISO format)
             */
            test_time?: string | null;
        };
        /**
         * RuleTestResponse
         * @description Schema for rule test response.
         * @example {
         *       "events_matched": 3,
         *       "events_tested": 10,
         *       "match_rate": 0.3,
         *       "results": [
         *         {
         *           "camera_id": "front_door",
         *           "event_id": 123,
         *           "matched_conditions": [
         *             "risk_score >= 70",
         *             "object_type in ['person']"
         *           ],
         *           "matches": true,
         *           "object_types": [
         *             "person"
         *           ],
         *           "risk_score": 75,
         *           "started_at": "2025-12-28T22:15:00Z"
         *         }
         *       ],
         *       "rule_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "rule_name": "Night Intruder Alert"
         *     }
         */
        RuleTestResponse: {
            /**
             * Rule Id
             * @description Rule ID that was tested
             */
            rule_id: string;
            /**
             * Rule Name
             * @description Rule name
             */
            rule_name: string;
            /**
             * Events Tested
             * @description Number of events tested
             */
            events_tested: number;
            /**
             * Events Matched
             * @description Number of events that matched the rule
             */
            events_matched: number;
            /**
             * Match Rate
             * @description Proportion of events that matched (0.0-1.0)
             */
            match_rate: number;
            /**
             * Results
             * @description Per-event test results
             */
            results: components["schemas"]["RuleTestEventResult"][];
        };
        /**
         * SceneChangeAcknowledgeResponse
         * @description Response schema for acknowledging a scene change.
         *
         *     Confirms that a scene change has been acknowledged.
         * @example {
         *       "acknowledged": true,
         *       "acknowledged_at": "2026-01-03T11:00:00Z",
         *       "id": 1
         *     }
         */
        SceneChangeAcknowledgeResponse: {
            /**
             * Id
             * @description Scene change ID
             */
            id: number;
            /**
             * Acknowledged
             * @description Acknowledgement status (always True)
             * @default true
             */
            acknowledged: boolean;
            /**
             * Acknowledged At
             * Format: date-time
             * @description When the change was acknowledged
             */
            acknowledged_at: string;
        };
        /**
         * SceneChangeListResponse
         * @description Response schema for listing scene changes.
         *
         *     Returns a list of scene changes for a camera with total count.
         * @example {
         *       "camera_id": "front_door",
         *       "scene_changes": [
         *         {
         *           "acknowledged": false,
         *           "change_type": "view_blocked",
         *           "detected_at": "2026-01-03T10:30:00Z",
         *           "id": 1,
         *           "similarity_score": 0.23
         *         }
         *       ],
         *       "total_changes": 1
         *     }
         */
        SceneChangeListResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Scene Changes
             * @description List of scene changes
             */
            scene_changes?: components["schemas"]["SceneChangeResponse"][];
            /**
             * Total Changes
             * @description Total number of scene changes
             * @default 0
             */
            total_changes: number;
        };
        /**
         * SceneChangeResponse
         * @description Response schema for a single scene change.
         *
         *     Represents a detected camera view change that may indicate
         *     tampering, angle changes, or blocked views.
         * @example {
         *       "acknowledged": false,
         *       "change_type": "view_blocked",
         *       "detected_at": "2026-01-03T10:30:00Z",
         *       "file_path": "/export/foscam/front_door/image.jpg",
         *       "id": 1,
         *       "similarity_score": 0.23
         *     }
         */
        SceneChangeResponse: {
            /**
             * Id
             * @description Unique scene change ID
             */
            id: number;
            /**
             * Detected At
             * Format: date-time
             * @description When the scene change was detected
             */
            detected_at: string;
            /**
             * Change Type
             * @description Type of change: view_blocked, angle_changed, view_tampered, unknown
             */
            change_type: string;
            /**
             * Similarity Score
             * @description SSIM similarity score (0-1, lower means more different)
             */
            similarity_score: number;
            /**
             * Acknowledged
             * @description Whether the change has been acknowledged
             * @default false
             */
            acknowledged: boolean;
            /**
             * Acknowledged At
             * @description When the change was acknowledged
             */
            acknowledged_at?: string | null;
            /**
             * File Path
             * @description Path to the image that triggered detection
             */
            file_path?: string | null;
        };
        /**
         * SearchResponse
         * @description Schema for search response with pagination.
         * @example {
         *       "limit": 50,
         *       "offset": 0,
         *       "results": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "object_types": "person, vehicle",
         *           "reasoning": "Unknown individual approaching entrance during nighttime",
         *           "relevance_score": 0.85,
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Suspicious person detected near front entrance"
         *         }
         *       ],
         *       "total_count": 42
         *     }
         */
        SearchResponse: {
            /**
             * Results
             * @description List of search results
             */
            results: components["schemas"]["SearchResult"][];
            /**
             * Total Count
             * @description Total number of matching events
             */
            total_count: number;
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * SearchResult
         * @description Schema for a single search result.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "detection_count": 5,
         *       "detection_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "ended_at": "2025-12-23T12:02:30Z",
         *       "id": 1,
         *       "object_types": "person, vehicle",
         *       "reasoning": "Unknown individual approaching entrance during nighttime hours",
         *       "relevance_score": 0.85,
         *       "reviewed": false,
         *       "risk_level": "medium",
         *       "risk_score": 75,
         *       "started_at": "2025-12-23T12:00:00Z",
         *       "summary": "Suspicious person detected near front entrance"
         *     }
         */
        SearchResult: {
            /**
             * Id
             * @description Event ID
             */
            id: number;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera display name
             */
            camera_name?: string | null;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score?: number | null;
            /**
             * Risk Level
             * @description Risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Summary
             * @description LLM-generated event summary
             */
            summary?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning for risk score
             */
            reasoning?: string | null;
            /**
             * Reviewed
             * @description Whether event has been reviewed
             * @default false
             */
            reviewed: boolean;
            /**
             * Detection Count
             * @description Number of detections in this event
             * @default 0
             */
            detection_count: number;
            /**
             * Detection Ids
             * @description List of detection IDs associated with this event
             */
            detection_ids?: number[];
            /**
             * Object Types
             * @description Comma-separated detected object types
             */
            object_types?: string | null;
            /**
             * Relevance Score
             * @description Full-text search relevance score (higher is more relevant)
             * @default 0
             */
            relevance_score: number;
        };
        /**
         * SeedCamerasRequest
         * @description Request schema for seeding cameras.
         */
        SeedCamerasRequest: {
            /**
             * Count
             * @description Number of cameras to create (1-6)
             * @default 6
             */
            count: number;
            /**
             * Clear Existing
             * @description Remove existing cameras first
             * @default false
             */
            clear_existing: boolean;
            /**
             * Create Folders
             * @description Create camera folders on filesystem
             * @default false
             */
            create_folders: boolean;
        };
        /**
         * SeedCamerasResponse
         * @description Response schema for seed cameras endpoint.
         */
        SeedCamerasResponse: {
            /** Created */
            created: number;
            /** Cleared */
            cleared: number;
            /** Cameras */
            cameras: {
                [key: string]: unknown;
            }[];
        };
        /**
         * SeedEventsRequest
         * @description Request schema for seeding events.
         */
        SeedEventsRequest: {
            /**
             * Count
             * @description Number of events to create (1-100)
             * @default 15
             */
            count: number;
            /**
             * Clear Existing
             * @description Remove existing events and detections
             * @default false
             */
            clear_existing: boolean;
        };
        /**
         * SeedEventsResponse
         * @description Response schema for seed events endpoint.
         */
        SeedEventsResponse: {
            /** Events Created */
            events_created: number;
            /** Detections Created */
            detections_created: number;
            /** Events Cleared */
            events_cleared: number;
            /** Detections Cleared */
            detections_cleared: number;
        };
        /**
         * ServiceHealthStatusResponse
         * @description Health status of a registered service.
         */
        ServiceHealthStatusResponse: {
            /**
             * Name
             * @description Service name
             */
            name: string;
            /**
             * Status
             * @description Health status (healthy, unhealthy, unknown)
             */
            status: string;
            /**
             * Last Check
             * @description Monotonic time of last health check
             */
            last_check?: number | null;
            /**
             * Consecutive Failures
             * @description Count of consecutive health check failures
             */
            consecutive_failures: number;
            /**
             * Error Message
             * @description Last error message if unhealthy
             */
            error_message?: string | null;
        };
        /**
         * ServiceStatus
         * @description Status information for a service component.
         */
        ServiceStatus: {
            /**
             * Status
             * @description Service status: healthy, unhealthy, or not_initialized
             */
            status: string;
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
            /**
             * Details
             * @description Additional service-specific details
             */
            details?: {
                [key: string]: string;
            } | null;
        };
        /**
         * SeverityDefinitionResponse
         * @description Definition of a single severity level.
         * @example {
         *       "color": "#f97316",
         *       "description": "Concerning activity, review soon",
         *       "label": "High",
         *       "max_score": 84,
         *       "min_score": 60,
         *       "priority": 1,
         *       "severity": "high"
         *     }
         */
        SeverityDefinitionResponse: {
            /** @description The severity level identifier */
            severity: components["schemas"]["SeverityEnum"];
            /**
             * Label
             * @description Human-readable label for the severity level
             */
            label: string;
            /**
             * Description
             * @description Description of when this severity applies
             */
            description: string;
            /**
             * Color
             * @description Hex color code for UI display (e.g., '#22c55e')
             */
            color: string;
            /**
             * Priority
             * @description Sort priority (0 = highest priority, 3 = lowest)
             */
            priority: number;
            /**
             * Min Score
             * @description Minimum risk score for this severity (inclusive)
             */
            min_score: number;
            /**
             * Max Score
             * @description Maximum risk score for this severity (inclusive)
             */
            max_score: number;
        };
        /**
         * SeverityEnum
         * @description Severity levels for API responses.
         * @enum {string}
         */
        SeverityEnum: "low" | "medium" | "high" | "critical";
        /**
         * SeverityMetadataResponse
         * @description Response schema for severity metadata endpoint.
         *
         *     Provides complete information about severity levels including:
         *     - All severity definitions with thresholds and colors
         *     - Current threshold configuration
         *     - Useful for frontend to display severity information consistently
         * @example {
         *       "definitions": [
         *         {
         *           "color": "#22c55e",
         *           "description": "Routine activity, no concern",
         *           "label": "Low",
         *           "max_score": 29,
         *           "min_score": 0,
         *           "priority": 3,
         *           "severity": "low"
         *         },
         *         {
         *           "color": "#eab308",
         *           "description": "Notable activity, worth reviewing",
         *           "label": "Medium",
         *           "max_score": 59,
         *           "min_score": 30,
         *           "priority": 2,
         *           "severity": "medium"
         *         },
         *         {
         *           "color": "#f97316",
         *           "description": "Concerning activity, review soon",
         *           "label": "High",
         *           "max_score": 84,
         *           "min_score": 60,
         *           "priority": 1,
         *           "severity": "high"
         *         },
         *         {
         *           "color": "#ef4444",
         *           "description": "Immediate attention required",
         *           "label": "Critical",
         *           "max_score": 100,
         *           "min_score": 85,
         *           "priority": 0,
         *           "severity": "critical"
         *         }
         *       ],
         *       "thresholds": {
         *         "high_max": 84,
         *         "low_max": 29,
         *         "medium_max": 59
         *       }
         *     }
         */
        SeverityMetadataResponse: {
            /**
             * Definitions
             * @description List of all severity level definitions
             */
            definitions: components["schemas"]["SeverityDefinitionResponse"][];
            /** @description Current severity threshold configuration */
            thresholds: components["schemas"]["SeverityThresholds"];
        };
        /**
         * SeverityThresholds
         * @description Current severity threshold configuration.
         * @example {
         *       "high_max": 84,
         *       "low_max": 29,
         *       "medium_max": 59
         *     }
         */
        SeverityThresholds: {
            /**
             * Low Max
             * @description Maximum risk score for LOW severity (0 to this value = LOW)
             */
            low_max: number;
            /**
             * Medium Max
             * @description Maximum risk score for MEDIUM severity (low_max+1 to this value = MEDIUM)
             */
            medium_max: number;
            /**
             * High Max
             * @description Maximum risk score for HIGH severity (medium_max+1 to this value = HIGH)
             */
            high_max: number;
        };
        /**
         * SeverityThresholdsUpdateRequest
         * @description Request schema for updating severity thresholds.
         *
         *     The thresholds must form contiguous ranges from 0-100:
         *     - LOW: 0 to low_max (inclusive)
         *     - MEDIUM: low_max+1 to medium_max (inclusive)
         *     - HIGH: medium_max+1 to high_max (inclusive)
         *     - CRITICAL: high_max+1 to 100 (inclusive)
         *
         *     Validation rules:
         *     - 0 < low_max < medium_max < high_max < 100
         *     - This ensures all ranges are valid and cover 0-100 without gaps or overlaps
         * @example {
         *       "high_max": 84,
         *       "low_max": 29,
         *       "medium_max": 59
         *     }
         */
        SeverityThresholdsUpdateRequest: {
            /**
             * Low Max
             * @description Maximum risk score for LOW severity (1-98)
             */
            low_max: number;
            /**
             * Medium Max
             * @description Maximum risk score for MEDIUM severity (2-99)
             */
            medium_max: number;
            /**
             * High Max
             * @description Maximum risk score for HIGH severity (3-99)
             */
            high_max: number;
        };
        /**
         * StageLatency
         * @description Latency statistics for a single pipeline stage.
         * @example {
         *       "avg_ms": 150.5,
         *       "max_ms": 500,
         *       "min_ms": 50,
         *       "p50_ms": 120,
         *       "p95_ms": 400,
         *       "p99_ms": 480,
         *       "sample_count": 100
         *     }
         */
        StageLatency: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms?: number | null;
            /**
             * Min Ms
             * @description Minimum latency in milliseconds
             */
            min_ms?: number | null;
            /**
             * Max Ms
             * @description Maximum latency in milliseconds
             */
            max_ms?: number | null;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms?: number | null;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms?: number | null;
            /**
             * P99 Ms
             * @description 99th percentile latency in milliseconds
             */
            p99_ms?: number | null;
            /**
             * Sample Count
             * @description Number of samples used to calculate statistics
             */
            sample_count: number;
        };
        /**
         * StorageCategoryStats
         * @description Storage statistics for a single category.
         */
        StorageCategoryStats: {
            /**
             * File Count
             * @description Number of files in this category
             */
            file_count: number;
            /**
             * Size Bytes
             * @description Total size in bytes for this category
             */
            size_bytes: number;
        };
        /**
         * StorageStatsResponse
         * @description Response schema for storage statistics endpoint.
         *
         *     Provides detailed storage usage information including:
         *     - Disk usage for the storage volume
         *     - Breakdown by data category (thumbnails, images, clips)
         *     - Database record counts
         * @example {
         *       "clips": {
         *         "file_count": 50,
         *         "size_bytes": 500000000
         *       },
         *       "detections_count": 892,
         *       "disk_free_bytes": 429496729600,
         *       "disk_total_bytes": 536870912000,
         *       "disk_usage_percent": 20,
         *       "disk_used_bytes": 107374182400,
         *       "events_count": 156,
         *       "gpu_stats_count": 2880,
         *       "images": {
         *         "file_count": 10000,
         *         "size_bytes": 5000000000
         *       },
         *       "logs_count": 5000,
         *       "thumbnails": {
         *         "file_count": 1500,
         *         "size_bytes": 75000000
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        StorageStatsResponse: {
            /**
             * Disk Used Bytes
             * @description Total disk space used in bytes
             */
            disk_used_bytes: number;
            /**
             * Disk Total Bytes
             * @description Total disk space available in bytes
             */
            disk_total_bytes: number;
            /**
             * Disk Free Bytes
             * @description Free disk space in bytes
             */
            disk_free_bytes: number;
            /**
             * Disk Usage Percent
             * @description Disk usage percentage (0-100)
             */
            disk_usage_percent: number;
            /** @description Storage used by detection thumbnails */
            thumbnails: components["schemas"]["StorageCategoryStats"];
            /** @description Storage used by original camera images */
            images: components["schemas"]["StorageCategoryStats"];
            /** @description Storage used by event video clips */
            clips: components["schemas"]["StorageCategoryStats"];
            /**
             * Events Count
             * @description Total number of events in database
             */
            events_count: number;
            /**
             * Detections Count
             * @description Total number of detections in database
             */
            detections_count: number;
            /**
             * Gpu Stats Count
             * @description Total number of GPU stats records in database
             */
            gpu_stats_count: number;
            /**
             * Logs Count
             * @description Total number of log entries in database
             */
            logs_count: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of storage stats snapshot
             */
            timestamp: string;
        };
        /**
         * SystemStatsResponse
         * @description Response schema for system statistics endpoint.
         * @example {
         *       "total_cameras": 4,
         *       "total_detections": 892,
         *       "total_events": 156,
         *       "uptime_seconds": 86400.5
         *     }
         */
        SystemStatsResponse: {
            /**
             * Total Cameras
             * @description Total number of cameras in the system
             */
            total_cameras: number;
            /**
             * Total Events
             * @description Total number of events recorded
             */
            total_events: number;
            /**
             * Total Detections
             * @description Total number of detections recorded
             */
            total_detections: number;
            /**
             * Uptime Seconds
             * @description Application uptime in seconds
             */
            uptime_seconds: number;
        };
        /**
         * TelemetryResponse
         * @description Response schema for pipeline telemetry endpoint.
         *
         *     Provides real-time visibility into:
         *     - Queue depths: How many items are waiting in detection/analysis queues
         *     - Stage latencies: How long each pipeline stage is taking
         *
         *     This helps operators:
         *     - Identify pipeline bottlenecks
         *     - Detect backlog situations
         *     - Monitor processing performance
         *     - Debug pipeline stalls
         * @example {
         *       "latencies": {
         *         "detect": {
         *           "avg_ms": 200,
         *           "max_ms": 800,
         *           "min_ms": 100,
         *           "p50_ms": 180,
         *           "p95_ms": 600,
         *           "p99_ms": 750,
         *           "sample_count": 500
         *         },
         *         "watch": {
         *           "avg_ms": 10,
         *           "max_ms": 50,
         *           "min_ms": 5,
         *           "p50_ms": 8,
         *           "p95_ms": 40,
         *           "p99_ms": 48,
         *           "sample_count": 500
         *         }
         *       },
         *       "queues": {
         *         "analysis_queue": 2,
         *         "detection_queue": 5
         *       },
         *       "timestamp": "2025-12-27T10:30:00Z"
         *     }
         */
        TelemetryResponse: {
            /** @description Current queue depths for detection and analysis queues */
            queues: components["schemas"]["QueueDepths"];
            /** @description Latency statistics for each pipeline stage */
            latencies?: components["schemas"]["PipelineLatencies"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of telemetry snapshot
             */
            timestamp: string;
        };
        /**
         * TestNotificationResponse
         * @description Schema for test notification result.
         * @example {
         *       "channel": "email",
         *       "message": "Test email sent successfully to test@example.com",
         *       "success": true
         *     }
         */
        TestNotificationResponse: {
            /** @description Channel that was tested */
            channel: components["schemas"]["NotificationChannel"];
            /**
             * Success
             * @description Whether the test was successful
             */
            success: boolean;
            /**
             * Error
             * @description Error message if test failed
             */
            error?: string | null;
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * VehicleEnrichment
         * @description Vehicle classification results.
         * @example {
         *       "color": "silver",
         *       "confidence": 0.91,
         *       "is_commercial": false,
         *       "type": "sedan"
         *     }
         */
        VehicleEnrichment: {
            /**
             * Type
             * @description Vehicle type (sedan, suv, truck, etc.)
             */
            type?: string | null;
            /**
             * Color
             * @description Vehicle color (if detected)
             */
            color?: string | null;
            /**
             * Confidence
             * @description Classification confidence
             */
            confidence?: number | null;
            /**
             * Is Commercial
             * @description Whether vehicle is commercial/delivery
             */
            is_commercial?: boolean | null;
            /**
             * Damage Detected
             * @description Whether vehicle damage was detected
             */
            damage_detected?: boolean | null;
            /**
             * Damage Types
             * @description Types of damage detected
             */
            damage_types?: string[] | null;
        };
        /**
         * ViolenceEnrichment
         * @description Violence detection results.
         * @example {
         *       "confidence": 0.88,
         *       "detected": false,
         *       "score": 0.12
         *     }
         */
        ViolenceEnrichment: {
            /**
             * Detected
             * @description Whether violence was detected
             * @default false
             */
            detected: boolean;
            /**
             * Score
             * @description Violence probability score
             * @default 0
             */
            score: number;
            /**
             * Confidence
             * @description Model confidence
             */
            confidence?: number | null;
        };
        /**
         * WeatherEnrichment
         * @description Weather classification results.
         * @example {
         *       "condition": "clear",
         *       "confidence": 0.95
         *     }
         */
        WeatherEnrichment: {
            /**
             * Condition
             * @description Weather condition (clear, rain, fog, etc.)
             */
            condition?: string | null;
            /**
             * Confidence
             * @description Classification confidence
             */
            confidence?: number | null;
        };
        /**
         * WebSocketBroadcasterStatus
         * @description Status of a WebSocket broadcaster's circuit breaker.
         */
        WebSocketBroadcasterStatus: {
            /** @description Current circuit state: closed (normal), open (failing), half_open (testing) */
            state: components["schemas"]["CircuitBreakerStateEnum"];
            /**
             * Failure Count
             * @description Current consecutive failure count
             */
            failure_count: number;
            /**
             * Is Degraded
             * @description Whether the broadcaster is in degraded mode
             */
            is_degraded: boolean;
        };
        /**
         * WebSocketHealthResponse
         * @description Response schema for WebSocket health endpoint.
         * @example {
         *       "event_broadcaster": {
         *         "failure_count": 0,
         *         "is_degraded": false,
         *         "state": "closed"
         *       },
         *       "system_broadcaster": {
         *         "failure_count": 0,
         *         "is_degraded": false,
         *         "state": "closed"
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        WebSocketHealthResponse: {
            /** @description Status of the event broadcaster circuit breaker */
            event_broadcaster?: components["schemas"]["WebSocketBroadcasterStatus"] | null;
            /** @description Status of the system broadcaster circuit breaker */
            system_broadcaster?: components["schemas"]["WebSocketBroadcasterStatus"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of health check
             */
            timestamp: string;
        };
        /**
         * WebhookTestNotificationRequest
         * @description Schema for testing notification configuration.
         * @example {
         *       "channel": "email",
         *       "email_recipients": [
         *         "test@example.com"
         *       ]
         *     }
         */
        WebhookTestNotificationRequest: {
            /** @description Channel to test */
            channel: components["schemas"]["NotificationChannel"];
            /**
             * Email Recipients
             * @description Email recipients for email test
             */
            email_recipients?: string[] | null;
            /**
             * Webhook Url
             * @description Webhook URL for webhook test. Must be HTTPS and not point to private IPs.
             */
            webhook_url?: string | null;
        };
        /**
         * WorkerStatus
         * @description Status information for a background worker/service.
         */
        WorkerStatus: {
            /**
             * Name
             * @description Worker/service name
             */
            name: string;
            /**
             * Running
             * @description Whether the worker is currently running
             */
            running: boolean;
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
        };
        /**
         * ZoneCreate
         * @description Schema for creating a new zone.
         * @example {
         *       "color": "#3B82F6",
         *       "coordinates": [
         *         [
         *           0.1,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.8
         *         ],
         *         [
         *           0.1,
         *           0.8
         *         ]
         *       ],
         *       "enabled": true,
         *       "name": "Front Door",
         *       "priority": 1,
         *       "shape": "rectangle",
         *       "zone_type": "entry_point"
         *     }
         */
        ZoneCreate: {
            /**
             * Name
             * @description Zone name
             */
            name: string;
            /**
             * @description Type of zone
             * @default other
             */
            zone_type: components["schemas"]["ZoneType"];
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates: number[][];
            /**
             * @description Shape of the zone
             * @default rectangle
             */
            shape: components["schemas"]["ZoneShape"];
            /**
             * Color
             * @description Hex color for UI display
             * @default #3B82F6
             */
            color: string;
            /**
             * Enabled
             * @description Whether zone is active
             * @default true
             */
            enabled: boolean;
            /**
             * Priority
             * @description Priority for overlapping zones (higher = more important)
             * @default 0
             */
            priority: number;
        };
        /**
         * ZoneListResponse
         * @description Schema for zone list response.
         * @example {
         *       "count": 1,
         *       "zones": [
         *         {
         *           "camera_id": "front_door",
         *           "color": "#3B82F6",
         *           "coordinates": [
         *             [
         *               0.1,
         *               0.2
         *             ],
         *             [
         *               0.3,
         *               0.2
         *             ],
         *             [
         *               0.3,
         *               0.8
         *             ],
         *             [
         *               0.1,
         *               0.8
         *             ]
         *           ],
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "enabled": true,
         *           "id": "123e4567-e89b-12d3-a456-426614174000",
         *           "name": "Front Door",
         *           "priority": 1,
         *           "shape": "rectangle",
         *           "updated_at": "2025-12-23T12:00:00Z",
         *           "zone_type": "entry_point"
         *         }
         *       ]
         *     }
         */
        ZoneListResponse: {
            /**
             * Zones
             * @description List of zones
             */
            zones: components["schemas"]["ZoneResponse"][];
            /**
             * Count
             * @description Total number of zones
             */
            count: number;
        };
        /**
         * ZoneResponse
         * @description Schema for zone response.
         * @example {
         *       "camera_id": "front_door",
         *       "color": "#3B82F6",
         *       "coordinates": [
         *         [
         *           0.1,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.8
         *         ],
         *         [
         *           0.1,
         *           0.8
         *         ]
         *       ],
         *       "created_at": "2025-12-23T10:00:00Z",
         *       "enabled": true,
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "name": "Front Door",
         *       "priority": 1,
         *       "shape": "rectangle",
         *       "updated_at": "2025-12-23T12:00:00Z",
         *       "zone_type": "entry_point"
         *     }
         */
        ZoneResponse: {
            /**
             * Id
             * @description Zone UUID
             */
            id: string;
            /**
             * Camera Id
             * @description Camera ID this zone belongs to
             */
            camera_id: string;
            /**
             * Name
             * @description Zone name
             */
            name: string;
            /** @description Type of zone */
            zone_type: components["schemas"]["ZoneType"];
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates: number[][];
            /** @description Shape of the zone */
            shape: components["schemas"]["ZoneShape"];
            /**
             * Color
             * @description Hex color for UI display
             */
            color: string;
            /**
             * Enabled
             * @description Whether zone is active
             */
            enabled: boolean;
            /**
             * Priority
             * @description Priority for overlapping zones
             */
            priority: number;
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when zone was created
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             * @description Timestamp when zone was last updated
             */
            updated_at: string;
        };
        /**
         * ZoneShape
         * @description Shape of the zone polygon.
         * @enum {string}
         */
        ZoneShape: "rectangle" | "polygon";
        /**
         * ZoneType
         * @description Type of zone for semantic categorization.
         * @enum {string}
         */
        ZoneType: "entry_point" | "driveway" | "sidewalk" | "yard" | "other";
        /**
         * ZoneUpdate
         * @description Schema for updating an existing zone.
         * @example {
         *       "enabled": false,
         *       "name": "Front Door - Updated"
         *     }
         */
        ZoneUpdate: {
            /**
             * Name
             * @description Zone name
             */
            name?: string | null;
            /** @description Type of zone */
            zone_type?: components["schemas"]["ZoneType"] | null;
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates?: number[][] | null;
            /** @description Shape of the zone */
            shape?: components["schemas"]["ZoneShape"] | null;
            /**
             * Color
             * @description Hex color for UI display
             */
            color?: string | null;
            /**
             * Enabled
             * @description Whether zone is active
             */
            enabled?: boolean | null;
            /**
             * Priority
             * @description Priority for overlapping zones (higher = more important)
             */
            priority?: number | null;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    seed_cameras_api_admin_seed_cameras_post: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeedCamerasRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeedCamerasResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    seed_events_api_admin_seed_events_post: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeedEventsRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeedEventsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_seeded_data_api_admin_seed_clear_delete: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ClearDataRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClearDataResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_audit_api_ai_audit_events__event_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventAuditResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    evaluate_event_api_ai_audit_events__event_id__evaluate_post: {
        parameters: {
            query?: {
                /** @description Force re-evaluation even if already evaluated */
                force?: boolean;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventAuditResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_audit_stats_api_ai_audit_stats_get: {
        parameters: {
            query?: {
                /** @description Number of days to include */
                days?: number;
                /** @description Filter by camera ID */
                camera_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_model_leaderboard_api_ai_audit_leaderboard_get: {
        parameters: {
            query?: {
                /** @description Number of days to include */
                days?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LeaderboardResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_recommendations_api_ai_audit_recommendations_get: {
        parameters: {
            query?: {
                /** @description Number of days to include */
                days?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecommendationsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    trigger_batch_audit_api_ai_audit_batch_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BatchAuditRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchAuditResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_rules_api_alerts_rules_get: {
        parameters: {
            query?: {
                /** @description Filter by enabled status */
                enabled?: boolean | null;
                /** @description Filter by severity level */
                severity?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_rule_api_alerts_rules_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertRuleCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_rule_api_alerts_rules__rule_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_rule_api_alerts_rules__rule_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertRuleUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_rule_api_alerts_rules__rule_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    test_rule_api_alerts_rules__rule_id__test_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RuleTestRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RuleTestResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_audit_logs_api_audit_get: {
        parameters: {
            query?: {
                /** @description Filter by action type */
                action?: string | null;
                /** @description Filter by resource type */
                resource_type?: string | null;
                /** @description Filter by resource ID */
                resource_id?: string | null;
                /** @description Filter by actor */
                actor?: string | null;
                /** @description Filter by status (success/failure) */
                status?: string | null;
                /** @description Filter from date (ISO format) */
                start_date?: string | null;
                /** @description Filter to date (ISO format) */
                end_date?: string | null;
                /** @description Page size */
                limit?: number;
                /** @description Page offset */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_audit_stats_api_audit_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogStats"];
                };
            };
        };
    };
    get_audit_log_api_audit__audit_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                audit_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_cameras_api_cameras_get: {
        parameters: {
            query?: {
                /** @description Filter by camera status */
                status?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_camera_api_cameras_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_api_cameras__camera_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_camera_api_cameras__camera_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_camera_api_cameras__camera_id__patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_snapshot_api_cameras__camera_id__snapshot_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Snapshot served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Camera or snapshot not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    validate_camera_paths_api_cameras_validation_paths_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    get_camera_baseline_api_cameras__camera_id__baseline_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BaselineSummaryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_baseline_anomalies_api_cameras__camera_id__baseline_anomalies_get: {
        parameters: {
            query?: {
                /** @description Number of days to look back */
                days?: number;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AnomalyListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_scene_changes_api_cameras__camera_id__scene_changes_get: {
        parameters: {
            query?: {
                /** @description Filter by acknowledgement status */
                acknowledged?: boolean | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SceneChangeListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    acknowledge_scene_change_api_cameras__camera_id__scene_changes__scene_change_id__acknowledge_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                scene_change_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SceneChangeAcknowledgeResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_detections_api_detections_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by object type */
                object_type?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Minimum confidence score */
                min_confidence?: number | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_detection_api_detections__detection_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_detection_enrichment_api_detections__detection_id__enrichment_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EnrichmentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_detection_image_api_detections__detection_id__image_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Image served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection or image not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to generate thumbnail */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    stream_detection_video_api_detections__detection_id__video_get: {
        parameters: {
            query?: never;
            header?: {
                Range?: string | null;
            };
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Full video content */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Partial video content (range request) */
            206: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection is not a video */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection or video file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Range not satisfiable */
            416: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_video_thumbnail_api_detections__detection_id__video_thumbnail_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Thumbnail served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection is not a video */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection or video not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to generate thumbnail */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_dlq_stats_api_dlq_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQStatsResponse"];
                };
            };
        };
    };
    get_dlq_jobs_api_dlq_jobs__queue_name__get: {
        parameters: {
            query?: {
                /** @description Start index (0-based) */
                start?: number;
                /** @description Maximum number of jobs to return */
                limit?: number;
            };
            header?: never;
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQJobsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    requeue_dlq_job_api_dlq_requeue__queue_name__post: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQRequeueResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    requeue_all_dlq_jobs_api_dlq_requeue_all__queue_name__post: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQRequeueResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_dlq_api_dlq__queue_name__delete: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQClearResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_entities_api_entities_get: {
        parameters: {
            query?: {
                /** @description Filter by entity type: 'person' or 'vehicle' */
                entity_type?: string | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter entities seen since this time */
                since?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_entity_api_entities__entity_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityDetail"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_entity_history_api_entities__entity_id__history_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_events_api_events_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by risk level (low, medium, high, critical) */
                risk_level?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
                /** @description Filter by detected object type */
                object_type?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_stats_api_events_stats_get: {
        parameters: {
            query?: {
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    search_events_endpoint_api_events_search_get: {
        parameters: {
            query: {
                /** @description Search query string */
                q: string;
                /** @description Filter by camera ID (comma-separated for multiple) */
                camera_id?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by risk levels (comma-separated: low,medium,high,critical) */
                severity?: string | null;
                /** @description Alias for severity - filter by risk levels (comma-separated: low,medium,high,critical) */
                risk_level?: string | null;
                /** @description Filter by object types (comma-separated: person,vehicle,animal) */
                object_type?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    export_events_api_events_export_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by risk level (low, medium, high, critical) */
                risk_level?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_api_events__event_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_event_api_events__event_id__patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_detections_api_events__event_id__detections_get: {
        parameters: {
            query?: {
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_enrichments_api_events__event_id__enrichments_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventEnrichmentsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_clip_api_events__event_id__clip_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClipInfoResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    generate_event_clip_api_events__event_id__clip_generate_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ClipGenerateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClipGenerateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_logs_api_logs_get: {
        parameters: {
            query?: {
                /** @description Filter by log level */
                level?: string | null;
                /** @description Filter by component name */
                component?: string | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by source (backend, frontend) */
                source?: string | null;
                /** @description Search in message text */
                search?: string | null;
                /** @description Filter from date (ISO format) */
                start_date?: string | null;
                /** @description Filter to date (ISO format) */
                end_date?: string | null;
                /** @description Page size */
                limit?: number;
                /** @description Page offset */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_log_stats_api_logs_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogStats"];
                };
            };
        };
    };
    get_log_api_logs__log_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                log_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogEntry"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_frontend_log_api_logs_frontend_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FrontendLogCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    serve_media_compat_api_media__path__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    serve_camera_file_api_media_cameras__camera_id___filename__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    serve_thumbnail_api_media_thumbnails__filename__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Thumbnail served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    serve_clip_api_media_clips__filename__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Clip served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    metrics_api_metrics_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_notification_config_api_notification_config_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationConfigResponse"];
                };
            };
        };
    };
    test_notification_api_notification_test_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookTestNotificationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TestNotificationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_health_api_system_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
        };
    };
    get_readiness_api_system_health_ready_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReadinessResponse"];
                };
            };
        };
    };
    get_websocket_health_api_system_health_websocket_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebSocketHealthResponse"];
                };
            };
        };
    };
    get_gpu_stats_api_system_gpu_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GPUStatsResponse"];
                };
            };
        };
    };
    get_gpu_stats_history_api_system_gpu_history_get: {
        parameters: {
            query?: {
                since?: string | null;
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GPUStatsHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_config_api_system_config_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConfigResponse"];
                };
            };
        };
    };
    patch_config_api_system_config_patch: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConfigUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_stats_api_system_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemStatsResponse"];
                };
            };
        };
    };
    get_telemetry_api_system_telemetry_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TelemetryResponse"];
                };
            };
        };
    };
    get_pipeline_latency_api_system_pipeline_latency_get: {
        parameters: {
            query?: {
                window_minutes?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineLatencyResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_pipeline_latency_history_api_system_pipeline_latency_history_get: {
        parameters: {
            query?: {
                /** @description Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours) */
                since?: number;
                /** @description Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour) */
                bucket_seconds?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineLatencyHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    trigger_cleanup_api_system_cleanup_post: {
        parameters: {
            query?: {
                dry_run?: boolean;
            };
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanupResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_severity_metadata_api_system_severity_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeverityMetadataResponse"];
                };
            };
        };
    };
    update_severity_thresholds_api_system_severity_put: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeverityThresholdsUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeverityMetadataResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_storage_stats_api_system_storage_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StorageStatsResponse"];
                };
            };
        };
    };
    get_circuit_breakers_api_system_circuit_breakers_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CircuitBreakersResponse"];
                };
            };
        };
    };
    reset_circuit_breaker_api_system_circuit_breakers__name__reset_post: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CircuitBreakerResetResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_cleanup_status_api_system_cleanup_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanupStatusResponse"];
                };
            };
        };
    };
    get_pipeline_status_api_system_pipeline_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineStatusResponse"];
                };
            };
        };
    };
    get_models_api_system_models_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelRegistryResponse"];
                };
            };
        };
    };
    get_model_api_system_models__model_name__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                model_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelStatusResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_model_zoo_status_api_system_model_zoo_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelZooStatusResponse"];
                };
            };
        };
    };
    get_model_zoo_latency_history_api_system_model_zoo_latency_history_get: {
        parameters: {
            query: {
                /** @description Model name to get latency history for (e.g., 'yolo11-license-plate') */
                model: string;
                /** @description Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours) */
                since?: number;
                /** @description Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour) */
                bucket_seconds?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelLatencyHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_zones_api_cameras__camera_id__zones_get: {
        parameters: {
            query?: {
                /** @description Filter by enabled status */
                enabled?: boolean | null;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_zone_api_cameras__camera_id__zones_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_zone_api_cameras__camera_id__zones__zone_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_zone_api_cameras__camera_id__zones__zone_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_zone_api_cameras__camera_id__zones__zone_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    root__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    health_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    ready_ready_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
