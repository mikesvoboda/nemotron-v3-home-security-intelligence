/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/admin/seed/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seed Cameras
         * @description Seed test cameras into the database.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *
         *     Args:
         *         request: Seed configuration (count, clear_existing, create_folders)
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of seeded cameras
         */
        post: operations["seed_cameras_api_admin_seed_cameras_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seed Events
         * @description Seed mock events and detections into the database.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *     Requires cameras to exist first.
         *
         *     Args:
         *         request: Seed configuration (count, clear_existing)
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of seeded events and detections
         */
        post: operations["seed_events_api_admin_seed_events_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/clear": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Seeded Data
         * @description Clear all seeded data (cameras, events, detections).
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *     Requires JSON body confirmation to prevent accidental data deletion:
         *     {"confirm": "DELETE_ALL_DATA"}
         *
         *     Args:
         *         body: Request body with confirmation string
         *         request: FastAPI request for audit logging
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of cleared data counts
         *
         *     Raises:
         *         HTTPException: 400 if confirmation string is incorrect
         */
        delete: operations["clear_seeded_data_api_admin_seed_clear_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Rules
         * @description List all alert rules with optional filtering and pagination.
         *
         *     Args:
         *         enabled: Filter by enabled status
         *         severity: Filter by severity level (low, medium, high, critical)
         *         limit: Maximum number of results to return
         *         offset: Number of results to skip for pagination
         *         db: Database session
         *
         *     Returns:
         *         AlertRuleListResponse with rules and pagination info
         */
        get: operations["list_rules_api_alerts_rules_get"];
        put?: never;
        /**
         * Create Rule
         * @description Create a new alert rule.
         *
         *     Args:
         *         rule_data: Rule creation data
         *         db: Database session
         *
         *     Returns:
         *         Created AlertRule
         */
        post: operations["create_rule_api_alerts_rules_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules/{rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Rule
         * @description Get a specific alert rule by ID.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         db: Database session
         *
         *     Returns:
         *         AlertRule
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        get: operations["get_rule_api_alerts_rules__rule_id__get"];
        /**
         * Update Rule
         * @description Update an existing alert rule.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         rule_data: Rule update data
         *         db: Database session
         *
         *     Returns:
         *         Updated AlertRule
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        put: operations["update_rule_api_alerts_rules__rule_id__put"];
        post?: never;
        /**
         * Delete Rule
         * @description Delete an alert rule.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        delete: operations["delete_rule_api_alerts_rules__rule_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules/{rule_id}/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Rule
         * @description Test a rule against historical events.
         *
         *     This endpoint allows testing rule configuration without actually
         *     creating alerts. Useful for validating rules before enabling them.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         test_data: Test configuration (event IDs, time override)
         *         db: Database session
         *
         *     Returns:
         *         RuleTestResponse with per-event match results
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        post: operations["test_rule_api_alerts_rules__rule_id__test_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Audit Logs
         * @description List audit logs with optional filtering and pagination.
         *
         *     This endpoint is intended for admin use to review security-sensitive operations.
         *
         *     Args:
         *         action: Optional action type to filter by
         *         resource_type: Optional resource type to filter by
         *         resource_id: Optional specific resource ID to filter by
         *         actor: Optional actor to filter by
         *         status_filter: Optional status to filter by (success/failure)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         limit: Maximum number of results to return (1-1000, default 100)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         AuditLogListResponse containing filtered logs and pagination info
         */
        get: operations["list_audit_logs_api_audit_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Stats
         * @description Get audit log statistics for dashboard.
         *
         *     Returns aggregated statistics about audit logs including:
         *     - Total log count
         *     - Logs today
         *     - Breakdown by action type
         *     - Breakdown by resource type
         *     - Breakdown by status
         *     - Recently active actors
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         AuditLogStats with aggregated statistics
         */
        get: operations["get_audit_stats_api_audit_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit/{audit_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Log
         * @description Get a specific audit log entry by ID.
         *
         *     Args:
         *         audit_id: Audit log ID
         *         db: Database session
         *
         *     Returns:
         *         AuditLog record
         *
         *     Raises:
         *         HTTPException: 404 if audit log not found
         */
        get: operations["get_audit_log_api_audit__audit_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Cameras
         * @description List all cameras with optional status filter.
         *
         *     Args:
         *         status_filter: Optional status to filter cameras by (online, offline, error)
         *         db: Database session
         *
         *     Returns:
         *         CameraListResponse containing list of cameras and total count
         */
        get: operations["list_cameras_api_cameras_get"];
        put?: never;
        /**
         * Create Camera
         * @description Create a new camera.
         *
         *     Args:
         *         camera_data: Camera creation data
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Created camera object with generated ID
         */
        post: operations["create_camera_api_cameras_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera
         * @description Get a specific camera by ID.
         *
         *     Args:
         *         camera_id: UUID of the camera
         *         db: Database session
         *
         *     Returns:
         *         Camera object
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_api_cameras__camera_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Camera
         * @description Delete a camera.
         *
         *     This operation cascades to all related detections and events.
         *
         *     Args:
         *         camera_id: UUID of the camera to delete
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        delete: operations["delete_camera_api_cameras__camera_id__delete"];
        options?: never;
        head?: never;
        /**
         * Update Camera
         * @description Update an existing camera.
         *
         *     Args:
         *         camera_id: UUID of the camera to update
         *         camera_data: Camera update data (all fields optional)
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Updated camera object
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        patch: operations["update_camera_api_cameras__camera_id__patch"];
        trace?: never;
    };
    "/api/cameras/{camera_id}/snapshot": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Snapshot
         * @description Return the latest image for a camera (best-effort snapshot).
         *
         *     This endpoint uses the camera's configured `folder_path` and returns the most recently
         *     modified image file under that directory.
         */
        get: operations["get_camera_snapshot_api_cameras__camera_id__snapshot_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Detections
         * @description List detections with optional filtering and pagination.
         *
         *     Args:
         *         camera_id: Optional camera ID to filter by
         *         object_type: Optional object type to filter by (person, car, etc.)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         min_confidence: Optional minimum confidence score (0-1)
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         DetectionListResponse containing filtered detections and pagination info
         */
        get: operations["list_detections_api_detections_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection
         * @description Get a specific detection by ID.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         Detection object
         *
         *     Raises:
         *         HTTPException: 404 if detection not found
         */
        get: operations["get_detection_api_detections__detection_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Image
         * @description Get detection image with bounding box overlay.
         *
         *     Returns the thumbnail image with bounding box drawn around the detected object.
         *     If thumbnail doesn't exist, generates it on the fly from the source image.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         JPEG image with bounding box overlay
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or image file doesn't exist
         *         HTTPException: 500 if image generation fails
         */
        get: operations["get_detection_image_api_detections__detection_id__image_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Stream Detection Video
         * @description Stream detection video with HTTP Range request support.
         *
         *     Supports partial content requests for video seeking and efficient playback.
         *     Returns 206 Partial Content for range requests, 200 OK for full content.
         *
         *     Args:
         *         detection_id: Detection ID
         *         range_header: HTTP Range header for partial content requests
         *         db: Database session
         *
         *     Returns:
         *         StreamingResponse with video content
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or not a video
         *         HTTPException: 416 if range is not satisfiable
         */
        get: operations["stream_detection_video_api_detections__detection_id__video_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/video/thumbnail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Video Thumbnail
         * @description Get thumbnail frame from a video detection.
         *
         *     Extracts and returns a thumbnail frame from the video. If thumbnail
         *     doesn't exist, generates it on the fly using ffmpeg.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         JPEG thumbnail image
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or not a video
         *         HTTPException: 500 if thumbnail generation fails
         */
        get: operations["get_video_thumbnail_api_detections__detection_id__video_thumbnail_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Dlq Stats
         * @description Get dead-letter queue statistics.
         *
         *     Returns the number of jobs in each DLQ and the total count.
         *
         *     Returns:
         *         DLQStatsResponse with queue counts
         */
        get: operations["get_dlq_stats_api_dlq_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/jobs/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Dlq Jobs
         * @description List jobs in a specific dead-letter queue.
         *
         *     Returns jobs in the specified DLQ without removing them.
         *     Use pagination parameters to control the result set.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         start: Start index for pagination
         *         limit: Maximum number of jobs to return
         *         redis: Redis client
         *
         *     Returns:
         *         DLQJobsResponse with list of jobs
         */
        get: operations["get_dlq_jobs_api_dlq_jobs__queue_name__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/requeue/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Requeue Dlq Job
         * @description Requeue the oldest job from a DLQ back to its original processing queue.
         *
         *     Removes the oldest job from the specified DLQ and adds it back to the
         *     original processing queue for retry.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         redis: Redis client
         *
         *     Returns:
         *         DLQRequeueResponse with operation result
         */
        post: operations["requeue_dlq_job_api_dlq_requeue__queue_name__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/requeue-all/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Requeue All Dlq Jobs
         * @description Requeue all jobs from a DLQ back to their original processing queue.
         *
         *     Removes all jobs from the specified DLQ and adds them back to the
         *     original processing queue for retry. Limited to settings.max_requeue_iterations
         *     to prevent resource exhaustion.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         redis: Redis client
         *
         *     Returns:
         *         DLQRequeueResponse with operation result and count
         */
        post: operations["requeue_all_dlq_jobs_api_dlq_requeue_all__queue_name__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Dlq
         * @description Clear all jobs from a dead-letter queue.
         *
         *     WARNING: This permanently removes all jobs from the specified DLQ.
         *     Use with caution.
         *
         *     Args:
         *         queue_name: Name of the DLQ to clear
         *         redis: Redis client
         *
         *     Returns:
         *         DLQClearResponse with operation result
         */
        delete: operations["clear_dlq_api_dlq__queue_name__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Events
         * @description List events with optional filtering and pagination.
         *
         *     Args:
         *         camera_id: Optional camera ID to filter by
         *         risk_level: Optional risk level to filter by (low, medium, high, critical)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         reviewed: Optional filter by reviewed status
         *         object_type: Optional object type to filter by (person, vehicle, animal, etc.)
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         EventListResponse containing filtered events and pagination info
         */
        get: operations["list_events_api_events_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Stats
         * @description Get aggregated event statistics.
         *
         *     Returns statistics about events including:
         *     - Total event count
         *     - Events grouped by risk level (critical, high, medium, low)
         *     - Events grouped by camera with camera names
         *
         *     Args:
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         db: Database session
         *
         *     Returns:
         *         EventStatsResponse with aggregated statistics
         */
        get: operations["get_event_stats_api_events_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Events Endpoint
         * @description Search events using full-text search.
         *
         *     This endpoint provides PostgreSQL full-text search across event summaries,
         *     reasoning, object types, and camera names.
         *
         *     Search Query Syntax:
         *     - Basic words: "person vehicle" (implicit AND)
         *     - Phrase search: '"suspicious person"' (exact phrase)
         *     - Boolean OR: "person OR animal"
         *     - Boolean NOT: "person NOT cat"
         *     - Boolean AND: "person AND vehicle" (explicit)
         *
         *     Args:
         *         q: Search query string (required)
         *         camera_id: Optional comma-separated camera IDs to filter by
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         severity: Optional comma-separated risk levels (low, medium, high, critical)
         *         object_type: Optional comma-separated object types (person, vehicle, animal)
         *         reviewed: Optional filter by reviewed status
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         SearchResponse with ranked results and pagination info
         */
        get: operations["search_events_endpoint_api_events_search_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export Events
         * @description Export events as CSV file for external analysis or record-keeping.
         *
         *     Exports events with the following fields:
         *     - Event ID, camera name, timestamps
         *     - Risk score, risk level, summary
         *     - Detection count, reviewed status
         *
         *     Args:
         *         camera_id: Optional camera ID to filter by
         *         risk_level: Optional risk level to filter by (low, medium, high, critical)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         reviewed: Optional filter by reviewed status
         *         db: Database session
         *
         *     Returns:
         *         StreamingResponse with CSV file containing exported events
         */
        get: operations["export_events_api_events_export_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event
         * @description Get a specific event by ID.
         *
         *     Args:
         *         event_id: Event ID
         *         db: Database session
         *
         *     Returns:
         *         Event object with detection count
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_api_events__event_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Event
         * @description Update an event (mark as reviewed).
         *
         *     Args:
         *         event_id: Event ID
         *         update_data: Update data (reviewed field)
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Updated event object
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        patch: operations["update_event_api_events__event_id__patch"];
        trace?: never;
    };
    "/api/events/{event_id}/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Detections
         * @description Get detections for a specific event.
         *
         *     Args:
         *         event_id: Event ID
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         DetectionListResponse containing detections for the event
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_detections_api_events__event_id__detections_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Logs
         * @description List logs with optional filtering and pagination.
         */
        get: operations["list_logs_api_logs_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Log Stats
         * @description Get log statistics for dashboard.
         */
        get: operations["get_log_stats_api_logs_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/{log_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Log
         * @description Get a single log entry by ID.
         */
        get: operations["get_log_api_logs__log_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/frontend": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Frontend Log
         * @description Receive and store a log from the frontend.
         */
        post: operations["create_frontend_log_api_logs_frontend_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Media Compat
         * @description Compatibility route: serve media via design-spec-style /api/media/{path}.
         *
         *     This preserves the stricter behavior of the new routes:
         *     - Path traversal protection
         *     - Allowed file type allowlist
         *     - Must remain under configured base directories
         *
         *     Mapping rules:
         *     - `cameras/<camera_id>/<filename...>` → camera media
         *     - `thumbnails/<filename>` → thumbnails
         */
        get: operations["serve_media_compat_api_media__path__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/cameras/{camera_id}/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Camera File
         * @description Serve camera images or videos from Foscam storage.
         *
         *     Args:
         *         camera_id: The camera identifier (directory name)
         *         filename: The file to serve (can include subdirectories)
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["serve_camera_file_api_media_cameras__camera_id___filename__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/thumbnails/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Thumbnail
         * @description Serve detection thumbnail images.
         *
         *     Args:
         *         filename: The thumbnail filename
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["serve_thumbnail_api_media_thumbnails__filename__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Metrics
         * @description Return Prometheus metrics in exposition format.
         *
         *     This endpoint returns all registered metrics in the standard
         *     Prometheus exposition format for scraping.
         *
         *     Returns:
         *         Response with text/plain content type containing metrics
         */
        get: operations["metrics_api_metrics_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Notification Config
         * @description Get notification configuration status.
         *
         *     Returns the current notification configuration including:
         *     - Whether notifications are enabled
         *     - Which channels are configured (email, webhook, push)
         *     - SMTP host and port (if configured)
         *     - Default webhook URL (if configured)
         *     - Default email recipients
         *
         *     Note: Sensitive fields like SMTP password are NOT returned.
         *
         *     Returns:
         *         NotificationConfigResponse with current notification settings
         */
        get: operations["get_notification_config_api_notification_config_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Notification
         * @description Test notification delivery for a specific channel.
         *
         *     Sends a test notification to verify the configuration is working.
         *     For email, sends a test email to the specified recipients or default recipients.
         *     For webhook, sends a test payload to the specified URL or default URL.
         *
         *     Args:
         *         test_request: Test notification request with channel and optional overrides
         *
         *     Returns:
         *         TestNotificationResponse with test result
         */
        post: operations["test_notification_api_notification_test_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Health
         * @description Get detailed system health check.
         *
         *     Checks the health of all system components:
         *     - Database connectivity
         *     - Redis connectivity
         *     - AI services status
         *
         *     Health checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).
         *     If a health check times out, the service is marked as unhealthy.
         *
         *     Returns:
         *         HealthResponse with overall status and individual service statuses.
         *         HTTP 200 if healthy, 503 if degraded or unhealthy.
         */
        get: operations["get_health_api_system_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/live": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Liveness
         * @description Kubernetes-style liveness probe endpoint.
         *
         *     This endpoint indicates whether the process is running and able to
         *     respond to HTTP requests. It always returns 200 with status "alive"
         *     if the process is up. This is a minimal check with no dependencies.
         *
         *     Note: The canonical liveness probe is GET /health at the root level.
         *     This endpoint exists for Kubernetes compatibility and provides the
         *     same functionality under the /api/system prefix.
         *
         *     Used by Kubernetes/Docker to determine if the container should be restarted.
         *     If this endpoint fails, the process is considered dead and should be restarted.
         *
         *     Returns:
         *         LivenessResponse with status "alive"
         */
        get: operations["get_liveness_api_system_health_live_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Readiness
         * @description Kubernetes-style readiness probe endpoint with detailed information.
         *
         *     This endpoint indicates whether the application is ready to receive
         *     traffic and process uploads. It checks all critical dependencies:
         *     - Database connectivity (critical)
         *     - Redis connectivity (required for queue processing)
         *     - AI services availability
         *     - Background worker status
         *
         *     Note: The canonical readiness probe is GET /ready at the root level.
         *     This endpoint provides the same readiness check but with detailed
         *     service and worker status information.
         *
         *     Used by Kubernetes/Docker to determine if traffic should be routed to this instance.
         *     If this endpoint returns not_ready, the instance should not receive new requests.
         *
         *     Health checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).
         *     If a health check times out, the service is marked as unhealthy.
         *
         *     Returns:
         *         ReadinessResponse with overall readiness status and detailed checks.
         *         HTTP 200 if ready, 503 if degraded or not ready.
         */
        get: operations["get_readiness_api_system_health_ready_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Gpu Stats
         * @description Get current GPU statistics.
         *
         *     Returns the most recent GPU statistics including:
         *     - GPU name
         *     - GPU utilization percentage
         *     - Memory usage (used/total)
         *     - Temperature
         *     - Power usage
         *     - Inference FPS
         *
         *     Returns:
         *         GPUStatsResponse with GPU statistics (null values if unavailable)
         */
        get: operations["get_gpu_stats_api_system_gpu_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Gpu Stats History
         * @description Get recent GPU stats samples as a time-series.
         *
         *     Args:
         *         since: Optional lower bound for recorded_at (ISO datetime)
         *         limit: Maximum number of samples to return (default 300)
         *         db: Database session
         */
        get: operations["get_gpu_stats_history_api_system_gpu_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Config
         * @description Get public configuration settings.
         *
         *     Returns non-sensitive application configuration values.
         *     Does NOT expose database URLs, API keys, or other secrets.
         *
         *     Returns:
         *         ConfigResponse with public configuration settings
         */
        get: operations["get_config_api_system_config_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Patch Config
         * @description Patch processing-related configuration and persist runtime overrides.
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     Notes:
         *     - This updates a runtime override env file (see `HSI_RUNTIME_ENV_PATH`) and clears the
         *       settings cache so subsequent `get_settings()` calls observe the new values.
         */
        patch: operations["patch_config_api_system_config_patch"];
        trace?: never;
    };
    "/api/system/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Stats
         * @description Get system statistics.
         *
         *     Returns aggregate statistics about the system:
         *     - Total number of cameras
         *     - Total number of events
         *     - Total number of detections
         *     - Application uptime
         *
         *     Returns:
         *         SystemStatsResponse with system statistics
         */
        get: operations["get_stats_api_system_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/telemetry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Telemetry
         * @description Get pipeline telemetry data.
         *
         *     Returns real-time metrics about the AI processing pipeline:
         *     - Queue depths: Items waiting in detection and analysis queues
         *     - Stage latencies: Processing time statistics for each pipeline stage
         *
         *     This endpoint helps operators:
         *     - Monitor pipeline health and throughput
         *     - Identify bottlenecks and backlogs
         *     - Debug pipeline stalls
         *     - Track performance trends
         *
         *     Returns:
         *         TelemetryResponse with queue depths and latency statistics
         */
        get: operations["get_telemetry_api_system_telemetry_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline-latency": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Latency
         * @description Get pipeline latency metrics with percentiles.
         *
         *     Returns latency statistics for each stage transition in the AI pipeline:
         *     - watch_to_detect: Time from file watcher detecting image to RT-DETR processing start
         *     - detect_to_batch: Time from detection completion to batch aggregation
         *     - batch_to_analyze: Time from batch completion to Nemotron analysis start
         *     - total_pipeline: Total end-to-end processing time
         *
         *     Each stage includes:
         *     - avg_ms: Average latency in milliseconds
         *     - min_ms: Minimum latency
         *     - max_ms: Maximum latency
         *     - p50_ms: 50th percentile (median)
         *     - p95_ms: 95th percentile
         *     - p99_ms: 99th percentile
         *     - sample_count: Number of samples used
         *
         *     Args:
         *         window_minutes: Time window for statistics calculation (default 60 minutes)
         *
         *     Returns:
         *         PipelineLatencyResponse with latency statistics for each stage
         */
        get: operations["get_pipeline_latency_api_system_pipeline_latency_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/cleanup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Cleanup
         * @description Trigger manual data cleanup based on retention settings.
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     This endpoint runs the CleanupService to delete old data according to
         *     the configured retention period. It deletes:
         *     - Events older than retention period
         *     - Detections older than retention period
         *     - GPU stats older than retention period
         *     - Logs older than log retention period
         *     - Associated thumbnail files
         *     - Optionally original image files (if delete_images is enabled)
         *
         *     The cleanup respects the current retention_days setting from the system
         *     configuration. To change the retention period before running cleanup,
         *     use PATCH /api/system/config first.
         *
         *     Args:
         *         dry_run: If True, calculate and return what would be deleted without
         *                  actually performing the deletion. Useful for verification
         *                  before destructive operations.
         *
         *     Returns:
         *         CleanupResponse with statistics about the cleanup operation.
         *         When dry_run=True, the counts represent what would be deleted.
         */
        post: operations["trigger_cleanup_api_system_cleanup_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/severity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Severity Metadata
         * @description Get severity level definitions and thresholds.
         *
         *     Returns complete information about the severity taxonomy including:
         *     - All severity level definitions (LOW, MEDIUM, HIGH, CRITICAL)
         *     - Risk score thresholds for each level
         *     - Color codes for UI display
         *     - Human-readable labels and descriptions
         *
         *     This endpoint is useful for frontends to:
         *     - Display severity information consistently
         *     - Show severity legends in the UI
         *     - Validate severity-related user inputs
         *     - Map risk scores to severity levels client-side
         *
         *     Returns:
         *         SeverityMetadataResponse with all severity definitions and current thresholds
         */
        get: operations["get_severity_metadata_api_system_severity_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/storage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Storage Stats
         * @description Get storage statistics and disk usage metrics.
         *
         *     Returns detailed storage usage information including:
         *     - Overall disk usage (used/total/free)
         *     - Storage breakdown by category (thumbnails, images, clips)
         *     - Database record counts (events, detections, GPU stats, logs)
         *
         *     This endpoint helps operators:
         *     - Monitor available storage space
         *     - Understand storage distribution across data types
         *     - Plan cleanup operations
         *     - Track database growth
         *
         *     Returns:
         *         StorageStatsResponse with comprehensive storage metrics
         */
        get: operations["get_storage_stats_api_system_storage_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/zones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Zones
         * @description List all zones for a camera with optional filtering.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         enabled: Optional filter for enabled/disabled zones
         *         db: Database session
         *
         *     Returns:
         *         ZoneListResponse containing list of zones and total count
         */
        get: operations["list_zones_api_cameras__camera_id__zones_get"];
        put?: never;
        /**
         * Create Zone
         * @description Create a new zone for a camera.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_data: Zone creation data
         *         db: Database session
         *
         *     Returns:
         *         Created zone object with generated ID
         */
        post: operations["create_zone_api_cameras__camera_id__zones_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/zones/{zone_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Zone
         * @description Get a specific zone by ID.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone
         *         db: Database session
         *
         *     Returns:
         *         Zone object
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        get: operations["get_zone_api_cameras__camera_id__zones__zone_id__get"];
        /**
         * Update Zone
         * @description Update an existing zone.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone to update
         *         zone_data: Zone update data (all fields optional)
         *         db: Database session
         *
         *     Returns:
         *         Updated zone object
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        put: operations["update_zone_api_cameras__camera_id__zones__zone_id__put"];
        post?: never;
        /**
         * Delete Zone
         * @description Delete a zone.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone to delete
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        delete: operations["delete_zone_api_cameras__camera_id__zones__zone_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Root
         * @description Health check endpoint.
         */
        get: operations["root__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health
         * @description Simple liveness health check endpoint (canonical liveness probe).
         *
         *     This endpoint indicates whether the process is running and able to
         *     respond to HTTP requests. It always returns 200 with status "alive"
         *     if the process is up.
         *
         *     This is the canonical liveness probe endpoint. Use this for:
         *     - Docker HEALTHCHECK liveness checks
         *     - Kubernetes liveness probes
         *     - Simple "is the server up?" monitoring
         *
         *     For detailed health information, use:
         *     - GET /api/system/health - Detailed health check with service status
         *     - GET /ready - Readiness probe (checks dependencies)
         *
         *     Returns:
         *         Simple status indicating the server is alive.
         */
        get: operations["health_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Ready
         * @description Simple readiness health check endpoint (canonical readiness probe).
         *
         *     This endpoint indicates whether the application is ready to receive
         *     traffic and process requests. It checks critical dependencies:
         *     - Database connectivity
         *     - Redis connectivity
         *     - Critical pipeline workers
         *
         *     This is the canonical readiness probe endpoint. Use this for:
         *     - Docker HEALTHCHECK readiness checks
         *     - Kubernetes readiness probes
         *     - Load balancer health checks
         *
         *     For detailed readiness information with service breakdown, use:
         *     - GET /api/system/health/ready - Full readiness response with details
         *
         *     Returns:
         *         Simple status indicating readiness. HTTP 200 if ready, 503 if not.
         */
        get: operations["ready_ready_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AlertRuleConditions
         * @description Schema for legacy alert rule conditions (backward compatibility).
         *
         *     New rules should use explicit fields on AlertRuleCreate/AlertRuleUpdate.
         *     This schema is kept for backward compatibility with existing rules.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "object_types": [
         *         "person",
         *         "vehicle"
         *       ],
         *       "risk_threshold": 70,
         *       "time_ranges": [
         *         {
         *           "end": "06:00",
         *           "start": "22:00"
         *         }
         *       ]
         *     }
         */
        AlertRuleConditions: {
            /**
             * Risk Threshold
             * @description Minimum risk score to trigger alert
             */
            risk_threshold?: number | null;
            /**
             * Object Types
             * @description Object types that trigger alerts (e.g., person, vehicle)
             */
            object_types?: string[] | null;
            /**
             * Camera Ids
             * @description Specific camera IDs that trigger alerts
             */
            camera_ids?: string[] | null;
            /**
             * Time Ranges
             * @description Time ranges when alerts are active (start/end in HH:MM format)
             */
            time_ranges?: {
                [key: string]: unknown;
            }[] | null;
        };
        /**
         * AlertRuleCreate
         * @description Schema for creating an alert rule.
         *
         *     All conditions use AND logic - all specified conditions must match for the rule to trigger.
         *     Leave a condition as null/empty to not filter on that criterion.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "channels": [
         *         "pushover",
         *         "webhook"
         *       ],
         *       "cooldown_seconds": 300,
         *       "dedup_key_template": "{camera_id}:{rule_id}",
         *       "description": "High-priority alert for person detection at night",
         *       "enabled": true,
         *       "min_confidence": 0.8,
         *       "name": "Night Intruder Alert",
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_threshold": 70,
         *       "schedule": {
         *         "days": [
         *           "monday",
         *           "tuesday",
         *           "wednesday",
         *           "thursday",
         *           "friday"
         *         ],
         *         "end_time": "06:00",
         *         "start_time": "22:00",
         *         "timezone": "America/New_York"
         *       },
         *       "severity": "critical"
         *     }
         */
        AlertRuleCreate: {
            /**
             * Name
             * @description Rule name
             */
            name: string;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             * @default true
             */
            enabled: boolean;
            /**
             * @description Severity level for triggered alerts
             * @default medium
             */
            severity: components["schemas"]["AlertSeverity"];
            /**
             * Risk Threshold
             * @description Alert when risk_score >= threshold
             */
            risk_threshold?: number | null;
            /**
             * Object Types
             * @description Object types to match (e.g., ['person', 'vehicle'])
             */
            object_types?: string[] | null;
            /**
             * Camera Ids
             * @description Camera IDs to apply rule to (empty = all cameras)
             */
            camera_ids?: string[] | null;
            /**
             * Zone Ids
             * @description Zone IDs to match (empty = any zone)
             */
            zone_ids?: string[] | null;
            /**
             * Min Confidence
             * @description Minimum detection confidence (0.0-1.0)
             */
            min_confidence?: number | null;
            /** @description Time-based conditions (null = always active) */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /** @description Legacy conditions (use explicit fields instead) */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Dedup Key Template
             * @description Template for dedup key. Variables: {camera_id}, {rule_id}, {object_type}
             * @default {camera_id}:{rule_id}
             */
            dedup_key_template: string;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             * @default 300
             */
            cooldown_seconds: number;
            /**
             * Channels
             * @description Notification channels for this rule
             */
            channels?: string[];
        };
        /**
         * AlertRuleListResponse
         * @description Schema for alert rule list response with pagination.
         * @example {
         *       "count": 1,
         *       "limit": 50,
         *       "offset": 0,
         *       "rules": [
         *         {
         *           "channels": [
         *             "pushover"
         *           ],
         *           "conditions": {
         *             "risk_threshold": 70
         *           },
         *           "cooldown_seconds": 300,
         *           "created_at": "2025-12-28T12:00:00Z",
         *           "enabled": true,
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "name": "High Risk Alert",
         *           "updated_at": "2025-12-28T12:00:00Z"
         *         }
         *       ]
         *     }
         */
        AlertRuleListResponse: {
            /**
             * Rules
             * @description List of alert rules
             */
            rules: components["schemas"]["AlertRuleResponse"][];
            /**
             * Count
             * @description Total number of rules
             */
            count: number;
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * AlertRuleResponse
         * @description Schema for alert rule response.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "channels": [
         *         "pushover",
         *         "webhook"
         *       ],
         *       "cooldown_seconds": 300,
         *       "created_at": "2025-12-28T12:00:00Z",
         *       "dedup_key_template": "{camera_id}:{rule_id}",
         *       "description": "High-priority alert for person detection at night",
         *       "enabled": true,
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "min_confidence": 0.8,
         *       "name": "Night Intruder Alert",
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_threshold": 70,
         *       "schedule": {
         *         "days": [
         *           "monday",
         *           "tuesday",
         *           "wednesday",
         *           "thursday",
         *           "friday"
         *         ],
         *         "end_time": "06:00",
         *         "start_time": "22:00",
         *         "timezone": "America/New_York"
         *       },
         *       "severity": "critical",
         *       "updated_at": "2025-12-28T12:00:00Z"
         *     }
         */
        AlertRuleResponse: {
            /**
             * Id
             * @description Alert rule UUID
             */
            id: string;
            /**
             * Name
             * @description Rule name
             */
            name: string;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             */
            enabled: boolean;
            /** @description Severity level */
            severity: components["schemas"]["AlertSeverity"];
            /**
             * Risk Threshold
             * @description Risk score threshold
             */
            risk_threshold?: number | null;
            /**
             * Object Types
             * @description Object types to match
             */
            object_types?: string[] | null;
            /**
             * Camera Ids
             * @description Camera IDs to apply to
             */
            camera_ids?: string[] | null;
            /**
             * Zone Ids
             * @description Zone IDs to match
             */
            zone_ids?: string[] | null;
            /**
             * Min Confidence
             * @description Minimum confidence
             */
            min_confidence?: number | null;
            /**
             * Schedule
             * @description Time-based conditions
             */
            schedule?: {
                [key: string]: unknown;
            } | null;
            /**
             * Conditions
             * @description Legacy conditions
             */
            conditions?: {
                [key: string]: unknown;
            } | null;
            /**
             * Dedup Key Template
             * @description Template for dedup key
             */
            dedup_key_template: string;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             */
            cooldown_seconds: number;
            /**
             * Channels
             * @description Notification channels
             */
            channels?: string[];
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             * @description Last update timestamp
             */
            updated_at: string;
        };
        /**
         * AlertRuleSchedule
         * @description Schema for alert rule schedule (time-based conditions).
         *
         *     If start_time > end_time, the schedule spans midnight (e.g., 22:00-06:00).
         *     Empty days array means all days. No schedule = always active (vacation mode).
         * @example {
         *       "days": [
         *         "monday",
         *         "tuesday",
         *         "wednesday",
         *         "thursday",
         *         "friday"
         *       ],
         *       "end_time": "06:00",
         *       "start_time": "22:00",
         *       "timezone": "America/New_York"
         *     }
         */
        AlertRuleSchedule: {
            /**
             * Days
             * @description Days of week when rule is active (empty = all days). Values: monday, tuesday, wednesday, thursday, friday, saturday, sunday
             */
            days?: string[] | null;
            /**
             * Start Time
             * @description Start time in HH:MM format
             */
            start_time?: string | null;
            /**
             * End Time
             * @description End time in HH:MM format
             */
            end_time?: string | null;
            /**
             * Timezone
             * @description Timezone for time evaluation
             * @default UTC
             */
            timezone: string;
        };
        /**
         * AlertRuleUpdate
         * @description Schema for updating an alert rule (PATCH).
         *
         *     Only provided fields will be updated. Null values clear the field.
         * @example {
         *       "cooldown_seconds": 600,
         *       "enabled": false,
         *       "risk_threshold": 80
         *     }
         */
        AlertRuleUpdate: {
            /**
             * Name
             * @description Rule name
             */
            name?: string | null;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             */
            enabled?: boolean | null;
            /** @description Severity level */
            severity?: components["schemas"]["AlertSeverity"] | null;
            /**
             * Risk Threshold
             * @description Alert when risk_score >= threshold
             */
            risk_threshold?: number | null;
            /**
             * Object Types
             * @description Object types to match
             */
            object_types?: string[] | null;
            /**
             * Camera Ids
             * @description Camera IDs to apply rule to
             */
            camera_ids?: string[] | null;
            /**
             * Zone Ids
             * @description Zone IDs to match
             */
            zone_ids?: string[] | null;
            /**
             * Min Confidence
             * @description Minimum detection confidence
             */
            min_confidence?: number | null;
            /** @description Time-based conditions */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /** @description Legacy conditions */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Dedup Key Template
             * @description Template for dedup key
             */
            dedup_key_template?: string | null;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             */
            cooldown_seconds?: number | null;
            /**
             * Channels
             * @description Notification channels for this rule
             */
            channels?: string[] | null;
        };
        /**
         * AlertSeverity
         * @description Alert severity levels.
         * @enum {string}
         */
        AlertSeverity: "low" | "medium" | "high" | "critical";
        /**
         * AuditLogListResponse
         * @description Schema for paginated audit log response.
         */
        AuditLogListResponse: {
            /**
             * Logs
             * @description List of audit log entries
             */
            logs: components["schemas"]["AuditLogResponse"][];
            /**
             * Count
             * @description Total count matching filters
             */
            count: number;
            /**
             * Limit
             * @description Page size
             */
            limit: number;
            /**
             * Offset
             * @description Page offset
             */
            offset: number;
        };
        /**
         * AuditLogResponse
         * @description Schema for a single audit log entry.
         */
        AuditLogResponse: {
            /**
             * Id
             * @description Audit log entry ID
             */
            id: number;
            /**
             * Timestamp
             * Format: date-time
             * @description When the action occurred
             */
            timestamp: string;
            /**
             * Action
             * @description The action performed
             */
            action: string;
            /**
             * Resource Type
             * @description Type of resource (event, alert, rule, camera, settings)
             */
            resource_type: string;
            /**
             * Resource Id
             * @description ID of the specific resource
             */
            resource_id?: string | null;
            /**
             * Actor
             * @description User or system that performed the action
             */
            actor: string;
            /**
             * Ip Address
             * @description IP address of the client
             */
            ip_address?: string | null;
            /**
             * User Agent
             * @description User agent string of the client
             */
            user_agent?: string | null;
            /**
             * Details
             * @description Action-specific details
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * Status
             * @description Status of the action (success/failure)
             */
            status: string;
        };
        /**
         * AuditLogStats
         * @description Schema for audit log statistics.
         */
        AuditLogStats: {
            /**
             * Total Logs
             * @description Total number of audit logs
             */
            total_logs: number;
            /**
             * Logs Today
             * @description Number of logs today
             */
            logs_today: number;
            /**
             * By Action
             * @description Counts by action type
             */
            by_action: {
                [key: string]: number;
            };
            /**
             * By Resource Type
             * @description Counts by resource type
             */
            by_resource_type: {
                [key: string]: number;
            };
            /**
             * By Status
             * @description Counts by status
             */
            by_status: {
                [key: string]: number;
            };
            /**
             * Recent Actors
             * @description Recently active actors
             */
            recent_actors: string[];
        };
        /**
         * CameraCreate
         * @description Schema for creating a new camera.
         * @example {
         *       "folder_path": "/export/foscam/front_door",
         *       "name": "Front Door Camera",
         *       "status": "online"
         *     }
         */
        CameraCreate: {
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path: string;
            /**
             * Status
             * @description Camera status (online, offline, error)
             * @default online
             */
            status: string;
        };
        /**
         * CameraListResponse
         * @description Schema for camera list response.
         * @example {
         *       "cameras": [
         *         {
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "folder_path": "/export/foscam/front_door",
         *           "id": "123e4567-e89b-12d3-a456-426614174000",
         *           "last_seen_at": "2025-12-23T12:00:00Z",
         *           "name": "Front Door Camera",
         *           "status": "online"
         *         }
         *       ],
         *       "count": 1
         *     }
         */
        CameraListResponse: {
            /**
             * Cameras
             * @description List of cameras
             */
            cameras: components["schemas"]["CameraResponse"][];
            /**
             * Count
             * @description Total number of cameras
             */
            count: number;
        };
        /**
         * CameraResponse
         * @description Schema for camera response.
         * @example {
         *       "created_at": "2025-12-23T10:00:00Z",
         *       "folder_path": "/export/foscam/front_door",
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "last_seen_at": "2025-12-23T12:00:00Z",
         *       "name": "Front Door Camera",
         *       "status": "online"
         *     }
         */
        CameraResponse: {
            /**
             * Id
             * @description Camera UUID
             */
            id: string;
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path: string;
            /**
             * Status
             * @description Camera status
             */
            status: string;
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when camera was created
             */
            created_at: string;
            /**
             * Last Seen At
             * @description Last time camera was active
             */
            last_seen_at?: string | null;
        };
        /**
         * CameraUpdate
         * @description Schema for updating an existing camera.
         * @example {
         *       "name": "Front Door Camera - Updated",
         *       "status": "offline"
         *     }
         */
        CameraUpdate: {
            /**
             * Name
             * @description Camera name
             */
            name?: string | null;
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path?: string | null;
            /**
             * Status
             * @description Camera status (online, offline, error)
             */
            status?: string | null;
        };
        /**
         * CleanupResponse
         * @description Response schema for data cleanup endpoint.
         *
         *     Returns statistics about the cleanup operation including counts of
         *     deleted records and files. When dry_run is True, the counts represent
         *     what would be deleted without actually deleting.
         * @example {
         *       "detections_deleted": 89,
         *       "dry_run": false,
         *       "events_deleted": 15,
         *       "gpu_stats_deleted": 2880,
         *       "images_deleted": 0,
         *       "logs_deleted": 150,
         *       "retention_days": 30,
         *       "space_reclaimed": 524288000,
         *       "thumbnails_deleted": 89,
         *       "timestamp": "2025-12-27T10:30:00Z"
         *     }
         */
        CleanupResponse: {
            /**
             * Events Deleted
             * @description Number of events deleted (or would be deleted in dry run)
             */
            events_deleted: number;
            /**
             * Detections Deleted
             * @description Number of detections deleted (or would be deleted in dry run)
             */
            detections_deleted: number;
            /**
             * Gpu Stats Deleted
             * @description Number of GPU stat records deleted (or would be deleted in dry run)
             */
            gpu_stats_deleted: number;
            /**
             * Logs Deleted
             * @description Number of log records deleted (or would be deleted in dry run)
             */
            logs_deleted: number;
            /**
             * Thumbnails Deleted
             * @description Number of thumbnail files deleted (or would be deleted in dry run)
             */
            thumbnails_deleted: number;
            /**
             * Images Deleted
             * @description Number of original image files deleted (or would be deleted in dry run)
             */
            images_deleted: number;
            /**
             * Space Reclaimed
             * @description Estimated disk space freed in bytes (or would be freed in dry run)
             */
            space_reclaimed: number;
            /**
             * Retention Days
             * @description Retention period used for cleanup
             */
            retention_days: number;
            /**
             * Dry Run
             * @description Whether this was a dry run (no actual deletion performed)
             * @default false
             */
            dry_run: boolean;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of cleanup operation
             */
            timestamp: string;
        };
        /**
         * ClearDataRequest
         * @description Request schema for clearing data - requires confirmation.
         */
        ClearDataRequest: {
            /**
             * Confirm
             * @description Must be exactly 'DELETE_ALL_DATA' to confirm deletion
             */
            confirm: string;
        };
        /**
         * ClearDataResponse
         * @description Response schema for clear data endpoint.
         */
        ClearDataResponse: {
            /** Cameras Cleared */
            cameras_cleared: number;
            /** Events Cleared */
            events_cleared: number;
            /** Detections Cleared */
            detections_cleared: number;
        };
        /**
         * ConfigResponse
         * @description Response schema for configuration endpoint.
         *
         *     Only includes public, non-sensitive configuration values.
         * @example {
         *       "app_name": "Home Security Intelligence",
         *       "batch_idle_timeout_seconds": 30,
         *       "batch_window_seconds": 90,
         *       "detection_confidence_threshold": 0.5,
         *       "retention_days": 30,
         *       "version": "0.1.0"
         *     }
         */
        ConfigResponse: {
            /**
             * App Name
             * @description Application name
             */
            app_name: string;
            /**
             * Version
             * @description Application version
             */
            version: string;
            /**
             * Retention Days
             * @description Number of days to retain events and detections
             */
            retention_days: number;
            /**
             * Batch Window Seconds
             * @description Time window for batch processing detections
             */
            batch_window_seconds: number;
            /**
             * Batch Idle Timeout Seconds
             * @description Idle timeout before processing incomplete batch
             */
            batch_idle_timeout_seconds: number;
            /**
             * Detection Confidence Threshold
             * @description Minimum confidence threshold for detections (0.0-1.0)
             */
            detection_confidence_threshold: number;
        };
        /**
         * ConfigUpdateRequest
         * @description Request schema for PATCH /api/system/config.
         *
         *     Only supports a subset of processing-related settings.
         */
        ConfigUpdateRequest: {
            /**
             * Retention Days
             * @description Number of days to retain events and detections
             */
            retention_days?: number | null;
            /**
             * Batch Window Seconds
             * @description Time window for batch processing detections
             */
            batch_window_seconds?: number | null;
            /**
             * Batch Idle Timeout Seconds
             * @description Idle timeout before processing incomplete batch
             */
            batch_idle_timeout_seconds?: number | null;
            /**
             * Detection Confidence Threshold
             * @description Minimum confidence threshold for detections (0.0-1.0)
             */
            detection_confidence_threshold?: number | null;
        };
        /**
         * DLQClearResponse
         * @description Response schema for clearing a DLQ.
         * @example {
         *       "message": "Cleared 5 jobs from dlq:detection_queue",
         *       "queue_name": "dlq:detection_queue",
         *       "success": true
         *     }
         */
        DLQClearResponse: {
            /**
             * Success
             * @description Whether the clear operation succeeded
             */
            success: boolean;
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Queue Name
             * @description Name of the cleared queue
             */
            queue_name: string;
        };
        /**
         * DLQJobResponse
         * @description Response schema for a single job in the dead-letter queue.
         * @example {
         *       "attempt_count": 3,
         *       "error": "Connection refused: detector service unavailable",
         *       "first_failed_at": "2025-12-23T10:30:05.000000",
         *       "last_failed_at": "2025-12-23T10:30:15.000000",
         *       "original_job": {
         *         "camera_id": "front_door",
         *         "file_path": "/export/foscam/front_door/image_001.jpg",
         *         "timestamp": "2025-12-23T10:30:00.000000"
         *       },
         *       "queue_name": "detection_queue"
         *     }
         */
        DLQJobResponse: {
            /**
             * Original Job
             * @description Original job payload that failed
             */
            original_job: {
                [key: string]: unknown;
            };
            /**
             * Error
             * @description Error message from the last failure attempt
             */
            error: string;
            /**
             * Attempt Count
             * @description Number of processing attempts made
             */
            attempt_count: number;
            /**
             * First Failed At
             * @description ISO timestamp of the first failure
             */
            first_failed_at: string;
            /**
             * Last Failed At
             * @description ISO timestamp of the last failure
             */
            last_failed_at: string;
            /**
             * Queue Name
             * @description Name of the original queue where the job came from
             */
            queue_name: string;
        };
        /**
         * DLQJobsResponse
         * @description Response schema for listing jobs in a DLQ.
         * @example {
         *       "count": 1,
         *       "jobs": [
         *         {
         *           "attempt_count": 3,
         *           "error": "Connection refused",
         *           "first_failed_at": "2025-12-23T10:30:05.000000",
         *           "last_failed_at": "2025-12-23T10:30:15.000000",
         *           "original_job": {
         *             "camera_id": "front_door",
         *             "file_path": "/export/foscam/front_door/image_001.jpg",
         *             "timestamp": "2025-12-23T10:30:00.000000"
         *           },
         *           "queue_name": "detection_queue"
         *         }
         *       ],
         *       "queue_name": "dlq:detection_queue"
         *     }
         */
        DLQJobsResponse: {
            /**
             * Queue Name
             * @description Name of the dead-letter queue
             */
            queue_name: string;
            /**
             * Jobs
             * @description List of jobs in the queue
             */
            jobs: components["schemas"]["DLQJobResponse"][];
            /**
             * Count
             * @description Number of jobs returned
             */
            count: number;
        };
        /**
         * DLQName
         * @description Available dead-letter queue names.
         * @enum {string}
         */
        DLQName: "dlq:detection_queue" | "dlq:analysis_queue";
        /**
         * DLQRequeueResponse
         * @description Response schema for requeuing a job from DLQ.
         * @example {
         *       "job": {
         *         "camera_id": "front_door",
         *         "file_path": "/export/foscam/front_door/image_001.jpg",
         *         "timestamp": "2025-12-23T10:30:00.000000"
         *       },
         *       "message": "Job requeued from dlq:detection_queue to detection_queue",
         *       "success": true
         *     }
         */
        DLQRequeueResponse: {
            /**
             * Success
             * @description Whether the requeue operation succeeded
             */
            success: boolean;
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Job
             * @description The requeued job data (if successful)
             */
            job?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * DLQStatsResponse
         * @description Response schema for DLQ statistics.
         * @example {
         *       "analysis_queue_count": 1,
         *       "detection_queue_count": 2,
         *       "total_count": 3
         *     }
         */
        DLQStatsResponse: {
            /**
             * Detection Queue Count
             * @description Number of jobs in the detection DLQ
             */
            detection_queue_count: number;
            /**
             * Analysis Queue Count
             * @description Number of jobs in the analysis DLQ
             */
            analysis_queue_count: number;
            /**
             * Total Count
             * @description Total number of jobs across all DLQs
             */
            total_count: number;
        };
        /**
         * DetectionListResponse
         * @description Schema for detection list response with pagination.
         * @example {
         *       "count": 1,
         *       "detections": [
         *         {
         *           "bbox_height": 400,
         *           "bbox_width": 200,
         *           "bbox_x": 100,
         *           "bbox_y": 150,
         *           "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *           "confidence": 0.95,
         *           "detected_at": "2025-12-23T12:00:00Z",
         *           "file_path": "/export/foscam/front_door/20251223_120000.jpg",
         *           "file_type": "image/jpeg",
         *           "id": 1,
         *           "object_type": "person",
         *           "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
         *         }
         *       ],
         *       "limit": 50,
         *       "offset": 0
         *     }
         */
        DetectionListResponse: {
            /**
             * Detections
             * @description List of detections
             */
            detections: components["schemas"]["DetectionResponse"][];
            /**
             * Count
             * @description Total number of detections matching filters
             */
            count: number;
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * DetectionResponse
         * @description Schema for detection response.
         * @example {
         *       "bbox_height": 400,
         *       "bbox_width": 200,
         *       "bbox_x": 100,
         *       "bbox_y": 150,
         *       "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *       "confidence": 0.95,
         *       "detected_at": "2025-12-23T12:00:00Z",
         *       "file_path": "/export/foscam/front_door/20251223_120000.jpg",
         *       "file_type": "image/jpeg",
         *       "id": 1,
         *       "media_type": "image",
         *       "object_type": "person",
         *       "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
         *     }
         */
        DetectionResponse: {
            /**
             * Id
             * @description Detection ID
             */
            id: number;
            /**
             * Camera Id
             * @description Camera UUID
             */
            camera_id: string;
            /**
             * File Path
             * @description Path to source image or video file
             */
            file_path: string;
            /**
             * File Type
             * @description MIME type of source file
             */
            file_type?: string | null;
            /**
             * Detected At
             * Format: date-time
             * @description Timestamp when detection was made
             */
            detected_at: string;
            /**
             * Object Type
             * @description Type of detected object (person, car, etc.)
             */
            object_type?: string | null;
            /**
             * Confidence
             * @description Detection confidence score (0-1)
             */
            confidence?: number | null;
            /**
             * Bbox X
             * @description Bounding box X coordinate
             */
            bbox_x?: number | null;
            /**
             * Bbox Y
             * @description Bounding box Y coordinate
             */
            bbox_y?: number | null;
            /**
             * Bbox Width
             * @description Bounding box width
             */
            bbox_width?: number | null;
            /**
             * Bbox Height
             * @description Bounding box height
             */
            bbox_height?: number | null;
            /**
             * Thumbnail Path
             * @description Path to thumbnail image with bbox overlay
             */
            thumbnail_path?: string | null;
            /**
             * Media Type
             * @description Media type: 'image' or 'video'
             * @default image
             */
            media_type: string | null;
            /**
             * Duration
             * @description Video duration in seconds (video only)
             */
            duration?: number | null;
            /**
             * Video Codec
             * @description Video codec (e.g., h264, hevc)
             */
            video_codec?: string | null;
            /**
             * Video Width
             * @description Video resolution width
             */
            video_width?: number | null;
            /**
             * Video Height
             * @description Video resolution height
             */
            video_height?: number | null;
        };
        /**
         * EventListResponse
         * @description Schema for event list response with pagination.
         * @example {
         *       "count": 1,
         *       "events": [
         *         {
         *           "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Person detected near front entrance"
         *         }
         *       ],
         *       "limit": 50,
         *       "offset": 0
         *     }
         */
        EventListResponse: {
            /**
             * Events
             * @description List of events
             */
            events: components["schemas"]["EventResponse"][];
            /**
             * Count
             * @description Total number of events matching filters
             */
            count: number;
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * EventResponse
         * @description Schema for event response.
         * @example {
         *       "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *       "detection_count": 5,
         *       "detection_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "ended_at": "2025-12-23T12:02:30Z",
         *       "id": 1,
         *       "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
         *       "reviewed": false,
         *       "risk_level": "medium",
         *       "risk_score": 75,
         *       "started_at": "2025-12-23T12:00:00Z",
         *       "summary": "Person detected near front entrance"
         *     }
         */
        EventResponse: {
            /**
             * Id
             * @description Event ID
             */
            id: number;
            /**
             * Camera Id
             * @description Camera UUID
             */
            camera_id: string;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score?: number | null;
            /**
             * Risk Level
             * @description Risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Summary
             * @description LLM-generated event summary
             */
            summary?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning for risk score
             */
            reasoning?: string | null;
            /**
             * Reviewed
             * @description Whether event has been reviewed
             * @default false
             */
            reviewed: boolean;
            /**
             * Notes
             * @description User notes for the event
             */
            notes?: string | null;
            /**
             * Detection Count
             * @description Number of detections in this event
             * @default 0
             */
            detection_count: number;
            /**
             * Detection Ids
             * @description List of detection IDs associated with this event
             */
            detection_ids?: number[];
        };
        /**
         * EventStatsResponse
         * @description Schema for aggregated event statistics.
         * @example {
         *       "events_by_camera": [
         *         {
         *           "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *           "camera_name": "Front Door",
         *           "event_count": 30
         *         },
         *         {
         *           "camera_id": "456e7890-e89b-12d3-a456-426614174001",
         *           "camera_name": "Back Door",
         *           "event_count": 14
         *         }
         *       ],
         *       "events_by_risk_level": {
         *         "critical": 2,
         *         "high": 5,
         *         "low": 25,
         *         "medium": 12
         *       },
         *       "total_events": 44
         *     }
         */
        EventStatsResponse: {
            /**
             * Total Events
             * @description Total number of events
             */
            total_events: number;
            /** @description Events grouped by risk level */
            events_by_risk_level: components["schemas"]["EventsByRiskLevel"];
            /**
             * Events By Camera
             * @description Events grouped by camera
             */
            events_by_camera: components["schemas"]["EventsByCamera"][];
        };
        /**
         * EventUpdate
         * @description Schema for updating an event (PATCH).
         * @example {
         *       "notes": "Verified - delivery person",
         *       "reviewed": true
         *     }
         */
        EventUpdate: {
            /**
             * Reviewed
             * @description Mark event as reviewed or not reviewed
             */
            reviewed?: boolean | null;
            /**
             * Notes
             * @description User notes for the event
             */
            notes?: string | null;
        };
        /**
         * EventsByCamera
         * @description Schema for events count by camera.
         * @example {
         *       "camera_id": "123e4567-e89b-12d3-a456-426614174000",
         *       "camera_name": "Front Door",
         *       "event_count": 15
         *     }
         */
        EventsByCamera: {
            /**
             * Camera Id
             * @description Camera UUID
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera name
             */
            camera_name: string;
            /**
             * Event Count
             * @description Number of events for this camera
             */
            event_count: number;
        };
        /**
         * EventsByRiskLevel
         * @description Schema for events count by risk level.
         * @example {
         *       "critical": 2,
         *       "high": 5,
         *       "low": 25,
         *       "medium": 12
         *     }
         */
        EventsByRiskLevel: {
            /**
             * Critical
             * @description Number of critical risk events
             * @default 0
             */
            critical: number;
            /**
             * High
             * @description Number of high risk events
             * @default 0
             */
            high: number;
            /**
             * Medium
             * @description Number of medium risk events
             * @default 0
             */
            medium: number;
            /**
             * Low
             * @description Number of low risk events
             * @default 0
             */
            low: number;
        };
        /**
         * FrontendLogCreate
         * @description Schema for frontend log submission.
         */
        FrontendLogCreate: {
            /**
             * Level
             * @description Log level
             */
            level: string;
            /**
             * Component
             * @description Frontend component name
             */
            component: string;
            /**
             * Message
             * @description Log message
             */
            message: string;
            /**
             * Extra
             * @description Additional context
             */
            extra?: {
                [key: string]: unknown;
            } | null;
            /**
             * User Agent
             * @description Browser user agent
             */
            user_agent?: string | null;
            /**
             * Url
             * @description Page URL where log occurred
             */
            url?: string | null;
        };
        /**
         * GPUStatsHistoryResponse
         * @description Response schema for GPU stats history endpoint.
         */
        GPUStatsHistoryResponse: {
            /**
             * Samples
             * @description GPU stats samples (chronological order)
             */
            samples: components["schemas"]["GPUStatsSample"][];
            /**
             * Count
             * @description Number of samples returned
             */
            count: number;
            /**
             * Limit
             * @description Applied limit
             */
            limit: number;
        };
        /**
         * GPUStatsResponse
         * @description Response schema for GPU statistics endpoint.
         * @example {
         *       "gpu_name": "NVIDIA RTX A5500",
         *       "inference_fps": 30.5,
         *       "memory_total": 24000,
         *       "memory_used": 12000,
         *       "power_usage": 150,
         *       "temperature": 65,
         *       "utilization": 75.5
         *     }
         */
        GPUStatsResponse: {
            /**
             * Gpu Name
             * @description GPU device name (e.g., 'NVIDIA RTX A5500')
             */
            gpu_name?: string | null;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization?: number | null;
            /**
             * Memory Used
             * @description GPU memory used in MB
             */
            memory_used?: number | null;
            /**
             * Memory Total
             * @description Total GPU memory in MB
             */
            memory_total?: number | null;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature?: number | null;
            /**
             * Power Usage
             * @description GPU power usage in watts
             */
            power_usage?: number | null;
            /**
             * Inference Fps
             * @description Inference frames per second
             */
            inference_fps?: number | null;
        };
        /**
         * GPUStatsSample
         * @description Single time-series sample of GPU statistics.
         */
        GPUStatsSample: {
            /**
             * Recorded At
             * Format: date-time
             * @description When the GPU sample was recorded (UTC)
             */
            recorded_at: string;
            /**
             * Gpu Name
             * @description GPU device name
             */
            gpu_name?: string | null;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization?: number | null;
            /**
             * Memory Used
             * @description GPU memory used in MB
             */
            memory_used?: number | null;
            /**
             * Memory Total
             * @description Total GPU memory in MB
             */
            memory_total?: number | null;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature?: number | null;
            /**
             * Power Usage
             * @description GPU power usage in watts
             */
            power_usage?: number | null;
            /**
             * Inference Fps
             * @description Inference frames per second
             */
            inference_fps?: number | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * HealthResponse
         * @description Response schema for health check endpoint.
         * @example {
         *       "services": {
         *         "ai": {
         *           "message": "AI services operational",
         *           "status": "healthy"
         *         },
         *         "database": {
         *           "message": "Database operational",
         *           "status": "healthy"
         *         },
         *         "redis": {
         *           "details": {
         *             "redis_version": "7.0.0"
         *           },
         *           "message": "Redis connected",
         *           "status": "healthy"
         *         }
         *       },
         *       "status": "healthy",
         *       "timestamp": "2025-12-23T10:30:00"
         *     }
         */
        HealthResponse: {
            /**
             * Status
             * @description Overall system status: healthy, degraded, or unhealthy
             */
            status: string;
            /**
             * Services
             * @description Status of individual services (database, redis, ai)
             */
            services: {
                [key: string]: components["schemas"]["ServiceStatus"];
            };
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of health check
             */
            timestamp: string;
        };
        /**
         * LivenessResponse
         * @description Response schema for liveness probe endpoint.
         *
         *     Liveness probes indicate whether the process is running and able to
         *     respond to HTTP requests. This is a minimal check that always returns
         *     200 if the process is up.
         * @example {
         *       "status": "alive"
         *     }
         */
        LivenessResponse: {
            /**
             * Status
             * @description Liveness status: always 'alive' if process is responding
             * @default alive
             */
            status: string;
        };
        /**
         * LogEntry
         * @description Schema for a single log entry.
         */
        LogEntry: {
            /**
             * Id
             * @description Log entry ID
             */
            id: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Log timestamp
             */
            timestamp: string;
            /**
             * Level
             * @description Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
             */
            level: string;
            /**
             * Component
             * @description Component/module name
             */
            component: string;
            /**
             * Message
             * @description Log message
             */
            message: string;
            /**
             * Camera Id
             * @description Associated camera ID
             */
            camera_id?: string | null;
            /**
             * Event Id
             * @description Associated event ID
             */
            event_id?: number | null;
            /**
             * Request Id
             * @description Request correlation ID
             */
            request_id?: string | null;
            /**
             * Detection Id
             * @description Associated detection ID
             */
            detection_id?: number | null;
            /**
             * Duration Ms
             * @description Operation duration in milliseconds
             */
            duration_ms?: number | null;
            /**
             * Extra
             * @description Additional structured data
             */
            extra?: {
                [key: string]: unknown;
            } | null;
            /**
             * Source
             * @description Log source (backend, frontend)
             * @default backend
             */
            source: string;
        };
        /**
         * LogStats
         * @description Schema for log statistics (dashboard).
         */
        LogStats: {
            /**
             * Total Today
             * @description Total logs today
             */
            total_today: number;
            /**
             * Errors Today
             * @description Error count today
             */
            errors_today: number;
            /**
             * Warnings Today
             * @description Warning count today
             */
            warnings_today: number;
            /**
             * By Component
             * @description Counts by component
             */
            by_component: {
                [key: string]: number;
            };
            /**
             * By Level
             * @description Counts by level
             */
            by_level: {
                [key: string]: number;
            };
            /**
             * Top Component
             * @description Most active component
             */
            top_component?: string | null;
        };
        /**
         * LogsResponse
         * @description Schema for paginated logs response.
         */
        LogsResponse: {
            /**
             * Logs
             * @description List of log entries
             */
            logs: components["schemas"]["LogEntry"][];
            /**
             * Count
             * @description Total count matching filters
             */
            count: number;
            /**
             * Limit
             * @description Page size
             */
            limit: number;
            /**
             * Offset
             * @description Page offset
             */
            offset: number;
        };
        /**
         * MediaErrorResponse
         * @description Error response for media access failures.
         */
        MediaErrorResponse: {
            /**
             * Error
             * @description Error message describing what went wrong
             */
            error: string;
            /**
             * Path
             * @description The path that was attempted to be accessed
             */
            path: string;
        };
        /**
         * NotificationChannel
         * @description Notification channel types.
         * @enum {string}
         */
        NotificationChannel: "email" | "webhook" | "push";
        /**
         * NotificationConfigResponse
         * @description Schema for notification configuration status.
         * @example {
         *       "available_channels": [
         *         "email",
         *         "webhook"
         *       ],
         *       "default_email_recipients": [
         *         "user@example.com"
         *       ],
         *       "default_webhook_url": "https://example.com/webhook",
         *       "email_configured": true,
         *       "notification_enabled": true,
         *       "push_configured": false,
         *       "smtp_from_address": "alerts@example.com",
         *       "smtp_host": "smtp.example.com",
         *       "smtp_port": 587,
         *       "smtp_use_tls": true,
         *       "webhook_configured": true,
         *       "webhook_timeout_seconds": 30
         *     }
         */
        NotificationConfigResponse: {
            /**
             * Notification Enabled
             * @description Whether notifications are enabled
             */
            notification_enabled: boolean;
            /**
             * Email Configured
             * @description Whether email (SMTP) is configured
             */
            email_configured: boolean;
            /**
             * Webhook Configured
             * @description Whether webhook is configured
             */
            webhook_configured: boolean;
            /**
             * Push Configured
             * @description Whether push notifications are configured
             */
            push_configured: boolean;
            /**
             * Available Channels
             * @description List of channels that are properly configured
             */
            available_channels: components["schemas"]["NotificationChannel"][];
            /**
             * Smtp Host
             * @description Configured SMTP host (if any)
             */
            smtp_host?: string | null;
            /**
             * Smtp Port
             * @description Configured SMTP port
             */
            smtp_port?: number | null;
            /**
             * Smtp From Address
             * @description Configured sender email
             */
            smtp_from_address?: string | null;
            /**
             * Smtp Use Tls
             * @description Whether TLS is enabled for SMTP
             */
            smtp_use_tls?: boolean | null;
            /**
             * Default Webhook Url
             * @description Default webhook URL
             */
            default_webhook_url?: string | null;
            /**
             * Webhook Timeout Seconds
             * @description Webhook request timeout
             */
            webhook_timeout_seconds?: number | null;
            /**
             * Default Email Recipients
             * @description Default email recipients
             */
            default_email_recipients?: string[];
        };
        /**
         * PipelineLatencies
         * @description Latency statistics for all pipeline stages.
         *
         *     Pipeline stages:
         *     - watch: File watcher detecting new images (file event -> queue)
         *     - detect: RT-DETRv2 object detection (image -> detections)
         *     - batch: Batch aggregation window (detections -> batch)
         *     - analyze: Nemotron LLM risk analysis (batch -> event)
         * @example {
         *       "analyze": {
         *         "avg_ms": 5000,
         *         "max_ms": 15000,
         *         "min_ms": 2000,
         *         "p50_ms": 4500,
         *         "p95_ms": 12000,
         *         "p99_ms": 14000,
         *         "sample_count": 100
         *       },
         *       "batch": {
         *         "avg_ms": 30000,
         *         "max_ms": 90000,
         *         "min_ms": 5000,
         *         "p50_ms": 25000,
         *         "p95_ms": 80000,
         *         "p99_ms": 88000,
         *         "sample_count": 100
         *       },
         *       "detect": {
         *         "avg_ms": 200,
         *         "max_ms": 800,
         *         "min_ms": 100,
         *         "p50_ms": 180,
         *         "p95_ms": 600,
         *         "p99_ms": 750,
         *         "sample_count": 500
         *       },
         *       "watch": {
         *         "avg_ms": 10,
         *         "max_ms": 50,
         *         "min_ms": 5,
         *         "p50_ms": 8,
         *         "p95_ms": 40,
         *         "p99_ms": 48,
         *         "sample_count": 500
         *       }
         *     }
         */
        PipelineLatencies: {
            /** @description File watcher stage latency (file event to queue) */
            watch?: components["schemas"]["StageLatency"] | null;
            /** @description Object detection stage latency (RT-DETRv2 inference) */
            detect?: components["schemas"]["StageLatency"] | null;
            /** @description Batch aggregation window time */
            batch?: components["schemas"]["StageLatency"] | null;
            /** @description LLM analysis stage latency (Nemotron inference) */
            analyze?: components["schemas"]["StageLatency"] | null;
        };
        /**
         * PipelineLatencyResponse
         * @description Response schema for pipeline latency endpoint.
         *
         *     Provides latency metrics for each stage transition in the AI pipeline:
         *     - watch_to_detect: Time from file watcher detecting image to RT-DETR processing start
         *     - detect_to_batch: Time from detection completion to batch aggregation
         *     - batch_to_analyze: Time from batch completion to Nemotron analysis start
         *     - total_pipeline: Total end-to-end processing time
         * @example {
         *       "batch_to_analyze": {
         *         "avg_ms": 5000,
         *         "max_ms": 15000,
         *         "min_ms": 2000,
         *         "p50_ms": 4500,
         *         "p95_ms": 12000,
         *         "p99_ms": 14000,
         *         "sample_count": 100
         *       },
         *       "detect_to_batch": {
         *         "avg_ms": 100,
         *         "max_ms": 500,
         *         "min_ms": 20,
         *         "p50_ms": 80,
         *         "p95_ms": 400,
         *         "p99_ms": 480,
         *         "sample_count": 500
         *       },
         *       "timestamp": "2025-12-28T10:30:00Z",
         *       "total_pipeline": {
         *         "avg_ms": 35000,
         *         "max_ms": 120000,
         *         "min_ms": 10000,
         *         "p50_ms": 30000,
         *         "p95_ms": 100000,
         *         "p99_ms": 110000,
         *         "sample_count": 100
         *       },
         *       "watch_to_detect": {
         *         "avg_ms": 50,
         *         "max_ms": 200,
         *         "min_ms": 10,
         *         "p50_ms": 40,
         *         "p95_ms": 150,
         *         "p99_ms": 180,
         *         "sample_count": 500
         *       },
         *       "window_minutes": 60
         *     }
         */
        PipelineLatencyResponse: {
            /** @description Latency from file detection to RT-DETR processing */
            watch_to_detect?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Latency from detection to batch aggregation */
            detect_to_batch?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Latency from batch to Nemotron analysis */
            batch_to_analyze?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Total end-to-end pipeline latency */
            total_pipeline?: components["schemas"]["PipelineStageLatency"] | null;
            /**
             * Window Minutes
             * @description Time window used for calculating statistics
             */
            window_minutes: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of latency snapshot
             */
            timestamp: string;
        };
        /**
         * PipelineStageLatency
         * @description Latency statistics for a single pipeline transition stage.
         *
         *     Tracks time between pipeline stages:
         *     - watch_to_detect: File detection to RT-DETR processing
         *     - detect_to_batch: Detection to batch aggregation
         *     - batch_to_analyze: Batch to Nemotron analysis
         *     - total_pipeline: End-to-end latency
         * @example {
         *       "avg_ms": 150.5,
         *       "max_ms": 500,
         *       "min_ms": 50,
         *       "p50_ms": 120,
         *       "p95_ms": 400,
         *       "p99_ms": 480,
         *       "sample_count": 100
         *     }
         */
        PipelineStageLatency: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms?: number | null;
            /**
             * Min Ms
             * @description Minimum latency in milliseconds
             */
            min_ms?: number | null;
            /**
             * Max Ms
             * @description Maximum latency in milliseconds
             */
            max_ms?: number | null;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms?: number | null;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms?: number | null;
            /**
             * P99 Ms
             * @description 99th percentile latency in milliseconds
             */
            p99_ms?: number | null;
            /**
             * Sample Count
             * @description Number of samples used to calculate statistics
             */
            sample_count: number;
        };
        /**
         * QueueDepths
         * @description Queue depth information for pipeline queues.
         * @example {
         *       "analysis_queue": 2,
         *       "detection_queue": 5
         *     }
         */
        QueueDepths: {
            /**
             * Detection Queue
             * @description Number of items in detection queue waiting for RT-DETRv2 processing
             */
            detection_queue: number;
            /**
             * Analysis Queue
             * @description Number of batches in analysis queue waiting for Nemotron LLM analysis
             */
            analysis_queue: number;
        };
        /**
         * ReadinessResponse
         * @description Response schema for readiness probe endpoint.
         *
         *     Readiness probes indicate whether the application is ready to receive
         *     traffic and process requests. This checks all dependencies:
         *     - Database connectivity
         *     - Redis connectivity
         *     - AI services availability
         *     - Background worker status
         * @example {
         *       "ready": true,
         *       "services": {
         *         "ai": {
         *           "message": "AI services operational",
         *           "status": "healthy"
         *         },
         *         "database": {
         *           "message": "Database operational",
         *           "status": "healthy"
         *         },
         *         "redis": {
         *           "details": {
         *             "redis_version": "7.0.0"
         *           },
         *           "message": "Redis connected",
         *           "status": "healthy"
         *         }
         *       },
         *       "status": "ready",
         *       "timestamp": "2025-12-23T10:30:00",
         *       "workers": [
         *         {
         *           "name": "gpu_monitor",
         *           "running": true
         *         },
         *         {
         *           "name": "cleanup_service",
         *           "running": true
         *         }
         *       ]
         *     }
         */
        ReadinessResponse: {
            /**
             * Ready
             * @description Overall readiness status: True if system can process requests
             */
            ready: boolean;
            /**
             * Status
             * @description Status string: 'ready', 'degraded', or 'not_ready'
             */
            status: string;
            /**
             * Services
             * @description Status of infrastructure services (database, redis, ai)
             */
            services: {
                [key: string]: components["schemas"]["ServiceStatus"];
            };
            /**
             * Workers
             * @description Status of background workers
             */
            workers?: components["schemas"]["WorkerStatus"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of readiness check
             */
            timestamp: string;
        };
        /**
         * RuleTestEventResult
         * @description Schema for a single event's test result.
         * @example {
         *       "camera_id": "front_door",
         *       "event_id": 123,
         *       "matched_conditions": [
         *         "risk_score >= 70",
         *         "object_type in ['person']"
         *       ],
         *       "matches": true,
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_score": 75,
         *       "started_at": "2025-12-28T22:15:00Z"
         *     }
         */
        RuleTestEventResult: {
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Risk Score
             * @description Event risk score
             */
            risk_score?: number | null;
            /**
             * Object Types
             * @description Detected object types
             */
            object_types?: string[];
            /**
             * Matches
             * @description Whether the rule matched this event
             */
            matches: boolean;
            /**
             * Matched Conditions
             * @description List of conditions that matched
             */
            matched_conditions?: string[];
            /**
             * Started At
             * @description Event start timestamp
             */
            started_at?: string | null;
        };
        /**
         * RuleTestRequest
         * @description Schema for testing a rule against historical events.
         * @example {
         *       "event_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "test_time": "2025-12-28T22:30:00Z"
         *     }
         */
        RuleTestRequest: {
            /**
             * Event Ids
             * @description Specific event IDs to test against. If not provided, tests against recent events.
             */
            event_ids?: number[] | null;
            /**
             * Limit
             * @description Maximum number of recent events to test (if event_ids not provided)
             * @default 10
             */
            limit: number;
            /**
             * Test Time
             * @description Override current time for schedule testing (ISO format)
             */
            test_time?: string | null;
        };
        /**
         * RuleTestResponse
         * @description Schema for rule test response.
         * @example {
         *       "events_matched": 3,
         *       "events_tested": 10,
         *       "match_rate": 0.3,
         *       "results": [
         *         {
         *           "camera_id": "front_door",
         *           "event_id": 123,
         *           "matched_conditions": [
         *             "risk_score >= 70",
         *             "object_type in ['person']"
         *           ],
         *           "matches": true,
         *           "object_types": [
         *             "person"
         *           ],
         *           "risk_score": 75,
         *           "started_at": "2025-12-28T22:15:00Z"
         *         }
         *       ],
         *       "rule_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "rule_name": "Night Intruder Alert"
         *     }
         */
        RuleTestResponse: {
            /**
             * Rule Id
             * @description Rule ID that was tested
             */
            rule_id: string;
            /**
             * Rule Name
             * @description Rule name
             */
            rule_name: string;
            /**
             * Events Tested
             * @description Number of events tested
             */
            events_tested: number;
            /**
             * Events Matched
             * @description Number of events that matched the rule
             */
            events_matched: number;
            /**
             * Match Rate
             * @description Proportion of events that matched (0.0-1.0)
             */
            match_rate: number;
            /**
             * Results
             * @description Per-event test results
             */
            results: components["schemas"]["RuleTestEventResult"][];
        };
        /**
         * SearchResponse
         * @description Schema for search response with pagination.
         * @example {
         *       "limit": 50,
         *       "offset": 0,
         *       "results": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "object_types": "person, vehicle",
         *           "reasoning": "Unknown individual approaching entrance during nighttime",
         *           "relevance_score": 0.85,
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Suspicious person detected near front entrance"
         *         }
         *       ],
         *       "total_count": 42
         *     }
         */
        SearchResponse: {
            /**
             * Results
             * @description List of search results
             */
            results: components["schemas"]["SearchResult"][];
            /**
             * Total Count
             * @description Total number of matching events
             */
            total_count: number;
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * SearchResult
         * @description Schema for a single search result.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "detection_count": 5,
         *       "detection_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "ended_at": "2025-12-23T12:02:30Z",
         *       "id": 1,
         *       "object_types": "person, vehicle",
         *       "reasoning": "Unknown individual approaching entrance during nighttime hours",
         *       "relevance_score": 0.85,
         *       "reviewed": false,
         *       "risk_level": "medium",
         *       "risk_score": 75,
         *       "started_at": "2025-12-23T12:00:00Z",
         *       "summary": "Suspicious person detected near front entrance"
         *     }
         */
        SearchResult: {
            /**
             * Id
             * @description Event ID
             */
            id: number;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera display name
             */
            camera_name?: string | null;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score?: number | null;
            /**
             * Risk Level
             * @description Risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Summary
             * @description LLM-generated event summary
             */
            summary?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning for risk score
             */
            reasoning?: string | null;
            /**
             * Reviewed
             * @description Whether event has been reviewed
             * @default false
             */
            reviewed: boolean;
            /**
             * Detection Count
             * @description Number of detections in this event
             * @default 0
             */
            detection_count: number;
            /**
             * Detection Ids
             * @description List of detection IDs associated with this event
             */
            detection_ids?: number[];
            /**
             * Object Types
             * @description Comma-separated detected object types
             */
            object_types?: string | null;
            /**
             * Relevance Score
             * @description Full-text search relevance score (higher is more relevant)
             * @default 0
             */
            relevance_score: number;
        };
        /**
         * SeedCamerasRequest
         * @description Request schema for seeding cameras.
         */
        SeedCamerasRequest: {
            /**
             * Count
             * @description Number of cameras to create (1-6)
             * @default 6
             */
            count: number;
            /**
             * Clear Existing
             * @description Remove existing cameras first
             * @default false
             */
            clear_existing: boolean;
            /**
             * Create Folders
             * @description Create camera folders on filesystem
             * @default false
             */
            create_folders: boolean;
        };
        /**
         * SeedCamerasResponse
         * @description Response schema for seed cameras endpoint.
         */
        SeedCamerasResponse: {
            /** Created */
            created: number;
            /** Cleared */
            cleared: number;
            /** Cameras */
            cameras: {
                [key: string]: unknown;
            }[];
        };
        /**
         * SeedEventsRequest
         * @description Request schema for seeding events.
         */
        SeedEventsRequest: {
            /**
             * Count
             * @description Number of events to create (1-100)
             * @default 15
             */
            count: number;
            /**
             * Clear Existing
             * @description Remove existing events and detections
             * @default false
             */
            clear_existing: boolean;
        };
        /**
         * SeedEventsResponse
         * @description Response schema for seed events endpoint.
         */
        SeedEventsResponse: {
            /** Events Created */
            events_created: number;
            /** Detections Created */
            detections_created: number;
            /** Events Cleared */
            events_cleared: number;
            /** Detections Cleared */
            detections_cleared: number;
        };
        /**
         * ServiceStatus
         * @description Status information for a service component.
         */
        ServiceStatus: {
            /**
             * Status
             * @description Service status: healthy, unhealthy, or not_initialized
             */
            status: string;
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
            /**
             * Details
             * @description Additional service-specific details
             */
            details?: {
                [key: string]: string;
            } | null;
        };
        /**
         * SeverityDefinitionResponse
         * @description Definition of a single severity level.
         * @example {
         *       "color": "#f97316",
         *       "description": "Concerning activity, review soon",
         *       "label": "High",
         *       "max_score": 84,
         *       "min_score": 60,
         *       "priority": 1,
         *       "severity": "high"
         *     }
         */
        SeverityDefinitionResponse: {
            /** @description The severity level identifier */
            severity: components["schemas"]["SeverityEnum"];
            /**
             * Label
             * @description Human-readable label for the severity level
             */
            label: string;
            /**
             * Description
             * @description Description of when this severity applies
             */
            description: string;
            /**
             * Color
             * @description Hex color code for UI display (e.g., '#22c55e')
             */
            color: string;
            /**
             * Priority
             * @description Sort priority (0 = highest priority, 3 = lowest)
             */
            priority: number;
            /**
             * Min Score
             * @description Minimum risk score for this severity (inclusive)
             */
            min_score: number;
            /**
             * Max Score
             * @description Maximum risk score for this severity (inclusive)
             */
            max_score: number;
        };
        /**
         * SeverityEnum
         * @description Severity levels for API responses.
         * @enum {string}
         */
        SeverityEnum: "low" | "medium" | "high" | "critical";
        /**
         * SeverityMetadataResponse
         * @description Response schema for severity metadata endpoint.
         *
         *     Provides complete information about severity levels including:
         *     - All severity definitions with thresholds and colors
         *     - Current threshold configuration
         *     - Useful for frontend to display severity information consistently
         * @example {
         *       "definitions": [
         *         {
         *           "color": "#22c55e",
         *           "description": "Routine activity, no concern",
         *           "label": "Low",
         *           "max_score": 29,
         *           "min_score": 0,
         *           "priority": 3,
         *           "severity": "low"
         *         },
         *         {
         *           "color": "#eab308",
         *           "description": "Notable activity, worth reviewing",
         *           "label": "Medium",
         *           "max_score": 59,
         *           "min_score": 30,
         *           "priority": 2,
         *           "severity": "medium"
         *         },
         *         {
         *           "color": "#f97316",
         *           "description": "Concerning activity, review soon",
         *           "label": "High",
         *           "max_score": 84,
         *           "min_score": 60,
         *           "priority": 1,
         *           "severity": "high"
         *         },
         *         {
         *           "color": "#ef4444",
         *           "description": "Immediate attention required",
         *           "label": "Critical",
         *           "max_score": 100,
         *           "min_score": 85,
         *           "priority": 0,
         *           "severity": "critical"
         *         }
         *       ],
         *       "thresholds": {
         *         "high_max": 84,
         *         "low_max": 29,
         *         "medium_max": 59
         *       }
         *     }
         */
        SeverityMetadataResponse: {
            /**
             * Definitions
             * @description List of all severity level definitions
             */
            definitions: components["schemas"]["SeverityDefinitionResponse"][];
            /** @description Current severity threshold configuration */
            thresholds: components["schemas"]["SeverityThresholds"];
        };
        /**
         * SeverityThresholds
         * @description Current severity threshold configuration.
         * @example {
         *       "high_max": 84,
         *       "low_max": 29,
         *       "medium_max": 59
         *     }
         */
        SeverityThresholds: {
            /**
             * Low Max
             * @description Maximum risk score for LOW severity (0 to this value = LOW)
             */
            low_max: number;
            /**
             * Medium Max
             * @description Maximum risk score for MEDIUM severity (low_max+1 to this value = MEDIUM)
             */
            medium_max: number;
            /**
             * High Max
             * @description Maximum risk score for HIGH severity (medium_max+1 to this value = HIGH)
             */
            high_max: number;
        };
        /**
         * StageLatency
         * @description Latency statistics for a single pipeline stage.
         * @example {
         *       "avg_ms": 150.5,
         *       "max_ms": 500,
         *       "min_ms": 50,
         *       "p50_ms": 120,
         *       "p95_ms": 400,
         *       "p99_ms": 480,
         *       "sample_count": 100
         *     }
         */
        StageLatency: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms?: number | null;
            /**
             * Min Ms
             * @description Minimum latency in milliseconds
             */
            min_ms?: number | null;
            /**
             * Max Ms
             * @description Maximum latency in milliseconds
             */
            max_ms?: number | null;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms?: number | null;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms?: number | null;
            /**
             * P99 Ms
             * @description 99th percentile latency in milliseconds
             */
            p99_ms?: number | null;
            /**
             * Sample Count
             * @description Number of samples used to calculate statistics
             */
            sample_count: number;
        };
        /**
         * StorageCategoryStats
         * @description Storage statistics for a single category.
         */
        StorageCategoryStats: {
            /**
             * File Count
             * @description Number of files in this category
             */
            file_count: number;
            /**
             * Size Bytes
             * @description Total size in bytes for this category
             */
            size_bytes: number;
        };
        /**
         * StorageStatsResponse
         * @description Response schema for storage statistics endpoint.
         *
         *     Provides detailed storage usage information including:
         *     - Disk usage for the storage volume
         *     - Breakdown by data category (thumbnails, images, clips)
         *     - Database record counts
         * @example {
         *       "clips": {
         *         "file_count": 50,
         *         "size_bytes": 500000000
         *       },
         *       "detections_count": 892,
         *       "disk_free_bytes": 429496729600,
         *       "disk_total_bytes": 536870912000,
         *       "disk_usage_percent": 20,
         *       "disk_used_bytes": 107374182400,
         *       "events_count": 156,
         *       "gpu_stats_count": 2880,
         *       "images": {
         *         "file_count": 10000,
         *         "size_bytes": 5000000000
         *       },
         *       "logs_count": 5000,
         *       "thumbnails": {
         *         "file_count": 1500,
         *         "size_bytes": 75000000
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        StorageStatsResponse: {
            /**
             * Disk Used Bytes
             * @description Total disk space used in bytes
             */
            disk_used_bytes: number;
            /**
             * Disk Total Bytes
             * @description Total disk space available in bytes
             */
            disk_total_bytes: number;
            /**
             * Disk Free Bytes
             * @description Free disk space in bytes
             */
            disk_free_bytes: number;
            /**
             * Disk Usage Percent
             * @description Disk usage percentage (0-100)
             */
            disk_usage_percent: number;
            /** @description Storage used by detection thumbnails */
            thumbnails: components["schemas"]["StorageCategoryStats"];
            /** @description Storage used by original camera images */
            images: components["schemas"]["StorageCategoryStats"];
            /** @description Storage used by event video clips */
            clips: components["schemas"]["StorageCategoryStats"];
            /**
             * Events Count
             * @description Total number of events in database
             */
            events_count: number;
            /**
             * Detections Count
             * @description Total number of detections in database
             */
            detections_count: number;
            /**
             * Gpu Stats Count
             * @description Total number of GPU stats records in database
             */
            gpu_stats_count: number;
            /**
             * Logs Count
             * @description Total number of log entries in database
             */
            logs_count: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of storage stats snapshot
             */
            timestamp: string;
        };
        /**
         * SystemStatsResponse
         * @description Response schema for system statistics endpoint.
         * @example {
         *       "total_cameras": 4,
         *       "total_detections": 892,
         *       "total_events": 156,
         *       "uptime_seconds": 86400.5
         *     }
         */
        SystemStatsResponse: {
            /**
             * Total Cameras
             * @description Total number of cameras in the system
             */
            total_cameras: number;
            /**
             * Total Events
             * @description Total number of events recorded
             */
            total_events: number;
            /**
             * Total Detections
             * @description Total number of detections recorded
             */
            total_detections: number;
            /**
             * Uptime Seconds
             * @description Application uptime in seconds
             */
            uptime_seconds: number;
        };
        /**
         * TelemetryResponse
         * @description Response schema for pipeline telemetry endpoint.
         *
         *     Provides real-time visibility into:
         *     - Queue depths: How many items are waiting in detection/analysis queues
         *     - Stage latencies: How long each pipeline stage is taking
         *
         *     This helps operators:
         *     - Identify pipeline bottlenecks
         *     - Detect backlog situations
         *     - Monitor processing performance
         *     - Debug pipeline stalls
         * @example {
         *       "latencies": {
         *         "detect": {
         *           "avg_ms": 200,
         *           "max_ms": 800,
         *           "min_ms": 100,
         *           "p50_ms": 180,
         *           "p95_ms": 600,
         *           "p99_ms": 750,
         *           "sample_count": 500
         *         },
         *         "watch": {
         *           "avg_ms": 10,
         *           "max_ms": 50,
         *           "min_ms": 5,
         *           "p50_ms": 8,
         *           "p95_ms": 40,
         *           "p99_ms": 48,
         *           "sample_count": 500
         *         }
         *       },
         *       "queues": {
         *         "analysis_queue": 2,
         *         "detection_queue": 5
         *       },
         *       "timestamp": "2025-12-27T10:30:00Z"
         *     }
         */
        TelemetryResponse: {
            /** @description Current queue depths for detection and analysis queues */
            queues: components["schemas"]["QueueDepths"];
            /** @description Latency statistics for each pipeline stage */
            latencies?: components["schemas"]["PipelineLatencies"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of telemetry snapshot
             */
            timestamp: string;
        };
        /**
         * TestNotificationRequest
         * @description Schema for testing notification configuration.
         * @example {
         *       "channel": "email",
         *       "email_recipients": [
         *         "test@example.com"
         *       ]
         *     }
         */
        TestNotificationRequest: {
            /** @description Channel to test */
            channel: components["schemas"]["NotificationChannel"];
            /**
             * Email Recipients
             * @description Email recipients for email test
             */
            email_recipients?: string[] | null;
            /**
             * Webhook Url
             * @description Webhook URL for webhook test
             */
            webhook_url?: string | null;
        };
        /**
         * TestNotificationResponse
         * @description Schema for test notification result.
         * @example {
         *       "channel": "email",
         *       "message": "Test email sent successfully to test@example.com",
         *       "success": true
         *     }
         */
        TestNotificationResponse: {
            /** @description Channel that was tested */
            channel: components["schemas"]["NotificationChannel"];
            /**
             * Success
             * @description Whether the test was successful
             */
            success: boolean;
            /**
             * Error
             * @description Error message if test failed
             */
            error?: string | null;
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * WorkerStatus
         * @description Status information for a background worker/service.
         */
        WorkerStatus: {
            /**
             * Name
             * @description Worker/service name
             */
            name: string;
            /**
             * Running
             * @description Whether the worker is currently running
             */
            running: boolean;
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
        };
        /**
         * ZoneCreate
         * @description Schema for creating a new zone.
         * @example {
         *       "color": "#3B82F6",
         *       "coordinates": [
         *         [
         *           0.1,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.8
         *         ],
         *         [
         *           0.1,
         *           0.8
         *         ]
         *       ],
         *       "enabled": true,
         *       "name": "Front Door",
         *       "priority": 1,
         *       "shape": "rectangle",
         *       "zone_type": "entry_point"
         *     }
         */
        ZoneCreate: {
            /**
             * Name
             * @description Zone name
             */
            name: string;
            /**
             * @description Type of zone
             * @default other
             */
            zone_type: components["schemas"]["ZoneType"];
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates: number[][];
            /**
             * @description Shape of the zone
             * @default rectangle
             */
            shape: components["schemas"]["ZoneShape"];
            /**
             * Color
             * @description Hex color for UI display
             * @default #3B82F6
             */
            color: string;
            /**
             * Enabled
             * @description Whether zone is active
             * @default true
             */
            enabled: boolean;
            /**
             * Priority
             * @description Priority for overlapping zones (higher = more important)
             * @default 0
             */
            priority: number;
        };
        /**
         * ZoneListResponse
         * @description Schema for zone list response.
         * @example {
         *       "count": 1,
         *       "zones": [
         *         {
         *           "camera_id": "front_door",
         *           "color": "#3B82F6",
         *           "coordinates": [
         *             [
         *               0.1,
         *               0.2
         *             ],
         *             [
         *               0.3,
         *               0.2
         *             ],
         *             [
         *               0.3,
         *               0.8
         *             ],
         *             [
         *               0.1,
         *               0.8
         *             ]
         *           ],
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "enabled": true,
         *           "id": "123e4567-e89b-12d3-a456-426614174000",
         *           "name": "Front Door",
         *           "priority": 1,
         *           "shape": "rectangle",
         *           "updated_at": "2025-12-23T12:00:00Z",
         *           "zone_type": "entry_point"
         *         }
         *       ]
         *     }
         */
        ZoneListResponse: {
            /**
             * Zones
             * @description List of zones
             */
            zones: components["schemas"]["ZoneResponse"][];
            /**
             * Count
             * @description Total number of zones
             */
            count: number;
        };
        /**
         * ZoneResponse
         * @description Schema for zone response.
         * @example {
         *       "camera_id": "front_door",
         *       "color": "#3B82F6",
         *       "coordinates": [
         *         [
         *           0.1,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.8
         *         ],
         *         [
         *           0.1,
         *           0.8
         *         ]
         *       ],
         *       "created_at": "2025-12-23T10:00:00Z",
         *       "enabled": true,
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "name": "Front Door",
         *       "priority": 1,
         *       "shape": "rectangle",
         *       "updated_at": "2025-12-23T12:00:00Z",
         *       "zone_type": "entry_point"
         *     }
         */
        ZoneResponse: {
            /**
             * Id
             * @description Zone UUID
             */
            id: string;
            /**
             * Camera Id
             * @description Camera ID this zone belongs to
             */
            camera_id: string;
            /**
             * Name
             * @description Zone name
             */
            name: string;
            /** @description Type of zone */
            zone_type: components["schemas"]["ZoneType"];
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates: number[][];
            /** @description Shape of the zone */
            shape: components["schemas"]["ZoneShape"];
            /**
             * Color
             * @description Hex color for UI display
             */
            color: string;
            /**
             * Enabled
             * @description Whether zone is active
             */
            enabled: boolean;
            /**
             * Priority
             * @description Priority for overlapping zones
             */
            priority: number;
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when zone was created
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             * @description Timestamp when zone was last updated
             */
            updated_at: string;
        };
        /**
         * ZoneShape
         * @description Shape of the zone polygon.
         * @enum {string}
         */
        ZoneShape: "rectangle" | "polygon";
        /**
         * ZoneType
         * @description Type of zone for semantic categorization.
         * @enum {string}
         */
        ZoneType: "entry_point" | "driveway" | "sidewalk" | "yard" | "other";
        /**
         * ZoneUpdate
         * @description Schema for updating an existing zone.
         * @example {
         *       "enabled": false,
         *       "name": "Front Door - Updated"
         *     }
         */
        ZoneUpdate: {
            /**
             * Name
             * @description Zone name
             */
            name?: string | null;
            /** @description Type of zone */
            zone_type?: components["schemas"]["ZoneType"] | null;
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates?: number[][] | null;
            /** @description Shape of the zone */
            shape?: components["schemas"]["ZoneShape"] | null;
            /**
             * Color
             * @description Hex color for UI display
             */
            color?: string | null;
            /**
             * Enabled
             * @description Whether zone is active
             */
            enabled?: boolean | null;
            /**
             * Priority
             * @description Priority for overlapping zones (higher = more important)
             */
            priority?: number | null;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    seed_cameras_api_admin_seed_cameras_post: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeedCamerasRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeedCamerasResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    seed_events_api_admin_seed_events_post: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeedEventsRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeedEventsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_seeded_data_api_admin_seed_clear_delete: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ClearDataRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClearDataResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_rules_api_alerts_rules_get: {
        parameters: {
            query?: {
                /** @description Filter by enabled status */
                enabled?: boolean | null;
                /** @description Filter by severity level */
                severity?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_rule_api_alerts_rules_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertRuleCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_rule_api_alerts_rules__rule_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_rule_api_alerts_rules__rule_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertRuleUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_rule_api_alerts_rules__rule_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    test_rule_api_alerts_rules__rule_id__test_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RuleTestRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RuleTestResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_audit_logs_api_audit_get: {
        parameters: {
            query?: {
                /** @description Filter by action type */
                action?: string | null;
                /** @description Filter by resource type */
                resource_type?: string | null;
                /** @description Filter by resource ID */
                resource_id?: string | null;
                /** @description Filter by actor */
                actor?: string | null;
                /** @description Filter by status (success/failure) */
                status?: string | null;
                /** @description Filter from date (ISO format) */
                start_date?: string | null;
                /** @description Filter to date (ISO format) */
                end_date?: string | null;
                /** @description Page size */
                limit?: number;
                /** @description Page offset */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_audit_stats_api_audit_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogStats"];
                };
            };
        };
    };
    get_audit_log_api_audit__audit_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                audit_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_cameras_api_cameras_get: {
        parameters: {
            query?: {
                /** @description Filter by camera status */
                status?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_camera_api_cameras_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_api_cameras__camera_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_camera_api_cameras__camera_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_camera_api_cameras__camera_id__patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_snapshot_api_cameras__camera_id__snapshot_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_detections_api_detections_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by object type */
                object_type?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Minimum confidence score */
                min_confidence?: number | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_detection_api_detections__detection_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_detection_image_api_detections__detection_id__image_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    stream_detection_video_api_detections__detection_id__video_get: {
        parameters: {
            query?: never;
            header?: {
                Range?: string | null;
            };
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_video_thumbnail_api_detections__detection_id__video_thumbnail_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_dlq_stats_api_dlq_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQStatsResponse"];
                };
            };
        };
    };
    get_dlq_jobs_api_dlq_jobs__queue_name__get: {
        parameters: {
            query?: {
                /** @description Start index (0-based) */
                start?: number;
                /** @description Maximum number of jobs to return */
                limit?: number;
            };
            header?: never;
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQJobsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    requeue_dlq_job_api_dlq_requeue__queue_name__post: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQRequeueResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    requeue_all_dlq_jobs_api_dlq_requeue_all__queue_name__post: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQRequeueResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_dlq_api_dlq__queue_name__delete: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQClearResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_events_api_events_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by risk level (low, medium, high, critical) */
                risk_level?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
                /** @description Filter by detected object type */
                object_type?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_stats_api_events_stats_get: {
        parameters: {
            query?: {
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    search_events_endpoint_api_events_search_get: {
        parameters: {
            query: {
                /** @description Search query string */
                q: string;
                /** @description Filter by camera ID (comma-separated for multiple) */
                camera_id?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by risk levels (comma-separated: low,medium,high,critical) */
                severity?: string | null;
                /** @description Filter by object types (comma-separated: person,vehicle,animal) */
                object_type?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    export_events_api_events_export_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by risk level (low, medium, high, critical) */
                risk_level?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_api_events__event_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_event_api_events__event_id__patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_detections_api_events__event_id__detections_get: {
        parameters: {
            query?: {
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_logs_api_logs_get: {
        parameters: {
            query?: {
                /** @description Filter by log level */
                level?: string | null;
                /** @description Filter by component name */
                component?: string | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by source (backend, frontend) */
                source?: string | null;
                /** @description Search in message text */
                search?: string | null;
                /** @description Filter from date (ISO format) */
                start_date?: string | null;
                /** @description Filter to date (ISO format) */
                end_date?: string | null;
                /** @description Page size */
                limit?: number;
                /** @description Page offset */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_log_stats_api_logs_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogStats"];
                };
            };
        };
    };
    get_log_api_logs__log_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                log_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogEntry"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_frontend_log_api_logs_frontend_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FrontendLogCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    serve_media_compat_api_media__path__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    serve_camera_file_api_media_cameras__camera_id___filename__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    serve_thumbnail_api_media_thumbnails__filename__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Thumbnail served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    metrics_api_metrics_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_notification_config_api_notification_config_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationConfigResponse"];
                };
            };
        };
    };
    test_notification_api_notification_test_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TestNotificationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TestNotificationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_health_api_system_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
        };
    };
    get_liveness_api_system_health_live_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LivenessResponse"];
                };
            };
        };
    };
    get_readiness_api_system_health_ready_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReadinessResponse"];
                };
            };
        };
    };
    get_gpu_stats_api_system_gpu_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GPUStatsResponse"];
                };
            };
        };
    };
    get_gpu_stats_history_api_system_gpu_history_get: {
        parameters: {
            query?: {
                since?: string | null;
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GPUStatsHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_config_api_system_config_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConfigResponse"];
                };
            };
        };
    };
    patch_config_api_system_config_patch: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConfigUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_stats_api_system_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemStatsResponse"];
                };
            };
        };
    };
    get_telemetry_api_system_telemetry_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TelemetryResponse"];
                };
            };
        };
    };
    get_pipeline_latency_api_system_pipeline_latency_get: {
        parameters: {
            query?: {
                window_minutes?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineLatencyResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    trigger_cleanup_api_system_cleanup_post: {
        parameters: {
            query?: {
                dry_run?: boolean;
            };
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanupResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_severity_metadata_api_system_severity_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeverityMetadataResponse"];
                };
            };
        };
    };
    get_storage_stats_api_system_storage_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StorageStatsResponse"];
                };
            };
        };
    };
    list_zones_api_cameras__camera_id__zones_get: {
        parameters: {
            query?: {
                /** @description Filter by enabled status */
                enabled?: boolean | null;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_zone_api_cameras__camera_id__zones_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_zone_api_cameras__camera_id__zones__zone_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_zone_api_cameras__camera_id__zones__zone_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_zone_api_cameras__camera_id__zones__zone_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    root__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    health_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    ready_ready_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
