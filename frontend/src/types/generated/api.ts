/* eslint-disable @typescript-eslint/no-redundant-type-constituents */
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Root
         * @description Health check endpoint.
         */
        get: operations["root__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/cleanup/orphans": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cleanup Orphans
         * @description Manually trigger orphaned file cleanup.
         *
         *     Scans camera upload directories for files that have no corresponding
         *     database records and optionally deletes them.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *
         *     Safety features:
         *     - dry_run=True by default (no actual deletions)
         *     - min_age_hours threshold prevents deleting files being processed
         *     - max_delete_gb limits total deletion per run
         *
         *     Args:
         *         request: Cleanup configuration (dry_run, min_age_hours, max_delete_gb)
         *         http_request: FastAPI request for audit logging
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of cleanup operation with statistics
         */
        post: operations["cleanup_orphans_api_admin_cleanup_orphans_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seed Cameras
         * @description Seed test cameras into the database.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *
         *     Args:
         *         request: Seed configuration (count, clear_existing, create_folders)
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of seeded cameras
         */
        post: operations["seed_cameras_api_admin_seed_cameras_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/clear": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Seeded Data
         * @description Clear all seeded data (cameras, events, detections).
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *     Requires JSON body confirmation to prevent accidental data deletion:
         *     {"confirm": "DELETE_ALL_DATA"}
         *
         *     Args:
         *         body: Request body with confirmation string
         *         request: FastAPI request for audit logging
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of cleared data counts
         *
         *     Raises:
         *         HTTPException: 400 if confirmation string is incorrect
         */
        delete: operations["clear_seeded_data_api_admin_seed_clear_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seed Events
         * @description Seed mock events and detections into the database.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *     Requires cameras to exist first.
         *
         *     Args:
         *         request: Seed configuration (count, clear_existing)
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of seeded events and detections
         */
        post: operations["seed_events_api_admin_seed_events_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Batch Audit
         * @description Trigger batch audit processing for multiple events.
         *
         *     This endpoint returns immediately with a job ID that can be used to
         *     track progress via GET /api/ai-audit/batch/{job_id}. Events are
         *     processed asynchronously in the background.
         *
         *     Args:
         *         request: Batch audit request with filtering criteria
         *         background_tasks: FastAPI background tasks
         *         db: Database session
         *         job_tracker: Job tracker for progress tracking
         *
         *     Returns:
         *         BatchAuditJobResponse with job ID for tracking progress
         */
        post: operations["trigger_batch_audit_api_ai_audit_batch_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/batch/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Batch Audit Status
         * @description Get the status of a batch audit job.
         *
         *     Provides progress information for an ongoing or completed batch audit,
         *     including the number of events processed and any errors.
         *
         *     Args:
         *         job_id: The job ID returned by trigger_batch_audit
         *         job_tracker: Job tracker for retrieving job status
         *
         *     Returns:
         *         BatchAuditJobStatusResponse with current progress
         *
         *     Raises:
         *         HTTPException: 404 if job not found
         */
        get: operations["get_batch_audit_status_api_ai_audit_batch__job_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/events/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Audit
         * @description Get audit information for a specific event.
         *
         *     Retrieves the AI pipeline audit record for the given event, including
         *     model contributions, quality scores, and prompt improvement suggestions.
         *
         *     Args:
         *         event_id: The ID of the event to get audit for
         *         db: Database session
         *
         *     Returns:
         *         EventAuditResponse containing full audit details
         *
         *     Raises:
         *         HTTPException: 404 if event or audit not found
         */
        get: operations["get_event_audit_api_ai_audit_events__event_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/events/{event_id}/evaluate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Evaluate Event
         * @description Trigger full evaluation for a specific event's audit.
         *
         *     Runs the complete self-evaluation pipeline (self-critique, rubric scoring,
         *     consistency check, prompt improvement) for the given event.
         *
         *     Args:
         *         event_id: The ID of the event to evaluate
         *         request: HTTP request for audit logging
         *         force: If True, re-evaluate even if already evaluated
         *         db: Database session
         *
         *     Returns:
         *         EventAuditResponse with updated evaluation results
         *
         *     Raises:
         *         HTTPException: 404 if event or audit not found
         */
        post: operations["evaluate_event_api_ai_audit_events__event_id__evaluate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/leaderboard": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Leaderboard
         * @description Get model leaderboard ranked by contribution rate.
         *
         *     Returns a ranked list of AI models by their contribution rate,
         *     along with quality correlation data.
         *
         *     Args:
         *         days: Number of days to include (1-90, default 7)
         *         db: Database session
         *
         *     Returns:
         *         LeaderboardResponse with ranked model entries
         */
        get: operations["get_model_leaderboard_api_ai_audit_leaderboard_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/prompt-config/{model}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Prompt Config
         * @description Get current prompt configuration for a model (database-backed).
         *
         *     Retrieves the prompt configuration from the database for the specified model.
         *     Returns 404 if no configuration exists for the model.
         *
         *     Args:
         *         model: Model name (nemotron, florence-2, yolo-world, x-clip, fashion-clip)
         *         db: Database session
         *
         *     Returns:
         *         PromptConfigResponse with current configuration
         *
         *     Raises:
         *         HTTPException: 404 if model not found or no configuration exists
         */
        get: operations["get_prompt_config_api_ai_audit_prompt_config__model__get"];
        /**
         * Update Prompt Config
         * @description Update prompt configuration for a model (database-backed).
         *
         *     Creates or updates the prompt configuration in the database.
         *     If updating an existing config, increments the version number.
         *
         *     Args:
         *         model: Model name (nemotron, florence-2, yolo-world, x-clip, fashion-clip)
         *         request: New configuration with system_prompt, temperature, max_tokens
         *         db: Database session
         *
         *     Returns:
         *         PromptConfigResponse with updated configuration
         *
         *     Raises:
         *         HTTPException: 404 if model not found, 400 if configuration invalid
         */
        put: operations["update_prompt_config_api_ai_audit_prompt_config__model__put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/prompts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Prompts
         * @description Get current prompt configurations for all AI models.
         *
         *     Returns configurations for nemotron, florence2, yolo_world, xclip,
         *     and fashion_clip models with their current versions.
         *
         *     Returns:
         *         AllPromptsResponse containing all model configurations
         */
        get: operations["get_all_prompts_api_ai_audit_prompts_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/prompts/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export Prompts
         * @description Export all AI model configurations as JSON.
         *
         *     Returns all current configurations in a format suitable for
         *     backup or transfer to another instance.
         *
         *     Returns:
         *         PromptExportResponse with all configurations
         */
        get: operations["export_prompts_api_ai_audit_prompts_export_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/prompts/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Prompts History
         * @description Get version history for all AI models.
         *
         *     Returns the most recent versions for each supported model.
         *
         *     Args:
         *         limit: Maximum number of versions to return per model (1-100, default 10)
         *
         *     Returns:
         *         Dict mapping model names to their version histories
         */
        get: operations["get_all_prompts_history_api_ai_audit_prompts_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/prompts/history/{model}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model History
         * @description Get version history for a specific AI model.
         *
         *     Returns all versions of the model's configuration, newest first,
         *     with pagination support.
         *
         *     Args:
         *         model: Model name to get history for
         *         limit: Maximum versions to return (1-100, default 50)
         *         offset: Number of versions to skip (default 0)
         *
         *     Returns:
         *         PromptHistoryResponse with version list
         *
         *     Raises:
         *         HTTPException: 404 if model not found
         */
        get: operations["get_model_history_api_ai_audit_prompts_history__model__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/prompts/history/{version}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restore Prompt Version
         * @description Restore a specific version of a model's prompt configuration.
         *
         *     Creates a new version with the configuration from the specified version.
         *     The restore action is recorded in the version history.
         *
         *     Args:
         *         version: Version number to restore
         *         model: Model name to restore version for
         *         request: Optional restore request with description
         *
         *     Returns:
         *         PromptRestoreResponse with restore details
         *
         *     Raises:
         *         HTTPException: 404 if model or version not found
         */
        post: operations["restore_prompt_version_api_ai_audit_prompts_history__version__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/prompts/import": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import Prompts
         * @description Import AI model configurations from JSON.
         *
         *     Imports configurations for multiple models at once. By default,
         *     existing configurations are not overwritten unless overwrite=true.
         *
         *     Args:
         *         request: Import request with configurations and overwrite flag
         *
         *     Returns:
         *         PromptImportResponse with import results
         *
         *     Raises:
         *         HTTPException: 400 if no prompts provided for import
         */
        post: operations["import_prompts_api_ai_audit_prompts_import_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/prompts/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Prompt
         * @description Test a modified prompt configuration against a specific event.
         *
         *     Runs inference with both the current and modified configurations,
         *     returning a comparison of the results to help evaluate changes.
         *
         *     Note: This currently returns mock results. In production, it would
         *     call the actual AI services with the modified configuration.
         *
         *     Args:
         *         request: Test request with model name, config, and event ID
         *         db: Database session
         *
         *     Returns:
         *         PromptTestResponse with before/after comparison
         *
         *     Raises:
         *         HTTPException: 404 if model or event not found, 400 if config invalid
         */
        post: operations["test_prompt_api_ai_audit_prompts_test_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/prompts/{model}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Prompt
         * @description Get current prompt configuration for a specific AI model.
         *
         *     Args:
         *         model: Model name (nemotron, florence2, yolo_world, xclip, fashion_clip)
         *
         *     Returns:
         *         ModelPromptResponse with current configuration
         *
         *     Raises:
         *         HTTPException: 404 if model not found
         */
        get: operations["get_model_prompt_api_ai_audit_prompts__model__get"];
        /**
         * Update Model Prompt
         * @description Update prompt configuration for a specific AI model.
         *
         *     Creates a new version of the configuration with the provided changes.
         *     The previous version is preserved in history.
         *
         *     Args:
         *         model: Model name to update
         *         request: New configuration and optional description
         *
         *     Returns:
         *         PromptUpdateResponse with new version info
         *
         *     Raises:
         *         HTTPException: 404 if model not found, 400 if configuration invalid
         */
        put: operations["update_model_prompt_api_ai_audit_prompts__model__put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/recommendations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Recommendations
         * @description Get aggregated prompt improvement recommendations.
         *
         *     Analyzes all audits to produce actionable recommendations for
         *     improving the AI pipeline prompt templates.
         *
         *     Args:
         *         days: Number of days to analyze (1-90, default 7)
         *         db: Database session
         *
         *     Returns:
         *         RecommendationsResponse with prioritized recommendations
         */
        get: operations["get_recommendations_api_ai_audit_recommendations_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Stats
         * @description Get aggregate AI audit statistics.
         *
         *     Returns aggregate statistics including total events, quality scores,
         *     model contribution rates, and audit trends over the specified period.
         *
         *     Args:
         *         days: Number of days to include in statistics (1-90, default 7)
         *         camera_id: Optional camera ID to filter stats
         *         db: Database session
         *
         *     Returns:
         *         AuditStatsResponse with aggregate statistics
         */
        get: operations["get_audit_stats_api_ai_audit_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/test-prompt": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Custom Prompt
         * @description Test a custom prompt against an existing event for A/B testing.
         *
         *     This endpoint allows testing a custom prompt without persisting results.
         *     It's designed for the Prompt Playground A/B testing feature where users
         *     can experiment with different prompts and compare results.
         *
         *     The endpoint:
         *     1. Fetches the event with its detections
         *     2. Builds context from the event data
         *     3. Calls the AI model with the custom prompt (or mocks if service unavailable)
         *     4. Returns results WITHOUT saving to database
         *
         *     Args:
         *         request: Test request containing event_id, custom_prompt, and optional
         *                  parameters (temperature, max_tokens, model)
         *         db: Database session
         *
         *     Returns:
         *         CustomTestPromptResponse with risk analysis results
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         *         HTTPException: 400 if prompt is invalid (empty or too long)
         *         HTTPException: 503 if AI service is unavailable
         *         HTTPException: 408 if request times out (>60s)
         */
        post: operations["test_custom_prompt_api_ai_audit_test_prompt_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Rules
         * @description List all alert rules with optional filtering and pagination.
         *
         *     Args:
         *         enabled: Filter by enabled status
         *         severity: Filter by severity level (low, medium, high, critical)
         *         limit: Maximum number of results to return
         *         offset: Number of results to skip for pagination
         *         db: Database session
         *
         *     Returns:
         *         AlertRuleListResponse with rules and pagination info
         */
        get: operations["list_rules_api_alerts_rules_get"];
        put?: never;
        /**
         * Create Rule
         * @description Create a new alert rule.
         *
         *     Args:
         *         rule_data: Rule creation data
         *         db: Database session
         *         cache: Cache service for cache invalidation (NEM-1952)
         *
         *     Returns:
         *         Created AlertRule
         */
        post: operations["create_rule_api_alerts_rules_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules/{rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Rule
         * @description Get a specific alert rule by ID.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         db: Database session
         *
         *     Returns:
         *         AlertRule
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        get: operations["get_rule_api_alerts_rules__rule_id__get"];
        /**
         * Update Rule
         * @description Update an existing alert rule.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         rule_data: Rule update data
         *         db: Database session
         *         cache: Cache service for cache invalidation (NEM-1952)
         *
         *     Returns:
         *         Updated AlertRule
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        put: operations["update_rule_api_alerts_rules__rule_id__put"];
        post?: never;
        /**
         * Delete Rule
         * @description Delete an alert rule.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         db: Database session
         *         cache: Cache service for cache invalidation (NEM-1952)
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        delete: operations["delete_rule_api_alerts_rules__rule_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules/{rule_id}/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Rule
         * @description Test a rule against historical events.
         *
         *     This endpoint allows testing rule configuration without actually
         *     creating alerts. Useful for validating rules before enabling them.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         test_data: Test configuration (event IDs, time override)
         *         db: Database session
         *         engine: AlertRuleEngine injected via Depends()
         *
         *     Returns:
         *         RuleTestResponse with per-event match results
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        post: operations["test_rule_api_alerts_rules__rule_id__test_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/{alert_id}/acknowledge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Acknowledge Alert
         * @description Acknowledge an alert.
         *
         *     Marks an alert as acknowledged and broadcasts the state change via WebSocket.
         *     Only alerts with status PENDING or DELIVERED can be acknowledged.
         *
         *     Uses optimistic locking to prevent race conditions when multiple requests
         *     attempt to modify the same alert concurrently. If a concurrent modification
         *     is detected, returns HTTP 409 Conflict.
         *
         *     NEM-2582: WebSocket broadcast now uses background task with retry logic
         *     to ensure delivery without blocking the main request.
         *
         *     Args:
         *         alert_id: Alert UUID
         *         background_tasks: FastAPI background tasks for non-blocking broadcast
         *         db: Database session
         *
         *     Returns:
         *         Updated AlertResponse
         *
         *     Raises:
         *         HTTPException: 404 if alert not found, 409 if alert cannot be acknowledged
         *                       or if concurrent modification detected
         */
        post: operations["acknowledge_alert_api_alerts__alert_id__acknowledge_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/{alert_id}/dismiss": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Dismiss Alert
         * @description Dismiss an alert.
         *
         *     Marks an alert as dismissed and broadcasts the state change via WebSocket.
         *     Only alerts with status PENDING, DELIVERED, or ACKNOWLEDGED can be dismissed.
         *
         *     Uses optimistic locking to prevent race conditions when multiple requests
         *     attempt to modify the same alert concurrently. If a concurrent modification
         *     is detected, returns HTTP 409 Conflict.
         *
         *     NEM-2582: WebSocket broadcast now uses background task with retry logic
         *     to ensure delivery without blocking the main request.
         *
         *     Args:
         *         alert_id: Alert UUID
         *         background_tasks: FastAPI background tasks for non-blocking broadcast
         *         db: Database session
         *
         *     Returns:
         *         Updated AlertResponse
         *
         *     Raises:
         *         HTTPException: 404 if alert not found, 409 if alert cannot be dismissed
         *                       or if concurrent modification detected
         */
        post: operations["dismiss_alert_api_alerts__alert_id__dismiss_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/camera-uptime": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Uptime
         * @description Get uptime percentage per camera.
         *
         *     Returns uptime percentage and detection count for each camera.
         *     Uptime is calculated based on the number of days with at least one detection
         *     divided by the total days in the date range.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         db: Database session
         *
         *     Returns:
         *         CameraUptimeResponse with per-camera uptime data
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["get_camera_uptime_api_analytics_camera_uptime_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/detection-trends": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Trends
         * @description Get detection counts aggregated by day.
         *
         *     Returns daily detection counts for the specified date range.
         *     Creates one data point per day even if there are no detections.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         db: Database session
         *
         *     Returns:
         *         DetectionTrendsResponse with daily detection counts
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["get_detection_trends_api_analytics_detection_trends_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/object-distribution": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Object Distribution
         * @description Get detection counts by object type.
         *
         *     Returns detection counts grouped by object type with percentages.
         *     Only includes detections with non-null object_type.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         db: Database session
         *
         *     Returns:
         *         ObjectDistributionResponse with object type counts and percentages
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["get_object_distribution_api_analytics_object_distribution_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/risk-history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Risk History
         * @description Get risk score distribution over time.
         *
         *     Returns daily counts of events grouped by risk level (low, medium, high, critical).
         *     Creates one data point per day even if there are no events.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         db: Database session
         *
         *     Returns:
         *         RiskHistoryResponse with daily risk level counts
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["get_risk_history_api_analytics_risk_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Audit Logs
         * @description List audit logs with optional filtering and cursor-based pagination.
         *
         *     This endpoint is intended for admin use to review security-sensitive operations.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Cursor-based pagination offers better performance for large datasets.
         *
         *     **Performance Note:** Total count queries are expensive for large datasets. By default,
         *     the total count is not calculated (returns 0). Use `include_total_count=true` only when
         *     the total count is needed (e.g., for displaying "X of Y results" in UI). For pagination,
         *     `has_more` and `next_cursor` provide sufficient information.
         *
         *     Args:
         *         action: Optional action type to filter by
         *         resource_type: Optional resource type to filter by
         *         resource_id: Optional specific resource ID to filter by
         *         actor: Optional actor to filter by
         *         status_filter: Optional status to filter by (success/failure)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         limit: Maximum number of results to return (1-1000, default 100)
         *         offset: Number of results to skip (deprecated, use cursor instead)
         *         cursor: Pagination cursor from previous response's next_cursor field
         *         include_total_count: Whether to calculate total count (default False for performance)
         *         db: Database session
         *
         *     Returns:
         *         AuditLogListResponse containing filtered logs and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         *         HTTPException: 400 if cursor is invalid
         */
        get: operations["list_audit_logs_api_audit_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Stats
         * @description Get audit log statistics for dashboard.
         *
         *     Returns aggregated statistics about audit logs including:
         *     - Total log count
         *     - Logs today
         *     - Breakdown by action type
         *     - Breakdown by resource type
         *     - Breakdown by status
         *     - Recently active actors
         *
         *     This endpoint is optimized to use a single aggregation query for counts
         *     (total, today, by_action, by_resource_type, by_status) plus one query
         *     for recent actors, reducing database round-trips from 6 to 2.
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         AuditLogStats with aggregated statistics
         */
        get: operations["get_audit_stats_api_audit_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit/{audit_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Log
         * @description Get a specific audit log entry by ID.
         *
         *     Args:
         *         audit_id: Audit log ID
         *         db: Database session
         *
         *     Returns:
         *         AuditLog record
         *
         *     Raises:
         *         HTTPException: 404 if audit log not found
         */
        get: operations["get_audit_log_api_audit__audit_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/calibration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Calibration
         * @description Get the current user's calibration settings.
         *
         *     Returns the calibration thresholds for the default user.
         *     If no calibration exists, one is automatically created with default values.
         *
         *     Returns:
         *         CalibrationResponse with current threshold settings
         */
        get: operations["get_calibration_api_calibration_get"];
        /**
         * Update Calibration
         * @description Update calibration thresholds (full replacement semantics).
         *
         *     Allows partial updates - only provided fields will be changed.
         *     Validates that threshold ordering is maintained (low < medium < high).
         *
         *     Note: For REST semantics, use PATCH for partial updates. This PUT endpoint
         *     is kept for backward compatibility and behaves identically to PATCH.
         *
         *     Args:
         *         update_data: Fields to update (partial updates supported)
         *         db: Database session
         *
         *     Returns:
         *         Updated CalibrationResponse
         *
         *     Raises:
         *         HTTPException: 422 if threshold ordering would be violated
         */
        put: operations["update_calibration_api_calibration_put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Patch Calibration
         * @description Partially update calibration thresholds.
         *
         *     Allows partial updates - only provided fields will be changed.
         *     Validates that threshold ordering is maintained (low < medium < high).
         *
         *     Args:
         *         update_data: Fields to update (partial updates supported)
         *         db: Database session
         *
         *     Returns:
         *         Updated CalibrationResponse
         *
         *     Raises:
         *         HTTPException: 422 if threshold ordering would be violated
         */
        patch: operations["patch_calibration_api_calibration_patch"];
        trace?: never;
    };
    "/api/calibration/defaults": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Calibration Defaults
         * @description Get default calibration threshold values.
         *
         *     Returns the default values used when creating new calibrations
         *     or when resetting to defaults. This endpoint is useful for
         *     displaying defaults in the UI or documentation.
         *
         *     Returns:
         *         CalibrationDefaultsResponse with default threshold values
         */
        get: operations["get_calibration_defaults_api_calibration_defaults_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/calibration/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset Calibration
         * @description Reset calibration to default thresholds.
         *
         *     Resets all thresholds to their default values:
         *     - low_threshold: 30
         *     - medium_threshold: 60
         *     - high_threshold: 85
         *     - decay_factor: 0.1
         *
         *     Note: Feedback counts (correct_count, false_positive_count, missed_threat_count,
         *     severity_wrong_count) are NOT reset by this operation.
         *
         *     Returns:
         *         CalibrationResetResponse with success message and reset calibration data
         */
        post: operations["reset_calibration_api_calibration_reset_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Cameras
         * @description List all cameras with optional status filter.
         *
         *     Uses Redis cache with cache-aside pattern to improve performance
         *     and generate cache hit metrics.
         *
         *     Sparse Fieldsets (NEM-1434):
         *     Use the `fields` parameter to request only specific fields in the response,
         *     reducing payload size. Example: ?fields=id,name,status
         *
         *     Args:
         *         status_filter: Optional status to filter cameras by (online, offline, error)
         *         fields: Comma-separated list of fields to include (sparse fieldsets)
         *         db: Database session
         *         cache: Cache service injected via FastAPI DI
         *
         *     Returns:
         *         CameraListResponse containing list of cameras and total count
         *
         *     Raises:
         *         HTTPException: 400 if invalid fields are requested
         */
        get: operations["list_cameras_api_cameras_get"];
        put?: never;
        /**
         * Create Camera
         * @description Create a new camera.
         *
         *     Args:
         *         camera_data: Camera creation data
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Created camera object with generated ID
         *
         *     Raises:
         *         HTTPException: 409 if camera with same name or folder_path already exists
         */
        post: operations["create_camera_api_cameras_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all soft-deleted cameras
         * @description List all soft-deleted cameras for trash view.
         *
         *     Returns cameras that have been soft-deleted (deleted_at is not null),
         *     ordered by deleted_at descending (most recently deleted first).
         *
         *     This endpoint enables a "trash" view where users can see deleted cameras
         *     and optionally restore them.
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         DeletedCamerasListResponse containing list of deleted cameras and count
         */
        get: operations["list_deleted_cameras_api_cameras_deleted_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/validation/paths": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Validate Camera Paths
         * @description Validate all camera folder paths against the configured base path.
         *
         *     This endpoint checks each camera's folder_path to determine:
         *     1. Whether the path is under the configured FOSCAM_BASE_PATH
         *     2. Whether the directory exists on disk
         *     3. Whether the directory contains any images or video files
         *
         *     NEM-2446: Video files (.mkv, .mp4, etc.) are now valid for snapshot
         *     extraction, so cameras with only video files pass validation.
         *
         *     Use this to diagnose cameras that show "No snapshot available" errors.
         *
         *     Returns:
         *         CameraPathValidationResponse with validation results for all cameras
         */
        get: operations["validate_camera_paths_api_cameras_validation_paths_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera
         * @description Get a specific camera by ID.
         *
         *     Args:
         *         camera_id: Normalized camera ID (e.g., "front_door", "backyard")
         *         db: Database session
         *
         *     Returns:
         *         Camera object
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_api_cameras__camera_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Camera
         * @description Delete a camera.
         *
         *     This operation cascades to all related detections and events.
         *
         *     Args:
         *         camera_id: Normalized camera ID (e.g., "front_door", "backyard")
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        delete: operations["delete_camera_api_cameras__camera_id__delete"];
        options?: never;
        head?: never;
        /**
         * Update Camera
         * @description Update an existing camera.
         *
         *     Args:
         *         camera_id: Normalized camera ID (e.g., "front_door", "backyard")
         *         camera_data: Camera update data (all fields optional)
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Updated camera object
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        patch: operations["update_camera_api_cameras__camera_id__patch"];
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Baseline
         * @description Get baseline activity data for a camera.
         *
         *     Returns comprehensive baseline statistics including:
         *     - Hourly activity patterns (0-23 hours)
         *     - Daily patterns (by day of week)
         *     - Object-specific baselines
         *     - Current deviation from baseline
         *
         *     Args:
         *         camera_id: ID of the camera
         *         db: Database session
         *         baseline_service: BaselineService injected via Depends()
         *
         *     Returns:
         *         BaselineSummaryResponse with all baseline data
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_baseline_api_cameras__camera_id__baseline_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline/activity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Activity Baseline
         * @description Get raw activity baseline data for a camera.
         *
         *     Returns up to 168 entries (24 hours x 7 days) representing the full
         *     weekly activity heatmap. Each entry contains the average count and
         *     sample count for that hour/day combination.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         db: Database session
         *         baseline_service: BaselineService injected via Depends()
         *
         *     Returns:
         *         ActivityBaselineResponse with entries for the heatmap
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_activity_baseline_api_cameras__camera_id__baseline_activity_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline/anomalies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Baseline Anomalies
         * @description Get recent anomaly events for a camera.
         *
         *     Returns a list of anomaly events detected within the specified time period.
         *     Anomalies are detections that significantly deviate from the established
         *     baseline activity patterns.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         days: Number of days to look back (default: 7, max: 90)
         *         db: Database session
         *         baseline_service: BaselineService injected via Depends()
         *
         *     Returns:
         *         AnomalyListResponse with list of anomaly events
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_baseline_anomalies_api_cameras__camera_id__baseline_anomalies_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline/classes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Class Baseline
         * @description Get class frequency baseline data for a camera.
         *
         *     Returns baseline entries grouped by object class and hour, showing
         *     the frequency of each object type at different times of day.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         db: Database session
         *         baseline_service: BaselineService injected via Depends()
         *
         *     Returns:
         *         ClassBaselineResponse with entries for each class/hour combination
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_class_baseline_api_cameras__camera_id__baseline_classes_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/restore": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restore a soft-deleted camera
         * @description Restore a soft-deleted camera.
         *
         *     Clears the deleted_at timestamp on a soft-deleted camera, making it
         *     visible again in normal queries.
         *
         *     Args:
         *         camera_id: ID of the camera to restore
         *         db: Database session
         *         cache: Cache service for invalidation
         *
         *     Returns:
         *         CameraResponse with the restored camera data
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         *         HTTPException: 400 if camera is not deleted (nothing to restore)
         */
        post: operations["restore_camera_api_cameras__camera_id__restore_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/scene-changes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Scene Changes
         * @description Get scene changes for a camera with cursor-based pagination.
         *
         *     Returns a list of detected scene changes that may indicate camera
         *     tampering, angle changes, or blocked views. Uses cursor-based pagination
         *     for efficient navigation through large datasets.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         acknowledged: Filter by acknowledgement status (None = all)
         *         limit: Maximum number of results (default: 50, max: 100)
         *         cursor: Cursor for pagination (detected_at timestamp from previous response)
         *         db: Database session
         *
         *     Returns:
         *         SceneChangeListResponse with list of scene changes and pagination info
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["get_camera_scene_changes_api_cameras__camera_id__scene_changes_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/scene-changes/{scene_change_id}/acknowledge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Acknowledge Scene Change
         * @description Acknowledge a scene change alert.
         *
         *     Marks a scene change as acknowledged to indicate it has been reviewed.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         scene_change_id: ID of the scene change to acknowledge
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         SceneChangeAcknowledgeResponse confirming acknowledgement
         *
         *     Raises:
         *         HTTPException: 404 if camera or scene change not found
         */
        post: operations["acknowledge_scene_change_api_cameras__camera_id__scene_changes__scene_change_id__acknowledge_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/snapshot": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Snapshot
         * @description Return the latest image for a camera (best-effort snapshot).
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves static image content accessed directly by browsers via <img> tags
         *     2. It has its own security controls (path traversal protection, file type allowlist)
         *     3. It has rate limiting to prevent abuse
         *
         *     This endpoint uses the camera's configured `folder_path` and returns the most recently
         *     modified image file under that directory.
         *
         *     NEM-2446: Now supports video-only cameras by extracting and caching frames.
         */
        get: operations["get_camera_snapshot_api_cameras__camera_id__snapshot_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/zones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Zones
         * @description List all zones for a camera with optional filtering.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         enabled: Optional filter for enabled/disabled zones
         *         db: Database session
         *
         *     Returns:
         *         ZoneListResponse containing list of zones and total count
         */
        get: operations["list_zones_api_cameras__camera_id__zones_get"];
        put?: never;
        /**
         * Create Zone
         * @description Create a new zone for a camera.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_data: Zone creation data
         *         db: Database session
         *
         *     Returns:
         *         Created zone object with generated ID
         */
        post: operations["create_zone_api_cameras__camera_id__zones_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/zones/{zone_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Zone
         * @description Get a specific zone by ID.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone
         *         db: Database session
         *
         *     Returns:
         *         Zone object
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        get: operations["get_zone_api_cameras__camera_id__zones__zone_id__get"];
        /**
         * Update Zone
         * @description Update an existing zone.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone to update
         *         zone_data: Zone update data (all fields optional)
         *         db: Database session
         *
         *     Returns:
         *         Updated zone object
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        put: operations["update_zone_api_cameras__camera_id__zones__zone_id__put"];
        post?: never;
        /**
         * Delete Zone
         * @description Delete a zone.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone to delete
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        delete: operations["delete_zone_api_cameras__camera_id__zones__zone_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/circuit-breakers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Circuit Breakers
         * @description Get all circuit breaker states.
         *
         *     Returns the current state and metrics for all registered circuit breakers,
         *     including failure counts, success counts, and configuration.
         *
         *     NEM-1642: Debug endpoint for circuit breaker diagnostics
         */
        get: operations["get_circuit_breakers_api_debug_circuit_breakers_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Config
         * @description Get current configuration with sensitive values redacted.
         *
         *     Returns all configuration settings with passwords, API keys, and other
         *     sensitive values replaced with [REDACTED]. URLs containing passwords
         *     will have only the password portion redacted, preserving the structure.
         *
         *     NEM-1642: Debug endpoint for configuration inspection
         */
        get: operations["get_config_api_debug_config_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/log-level": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Log Level
         * @description Get current log level.
         *
         *     NEM-1471: Log level inspection endpoint
         */
        get: operations["get_log_level_api_debug_log_level_get"];
        put?: never;
        /**
         * Set Log Level
         * @description Set log level at runtime for debugging.
         *
         *     Allows changing the log level without restarting the application.
         *     Useful for temporarily enabling DEBUG logging to investigate issues.
         *
         *     NEM-1471: Log level runtime override
         *
         *     Args:
         *         request: Log level request with new level
         *
         *     Returns:
         *         Current and previous log level
         *
         *     Raises:
         *         HTTPException: If the log level is invalid
         */
        post: operations["set_log_level_api_debug_log_level_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/pipeline-errors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Errors
         * @description Get recent pipeline errors from the AI analysis pipeline.
         *
         *     Retrieves errors stored in Redis for debugging pipeline issues.
         *     Supports optional filtering by component and error type.
         *
         *     Args:
         *         limit: Maximum number of errors to return (default: 10, max: 100)
         *         component: Optional filter by component (e.g., "detector", "analyzer")
         *         error_type: Optional filter by error type (e.g., "connection_error")
         *
         *     Returns:
         *         List of recent pipeline errors with metadata
         *
         *     NEM-2485: Pipeline errors retrieval endpoint for Debug API
         */
        get: operations["get_pipeline_errors_api_debug_pipeline_errors_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/pipeline-state": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline State
         * @description Get current state of the AI processing pipeline.
         *
         *     Returns queue depths, worker status, and recent errors for debugging
         *     pipeline issues and monitoring system health.
         *
         *     Args:
         *         error_limit: Maximum number of recent errors to return (default: 10, max: 100)
         *
         *     NEM-1470: Debug endpoint for pipeline state inspection
         *     NEM-2485: Complete pipeline errors retrieval implementation
         */
        get: operations["get_pipeline_state_api_debug_pipeline_state_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/profile/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Profiling
         * @description Start performance profiling.
         *
         *     Begins collecting profiling data for performance analysis.
         *     Profile data is saved to disk when stop is called.
         *
         *     NEM-1644: Debug endpoint for performance profiling
         *
         *     Returns:
         *         Profiling start status
         */
        post: operations["start_profiling_api_debug_profile_start_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/profile/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Profile Stats
         * @description Get current profiling statistics.
         *
         *     Returns the current profiling state and statistics from the last
         *     completed profiling session.
         *
         *     NEM-1644: Debug endpoint for performance profiling
         *
         *     Returns:
         *         Profiling status and statistics
         */
        get: operations["get_profile_stats_api_debug_profile_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/profile/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stop Profiling
         * @description Stop performance profiling and save results.
         *
         *     Stops the profiler and saves the profile data to a .prof file.
         *     The file can be analyzed with snakeviz or py-spy.
         *
         *     NEM-1644: Debug endpoint for performance profiling
         *
         *     Returns:
         *         Profiling stop status with path to saved profile
         */
        post: operations["stop_profiling_api_debug_profile_stop_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/recordings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Recordings
         * @description List available request recordings.
         *
         *     Returns a list of recorded requests, sorted by timestamp (newest first).
         *     Use the recording_id to replay a specific request.
         *
         *     NEM-1646: Request recording and replay for debugging
         *
         *     Args:
         *         limit: Maximum number of recordings to return (default: 50)
         *
         *     Returns:
         *         List of recordings with metadata
         */
        get: operations["list_recordings_api_debug_recordings_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/recordings/{recording_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Recording
         * @description Get details of a specific recording.
         *
         *     Returns the full recording data including headers, body, and response.
         *
         *     NEM-1646: Request recording and replay for debugging
         *
         *     Args:
         *         recording_id: ID of the recording to retrieve
         *
         *     Returns:
         *         Full recording data
         *
         *     Raises:
         *         HTTPException: 404 if recording not found
         */
        get: operations["get_recording_api_debug_recordings__recording_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Recording
         * @description Delete a specific recording.
         *
         *     NEM-1646: Request recording management
         *
         *     Args:
         *         recording_id: ID of the recording to delete
         *
         *     Returns:
         *         Confirmation message
         *
         *     Raises:
         *         HTTPException: 404 if recording not found
         */
        delete: operations["delete_recording_api_debug_recordings__recording_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/redis/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Redis Info
         * @description Get Redis connection stats and pub/sub channel information.
         *
         *     Returns Redis server info, memory usage, connection stats, and
         *     active pub/sub channels with their subscriber counts.
         *
         *     NEM-1642: Debug endpoint for Redis diagnostics
         */
        get: operations["get_redis_info_api_debug_redis_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/replay/{recording_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Replay Request
         * @description Replay a recorded request for debugging.
         *
         *     Reconstructs the original request from the recording and executes it
         *     against the current application. This is useful for:
         *     - Reproducing production issues locally
         *     - Testing fixes for error scenarios
         *     - Debugging intermittent failures
         *
         *     SECURITY: This endpoint is only available when debug=True and requires
         *     the request to pass through the debug mode gate.
         *
         *     NEM-1646: Request recording and replay for debugging
         *
         *     Args:
         *         recording_id: ID of the recording to replay
         *
         *     Returns:
         *         Replay response with original and new status codes
         *
         *     Raises:
         *         HTTPException: 404 if recording not found
         */
        post: operations["replay_request_api_debug_replay__recording_id__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/websocket/connections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Websocket Connections
         * @description Get active WebSocket connection states.
         *
         *     Returns connection counts and health status for both the event broadcaster
         *     (security event stream) and system broadcaster (system status stream).
         *
         *     NEM-1642: Debug endpoint for WebSocket diagnostics
         */
        get: operations["get_websocket_connections_api_debug_websocket_connections_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Detections
         * @description List detections with optional filtering and cursor-based pagination.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Cursor-based pagination offers better performance for large datasets.
         *
         *     Sparse Fieldsets (NEM-1434):
         *     Use the `fields` parameter to request only specific fields in the response,
         *     reducing payload size. Example: ?fields=id,camera_id,object_type,confidence
         *
         *     Args:
         *         camera_id: Optional camera ID to filter by
         *         object_type: Optional object type to filter by (person, car, etc.)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         min_confidence: Optional minimum confidence score (0-1)
         *         limit: Maximum number of results to return (1-100, default 50)
         *         offset: Number of results to skip (deprecated, use cursor instead)
         *         cursor: Pagination cursor from previous response's next_cursor field
         *         fields: Comma-separated list of fields to include (sparse fieldsets)
         *         db: Database session
         *
         *     Returns:
         *         DetectionListResponse containing filtered detections and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         *         HTTPException: 400 if cursor is invalid
         *         HTTPException: 400 if invalid fields are requested
         */
        get: operations["list_detections_api_detections_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/bulk": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Bulk create detections
         * @description Create multiple detections in a single request.
         *
         *     Supports partial success - some detections may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk create request with up to 100 detections
         *         db: Database session
         *         cache: Cache service for invalidation (NEM-1951)
         *
         *     Returns:
         *         DetectionBulkCreateResponse with per-item results
         */
        post: operations["bulk_create_detections_api_detections_bulk_post"];
        /**
         * Bulk delete detections
         * @description Delete multiple detections in a single request.
         *
         *     Supports partial success - some deletions may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Note: Detection deletion is always hard delete as detections are raw data
         *     and soft-delete is not supported.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk delete request with up to 100 detection IDs
         *         db: Database session
         *         cache: Cache service for invalidation (NEM-1951)
         *
         *     Returns:
         *         BulkOperationResponse with per-item results
         */
        delete: operations["bulk_delete_detections_api_detections_bulk_delete"];
        options?: never;
        head?: never;
        /**
         * Bulk update detections
         * @description Update multiple detections in a single request.
         *
         *     Supports partial success - some updates may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk update request with up to 100 detection updates
         *         db: Database session
         *         cache: Cache service for invalidation (NEM-1951)
         *
         *     Returns:
         *         BulkOperationResponse with per-item results
         */
        patch: operations["bulk_update_detections_api_detections_bulk_patch"];
        trace?: never;
    };
    "/api/detections/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Detection Labels
         * @description Get all unique detection labels with counts.
         */
        get: operations["list_detection_labels_api_detections_labels_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Detections
         * @description Search detections using full-text search.
         */
        get: operations["search_detections_api_detections_search_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Stats
         * @description Get aggregate detection statistics including class distribution.
         *
         *     Returns:
         *     - Total detection count
         *     - Detection counts grouped by object class (person, car, truck, etc.)
         *     - Average confidence score across all detections
         *
         *     Used by the AI Performance page to display detection class distribution charts.
         *
         *     Optimized to use a single query with window functions instead of 3 separate queries
         *     (NEM-1321). The query combines:
         *     - Per-class counts via GROUP BY
         *     - Total count via SUM(COUNT(*)) OVER() window function
         *     - Per-class avg confidence, then combined using weighted average formula
         *
         *     Args:
         *         camera_id: Optional camera ID filter (for camera-specific stats)
         *         db: Database session
         *
         *     Returns:
         *         DetectionStatsResponse with aggregate detection statistics
         */
        get: operations["get_detection_stats_api_detections_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection
         * @description Get a specific detection by ID.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         Detection object
         *
         *     Raises:
         *         HTTPException: 404 if detection not found
         */
        get: operations["get_detection_api_detections__detection_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/enrichment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Enrichment
         * @description Get structured enrichment data for a detection.
         *
         *     Returns results from the 18+ vision models run during the enrichment pipeline:
         *     - License plate detection and OCR
         *     - Face detection
         *     - Vehicle classification and damage detection
         *     - Clothing analysis (FashionCLIP and SegFormer)
         *     - Violence detection
         *     - Image quality assessment
         *     - Pet classification
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         EnrichmentResponse with structured vision model results
         *
         *     Raises:
         *         HTTPException: 404 if detection not found
         */
        get: operations["get_detection_enrichment_api_detections__detection_id__enrichment_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Image
         * @description Get detection image with bounding box overlay, or full-size original.
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves static image content accessed directly by browsers via <img> tags
         *     2. Detection IDs are not predictable (integer IDs require prior knowledge)
         *     3. It has rate limiting to prevent abuse
         *
         *     By default, returns the thumbnail image with bounding box drawn around the
         *     detected object. If thumbnail doesn't exist, generates it on the fly from
         *     the source image or video.
         *
         *     For video detections, extracts a frame from the video using ffmpeg.
         *
         *     When full=true is passed, returns the original source image without any
         *     bounding box overlay. This is used for the full-size image lightbox viewer.
         *     Note: For video detections with full=true, returns the first frame as an image.
         *
         *     Args:
         *         detection_id: Detection ID
         *         full: If true, return the original full-size image instead of thumbnail
         *         db: Database session
         *         thumbnail_generator: ThumbnailGenerator injected via Depends()
         *         video_processor: VideoProcessor injected via Depends() for video detections
         *
         *     Returns:
         *         JPEG image (thumbnail with bounding box, or full-size original)
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or image file doesn't exist
         *         HTTPException: 500 if image generation fails
         */
        get: operations["get_detection_image_api_detections__detection_id__image_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/thumbnail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get detection thumbnail
         * @description Serve the cropped thumbnail image with bounding box overlay.
         */
        get: operations["get_detection_thumbnail_api_detections__detection_id__thumbnail_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Stream Detection Video
         * @description Stream detection video with HTTP Range request support.
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves video content accessed directly by browsers via <video> tags
         *     2. Detection IDs are not predictable (integer IDs require prior knowledge)
         *     3. It has rate limiting to prevent abuse
         *
         *     Supports partial content requests for video seeking and efficient playback.
         *     Returns 206 Partial Content for range requests, 200 OK for full content.
         *
         *     Args:
         *         detection_id: Detection ID
         *         range_header: HTTP Range header for partial content requests
         *         db: Database session
         *
         *     Returns:
         *         StreamingResponse with video content
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or not a video
         *         HTTPException: 416 if range is not satisfiable
         */
        get: operations["stream_detection_video_api_detections__detection_id__video_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/video/thumbnail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Video Thumbnail
         * @description Get thumbnail frame from a video detection.
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves static image content accessed directly by browsers via <img> tags
         *     2. Detection IDs are not predictable (integer IDs require prior knowledge)
         *     3. It has rate limiting to prevent abuse
         *
         *     Extracts and returns a thumbnail frame from the video. If thumbnail
         *     doesn't exist, generates it on the fly using ffmpeg.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *         video_processor: VideoProcessor injected via Depends()
         *
         *     Returns:
         *         JPEG thumbnail image
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or not a video
         *         HTTPException: 500 if thumbnail generation fails
         */
        get: operations["get_video_thumbnail_api_detections__detection_id__video_thumbnail_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/jobs/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Dlq Jobs
         * @description List jobs in a specific dead-letter queue with enriched error context.
         *
         *     Returns jobs in the specified DLQ without removing them.
         *     Use pagination parameters to control the result set.
         *
         *     Each job includes enriched error context (NEM-1474):
         *     - error_type: Exception class name for categorization
         *     - stack_trace: Truncated stack trace for debugging
         *     - http_status: HTTP status code (for network errors)
         *     - response_body: Truncated AI service response
         *     - retry_delays: Delays applied between retry attempts
         *     - context: System state snapshot at failure time
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         start: Start index for pagination
         *         limit: Maximum number of jobs to return
         *         redis: Redis client
         *
         *     Returns:
         *         DLQJobsResponse with list of jobs including error context (NEM-2178 pagination envelope)
         */
        get: operations["get_dlq_jobs_api_dlq_jobs__queue_name__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/requeue-all/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Requeue All Dlq Jobs
         * @description Requeue all jobs from a DLQ back to their original processing queue.
         *
         *     Removes all jobs from the specified DLQ and adds them back to the
         *     original processing queue for retry. Limited to settings.max_requeue_iterations
         *     to prevent resource exhaustion.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         redis: Redis client
         *
         *     Returns:
         *         DLQRequeueResponse with operation result and count
         */
        post: operations["requeue_all_dlq_jobs_api_dlq_requeue_all__queue_name__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/requeue/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Requeue Dlq Job
         * @description Requeue the oldest job from a DLQ back to its original processing queue.
         *
         *     Removes the oldest job from the specified DLQ and adds it back to the
         *     original processing queue for retry.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         redis: Redis client
         *
         *     Returns:
         *         DLQRequeueResponse with operation result
         */
        post: operations["requeue_dlq_job_api_dlq_requeue__queue_name__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Dlq Stats
         * @description Get dead-letter queue statistics.
         *
         *     Returns the number of jobs in each DLQ and the total count.
         *
         *     Returns:
         *         DLQStatsResponse with queue counts
         */
        get: operations["get_dlq_stats_api_dlq_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Dlq
         * @description Clear all jobs from a dead-letter queue.
         *
         *     WARNING: This permanently removes all jobs from the specified DLQ.
         *     Use with caution.
         *
         *     Args:
         *         queue_name: Name of the DLQ to clear
         *         redis: Redis client
         *
         *     Returns:
         *         DLQClearResponse with operation result
         */
        delete: operations["clear_dlq_api_dlq__queue_name__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Entities
         * @description List tracked entities with optional filtering.
         *
         *     Returns a paginated list of entities from PostgreSQL. Entities are
         *     tracked via re-identification and stored in the database.
         *
         *     Args:
         *         entity_type: Filter by entity type ('person' or 'vehicle')
         *         camera_id: Filter by camera ID
         *         since: Filter entities seen since this timestamp
         *         limit: Maximum number of results (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         entity_repo: Entity repository dependency for PostgreSQL queries
         *
         *     Returns:
         *         EntityListResponse with filtered entities and pagination info
         */
        get: operations["list_entities_api_entities_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/matches/{detection_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity Matches
         * @description Find entities matching a specific detection's embedding.
         *
         *     Searches for entities similar to the specified detection's embedding
         *     across all cameras. Used to show re-ID matches in the EventDetailModal.
         *
         *     NOTE: This endpoint continues to use Redis for real-time similarity matching.
         *
         *     Args:
         *         detection_id: Detection ID to find matches for
         *         entity_type: Type of entity to search ('person' or 'vehicle')
         *         threshold: Minimum cosine similarity threshold (default 0.85)
         *         reid_service: Re-identification service dependency
         *
         *     Returns:
         *         EntityMatchResponse with matching entities sorted by similarity
         *
         *     Raises:
         *         HTTPException: 404 if detection embedding not found, 503 if Redis unavailable
         */
        get: operations["get_entity_matches_api_entities_matches__detection_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity Stats
         * @description Get aggregated entity statistics.
         *
         *     Returns statistics about tracked entities including counts by type,
         *     camera, and repeat visitors.
         *
         *     Args:
         *         since: Filter entities seen since this timestamp
         *         until: Filter entities seen until this timestamp
         *         entity_repo: Entity repository dependency
         *
         *     Returns:
         *         EntityStatsResponse with aggregated statistics
         */
        get: operations["get_entity_stats_api_entities_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/v2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Entities V2
         * @description List tracked entities with historical query support.
         *
         *     Returns a paginated list of entities from Redis (hot cache) and/or
         *     PostgreSQL (historical data). Use the source parameter to control
         *     which backend to query.
         *
         *     Args:
         *         entity_type: Filter by entity type ('person' or 'vehicle')
         *         camera_id: Filter by camera ID
         *         since: Filter entities seen since this timestamp
         *         until: Filter entities seen until this timestamp
         *         source: Data source ('redis', 'postgres', 'both') - default 'both'
         *         limit: Maximum number of results (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         reid_service: Re-identification service dependency
         *         hybrid_storage: Hybrid storage service dependency
         *
         *     Returns:
         *         EntityListResponse with filtered entities and pagination info
         */
        get: operations["list_entities_v2_api_entities_v2_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/v2/{entity_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity V2
         * @description Get detailed information about a specific entity from PostgreSQL.
         *
         *     Returns the canonical PostgreSQL entity record with full history.
         *     For real-time Redis entities, use the original /api/entities/{entity_id} endpoint.
         *
         *     Args:
         *         entity_id: UUID of the entity
         *         hybrid_storage: Hybrid storage service dependency
         *
         *     Returns:
         *         EntityDetail with full entity information
         *
         *     Raises:
         *         HTTPException: 404 if entity not found
         */
        get: operations["get_entity_v2_api_entities_v2__entity_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/v2/{entity_id}/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity Detections
         * @description List all detections linked to an entity.
         *
         *     Returns paginated detections associated with the specified entity.
         *
         *     Args:
         *         entity_id: UUID of the entity
         *         limit: Maximum number of results (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         entity_repo: Entity repository dependency
         *
         *     Returns:
         *         EntityDetectionsResponse with linked detections and pagination info
         *
         *     Raises:
         *         HTTPException: 404 if entity not found
         */
        get: operations["get_entity_detections_api_entities_v2__entity_id__detections_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/{entity_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity
         * @description Get detailed information about a specific entity.
         *
         *     Returns the entity's summary information along with all recorded appearances
         *     from PostgreSQL.
         *
         *     Args:
         *         entity_id: UUID of the entity
         *         entity_repo: Entity repository dependency for PostgreSQL queries
         *
         *     Returns:
         *         EntityDetail with full entity information
         *
         *     Raises:
         *         HTTPException: 404 if entity not found
         */
        get: operations["get_entity_api_entities__entity_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/{entity_id}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity History
         * @description Get the appearance timeline for a specific entity.
         *
         *     Returns a chronological list of all appearances for the entity
         *     across all cameras from PostgreSQL.
         *
         *     Args:
         *         entity_id: UUID of the entity
         *         entity_repo: Entity repository dependency for PostgreSQL queries
         *
         *     Returns:
         *         EntityHistoryResponse with appearance timeline
         *
         *     Raises:
         *         HTTPException: 404 if entity not found
         */
        get: operations["get_entity_history_api_entities__entity_id__history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Events
         * @description List events with optional filtering and cursor-based pagination.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Cursor-based pagination offers better performance for large datasets.
         *
         *     Sparse Fieldsets (NEM-1434):
         *     Use the `fields` parameter to request only specific fields in the response,
         *     reducing payload size. Example: ?fields=id,camera_id,risk_level,summary,reviewed
         *
         *     Args:
         *         camera_id: Optional camera ID to filter by
         *         risk_level: Optional risk level to filter by (low, medium, high, critical)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         reviewed: Optional filter by reviewed status
         *         object_type: Optional object type to filter by (person, vehicle, animal, etc.)
         *         limit: Maximum number of results to return (1-100, default 50)
         *         offset: Number of results to skip (deprecated, use cursor instead)
         *         cursor: Pagination cursor from previous response's next_cursor field
         *         fields: Comma-separated list of fields to include (sparse fieldsets)
         *         db: Database session
         *
         *     Returns:
         *         EventListResponse containing filtered events and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         *         HTTPException: 400 if cursor is invalid
         *         HTTPException: 400 if invalid fields are requested
         */
        get: operations["list_events_api_events_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/analyze/{batch_id}/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Analyze Batch Streaming
         * @description Stream LLM analysis progress for a batch via Server-Sent Events (NEM-1665).
         *
         *     This endpoint provides progressive LLM response updates during long inference
         *     times, allowing the frontend to display partial results and show typing
         *     indicators while the analysis is in progress.
         *
         *     Event Types:
         *     - progress: Partial LLM response chunk with accumulated_text
         *     - complete: Final event with risk assessment and event_id
         *     - error: Error information with error_code and recoverable flag
         *
         *     Args:
         *         batch_id: Batch identifier to analyze
         *         camera_id: Optional camera ID (uses Redis lookup if not provided)
         *         detection_ids: Optional comma-separated detection IDs
         *         analyzer: NemotronAnalyzer injected via Depends()
         *
         *     Returns:
         *         StreamingResponse with SSE event stream (text/event-stream)
         *
         *     Example SSE output:
         *         data: {"event_type": "progress", "content": "Based on", "accumulated_text": "Based on"}
         *
         *         data: {"event_type": "progress", "content": " the", "accumulated_text": "Based on the"}
         *
         *         data: {"event_type": "complete", "event_id": 123, "risk_score": 75, ...}
         */
        get: operations["analyze_batch_streaming_api_events_analyze__batch_id__stream_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/bulk": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Bulk create events
         * @description Create multiple events in a single request.
         *
         *     Supports partial success - some events may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk create request with up to 100 events
         *         db: Database session
         *
         *     Returns:
         *         EventBulkCreateResponse with per-item results
         */
        post: operations["bulk_create_events_api_events_bulk_post"];
        /**
         * Bulk delete events
         * @description Delete multiple events in a single request.
         *
         *     Supports partial success - some deletions may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     By default uses soft delete (sets deleted_at timestamp) with cascade to
         *     related detections. Use soft_delete=false for permanent deletion.
         *     Use cascade=false to only delete the event without affecting detections.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk delete request with up to 100 event IDs
         *         db: Database session
         *         cache: Cache service for invalidation
         *
         *     Returns:
         *         BulkOperationResponse with per-item results
         */
        delete: operations["bulk_delete_events_api_events_bulk_delete"];
        options?: never;
        head?: never;
        /**
         * Bulk update events
         * @description Update multiple events in a single request.
         *
         *     Supports partial success - some updates may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk update request with up to 100 event updates
         *         db: Database session
         *
         *     Returns:
         *         BulkOperationResponse with per-item results
         */
        patch: operations["bulk_update_events_api_events_bulk_patch"];
        trace?: never;
    };
    "/api/events/deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all soft-deleted events
         * @description List all soft-deleted events for trash view.
         *
         *     Returns events that have been soft-deleted (deleted_at is not null),
         *     ordered by deleted_at descending (most recently deleted first).
         *
         *     This endpoint enables a "trash" view where users can see deleted events
         *     and optionally restore them.
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         DeletedEventsListResponse containing list of deleted events and count
         */
        get: operations["list_deleted_events_api_events_deleted_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export Events
         * @description Export events as CSV or Excel file for external analysis or record-keeping.
         *
         *     Supports content negotiation via HTTP Accept header:
         *     - `Accept: text/csv` or `Accept: application/csv` - CSV format (default)
         *     - `Accept: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet` - Excel (XLSX)
         *     - `Accept: application/vnd.ms-excel` or `Accept: application/xlsx` - Excel (XLSX)
         *
         *     This endpoint is rate-limited to 10 requests per minute per client IP
         *     to prevent abuse and protect against data exfiltration attacks.
         *
         *     Exports events with the following fields:
         *     - Event ID, camera name, timestamps
         *     - Risk score, risk level, summary
         *     - Detection count, reviewed status
         *
         *     Args:
         *         request: FastAPI request object (includes Accept header for format selection)
         *         camera_id: Optional camera ID to filter by
         *         risk_level: Optional risk level to filter by (low, medium, high, critical)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         reviewed: Optional filter by reviewed status
         *         db: Database session
         *         _rate_limit: Rate limiter dependency (10 req/min, no burst)
         *
         *     Returns:
         *         StreamingResponse with CSV or Response with Excel file containing exported events
         *
         *     Raises:
         *         HTTPException: 429 if rate limit exceeded
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["export_events_api_events_export_get"];
        put?: never;
        /**
         * Start export job
         * @description Start a background export job for events. Returns a job ID that can be used to track progress via GET /api/jobs/{job_id}.
         */
        post: operations["start_export_job_api_events_export_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Events Endpoint
         * @description Search events using full-text search.
         *
         *     This endpoint provides PostgreSQL full-text search across event summaries,
         *     reasoning, object types, and camera names.
         *
         *     Search Query Syntax:
         *     - Basic words: "person vehicle" (implicit AND)
         *     - Phrase search: '"suspicious person"' (exact phrase)
         *     - Boolean OR: "person OR animal"
         *     - Boolean NOT: "person NOT cat"
         *     - Boolean AND: "person AND vehicle" (explicit)
         *
         *     Args:
         *         q: Search query string (required)
         *         camera_id: Optional comma-separated camera IDs to filter by
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         severity: Optional comma-separated risk levels (low, medium, high, critical)
         *         risk_level: Alias for severity - accepts same format
         *         object_type: Optional comma-separated object types (person, vehicle, animal)
         *         reviewed: Optional filter by reviewed status
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         SearchResponse with ranked results and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if any severity value is invalid
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["search_events_endpoint_api_events_search_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Stats
         * @description Get aggregated event statistics.
         *
         *     Returns statistics about events including:
         *     - Total event count
         *     - Events grouped by risk level (critical, high, medium, low)
         *     - Events grouped by camera with camera names
         *
         *     Uses Redis cache with cache-aside pattern to improve performance
         *     and generate cache hit metrics.
         *
         *     Args:
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         camera_id: Optional camera ID filter (for camera-specific stats)
         *         db: Database session
         *         cache: Cache service injected via FastAPI DI
         *
         *     Returns:
         *         EventStatsResponse with aggregated statistics
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["get_event_stats_api_events_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event
         * @description Get a specific event by ID with HATEOAS links.
         *
         *     Args:
         *         event_id: Event ID
         *         request: FastAPI request object for building HATEOAS links
         *         db: Database session
         *
         *     Returns:
         *         Event object with detection count and HATEOAS links
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_api_events__event_id__get"];
        put?: never;
        post?: never;
        /**
         * Soft delete a single event
         * @description Soft delete a single event with optional cascade to related detections.
         *
         *     By default, cascade=True soft deletes all related detections using the same
         *     timestamp as the event. This enables cascade restore by matching timestamps.
         *
         *     Args:
         *         event_id: ID of the event to delete
         *         cascade: If True, cascade soft delete to related detections
         *         db: Database session
         *         cache: Cache service for invalidation
         *
         *     Raises:
         *         HTTPException: 404 if event not found, 409 if already deleted
         */
        delete: operations["delete_event_api_events__event_id__delete"];
        options?: never;
        head?: never;
        /**
         * Update Event
         * @description Update an event (mark as reviewed).
         *
         *     Args:
         *         event_id: Event ID
         *         update_data: Update data (reviewed field)
         *         request: FastAPI request for audit logging
         *         db: Database session
         *         cache: Cache service for cache invalidation (NEM-1938)
         *
         *     Returns:
         *         Updated event object
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        patch: operations["update_event_api_events__event_id__patch"];
        trace?: never;
    };
    "/api/events/{event_id}/clip": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Clip
         * @description Get clip information for a specific event.
         *
         *     Returns information about whether a video clip is available for the event,
         *     and if so, provides the URL to access it along with metadata.
         *
         *     Args:
         *         event_id: Event ID
         *         db: Database session
         *
         *     Returns:
         *         ClipInfoResponse with clip availability and metadata
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_clip_api_events__event_id__clip_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/clip/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Event Clip
         * @description Trigger video clip generation for an event.
         *
         *     If a clip already exists and force=False, returns the existing clip info.
         *     If force=True, regenerates the clip even if one exists.
         *
         *     Clip generation uses detection images to create a video sequence, or
         *     extracts from existing video if available.
         *
         *     Args:
         *         event_id: Event ID
         *         request: Clip generation parameters
         *         db: Database session
         *         clip_generator: ClipGenerator injected via Depends()
         *
         *     Returns:
         *         ClipGenerateResponse with generation status and clip info
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         *         HTTPException: 400 if event has no detections to generate clip from
         */
        post: operations["generate_event_clip_api_events__event_id__clip_generate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Detections
         * @description Get detections for a specific event.
         *
         *     Args:
         *         event_id: Event ID
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         DetectionListResponse containing detections for the event
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_detections_api_events__event_id__detections_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/enrichments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Enrichments
         * @description Get enrichment data for detections in an event with pagination.
         *
         *     Returns structured vision model results from the enrichment pipeline for
         *     each detection in the event. Results include:
         *     - License plate detection and OCR
         *     - Face detection
         *     - Vehicle classification and damage detection
         *     - Clothing analysis (FashionCLIP and SegFormer)
         *     - Violence detection
         *     - Image quality assessment
         *     - Pet classification
         *
         *     Args:
         *         event_id: Event ID
         *         limit: Maximum number of enrichments to return (1-200, default 50)
         *         offset: Number of enrichments to skip (default 0)
         *         db: Database session
         *
         *     Returns:
         *         EventEnrichmentsResponse with enrichment data for each detection and pagination metadata
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["get_event_enrichments_api_events__event_id__enrichments_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/restore": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restore a soft-deleted event
         * @description Restore a soft-deleted event with optional cascade to related detections.
         *
         *     When cascade=True, this restores detections that were deleted at the same
         *     timestamp as the event, indicating they were cascade-deleted together.
         *
         *     Args:
         *         event_id: ID of the event to restore
         *         cascade: If True, cascade restore to related detections
         *         db: Database session
         *         cache: Cache service for invalidation
         *
         *     Returns:
         *         The restored event as EventResponse
         *
         *     Raises:
         *         HTTPException: 404 if event not found, 409 if not deleted
         */
        post: operations["restore_event_api_events__event_id__restore_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/exports": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List export jobs
         * @description List recent export jobs with optional filtering by status.
         */
        get: operations["list_exports_api_exports_get"];
        put?: never;
        /**
         * Start export job
         * @description Start a new background export job. Returns a job ID that can be used to track progress via GET /api/exports/{job_id}.
         */
        post: operations["start_export_api_exports_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/exports/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get export status
         * @description Get the current status and progress of an export job.
         */
        get: operations["get_export_status_api_exports__job_id__get"];
        put?: never;
        post?: never;
        /**
         * Cancel export job
         * @description Cancel a pending or running export job. Completed or failed jobs cannot be cancelled.
         */
        delete: operations["cancel_export_api_exports__job_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/exports/{job_id}/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download export file
         * @description Download the completed export file.
         */
        get: operations["download_export_api_exports__job_id__download_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/exports/{job_id}/download/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get download info
         * @description Get metadata about the export file for download.
         */
        get: operations["get_download_info_api_exports__job_id__download_info_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/feedback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Submit event feedback
         * @description Submit feedback for an event.
         *
         *     Allows users to mark events as false positives, missed detections,
         *     wrong severity, or correctly classified. Only one feedback per event
         *     is allowed (enforced by unique constraint).
         *
         *     This feedback is used to calibrate personalized risk thresholds
         *     and improve the AI model's accuracy over time.
         *
         *     Args:
         *         feedback_data: Feedback details including event_id and feedback_type
         *         db: Database session
         *
         *     Returns:
         *         The created feedback record
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         *         HTTPException: 409 if feedback already exists for this event
         */
        post: operations["create_feedback_api_feedback_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/feedback/event/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get feedback for an event
         * @description Get feedback for a specific event.
         *
         *     Args:
         *         event_id: The event ID to get feedback for
         *         db: Database session
         *
         *     Returns:
         *         The feedback record for the event
         *
         *     Raises:
         *         HTTPException: 404 if no feedback exists for the event
         */
        get: operations["get_event_feedback_api_feedback_event__event_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/feedback/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get feedback statistics
         * @description Get aggregate feedback statistics.
         *
         *     Returns counts of feedback grouped by:
         *     - Feedback type (false_positive, missed_detection, wrong_severity, correct)
         *     - Camera ID
         *
         *     This data is useful for:
         *     - Identifying cameras with high false positive rates
         *     - Calibrating risk thresholds per camera
         *     - Tracking model accuracy over time
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         Aggregate statistics including total count and breakdowns
         */
        get: operations["get_feedback_stats_api_feedback_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all jobs
         * @description List all background jobs with optional filtering by type and status.
         */
        get: operations["list_jobs_api_jobs_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/bulk-cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Bulk cancel jobs
         * @description Cancel multiple jobs at once. Returns counts of successful and failed cancellations.
         */
        post: operations["bulk_cancel_jobs_api_jobs_bulk_cancel_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search and filter jobs
         * @description Search and filter jobs with advanced query capabilities. Supports free text search, filtering by status/type/timestamps/duration, and returns aggregation data for faceted filtering. NEM-2392: Advanced job search endpoint.
         */
        get: operations["search_jobs_api_jobs_search_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get job statistics
         * @description Get aggregate statistics about jobs including counts by status, counts by type, and timing information.
         */
        get: operations["get_job_stats_api_jobs_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List available job types
         * @description List all available job types that can be created.
         */
        get: operations["list_job_types_api_jobs_types_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get job status
         * @description Get the current status and progress of a background job.
         */
        get: operations["get_job_status_api_jobs__job_id__get"];
        put?: never;
        post?: never;
        /**
         * Cancel or abort a job
         * @description Cancel or abort a job based on its current state. Queued jobs will be cancelled, running jobs will be aborted.
         */
        delete: operations["delete_job_api_jobs__job_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/abort": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Abort a running job
         * @description Abort a running background job by sending a signal to the worker. Only jobs with status 'running' can be aborted. Queued jobs should use the /cancel endpoint instead.
         */
        post: operations["abort_job_api_jobs__job_id__abort_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel a job
         * @description Request cancellation of a background job. Jobs that are already completed or failed cannot be cancelled.
         */
        post: operations["cancel_job_api_jobs__job_id__cancel_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/detail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get detailed job information
         * @description Get detailed information about a specific job including full progress history, timing information, retry details, and execution metadata. NEM-2390: Provides comprehensive job status for monitoring and debugging.
         */
        get: operations["get_job_detail_api_jobs__job_id__detail_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get job history
         * @description Retrieve complete job execution history including state transitions, retry attempts, and execution timeline. Provides audit trail for debugging and compliance purposes. NEM-2396.
         */
        get: operations["get_job_history_api_jobs__job_id__history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get job logs
         * @description Retrieve execution logs for a job with optional filtering by level and time range. Useful for debugging and monitoring job execution. NEM-2396.
         */
        get: operations["get_job_logs_api_jobs__job_id__logs_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Logs
         * @description List logs with optional filtering and cursor-based pagination.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Cursor-based pagination offers better performance for large datasets.
         *
         *     **Performance Note:** Total count queries are expensive for large datasets. By default,
         *     the total count is not calculated (returns 0). Use `include_total_count=true` only when
         *     the total count is needed (e.g., for displaying "X of Y results" in UI). For pagination,
         *     `has_more` and `next_cursor` provide sufficient information.
         *
         *     Args:
         *         level: Optional log level to filter by (DEBUG, INFO, WARNING, ERROR, CRITICAL)
         *         component: Optional component name to filter by
         *         camera_id: Optional camera ID to filter by
         *         source: Optional source to filter by (backend, frontend)
         *         search: Optional search term for message text
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         limit: Maximum number of results to return (1-1000, default 100)
         *         offset: Number of results to skip (deprecated, use cursor instead)
         *         cursor: Pagination cursor from previous response's next_cursor field
         *         include_total_count: Whether to calculate total count (default False for performance)
         *         db: Database session
         *
         *     Returns:
         *         LogsResponse containing filtered logs and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         *         HTTPException: 400 if cursor is invalid
         */
        get: operations["list_logs_api_logs_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/frontend": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Frontend Log
         * @description Receive and store a log from the frontend.
         */
        post: operations["create_frontend_log_api_logs_frontend_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Log Stats
         * @description Get log statistics for dashboard.
         *
         *     Optimized to use a single aggregation query with conditional counting
         *     instead of 5 separate queries. This reduces database round-trips and
         *     improves performance for high-volume log tables.
         */
        get: operations["get_log_stats_api_logs_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/{log_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Log
         * @description Get a single log entry by ID.
         */
        get: operations["get_log_api_logs__log_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/cameras/{camera_id}/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Camera File
         * @description Serve camera images or videos from Foscam storage.
         *
         *     Args:
         *         camera_id: The camera identifier (directory name)
         *         filename: The file to serve (can include subdirectories)
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["serve_camera_file_api_media_cameras__camera_id___filename__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/clips/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Clip
         * @description Serve event video clips.
         *
         *     Clips are generated by the ClipGenerator service and stored in the
         *     configured clips directory.
         *
         *     Args:
         *         filename: The clip filename (e.g., "123_clip.mp4")
         *         clip_generator: ClipGenerator injected via Depends()
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["serve_clip_api_media_clips__filename__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/thumbnails/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Thumbnail
         * @description Serve detection thumbnail images.
         *
         *     Args:
         *         filename: The thumbnail filename
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["serve_thumbnail_api_media_thumbnails__filename__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Media Compat
         * @description Compatibility route: serve media via design-spec-style /api/media/{path}.
         *
         *     This preserves the stricter behavior of the new routes:
         *     - Path traversal protection
         *     - Allowed file type allowlist
         *     - Must remain under configured base directories
         *
         *     Mapping rules:
         *     - `cameras/<camera_id>/<filename...>` -> camera media
         *     - `thumbnails/<filename>` -> thumbnails
         *     - `detections/<id>` -> detection images
         */
        get: operations["serve_media_compat_api_media__path__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Metrics
         * @description Return Prometheus metrics in exposition format.
         *
         *     This endpoint returns all registered metrics in the standard
         *     Prometheus exposition format for scraping.
         *
         *     Returns:
         *         Response with text/plain content type containing metrics
         */
        get: operations["metrics_api_metrics_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Notification Preferences
         * @description Get global notification preferences.
         *
         *     Returns the global notification settings including:
         *     - Whether notifications are enabled
         *     - Notification sound selection
         *     - Risk level filters (which risk levels trigger notifications)
         *
         *     Returns:
         *         NotificationPreferencesResponse with current preferences
         */
        get: operations["get_notification_preferences_api_notification_preferences__get"];
        /**
         * Update Notification Preferences
         * @description Update global notification preferences.
         *
         *     Args:
         *         update: Preferences update data
         *
         *     Returns:
         *         NotificationPreferencesResponse with updated preferences
         *
         *     Raises:
         *         HTTPException: 400 if sound value is invalid
         */
        put: operations["update_notification_preferences_api_notification_preferences__put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Camera Settings
         * @description Get all camera notification settings.
         *
         *     Returns:
         *         CameraNotificationSettingsListResponse with all camera settings
         */
        get: operations["get_all_camera_settings_api_notification_preferences_cameras_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/cameras/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Setting
         * @description Get notification setting for a specific camera.
         *
         *     Args:
         *         camera_id: Camera ID
         *
         *     Returns:
         *         CameraNotificationSettingResponse for the camera
         *
         *     Raises:
         *         HTTPException: 404 if setting not found
         */
        get: operations["get_camera_setting_api_notification_preferences_cameras__camera_id__get"];
        /**
         * Update Camera Setting
         * @description Update or create notification setting for a camera.
         *
         *     Args:
         *         camera_id: Camera ID
         *         update: Setting update data
         *
         *     Returns:
         *         CameraNotificationSettingResponse with updated setting
         *
         *     Raises:
         *         HTTPException: 404 if camera doesn't exist
         */
        put: operations["update_camera_setting_api_notification_preferences_cameras__camera_id__put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/quiet-hours": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Quiet Hours
         * @description Get all quiet hours periods.
         *
         *     Returns:
         *         QuietHoursPeriodsListResponse with all quiet periods
         */
        get: operations["get_quiet_hours_api_notification_preferences_quiet_hours_get"];
        put?: never;
        /**
         * Create Quiet Hours Period
         * @description Create a new quiet hours period.
         *
         *     Args:
         *         period: Quiet hours period data
         *
         *     Returns:
         *         QuietHoursPeriodResponse with created period
         *
         *     Raises:
         *         HTTPException: 400 if start_time equals end_time (zero-length period)
         *
         *     Note:
         *         Periods can span midnight (e.g., 22:00 to 06:00).
         *         If start_time > end_time, the period wraps to the next day.
         */
        post: operations["create_quiet_hours_period_api_notification_preferences_quiet_hours_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/quiet-hours/{period_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Quiet Hours Period
         * @description Delete a quiet hours period.
         *
         *     Args:
         *         period_id: Period UUID
         *
         *     Raises:
         *         HTTPException: 404 if period not found
         */
        delete: operations["delete_quiet_hours_period_api_notification_preferences_quiet_hours__period_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Notification Config
         * @description Get notification configuration status.
         *
         *     Returns the current notification configuration including:
         *     - Whether notifications are enabled
         *     - Which channels are configured (email, webhook, push)
         *     - SMTP host and port (if configured)
         *     - Default webhook URL (if configured)
         *     - Default email recipients
         *
         *     Note: Sensitive fields like SMTP password are NOT returned.
         *
         *     Returns:
         *         NotificationConfigResponse with current notification settings
         */
        get: operations["get_notification_config_api_notification_config_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Notification
         * @description Test notification delivery for a specific channel.
         *
         *     Sends a test notification to verify the configuration is working.
         *     For email, sends a test email to the specified recipients or default recipients.
         *     For webhook, sends a test payload to the specified URL or default URL.
         *
         *     Args:
         *         test_request: Test notification request with channel and optional overrides
         *
         *     Returns:
         *         TestNotificationResponse with test result
         */
        post: operations["test_notification_api_notification_test_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/queues/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get queue status
         * @description Get the status of all job queues including depth, processing rate, and health.
         *
         *     **Queues Monitored:**
         *     - `detection`: Object detection jobs from camera uploads
         *     - `ai_analysis`: LLM risk analysis jobs for batched detections
         *     - `dlq`: Dead-letter queue for failed jobs
         *
         *     **Health Status:**
         *     - `healthy`: Queue depth below warning threshold, wait times acceptable
         *     - `warning`: Queue depth approaching limits or wait times elevated
         *     - `critical`: Queue depth exceeds limits or oldest job waiting too long
         *
         *     **Thresholds:**
         *     Each queue has configurable thresholds:
         *     - `depth_warning`: Queue depth that triggers warning status
         *     - `depth_critical`: Queue depth that triggers critical status
         *     - `max_wait_seconds`: Maximum acceptable wait time for oldest job
         */
        get: operations["get_queues_status_api_queues_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rum": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ingest RUM metrics
         * @description Receive Core Web Vitals metrics from the frontend for Real User Monitoring.
         */
        post: operations["ingest_rum_metrics_api_rum_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/anomaly-config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Anomaly Config
         * @description Get current anomaly detection configuration.
         *
         *     Returns the current settings for the baseline service including:
         *     - threshold_stdev: Number of standard deviations for anomaly detection
         *     - min_samples: Minimum samples required before anomaly detection is reliable
         *     - decay_factor: Exponential decay factor for EWMA (weights recent observations)
         *     - window_days: Rolling window size in days for baseline calculations
         *
         *     Args:
         *         service: BaselineService injected via Depends()
         *
         *     Returns:
         *         AnomalyConfig with current anomaly detection settings
         */
        get: operations["get_anomaly_config_api_system_anomaly_config_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Anomaly Config
         * @description Update anomaly detection configuration.
         *
         *     Allows updating the anomaly detection thresholds:
         *     - threshold_stdev: Number of standard deviations for anomaly detection
         *     - min_samples: Minimum samples required before anomaly detection is reliable
         *
         *     Note: decay_factor and window_days are not configurable at runtime
         *     as they affect historical data calculations.
         *
         *     Requires API key authentication.
         *
         *     Args:
         *         config_update: Configuration values to update (only provided values are changed)
         *         request: HTTP request for audit logging
         *         db: Database session
         *         service: BaselineService injected via Depends()
         *
         *     Returns:
         *         AnomalyConfig with updated settings
         */
        patch: operations["update_anomaly_config_api_system_anomaly_config_patch"];
        trace?: never;
    };
    "/api/system/circuit-breakers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Circuit Breakers
         * @description Get status of all circuit breakers in the system.
         *
         *     Returns the current state and metrics for each circuit breaker,
         *     which protect external services from cascading failures.
         *
         *     Circuit breakers can be in one of three states:
         *     - CLOSED: Normal operation, calls pass through
         *     - OPEN: Service failing, calls rejected immediately
         *     - HALF_OPEN: Testing recovery, limited calls allowed
         *
         *     Returns:
         *         CircuitBreakersResponse with status of all circuit breakers
         */
        get: operations["get_circuit_breakers_api_system_circuit_breakers_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/circuit-breakers/{name}/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset Circuit Breaker
         * @description Reset a specific circuit breaker to CLOSED state.
         *
         *     This manually resets a circuit breaker, clearing failure counts
         *     and returning it to normal operation. Use this to recover from
         *     transient failures or after fixing an underlying issue.
         *
         *     Requires API key authentication when api_key_enabled is True.
         *
         *     Args:
         *         name: Name of the circuit breaker to reset
         *
         *     Returns:
         *         CircuitBreakerResetResponse with reset confirmation
         *
         *     Raises:
         *         HTTPException 400: If name is invalid (empty, too long, or contains invalid characters)
         *         HTTPException 404: If circuit breaker not found
         */
        post: operations["reset_circuit_breaker_api_system_circuit_breakers__name__reset_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/cleanup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Cleanup
         * @description Trigger manual data cleanup based on retention settings.
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     This endpoint runs the CleanupService to delete old data according to
         *     the configured retention period. It deletes:
         *     - Events older than retention period
         *     - Detections older than retention period
         *     - GPU stats older than retention period
         *     - Logs older than log retention period
         *     - Associated thumbnail files
         *     - Optionally original image files (if delete_images is enabled)
         *
         *     The cleanup respects the current retention_days setting from the system
         *     configuration. To change the retention period before running cleanup,
         *     use PATCH /api/system/config first.
         *
         *     Args:
         *         dry_run: If True, calculate and return what would be deleted without
         *                  actually performing the deletion. Useful for verification
         *                  before destructive operations.
         *
         *     Returns:
         *         CleanupResponse with statistics about the cleanup operation.
         *         When dry_run=True, the counts represent what would be deleted.
         */
        post: operations["trigger_cleanup_api_system_cleanup_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/cleanup/orphaned-files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Run Orphaned File Cleanup
         * @description Find and clean up orphaned files (files on disk not referenced in database).
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     This endpoint scans storage directories for files that are not referenced
         *     in the database and optionally deletes them to reclaim disk space.
         *
         *     Storage directories scanned:
         *     - Thumbnails directory (video_thumbnails_dir setting)
         *     - Clips directory (clips_directory setting)
         *
         *     Database tables checked for file references:
         *     - Detection.file_path (source images)
         *     - Detection.thumbnail_path (thumbnails)
         *     - Event.clip_path (generated clips)
         *
         *     **Safety Features:**
         *     - dry_run=True by default to prevent accidental deletion
         *     - Progress tracking via job system
         *     - Detailed reporting of orphaned files
         *
         *     Args:
         *         dry_run: If True, calculate and return what would be deleted without
         *                  actually performing the deletion. Default is True for safety.
         *                  Set to False to actually delete orphaned files.
         *
         *     Returns:
         *         OrphanedFileCleanupResponse with statistics about orphaned files.
         *         When dry_run=True, shows what would be deleted.
         *         When dry_run=False, shows what was deleted.
         */
        post: operations["run_orphaned_file_cleanup_api_system_cleanup_orphaned_files_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/cleanup/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Cleanup Status
         * @description Get current status of the cleanup service.
         *
         *     Returns information about the automated cleanup service including:
         *     - Whether the service is running
         *     - Current retention settings
         *     - Next scheduled cleanup time
         *
         *     Returns:
         *         CleanupStatusResponse with cleanup service status
         */
        get: operations["get_cleanup_status_api_system_cleanup_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Config
         * @description Get public configuration settings.
         *
         *     Returns non-sensitive application configuration values.
         *     Does NOT expose database URLs, API keys, or other secrets.
         *
         *     Returns:
         *         ConfigResponse with public configuration settings
         */
        get: operations["get_config_api_system_config_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Patch Config
         * @description Patch processing-related configuration and persist runtime overrides.
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     Notes:
         *     - This updates a runtime override env file (see `HSI_RUNTIME_ENV_PATH`) and clears the
         *       settings cache so subsequent `get_settings()` calls observe the new values.
         */
        patch: operations["patch_config_api_system_config_patch"];
        trace?: never;
    };
    "/api/system/gpu": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Gpu Stats
         * @description Get current GPU statistics.
         *
         *     Returns the most recent GPU statistics including:
         *     - GPU name
         *     - GPU utilization percentage
         *     - Memory usage (used/total)
         *     - Temperature
         *     - Power usage
         *     - Inference FPS
         *
         *     Returns:
         *         GPUStatsResponse with GPU statistics (null values if unavailable)
         */
        get: operations["get_gpu_stats_api_system_gpu_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Gpu Stats History
         * @description Get recent GPU stats samples as a time-series.
         *
         *     Returns GPU stats in standard pagination envelope format (NEM-2178):
         *     - items: GPU stats samples (renamed from 'samples')
         *     - pagination: Standard pagination metadata
         *
         *     Args:
         *         since: Optional lower bound for recorded_at (ISO datetime)
         *         limit: Maximum number of samples to return (default 300, max 5000)
         *         db: Database session
         */
        get: operations["get_gpu_stats_history_api_system_gpu_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Health
         * @description Get detailed system health check.
         *
         *     Checks the health of all system components:
         *     - Database connectivity
         *     - Redis connectivity
         *     - AI services status
         *
         *     Health checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).
         *     If a health check times out, the service is marked as unhealthy.
         *
         *     Returns:
         *         HealthResponse with overall status and individual service statuses.
         *         HTTP 200 if healthy, 503 if degraded or unhealthy.
         */
        get: operations["get_health_api_system_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/full": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Full System Health Status
         * @description Get comprehensive health status for all system components.
         */
        get: operations["get_full_health_api_system_health_full_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Readiness
         * @description Kubernetes-style readiness probe endpoint with detailed information.
         *
         *     This endpoint indicates whether the application is ready to receive
         *     traffic and process uploads. It checks all critical dependencies:
         *     - Database connectivity (critical)
         *     - Redis connectivity (required for queue processing)
         *     - AI services availability
         *     - Background worker status
         *
         *     Note: The canonical readiness probe is GET /ready at the root level.
         *     This endpoint provides the same readiness check but with detailed
         *     service and worker status information.
         *
         *     Used by Kubernetes/Docker to determine if traffic should be routed to this instance.
         *     If this endpoint returns not_ready, the instance should not receive new requests.
         *
         *     Health checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).
         *     If a health check times out, the service is marked as unhealthy.
         *
         *     Returns:
         *         ReadinessResponse with overall readiness status and detailed checks.
         *         HTTP 200 if ready, 503 if degraded or not ready.
         */
        get: operations["get_readiness_api_system_health_ready_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/websocket": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Websocket Health
         * @description Get health status of WebSocket broadcasters and their circuit breakers.
         *
         *     Returns the current state of circuit breakers for:
         *     - Event broadcaster: Handles real-time security event distribution
         *     - System broadcaster: Handles system status updates (GPU, cameras, queues)
         *
         *     Circuit breakers protect the system from cascading failures by:
         *     - Opening after repeated connection failures
         *     - Blocking recovery attempts while open to allow stabilization
         *     - Gradually testing recovery in half-open state
         *
         *     Circuit breaker states:
         *     - closed: Normal operation, WebSocket events flowing normally
         *     - open: Failures detected, events may be delayed or unavailable
         *     - half_open: Testing recovery, limited operations allowed
         *
         *     Returns:
         *         WebSocketHealthResponse with circuit breaker status for both broadcasters
         */
        get: operations["get_websocket_health_api_system_health_websocket_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/model-zoo/latency/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Zoo Latency History
         * @description Get latency history for a specific Model Zoo model.
         *
         *     Returns time-series latency data for the dropdown-controlled chart.
         *     Each bucket contains aggregated statistics (avg, p50, p95).
         *
         *     Args:
         *         model: Model name to get history for
         *         since: Number of minutes of history to return (default 60)
         *         bucket_seconds: Size of each time bucket in seconds (default 60)
         *
         *     Returns:
         *         ModelLatencyHistoryResponse with chronologically ordered snapshots
         *
         *     Raises:
         *         HTTPException: 404 if model not found in registry
         */
        get: operations["get_model_zoo_latency_history_api_system_model_zoo_latency_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/model-zoo/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Zoo Status
         * @description Get status information for all Model Zoo models.
         *
         *     Returns status information for all 18 Model Zoo models, including:
         *     - Current status (loaded, unloaded, disabled)
         *     - VRAM usage when loaded
         *     - Last usage timestamp
         *     - Category grouping for UI display
         *
         *     This endpoint is optimized for the compact status card display
         *     in the AI Performance page.
         *
         *     Returns:
         *         ModelZooStatusResponse with all model statuses
         */
        get: operations["get_model_zoo_status_api_system_model_zoo_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/models": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Zoo Registry
         * @description Get the current status of all models in the Model Zoo.
         *
         *     Returns comprehensive information about all AI models available in the system,
         *     including their VRAM requirements, loading status, and configuration.
         *
         *     **VRAM Budget**: The Model Zoo has a dedicated VRAM budget of 1650 MB,
         *     separate from the RT-DETRv2 detector and Nemotron LLM allocations.
         *
         *     **Loading Strategy**: Models are loaded sequentially (one at a time) to
         *     prevent VRAM fragmentation and ensure stable operation.
         *
         *     **Model Categories**:
         *     - detection: Object detection models (YOLO variants)
         *     - recognition: Face and license plate recognition
         *     - ocr: Optical character recognition
         *     - embedding: Visual embedding models (CLIP)
         *     - depth-estimation: Depth estimation models
         *     - pose: Human pose estimation
         *
         *     Returns:
         *         ModelRegistryResponse with VRAM stats and all model statuses
         */
        get: operations["get_models_api_system_models_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/models/{model_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Status
         * @description Get detailed status information for a specific model.
         *
         *     Args:
         *         model_name: Unique identifier of the model (e.g., 'yolo11-license-plate')
         *
         *     Returns:
         *         ModelStatusResponse with detailed model information
         *
         *     Raises:
         *         HTTPException: 404 if model not found in registry
         */
        get: operations["get_model_api_system_models__model_name__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/monitoring/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Monitoring Health
         * @description Get comprehensive monitoring stack health status.
         *
         *     Checks the health of the monitoring infrastructure including:
         *     - Prometheus server reachability
         *     - Scrape target status (UP/DOWN counts by job)
         *     - Exporter status (redis-exporter, json-exporter, blackbox-exporter)
         *     - Metrics collection status
         *
         *     This endpoint provides operators with a quick view of monitoring
         *     stack health without needing to access the Prometheus UI directly.
         *
         *     Returns:
         *         MonitoringHealthResponse with full monitoring stack status.
         *         The 'healthy' field is True if Prometheus is reachable and
         *         the majority of critical targets are up.
         */
        get: operations["get_monitoring_health_api_system_monitoring_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/monitoring/targets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Monitoring Targets
         * @description Get detailed status of all Prometheus scrape targets.
         *
         *     Returns complete information about every target Prometheus is
         *     configured to scrape, including:
         *     - Job and instance identifiers
         *     - Health status (up/down)
         *     - All labels associated with the target
         *     - Last scrape timestamp and duration
         *     - Any scrape errors
         *
         *     This endpoint is useful for debugging specific target issues
         *     or getting a comprehensive view of all monitored endpoints.
         *
         *     Returns:
         *         MonitoringTargetsResponse with detailed target information.
         *
         *     Raises:
         *         HTTPException: 503 if Prometheus is unreachable
         */
        get: operations["get_monitoring_targets_api_system_monitoring_targets_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/performance": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Performance Metrics
         * @description Get current system performance metrics.
         *
         *     Collects and returns real-time metrics from all system components:
         *     - GPU: Utilization, VRAM usage, temperature, power consumption
         *     - AI Models: RT-DETRv2 and Nemotron status and resource usage
         *     - Inference: Latency percentiles and throughput metrics
         *     - Databases: PostgreSQL and Redis connection status and performance
         *     - Host: CPU, RAM, and disk usage
         *     - Containers: Health status of all running containers
         *     - Alerts: Active performance alerts when thresholds are exceeded
         *
         *     This endpoint powers the System Performance Dashboard and provides
         *     a comprehensive snapshot of system health at the time of the request.
         *
         *     Returns:
         *         PerformanceUpdate with all available metrics. Fields may be None
         *         if a particular metric source is unavailable.
         *
         *     Raises:
         *         HTTPException: 503 if performance collector is not initialized
         *         HTTPException: 500 if metric collection fails
         */
        get: operations["get_performance_metrics_api_system_performance_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/performance/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Performance History
         * @description Get historical system performance metrics.
         *
         *     Returns historical performance snapshots for time-series visualization.
         *     The data is sampled based on the requested time range to provide
         *     approximately 60 data points for each range:
         *
         *     - 5m: All snapshots from the last 5 minutes (every 5s = 60 points max)
         *     - 15m: Sampled snapshots from last 15 minutes (every 15s = 60 points max)
         *     - 60m: Sampled snapshots from last 60 minutes (every 60s = 60 points max)
         *
         *     This endpoint enables the System Performance Dashboard to display
         *     historical trends and patterns in system metrics.
         *
         *     Args:
         *         time_range: Time range for history (5m, 15m, or 60m). Defaults to 5m.
         *
         *     Returns:
         *         PerformanceHistoryResponse containing:
         *         - snapshots: List of PerformanceUpdate objects in chronological order
         *         - time_range: The requested time range
         *         - count: Number of snapshots returned
         */
        get: operations["get_performance_history_api_system_performance_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Status
         * @description Get combined status of all pipeline operations.
         *
         *     Returns real-time visibility into the AI processing pipeline:
         *
         *     **FileWatcher**: Monitors camera directories for new uploads
         *     - running: Whether the watcher is active
         *     - camera_root: Directory being watched
         *     - pending_tasks: Files waiting for debounce completion
         *     - observer_type: Filesystem observer type (native/polling)
         *
         *     **BatchAggregator**: Groups detections into time-based batches
         *     - active_batches: Number of batches being aggregated
         *     - batches: Details of each active batch
         *     - batch_window_seconds: Configured window timeout
         *     - idle_timeout_seconds: Configured idle timeout
         *
         *     **DegradationManager**: Handles graceful degradation
         *     - mode: Current degradation mode (normal/degraded/minimal/offline)
         *     - is_degraded: Whether system is in any degraded state
         *     - services: Health status of registered services
         *     - available_features: Features available in current mode
         *
         *     Returns:
         *         PipelineStatusResponse with status of all pipeline services
         */
        get: operations["get_pipeline_status_api_system_pipeline_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline-latency": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Latency
         * @description Get pipeline latency metrics with percentiles.
         *
         *     Returns latency statistics for each stage transition in the AI pipeline:
         *     - watch_to_detect: Time from file watcher detecting image to RT-DETR processing start
         *     - detect_to_batch: Time from detection completion to batch aggregation
         *     - batch_to_analyze: Time from batch completion to Nemotron analysis start
         *     - total_pipeline: Total end-to-end processing time
         *
         *     Each stage includes:
         *     - avg_ms: Average latency in milliseconds
         *     - min_ms: Minimum latency
         *     - max_ms: Maximum latency
         *     - p50_ms: 50th percentile (median)
         *     - p95_ms: 95th percentile
         *     - p99_ms: 99th percentile
         *     - sample_count: Number of samples used
         *
         *     Args:
         *         window_minutes: Time window for statistics calculation (default 60 minutes)
         *
         *     Returns:
         *         PipelineLatencyResponse with latency statistics for each stage
         */
        get: operations["get_pipeline_latency_api_system_pipeline_latency_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline-latency/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Latency History
         * @description Get pipeline latency history for time-series visualization.
         *
         *     Returns latency data grouped into time buckets for charting.
         *     Each bucket contains aggregated statistics for all pipeline stages.
         *
         *     Args:
         *         since: Number of minutes of history to return (1-1440, default 60)
         *         bucket_seconds: Size of each time bucket in seconds (10-3600, default 60)
         *
         *     Returns:
         *         PipelineLatencyHistoryResponse with chronologically ordered snapshots
         */
        get: operations["get_pipeline_latency_history_api_system_pipeline_latency_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Services
         * @description Get status of all managed services.
         *
         *     Args:
         *         category: Optional filter by category (infrastructure, ai, monitoring)
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         List of services with status and category summaries.
         */
        get: operations["list_services_api_system_services_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services/{name}/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Disable Service
         * @description Manually disable a service.
         *
         *     Prevents self-healing restarts.
         *
         *     Args:
         *         name: Service name to disable
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         Action result with updated service information
         *
         *     Raises:
         *         HTTPException: 404 if service not found
         */
        post: operations["disable_service_api_system_services__name__disable_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services/{name}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable Service
         * @description Re-enable a disabled service.
         *
         *     Resets failure count and allows self-healing to resume.
         *
         *     Args:
         *         name: Service name to enable
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         Action result with updated service information
         *
         *     Raises:
         *         HTTPException: 404 if service not found
         */
        post: operations["enable_service_api_system_services__name__enable_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services/{name}/restart": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restart Service
         * @description Manually restart a service.
         *
         *     Resets failure count (manual restart is intentional).
         *
         *     Args:
         *         name: Service name to restart
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         Action result with updated service information
         *
         *     Raises:
         *         HTTPException: 404 if service not found, 400 if service is disabled
         */
        post: operations["restart_service_api_system_services__name__restart_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services/{name}/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Service
         * @description Start a stopped service container.
         *
         *     Args:
         *         name: Service name to start
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         Action result with updated service information
         *
         *     Raises:
         *         HTTPException: 404 if service not found,
         *                        400 if service is already running or disabled
         */
        post: operations["start_service_api_system_services__name__start_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/severity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Severity Metadata
         * @description Get severity level definitions and thresholds.
         *
         *     Returns complete information about the severity taxonomy including:
         *     - All severity level definitions (LOW, MEDIUM, HIGH, CRITICAL)
         *     - Risk score thresholds for each level
         *     - Color codes for UI display
         *     - Human-readable labels and descriptions
         *
         *     This endpoint is useful for frontends to:
         *     - Display severity information consistently
         *     - Show severity legends in the UI
         *     - Validate severity-related user inputs
         *     - Map risk scores to severity levels client-side
         *
         *     Returns:
         *         SeverityMetadataResponse with all severity definitions and current thresholds
         */
        get: operations["get_severity_metadata_api_system_severity_get"];
        /**
         * Update Severity Thresholds
         * @description Update severity threshold configuration.
         *
         *     Updates the risk score thresholds for severity levels. The thresholds
         *     define how risk scores (0-100) are mapped to severity levels:
         *     - LOW: 0 to low_max
         *     - MEDIUM: low_max+1 to medium_max
         *     - HIGH: medium_max+1 to high_max
         *     - CRITICAL: high_max+1 to 100
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     Validation:
         *     - Thresholds must be strictly ordered: low_max < medium_max < high_max
         *     - All thresholds must be between 1 and 99
         *     - This ensures contiguous, non-overlapping ranges covering 0-100
         *
         *     Note: Changes only affect new events. Existing events retain their
         *     original severity assignment.
         *
         *     Args:
         *         update: New threshold values
         *
         *     Returns:
         *         SeverityMetadataResponse with updated definitions and thresholds
         *
         *     Raises:
         *         HTTPException 400: If thresholds are not strictly ordered
         */
        put: operations["update_severity_thresholds_api_system_severity_put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Stats
         * @description Get system statistics.
         *
         *     Returns aggregate statistics about the system:
         *     - Total number of cameras
         *     - Total number of events
         *     - Total number of detections
         *     - Application uptime
         *
         *     Returns:
         *         SystemStatsResponse with system statistics
         */
        get: operations["get_stats_api_system_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/storage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Storage Stats
         * @description Get storage statistics and disk usage metrics.
         *
         *     Returns detailed storage usage information including:
         *     - Overall disk usage (used/total/free)
         *     - Storage breakdown by category (thumbnails, images, clips)
         *     - Database record counts (events, detections, GPU stats, logs)
         *
         *     This endpoint helps operators:
         *     - Monitor available storage space
         *     - Understand storage distribution across data types
         *     - Plan cleanup operations
         *     - Track database growth
         *
         *     Returns:
         *         StorageStatsResponse with comprehensive storage metrics
         */
        get: operations["get_storage_stats_api_system_storage_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/supervisor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Supervisor Status
         * @description Get status of the Worker Supervisor and all supervised workers.
         *
         *     The Worker Supervisor monitors pipeline worker tasks and automatically
         *     restarts them with exponential backoff when they crash.
         *
         *     Returns:
         *         WorkerSupervisorStatusResponse with:
         *         - running: Whether the supervisor is active
         *         - worker_count: Number of registered workers
         *         - workers: Detailed status of each supervised worker including:
         *           - status: running/stopped/crashed/restarting/failed
         *           - restart_count: Number of restart attempts
         *           - last_started_at/last_crashed_at: Timestamps
         *           - error: Last error message if crashed
         *
         *     Use this endpoint to monitor worker health and identify workers that
         *     are repeatedly crashing or have exceeded their restart limit.
         */
        get: operations["get_supervisor_status_api_system_supervisor_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/supervisor/reset/{worker_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset Worker
         * @description Reset a failed worker's restart count to allow new restart attempts.
         *
         *     When a worker exceeds its max restart limit, it enters FAILED status
         *     and won't be restarted. Use this endpoint to reset the worker's
         *     restart count and transition it back to STOPPED status, allowing
         *     the supervisor to attempt restarts again.
         *
         *     Args:
         *         worker_name: Name of the worker to reset
         *
         *     Returns:
         *         Dictionary with success status and message
         *
         *     Raises:
         *         HTTPException 404: Worker not found
         *         HTTPException 503: Supervisor not initialized
         */
        post: operations["reset_worker_api_system_supervisor_reset__worker_name__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/telemetry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Telemetry
         * @description Get pipeline telemetry data.
         *
         *     Returns real-time metrics about the AI processing pipeline:
         *     - Queue depths: Items waiting in detection and analysis queues
         *     - Stage latencies: Processing time statistics for each pipeline stage
         *
         *     This endpoint helps operators:
         *     - Monitor pipeline health and throughput
         *     - Identify bottlenecks and backlogs
         *     - Debug pipeline stalls
         *     - Track performance trends
         *
         *     Returns:
         *         TelemetryResponse with queue depths and latency statistics
         */
        get: operations["get_telemetry_api_system_telemetry_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/websocket/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Websocket Event Types
         * @description List all available WebSocket event types with schemas.
         *
         *     Returns the complete registry of WebSocket event types supported by the system,
         *     including their descriptions, payload schemas, and example payloads. This
         *     endpoint enables frontend developers and API consumers to discover and
         *     understand all available real-time event types.
         *
         *     Event types follow a hierarchical naming convention: {domain}.{action}
         *     For example: detection.new, event.created, camera.status_changed
         *
         *     Channels group related events:
         *     - detections: AI detection pipeline events
         *     - events: Security event lifecycle events
         *     - alerts: Alert notifications and state changes
         *     - cameras: Camera status and configuration changes
         *     - jobs: Background job lifecycle events
         *     - system: System health and status events
         *
         *     Note: Some event types are marked as deprecated with suggested replacements.
         *     These remain available for backward compatibility but should be avoided in
         *     new implementations.
         *
         *     Returns:
         *         EventRegistryResponse containing:
         *         - event_types: List of all event types with schemas and examples
         *         - channels: List of available WebSocket channels
         *         - total_count: Total number of event types
         *         - deprecated_count: Number of deprecated event types
         */
        get: operations["list_websocket_event_types_api_system_websocket_events_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health
         * @description Simple liveness health check endpoint (canonical liveness probe).
         *
         *     This endpoint indicates whether the process is running and able to
         *     respond to HTTP requests. It always returns 200 with status "alive"
         *     if the process is up.
         *
         *     This is the canonical liveness probe endpoint. Use this for:
         *     - Docker HEALTHCHECK liveness checks
         *     - Kubernetes liveness probes
         *     - Simple "is the server up?" monitoring
         *
         *     For detailed health information, use:
         *     - GET /api/system/health - Detailed health check with service status
         *     - GET /ready - Readiness probe (checks dependencies)
         *
         *     Returns:
         *         LivenessResponse with status "alive".
         */
        get: operations["health_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Ready
         * @description Simple readiness health check endpoint (canonical readiness probe).
         *
         *     This endpoint indicates whether the application is ready to receive
         *     traffic and process requests. It checks critical dependencies:
         *     - Database connectivity
         *     - Redis connectivity
         *     - Critical pipeline workers
         *
         *     This is the canonical readiness probe endpoint. Use this for:
         *     - Docker HEALTHCHECK readiness checks
         *     - Kubernetes readiness probes
         *     - Load balancer health checks
         *
         *     For detailed readiness information with service breakdown, use:
         *     - GET /api/system/health/ready - Full readiness response with details
         *
         *     Returns:
         *         SimpleReadinessResponse with ready bool and status. HTTP 200 if ready, 503 if not.
         */
        get: operations["ready_ready_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AIServiceHealthStatus
         * @description Health status for an AI service.
         *
         *     Includes service identification, health state, circuit breaker state,
         *     and response time metrics.
         * @example {
         *       "circuit_state": "closed",
         *       "display_name": "RT-DETRv2 Object Detection",
         *       "last_check": "2026-01-08T10:30:00Z",
         *       "name": "rtdetr",
         *       "response_time_ms": 45.2,
         *       "status": "healthy",
         *       "url": "http://ai-detector:8090"
         *     }
         */
        AIServiceHealthStatus: {
            /**
             * @description Circuit breaker state
             * @default closed
             */
            circuit_state: components["schemas"]["CircuitState"];
            /**
             * Display Name
             * @description Human-readable service name
             */
            display_name: string;
            /**
             * Error
             * @description Error message if unhealthy
             */
            error?: string | null;
            /**
             * Last Check
             * @description Timestamp of last health check
             */
            last_check?: string | null;
            /**
             * Name
             * @description Service identifier (e.g., 'rtdetr', 'nemotron')
             */
            name: string;
            /**
             * Response Time Ms
             * @description Health check response time in milliseconds
             */
            response_time_ms?: number | null;
            /** @description Current health state */
            status: components["schemas"]["ServiceHealthState"];
            /**
             * Url
             * @description Service URL if configured
             */
            url?: string | null;
        };
        /**
         * ActivityBaselineEntry
         * @description A single activity baseline entry for a specific hour and day combination.
         *
         *     This represents one cell in the 24x7 activity heatmap (168 total entries).
         * @example {
         *       "avg_count": 5.2,
         *       "day_of_week": 0,
         *       "hour": 17,
         *       "is_peak": true,
         *       "sample_count": 30
         *     }
         */
        ActivityBaselineEntry: {
            /**
             * Avg Count
             * @description Average activity count for this time slot
             */
            avg_count: number;
            /**
             * Day Of Week
             * @description Day of week (0=Monday, 6=Sunday)
             */
            day_of_week: number;
            /**
             * Hour
             * @description Hour of day (0-23)
             */
            hour: number;
            /**
             * Is Peak
             * @description Whether this time slot has above-average activity
             * @default false
             */
            is_peak: boolean;
            /**
             * Sample Count
             * @description Number of samples used to calculate this average
             */
            sample_count: number;
        };
        /**
         * ActivityBaselineResponse
         * @description Response for camera activity baseline endpoint.
         *
         *     Contains 168 entries (24 hours x 7 days) representing the full weekly
         *     activity heatmap for a camera.
         * @example {
         *       "camera_id": "front_door",
         *       "entries": [
         *         {
         *           "avg_count": 0.5,
         *           "day_of_week": 0,
         *           "hour": 0,
         *           "is_peak": false,
         *           "sample_count": 30
         *         },
         *         {
         *           "avg_count": 5.2,
         *           "day_of_week": 4,
         *           "hour": 17,
         *           "is_peak": true,
         *           "sample_count": 30
         *         }
         *       ],
         *       "learning_complete": true,
         *       "min_samples_required": 10,
         *       "peak_day": 4,
         *       "peak_hour": 17,
         *       "total_samples": 720
         *     }
         */
        ActivityBaselineResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Entries
             * @description Activity baseline entries (up to 168 = 24h x 7 days)
             */
            entries?: components["schemas"]["ActivityBaselineEntry"][];
            /**
             * Learning Complete
             * @description Whether baseline has sufficient samples for reliable anomaly detection
             * @default false
             */
            learning_complete: boolean;
            /**
             * Min Samples Required
             * @description Minimum samples required per time slot for learning completion
             * @default 10
             */
            min_samples_required: number;
            /**
             * Peak Day
             * @description Day with highest average activity (0=Monday, 6=Sunday)
             */
            peak_day?: number | null;
            /**
             * Peak Hour
             * @description Hour with highest average activity (0-23)
             */
            peak_hour?: number | null;
            /**
             * Total Samples
             * @description Total number of samples across all entries
             */
            total_samples: number;
        };
        /**
         * AiModelMetrics
         * @description Metrics for RT-DETRv2 model.
         * @example {
         *       "device": "cuda:0",
         *       "model": "rtdetr_r50vd_coco_o365",
         *       "status": "healthy",
         *       "vram_gb": 0.17
         *     }
         */
        AiModelMetrics: {
            /**
             * Device
             * @description Device (e.g., 'cuda:0')
             */
            device: string;
            /**
             * Model
             * @description Model name
             */
            model: string;
            /**
             * Status
             * @description Health status: healthy, unhealthy, unreachable
             */
            status: string;
            /**
             * Vram Gb
             * @description VRAM used by the model in GB
             */
            vram_gb: number;
        };
        /**
         * AlertResponse
         * @description Schema for alert response.
         * @example {
         *       "channels": [
         *         "pushover"
         *       ],
         *       "created_at": "2025-12-28T12:00:00Z",
         *       "dedup_key": "front_door:person:entry_zone",
         *       "delivered_at": "2025-12-28T12:00:30Z",
         *       "event_id": 123,
         *       "id": "550e8400-e29b-41d4-a716-446655440001",
         *       "metadata": {
         *         "camera_name": "Front Door"
         *       },
         *       "rule_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "severity": "high",
         *       "status": "delivered",
         *       "updated_at": "2025-12-28T12:01:00Z"
         *     }
         */
        AlertResponse: {
            /**
             * Channels
             * @description Notification channels
             */
            channels?: string[];
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp
             */
            created_at: string;
            /**
             * Dedup Key
             * @description Deduplication key
             */
            dedup_key: string;
            /**
             * Delivered At
             * @description Delivery timestamp
             */
            delivered_at?: string | null;
            /**
             * Event Id
             * @description Event ID that triggered this alert
             */
            event_id: number;
            /**
             * Id
             * @description Alert UUID
             */
            id: string;
            /**
             * Metadata
             * @description Additional context
             */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /**
             * Rule Id
             * @description Alert rule UUID that matched
             */
            rule_id?: string | null;
            /** @description Alert severity level */
            severity: components["schemas"]["AlertSeverity"];
            /** @description Alert status */
            status: components["schemas"]["AlertStatus"];
            /**
             * Updated At
             * Format: date-time
             * @description Last update timestamp
             */
            updated_at: string;
        };
        /**
         * AlertRuleConditions
         * @description Schema for legacy alert rule conditions (backward compatibility).
         *
         *     New rules should use explicit fields on AlertRuleCreate/AlertRuleUpdate.
         *     This schema is kept for backward compatibility with existing rules.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "object_types": [
         *         "person",
         *         "vehicle"
         *       ],
         *       "risk_threshold": 70,
         *       "time_ranges": [
         *         {
         *           "end": "06:00",
         *           "start": "22:00"
         *         }
         *       ]
         *     }
         */
        AlertRuleConditions: {
            /**
             * Camera Ids
             * @description Specific camera IDs that trigger alerts
             */
            camera_ids?: string[] | null;
            /**
             * Object Types
             * @description Object types that trigger alerts (e.g., person, vehicle)
             */
            object_types?: string[] | null;
            /**
             * Risk Threshold
             * @description Minimum risk score to trigger alert
             */
            risk_threshold?: number | null;
            /**
             * Time Ranges
             * @description Time ranges when alerts are active (start/end in HH:MM format)
             */
            time_ranges?: {
                [key: string]: unknown;
            }[] | null;
        };
        /**
         * AlertRuleCreate
         * @description Schema for creating an alert rule.
         *
         *     All conditions use AND logic - all specified conditions must match for the rule to trigger.
         *     Leave a condition as null/empty to not filter on that criterion.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "channels": [
         *         "pushover",
         *         "webhook"
         *       ],
         *       "cooldown_seconds": 300,
         *       "dedup_key_template": "{camera_id}:{rule_id}",
         *       "description": "High-priority alert for person detection at night",
         *       "enabled": true,
         *       "min_confidence": 0.8,
         *       "name": "Night Intruder Alert",
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_threshold": 70,
         *       "schedule": {
         *         "days": [
         *           "monday",
         *           "tuesday",
         *           "wednesday",
         *           "thursday",
         *           "friday"
         *         ],
         *         "end_time": "06:00",
         *         "start_time": "22:00",
         *         "timezone": "America/New_York"
         *       },
         *       "severity": "critical"
         *     }
         */
        AlertRuleCreate: {
            /**
             * Camera Ids
             * @description Camera IDs to apply rule to (empty = all cameras)
             */
            camera_ids?: string[] | null;
            /**
             * Channels
             * @description Notification channels for this rule
             */
            channels?: string[];
            /** @description Legacy conditions (use explicit fields instead) */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             * @default 300
             */
            cooldown_seconds: number;
            /**
             * Dedup Key Template
             * @description Template for dedup key. Variables: {camera_id}, {rule_id}, {object_type}
             * @default {camera_id}:{rule_id}
             */
            dedup_key_template: string;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             * @default true
             */
            enabled: boolean;
            /**
             * Min Confidence
             * @description Minimum detection confidence (0.0-1.0)
             */
            min_confidence?: number | null;
            /**
             * Name
             * @description Rule name
             */
            name: string;
            /**
             * Object Types
             * @description Object types to match (e.g., ['person', 'vehicle'])
             */
            object_types?: string[] | null;
            /**
             * Risk Threshold
             * @description Alert when risk_score >= threshold
             */
            risk_threshold?: number | null;
            /** @description Time-based conditions (null = always active) */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /**
             * @description Severity level for triggered alerts
             * @default medium
             */
            severity: components["schemas"]["AlertSeverity"];
            /**
             * Zone Ids
             * @description Zone IDs to match (empty = any zone)
             */
            zone_ids?: string[] | null;
        };
        /**
         * AlertRuleListResponse
         * @description Schema for alert rule list response with pagination.
         * @example {
         *       "items": [
         *         {
         *           "channels": [
         *             "pushover"
         *           ],
         *           "conditions": {
         *             "risk_threshold": 70
         *           },
         *           "cooldown_seconds": 300,
         *           "created_at": "2025-12-28T12:00:00Z",
         *           "enabled": true,
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "name": "High Risk Alert",
         *           "updated_at": "2025-12-28T12:00:00Z"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        AlertRuleListResponse: {
            /**
             * Items
             * @description List of alert rules
             */
            items: components["schemas"]["AlertRuleResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * AlertRuleResponse
         * @description Schema for alert rule response.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "channels": [
         *         "pushover",
         *         "webhook"
         *       ],
         *       "cooldown_seconds": 300,
         *       "created_at": "2025-12-28T12:00:00Z",
         *       "dedup_key_template": "{camera_id}:{rule_id}",
         *       "description": "High-priority alert for person detection at night",
         *       "enabled": true,
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "min_confidence": 0.8,
         *       "name": "Night Intruder Alert",
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_threshold": 70,
         *       "schedule": {
         *         "days": [
         *           "monday",
         *           "tuesday",
         *           "wednesday",
         *           "thursday",
         *           "friday"
         *         ],
         *         "end_time": "06:00",
         *         "start_time": "22:00",
         *         "timezone": "America/New_York"
         *       },
         *       "severity": "critical",
         *       "updated_at": "2025-12-28T12:00:00Z"
         *     }
         */
        AlertRuleResponse: {
            /**
             * Camera Ids
             * @description Camera IDs to apply to
             */
            camera_ids?: string[] | null;
            /**
             * Channels
             * @description Notification channels
             */
            channels?: string[];
            /** @description Legacy conditions */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             */
            cooldown_seconds: number;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp
             */
            created_at: string;
            /**
             * Dedup Key Template
             * @description Template for dedup key
             */
            dedup_key_template: string;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             */
            enabled: boolean;
            /**
             * Id
             * @description Alert rule UUID
             */
            id: string;
            /**
             * Min Confidence
             * @description Minimum confidence
             */
            min_confidence?: number | null;
            /**
             * Name
             * @description Rule name
             */
            name: string;
            /**
             * Object Types
             * @description Object types to match
             */
            object_types?: string[] | null;
            /**
             * Risk Threshold
             * @description Risk score threshold
             */
            risk_threshold?: number | null;
            /** @description Time-based conditions */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /** @description Severity level */
            severity: components["schemas"]["AlertSeverity"];
            /**
             * Updated At
             * Format: date-time
             * @description Last update timestamp
             */
            updated_at: string;
            /**
             * Zone Ids
             * @description Zone IDs to match
             */
            zone_ids?: string[] | null;
        };
        /**
         * AlertRuleSchedule
         * @description Schema for alert rule schedule (time-based conditions).
         *
         *     If start_time > end_time, the schedule spans midnight (e.g., 22:00-06:00).
         *     Empty days array means all days. No schedule = always active (vacation mode).
         *
         *     Validation:
         *     - Days must be valid day names (monday-sunday)
         *     - Times must be valid HH:MM format with hours 00-23, minutes 00-59
         *     - Start and end times are validated but can span midnight
         * @example {
         *       "days": [
         *         "monday",
         *         "tuesday",
         *         "wednesday",
         *         "thursday",
         *         "friday"
         *       ],
         *       "end_time": "06:00",
         *       "start_time": "22:00",
         *       "timezone": "America/New_York"
         *     }
         */
        AlertRuleSchedule: {
            /**
             * Days
             * @description Days of week when rule is active (empty = all days). Values: monday, tuesday, wednesday, thursday, friday, saturday, sunday
             */
            days?: string[] | null;
            /**
             * End Time
             * @description End time in HH:MM format (00:00-23:59)
             */
            end_time?: string | null;
            /**
             * Start Time
             * @description Start time in HH:MM format (00:00-23:59)
             */
            start_time?: string | null;
            /**
             * Timezone
             * @description Timezone for time evaluation
             * @default UTC
             */
            timezone: string;
        };
        /**
         * AlertRuleUpdate
         * @description Schema for updating an alert rule (PATCH).
         *
         *     Only provided fields will be updated. Null values clear the field.
         * @example {
         *       "cooldown_seconds": 600,
         *       "enabled": false,
         *       "risk_threshold": 80
         *     }
         */
        AlertRuleUpdate: {
            /**
             * Camera Ids
             * @description Camera IDs to apply rule to
             */
            camera_ids?: string[] | null;
            /**
             * Channels
             * @description Notification channels for this rule
             */
            channels?: string[] | null;
            /** @description Legacy conditions */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             */
            cooldown_seconds?: number | null;
            /**
             * Dedup Key Template
             * @description Template for dedup key
             */
            dedup_key_template?: string | null;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             */
            enabled?: boolean | null;
            /**
             * Min Confidence
             * @description Minimum detection confidence
             */
            min_confidence?: number | null;
            /**
             * Name
             * @description Rule name
             */
            name?: string | null;
            /**
             * Object Types
             * @description Object types to match
             */
            object_types?: string[] | null;
            /**
             * Risk Threshold
             * @description Alert when risk_score >= threshold
             */
            risk_threshold?: number | null;
            /** @description Time-based conditions */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /** @description Severity level */
            severity?: components["schemas"]["AlertSeverity"] | null;
            /**
             * Zone Ids
             * @description Zone IDs to match
             */
            zone_ids?: string[] | null;
        };
        /**
         * AlertSeverity
         * @description Alert severity levels.
         * @enum {string}
         */
        AlertSeverity: "low" | "medium" | "high" | "critical";
        /**
         * AlertStatus
         * @description Alert status values.
         * @enum {string}
         */
        AlertStatus: "pending" | "delivered" | "acknowledged" | "dismissed";
        /**
         * AllPromptsResponse
         * @description Response containing prompts for all models.
         * @example {
         *       "prompts": {
         *         "florence2": {
         *           "config": {
         *             "vqa_queries": [
         *               "What is this?"
         *             ]
         *           },
         *           "model_name": "florence2",
         *           "updated_at": "2026-01-01T08:00:00Z",
         *           "version": 1
         *         },
         *         "nemotron": {
         *           "config": {
         *             "system_prompt": "...",
         *             "temperature": 0.7
         *           },
         *           "model_name": "nemotron",
         *           "updated_at": "2026-01-03T10:30:00Z",
         *           "version": 3
         *         }
         *       }
         *     }
         */
        AllPromptsResponse: {
            /**
             * Prompts
             * @description Dictionary mapping model names to their configurations
             */
            prompts: {
                [key: string]: components["schemas"]["ModelPromptResponse"];
            };
        };
        /**
         * AnomalyConfig
         * @description Current anomaly detection configuration.
         * @example {
         *       "decay_factor": 0.1,
         *       "min_samples": 10,
         *       "threshold_stdev": 2,
         *       "window_days": 30
         *     }
         */
        AnomalyConfig: {
            /**
             * Decay Factor
             * @description Exponential decay factor for EWMA (0 < factor <= 1)
             */
            decay_factor: number;
            /**
             * Min Samples
             * @description Minimum samples required before anomaly detection is reliable
             */
            min_samples: number;
            /**
             * Threshold Stdev
             * @description Number of standard deviations from mean for anomaly detection
             */
            threshold_stdev: number;
            /**
             * Window Days
             * @description Rolling window size in days for baseline calculations
             */
            window_days: number;
        };
        /**
         * AnomalyConfigUpdate
         * @description Request to update anomaly detection configuration.
         * @example {
         *       "min_samples": 15,
         *       "threshold_stdev": 2.5
         *     }
         */
        AnomalyConfigUpdate: {
            /**
             * Min Samples
             * @description Minimum samples required before anomaly detection is reliable
             */
            min_samples?: number | null;
            /**
             * Threshold Stdev
             * @description Number of standard deviations from mean for anomaly detection
             */
            threshold_stdev?: number | null;
        };
        /**
         * AnomalyEvent
         * @description A single anomaly event detected for a camera.
         * @example {
         *       "anomaly_score": 0.95,
         *       "detection_class": "vehicle",
         *       "expected_frequency": 0.1,
         *       "observed_frequency": 5,
         *       "reason": "Vehicle detected at 2:30 AM when rarely seen at this hour",
         *       "timestamp": "2026-01-03T02:30:00Z"
         *     }
         */
        AnomalyEvent: {
            /**
             * Anomaly Score
             * @description Anomaly score (0.0-1.0, higher is more anomalous)
             */
            anomaly_score: number;
            /**
             * Detection Class
             * @description Object class that triggered the anomaly
             */
            detection_class: string;
            /**
             * Expected Frequency
             * @description Expected frequency for this class at this time
             */
            expected_frequency: number;
            /**
             * Observed Frequency
             * @description Observed frequency that triggered the anomaly
             */
            observed_frequency: number;
            /**
             * Reason
             * @description Human-readable explanation of why this is anomalous
             */
            reason: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the anomaly was detected
             */
            timestamp: string;
        };
        /**
         * AnomalyListResponse
         * @description Response schema for camera anomaly list endpoint.
         * @example {
         *       "anomalies": [
         *         {
         *           "anomaly_score": 0.95,
         *           "detection_class": "vehicle",
         *           "expected_frequency": 0.1,
         *           "observed_frequency": 5,
         *           "reason": "Vehicle detected at 2:30 AM when rarely seen",
         *           "timestamp": "2026-01-03T02:30:00Z"
         *         }
         *       ],
         *       "camera_id": "front_door",
         *       "count": 1,
         *       "period_days": 7
         *     }
         */
        AnomalyListResponse: {
            /**
             * Anomalies
             * @description List of recent anomaly events
             */
            anomalies?: components["schemas"]["AnomalyEvent"][];
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Count
             * @description Total number of anomalies returned
             */
            count: number;
            /**
             * Period Days
             * @description Number of days covered by this query
             */
            period_days: number;
        };
        /**
         * AuditLogListResponse
         * @description Schema for paginated audit log response.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Cursor-based pagination offers better performance for large datasets.
         * @example {
         *       "items": [
         *         {
         *           "action": "acknowledge",
         *           "actor": "admin@example.com",
         *           "id": 1,
         *           "ip_address": "192.168.1.100",
         *           "resource_id": "123",
         *           "resource_type": "event",
         *           "status": "success",
         *           "timestamp": "2026-01-03T10:30:00Z"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjYtMDEtMDNUMTA6MzA6MDBaIn0=", // pragma: allowlist secret
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        AuditLogListResponse: {
            /**
             * Deprecation Warning
             * @description Warning when using deprecated offset pagination
             */
            deprecation_warning?: string | null;
            /**
             * Items
             * @description List of audit log entries
             */
            items: components["schemas"]["AuditLogResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * AuditLogResponse
         * @description Schema for a single audit log entry.
         * @example {
         *       "action": "acknowledge",
         *       "actor": "admin@example.com",
         *       "details": {
         *         "new_status": "acknowledged",
         *         "previous_status": "unacknowledged"
         *       },
         *       "id": 1,
         *       "ip_address": "192.168.1.100",
         *       "resource_id": "123",
         *       "resource_type": "event",
         *       "status": "success",
         *       "timestamp": "2026-01-03T10:30:00Z",
         *       "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0"
         *     }
         */
        AuditLogResponse: {
            /**
             * Action
             * @description The action performed (e.g., 'create', 'update', 'delete', 'acknowledge')
             */
            action: string;
            /**
             * Actor
             * @description User or system that performed the action
             */
            actor: string;
            /**
             * Details
             * @description Action-specific details (JSON-serializable)
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * Id
             * @description Audit log entry ID
             */
            id: number;
            /**
             * Ip Address
             * @description IP address of the client (IPv4 or IPv6)
             */
            ip_address?: string | null;
            /**
             * Resource Id
             * @description ID of the specific resource
             */
            resource_id?: string | null;
            /**
             * Resource Type
             * @description Type of resource (event, alert, rule, camera, settings)
             */
            resource_type: string;
            /**
             * Status
             * @description Status of the action (success/failure)
             */
            status: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the action occurred (UTC)
             */
            timestamp: string;
            /**
             * User Agent
             * @description User agent string of the client
             */
            user_agent?: string | null;
        };
        /**
         * AuditLogStats
         * @description Schema for audit log statistics.
         * @example {
         *       "by_action": {
         *         "acknowledge": 50,
         *         "create": 30,
         *         "delete": 25,
         *         "update": 45
         *       },
         *       "by_resource_type": {
         *         "alert": 40,
         *         "camera": 20,
         *         "event": 80,
         *         "settings": 10
         *       },
         *       "by_status": {
         *         "failure": 5,
         *         "success": 145
         *       },
         *       "logs_today": 150,
         *       "recent_actors": [
         *         "admin@example.com",
         *         "system",
         *         "scheduler"
         *       ],
         *       "total_logs": 5000
         *     }
         */
        AuditLogStats: {
            /**
             * By Action
             * @description Counts by action type
             */
            by_action: {
                [key: string]: number;
            };
            /**
             * By Resource Type
             * @description Counts by resource type
             */
            by_resource_type: {
                [key: string]: number;
            };
            /**
             * By Status
             * @description Counts by status
             */
            by_status: {
                [key: string]: number;
            };
            /**
             * Logs Today
             * @description Number of logs today
             */
            logs_today: number;
            /**
             * Recent Actors
             * @description Recently active actors
             */
            recent_actors: string[];
            /**
             * Total Logs
             * @description Total number of audit logs
             */
            total_logs: number;
        };
        /**
         * AuditStatsResponse
         * @description Aggregate audit statistics.
         * @example {
         *       "audited_events": 1100,
         *       "audits_by_day": [
         *         {
         *           "count": 45,
         *           "date": "2026-01-01"
         *         },
         *         {
         *           "count": 52,
         *           "date": "2026-01-02"
         *         },
         *         {
         *           "count": 38,
         *           "date": "2026-01-03"
         *         }
         *       ],
         *       "avg_consistency_rate": 0.92,
         *       "avg_enrichment_utilization": 0.78,
         *       "avg_quality_score": 4.1,
         *       "fully_evaluated_events": 950,
         *       "model_contribution_rates": {
         *         "clothing": 0.72,
         *         "florence": 0.85,
         *         "rtdetr": 0.98,
         *         "weather": 0.95
         *       },
         *       "total_events": 1250
         *     }
         */
        AuditStatsResponse: {
            /** Audited Events */
            audited_events: number;
            /** Audits By Day */
            audits_by_day: {
                [key: string]: unknown;
            }[];
            /** Avg Consistency Rate */
            avg_consistency_rate: number | null;
            /** Avg Enrichment Utilization */
            avg_enrichment_utilization: number | null;
            /** Avg Quality Score */
            avg_quality_score: number | null;
            /** Fully Evaluated Events */
            fully_evaluated_events: number;
            /** Model Contribution Rates */
            model_contribution_rates: {
                [key: string]: number;
            };
            /** Total Events */
            total_events: number;
        };
        /**
         * BaselineSummaryResponse
         * @description Response schema for camera baseline summary endpoint.
         *
         *     Provides comprehensive baseline data for a camera including:
         *     - Hourly activity patterns (0-23 hours)
         *     - Daily patterns (by day of week)
         *     - Object-specific baselines
         *     - Current deviation from baseline
         * @example {
         *       "baseline_established": "2026-01-01T00:00:00Z",
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "current_deviation": {
         *         "contributing_factors": [
         *           "person_count_elevated"
         *         ],
         *         "interpretation": "slightly_above_normal",
         *         "score": 1.8
         *       },
         *       "daily_patterns": {
         *         "monday": {
         *           "avg_detections": 45,
         *           "peak_hour": 17,
         *           "total_samples": 24
         *         }
         *       },
         *       "data_points": 720,
         *       "hourly_patterns": {
         *         "0": {
         *           "avg_detections": 0.5,
         *           "sample_count": 30,
         *           "std_dev": 0.3
         *         },
         *         "17": {
         *           "avg_detections": 5.2,
         *           "sample_count": 30,
         *           "std_dev": 1.1
         *         }
         *       },
         *       "object_baselines": {
         *         "person": {
         *           "avg_hourly": 2.3,
         *           "peak_hour": 17,
         *           "total_detections": 550
         *         }
         *       }
         *     }
         */
        BaselineSummaryResponse: {
            /**
             * Baseline Established
             * @description When baseline data collection started (null if no data)
             */
            baseline_established?: string | null;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name: string;
            /** @description Current deviation from baseline (null if insufficient data) */
            current_deviation?: components["schemas"]["CurrentDeviation"] | null;
            /**
             * Daily Patterns
             * @description Activity patterns by day of week (monday-sunday)
             */
            daily_patterns?: {
                [key: string]: components["schemas"]["DailyPattern"];
            };
            /**
             * Data Points
             * @description Total number of data points in baseline
             */
            data_points: number;
            /**
             * Hourly Patterns
             * @description Activity patterns by hour (0-23)
             */
            hourly_patterns?: {
                [key: string]: components["schemas"]["HourlyPattern"];
            };
            /**
             * Object Baselines
             * @description Baseline statistics by object type
             */
            object_baselines?: {
                [key: string]: components["schemas"]["ObjectBaseline"];
            };
        };
        /**
         * BatchAggregatorStatusResponse
         * @description Status information for the BatchAggregator service.
         * @example {
         *       "active_batches": 2,
         *       "batch_window_seconds": 90,
         *       "batches": [
         *         {
         *           "age_seconds": 45.5,
         *           "batch_id": "abc123",
         *           "camera_id": "front_door",
         *           "detection_count": 5,
         *           "last_activity_seconds": 10.2,
         *           "started_at": 1735500000
         *         }
         *       ],
         *       "idle_timeout_seconds": 30
         *     }
         */
        BatchAggregatorStatusResponse: {
            /**
             * Active Batches
             * @description Number of active batches being aggregated
             */
            active_batches: number;
            /**
             * Batch Window Seconds
             * @description Configured batch window timeout in seconds
             */
            batch_window_seconds: number;
            /**
             * Batches
             * @description Details of active batches
             */
            batches?: components["schemas"]["BatchInfoResponse"][];
            /**
             * Idle Timeout Seconds
             * @description Configured idle timeout in seconds
             */
            idle_timeout_seconds: number;
        };
        /**
         * BatchAuditJobResponse
         * @description Response for async batch audit job creation.
         *
         *     Returned immediately when triggering a batch audit, containing
         *     the job ID for progress tracking via GET /api/ai-audit/batch/{job_id}.
         * @example {
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Batch audit job created. Use GET /api/ai-audit/batch/550e8400-e29b-41d4-a716-446655440000 to track progress.",
         *       "status": "pending",
         *       "total_events": 75
         *     }
         */
        BatchAuditJobResponse: {
            /**
             * Job Id
             * @description Unique job ID for tracking progress
             */
            job_id: string;
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Status
             * @description Initial job status (pending)
             */
            status: string;
            /**
             * Total Events
             * @description Number of events queued for processing
             */
            total_events: number;
        };
        /**
         * BatchAuditJobStatusResponse
         * @description Response for batch audit job status query.
         *
         *     Provides detailed progress information for an ongoing or completed
         *     batch audit job.
         * @example {
         *       "created_at": "2026-01-03T10:30:00Z",
         *       "failed_events": 2,
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Processing event 45 of 100",
         *       "processed_events": 45,
         *       "progress": 45,
         *       "started_at": "2026-01-03T10:30:01Z",
         *       "status": "running",
         *       "total_events": 100
         *     }
         */
        BatchAuditJobStatusResponse: {
            /**
             * Completed At
             * @description When processing completed
             */
            completed_at?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description When the job was created
             */
            created_at: string;
            /**
             * Error
             * @description Error message if job failed
             */
            error?: string | null;
            /**
             * Failed Events
             * @description Events that failed processing
             * @default 0
             */
            failed_events: number;
            /**
             * Job Id
             * @description Unique job ID
             */
            job_id: string;
            /**
             * Message
             * @description Current status message
             */
            message?: string | null;
            /**
             * Processed Events
             * @description Events successfully processed
             */
            processed_events: number;
            /**
             * Progress
             * @description Progress percentage (0-100)
             */
            progress: number;
            /**
             * Started At
             * @description When processing started
             */
            started_at?: string | null;
            /**
             * Status
             * @description Current job status (pending, running, completed, failed)
             */
            status: string;
            /**
             * Total Events
             * @description Total events to process
             */
            total_events: number;
        };
        /**
         * BatchAuditRequest
         * @description Request for batch audit processing.
         * @example {
         *       "force_reevaluate": false,
         *       "limit": 100,
         *       "min_risk_score": 50
         *     }
         */
        BatchAuditRequest: {
            /**
             * Force Reevaluate
             * @default false
             */
            force_reevaluate: boolean;
            /**
             * Limit
             * @default 100
             */
            limit: number;
            /** Min Risk Score */
            min_risk_score?: number | null;
        };
        /**
         * BatchInfoResponse
         * @description Information about an active batch.
         */
        BatchInfoResponse: {
            /**
             * Age Seconds
             * @description Time since batch started in seconds
             */
            age_seconds: number;
            /**
             * Batch Id
             * @description Unique batch identifier
             */
            batch_id: string;
            /**
             * Camera Id
             * @description Camera ID this batch belongs to
             */
            camera_id: string;
            /**
             * Detection Count
             * @description Number of detections in this batch
             */
            detection_count: number;
            /**
             * Last Activity Seconds
             * @description Time since last activity in seconds
             */
            last_activity_seconds: number;
            /**
             * Started At
             * @description Batch start time (Unix timestamp)
             */
            started_at: number;
        };
        /**
         * BulkCancelError
         * @description Error details for a single job in bulk cancellation.
         * @example {
         *       "error": "Job not found",
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000"
         *     }
         */
        BulkCancelError: {
            /**
             * Error
             * @description Error message
             */
            error: string;
            /**
             * Job Id
             * @description Job ID that failed to cancel
             */
            job_id: string;
        };
        /**
         * BulkCancelRequest
         * @description Request model for bulk job cancellation.
         * @example {
         *       "job_ids": [
         *         "550e8400-e29b-41d4-a716-446655440000",
         *         "550e8400-e29b-41d4-a716-446655440001"
         *       ]
         *     }
         */
        BulkCancelRequest: {
            /**
             * Job Ids
             * @description List of job IDs to cancel (1-100 jobs)
             */
            job_ids: string[];
        };
        /**
         * BulkCancelResponse
         * @description Response model for bulk job cancellation.
         * @example {
         *       "cancelled": 5,
         *       "errors": [
         *         {
         *           "error": "Job already completed",
         *           "job_id": "550e8400-e29b-41d4-a716-446655440005"
         *         }
         *       ],
         *       "failed": 1
         *     }
         */
        BulkCancelResponse: {
            /**
             * Cancelled
             * @description Number of jobs successfully cancelled
             */
            cancelled: number;
            /**
             * Errors
             * @description Details of cancellation failures
             */
            errors?: components["schemas"]["BulkCancelError"][];
            /**
             * Failed
             * @description Number of jobs that failed to cancel
             */
            failed: number;
        };
        /**
         * BulkItemResult
         * @description Result for a single item in a bulk operation.
         *
         *     Attributes:
         *         index: Zero-based index of the item in the request array
         *         status: Operation status (success, failed, skipped)
         *         id: ID of the created/updated resource (for successful operations)
         *         error: Error message (for failed operations)
         */
        BulkItemResult: {
            /**
             * Error
             * @description Error message for failed operations
             */
            error?: string | null;
            /**
             * Id
             * @description ID of the created/updated resource
             */
            id?: number | null;
            /**
             * Index
             * @description Zero-based index of the item in the request
             */
            index: number;
            /** @description Operation status */
            status: components["schemas"]["BulkOperationStatus"];
        };
        /**
         * BulkOperationResponse
         * @description Base response for bulk operations with partial success support.
         *
         *     Uses HTTP 207 Multi-Status when some operations succeed and others fail.
         *
         *     Attributes:
         *         total: Total number of items in the request
         *         succeeded: Number of successful operations
         *         failed: Number of failed operations
         *         skipped: Number of skipped operations
         *         results: Per-item results with status and error details
         */
        BulkOperationResponse: {
            /**
             * Failed
             * @description Number of failed operations
             */
            failed: number;
            /**
             * Results
             * @description Per-item results
             */
            results?: components["schemas"]["BulkItemResult"][];
            /**
             * Skipped
             * @description Number of skipped operations
             * @default 0
             */
            skipped: number;
            /**
             * Succeeded
             * @description Number of successful operations
             */
            succeeded: number;
            /**
             * Total
             * @description Total number of items in the request
             */
            total: number;
        };
        /**
         * BulkOperationStatus
         * @description Status of individual items in a bulk operation.
         * @enum {string}
         */
        BulkOperationStatus: "success" | "failed" | "skipped";
        /**
         * CalibrationDefaultsResponse
         * @description Schema for calibration defaults response.
         *
         *     Returns the system default threshold values.
         * @example {
         *       "decay_factor": 0.1,
         *       "high_threshold": 85,
         *       "low_threshold": 30,
         *       "medium_threshold": 60
         *     }
         */
        CalibrationDefaultsResponse: {
            /**
             * Decay Factor
             * @description Default decay factor value
             * @default 0.1
             */
            decay_factor: number;
            /**
             * High Threshold
             * @description Default high threshold value
             * @default 85
             */
            high_threshold: number;
            /**
             * Low Threshold
             * @description Default low threshold value
             * @default 30
             */
            low_threshold: number;
            /**
             * Medium Threshold
             * @description Default medium threshold value
             * @default 60
             */
            medium_threshold: number;
        };
        /**
         * CalibrationResetResponse
         * @description Schema for calibration reset response.
         *
         *     Returned after resetting calibration to default values.
         * @example {
         *       "calibration": {
         *         "created_at": "2025-01-01T12:00:00Z",
         *         "decay_factor": 0.1,
         *         "false_positive_count": 5,
         *         "high_threshold": 85,
         *         "id": 1,
         *         "low_threshold": 30,
         *         "medium_threshold": 60,
         *         "missed_threat_count": 3,
         *         "updated_at": "2025-01-01T12:00:00Z",
         *         "user_id": "default"
         *       },
         *       "message": "Calibration reset to default values"
         *     }
         */
        CalibrationResetResponse: {
            /** @description Reset calibration data */
            calibration: components["schemas"]["UserCalibrationResponse"];
            /**
             * Message
             * @description Success message
             */
            message: string;
        };
        /**
         * CameraCreate
         * @description Schema for creating a new camera.
         *
         *     NEM-2569: Enhanced with explicit Pydantic validators for:
         *     - Name: Control character rejection, whitespace stripping, empty validation
         *     - Folder path: Path traversal prevention, forbidden character rejection
         * @example {
         *       "folder_path": "/export/foscam/front_door",
         *       "name": "Front Door Camera",
         *       "status": "online"
         *     }
         */
        CameraCreate: {
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path: string;
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * @description Camera status (online, offline, error, unknown)
             * @default online
             */
            status: components["schemas"]["CameraStatus"];
        };
        /**
         * CameraListResponse
         * @description Schema for camera list response.
         *
         *     NEM-2075: Standardized pagination envelope with items + pagination structure.
         * @example {
         *       "items": [
         *         {
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "folder_path": "/export/foscam/front_door",
         *           "id": "front_door",
         *           "last_seen_at": "2025-12-23T12:00:00Z",
         *           "name": "Front Door Camera",
         *           "status": "online"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        CameraListResponse: {
            /**
             * Items
             * @description List of cameras
             */
            items: components["schemas"]["CameraResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * CameraNotificationSettingResponse
         * @description Schema for camera notification setting response.
         * @example {
         *       "camera_id": "front_door",
         *       "enabled": true,
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "risk_threshold": 50
         *     }
         */
        CameraNotificationSettingResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Enabled
             * @description Whether notifications are enabled for this camera
             */
            enabled: boolean;
            /**
             * Id
             * @description Setting UUID
             */
            id: string;
            /**
             * Risk Threshold
             * @description Minimum risk score to trigger notifications (0-100)
             */
            risk_threshold: number;
        };
        /**
         * CameraNotificationSettingUpdate
         * @description Schema for updating camera notification setting.
         * @example {
         *       "enabled": false,
         *       "risk_threshold": 70
         *     }
         */
        CameraNotificationSettingUpdate: {
            /**
             * Enabled
             * @description Whether notifications are enabled for this camera
             */
            enabled?: boolean | null;
            /**
             * Risk Threshold
             * @description Minimum risk score to trigger notifications (0-100)
             */
            risk_threshold?: number | null;
        };
        /**
         * CameraNotificationSettingsListResponse
         * @description Schema for camera notification settings list response with pagination.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "enabled": true,
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "risk_threshold": 50
         *         },
         *         {
         *           "camera_id": "back_yard",
         *           "enabled": false,
         *           "id": "550e8400-e29b-41d4-a716-446655440001",
         *           "risk_threshold": 70
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 2
         *       }
         *     }
         */
        CameraNotificationSettingsListResponse: {
            /**
             * Items
             * @description List of camera notification settings
             */
            items: components["schemas"]["CameraNotificationSettingResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * CameraPathValidationResponse
         * @description Schema for camera path validation response.
         *
         *     NEM-2063: Response model for the /api/cameras/validation/paths endpoint.
         *     Validates all camera folder paths against the configured base path.
         * @example {
         *       "base_path": "/export/foscam",
         *       "invalid_cameras": [
         *         {
         *           "folder_path": "/export/foscam/garage",
         *           "id": "garage",
         *           "issues": [
         *             "directory does not exist"
         *           ],
         *           "name": "Garage Camera",
         *           "status": "offline"
         *         }
         *       ],
         *       "invalid_count": 2,
         *       "total_cameras": 6,
         *       "valid_cameras": [
         *         {
         *           "folder_path": "/export/foscam/front_door",
         *           "id": "front_door",
         *           "name": "Front Door Camera",
         *           "status": "online"
         *         }
         *       ],
         *       "valid_count": 4
         *     }
         */
        CameraPathValidationResponse: {
            /**
             * Base Path
             * @description Configured base path for camera folders
             */
            base_path: string;
            /**
             * Invalid Cameras
             * @description Cameras with validation issues
             */
            invalid_cameras: components["schemas"]["CameraValidationInfo"][];
            /**
             * Invalid Count
             * @description Number of cameras with invalid paths
             */
            invalid_count: number;
            /**
             * Total Cameras
             * @description Total number of cameras validated
             */
            total_cameras: number;
            /**
             * Valid Cameras
             * @description Cameras with valid paths
             */
            valid_cameras: components["schemas"]["CameraValidationInfo"][];
            /**
             * Valid Count
             * @description Number of cameras with valid paths
             */
            valid_count: number;
        };
        /**
         * CameraResponse
         * @description Schema for camera response.
         * @example {
         *       "created_at": "2025-12-23T10:00:00Z",
         *       "folder_path": "/export/foscam/front_door",
         *       "id": "front_door",
         *       "last_seen_at": "2025-12-23T12:00:00Z",
         *       "name": "Front Door Camera",
         *       "status": "online"
         *     }
         */
        CameraResponse: {
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when camera was created
             */
            created_at: string;
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path: string;
            /**
             * Id
             * @description Normalized camera ID derived from folder name (e.g., 'front_door')
             */
            id: string;
            /**
             * Last Seen At
             * @description Last time camera was active
             */
            last_seen_at?: string | null;
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /** @description Camera status (online, offline, error, unknown) */
            status: components["schemas"]["CameraStatus"];
        };
        /**
         * CameraStatus
         * @description Camera status values.
         *
         *     Indicates the operational state of a camera:
         *     - ONLINE: Camera is active and receiving images
         *     - OFFLINE: Camera is not currently active (e.g., disconnected)
         *     - ERROR: Camera is experiencing an error condition
         *     - UNKNOWN: Camera status cannot be determined
         * @enum {string}
         */
        CameraStatus: "online" | "offline" | "error" | "unknown";
        /**
         * CameraUpdate
         * @description Schema for updating an existing camera.
         *
         *     NEM-2569: Enhanced with explicit Pydantic validators for partial updates.
         *     All fields are optional; only provided fields are validated.
         * @example {
         *       "name": "Front Door Camera - Updated",
         *       "status": "offline"
         *     }
         */
        CameraUpdate: {
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path?: string | null;
            /**
             * Name
             * @description Camera name
             */
            name?: string | null;
            /** @description Camera status (online, offline, error, unknown) */
            status?: components["schemas"]["CameraStatus"] | null;
        };
        /**
         * CameraUptimeDataPoint
         * @description Schema for a single camera uptime data point.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "detection_count": 150,
         *       "uptime_percentage": 98.5
         *     }
         */
        CameraUptimeDataPoint: {
            /**
             * Camera Id
             * @description Normalized camera ID (e.g., 'front_door')
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera name
             */
            camera_name: string;
            /**
             * Detection Count
             * @description Total detections in date range
             */
            detection_count: number;
            /**
             * Uptime Percentage
             * @description Uptime percentage (0-100)
             */
            uptime_percentage: number;
        };
        /**
         * CameraUptimeResponse
         * @description Schema for camera uptime percentage per camera.
         * @example {
         *       "cameras": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_count": 150,
         *           "uptime_percentage": 98.5
         *         },
         *         {
         *           "camera_id": "back_door",
         *           "camera_name": "Back Door",
         *           "detection_count": 120,
         *           "uptime_percentage": 95.2
         *         }
         *       ],
         *       "end_date": "2025-01-07",
         *       "start_date": "2025-01-01"
         *     }
         */
        CameraUptimeResponse: {
            /**
             * Cameras
             * @description Uptime data per camera
             */
            cameras: components["schemas"]["CameraUptimeDataPoint"][];
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
        };
        /**
         * CameraValidationInfo
         * @description Schema for individual camera validation result.
         *
         *     NEM-2063: Response model for camera path validation details.
         * @example {
         *       "folder_path": "/export/foscam/front_door",
         *       "id": "front_door",
         *       "issues": [
         *         "directory does not exist"
         *       ],
         *       "name": "Front Door Camera",
         *       "resolved_path": "/export/foscam/front_door",
         *       "status": "online"
         *     }
         */
        CameraValidationInfo: {
            /**
             * Folder Path
             * @description Configured folder path
             */
            folder_path: string;
            /**
             * Id
             * @description Camera ID
             */
            id: string;
            /**
             * Issues
             * @description List of validation issues (only for invalid cameras)
             */
            issues?: string[] | null;
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * Resolved Path
             * @description Resolved absolute path (included if path is outside base_path)
             */
            resolved_path?: string | null;
            /** @description Camera status */
            status: components["schemas"]["CameraStatus"];
        };
        /**
         * CategorySummary
         * @description Summary of services in a category.
         *
         *     Provides a quick overview of service health within a category
         *     for dashboard displays.
         * @example {
         *       "healthy": 3,
         *       "total": 5,
         *       "unhealthy": 2
         *     }
         */
        CategorySummary: {
            /**
             * Healthy
             * @description Number of healthy (running) services
             */
            healthy: number;
            /**
             * Total
             * @description Total number of services in this category
             */
            total: number;
            /**
             * Unhealthy
             * @description Number of unhealthy/stopped/disabled services
             */
            unhealthy: number;
        };
        /**
         * CircuitBreakerConfigResponse
         * @description Configuration for a circuit breaker.
         */
        CircuitBreakerConfigResponse: {
            /**
             * Failure Threshold
             * @description Number of failures before opening circuit
             */
            failure_threshold: number;
            /**
             * Half Open Max Calls
             * @description Maximum calls allowed in half-open state
             */
            half_open_max_calls: number;
            /**
             * Recovery Timeout
             * @description Seconds to wait before transitioning to half-open
             */
            recovery_timeout: number;
            /**
             * Success Threshold
             * @description Successes needed in half-open to close circuit
             */
            success_threshold: number;
        };
        /**
         * CircuitBreakerResetResponse
         * @description Response for circuit breaker reset operation.
         */
        CircuitBreakerResetResponse: {
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
            /**
             * Name
             * @description Name of the circuit breaker that was reset
             */
            name: string;
            /** @description State after reset (should be closed) */
            new_state: components["schemas"]["CircuitBreakerStateEnum"];
            /** @description State before reset */
            previous_state: components["schemas"]["CircuitBreakerStateEnum"];
        };
        /**
         * CircuitBreakerStateEnum
         * @description Circuit breaker states.
         * @enum {string}
         */
        CircuitBreakerStateEnum: "closed" | "open" | "half_open" | "unavailable";
        /**
         * CircuitBreakerStatusResponse
         * @description Status of a single circuit breaker.
         * @example {
         *       "config": {
         *         "failure_threshold": 5,
         *         "half_open_max_calls": 3,
         *         "recovery_timeout": 30,
         *         "success_threshold": 2
         *       },
         *       "failure_count": 0,
         *       "name": "ai_service",
         *       "rejected_calls": 0,
         *       "state": "closed",
         *       "success_count": 0,
         *       "total_calls": 150
         *     }
         */
        CircuitBreakerStatusResponse: {
            /** @description Circuit breaker configuration */
            config: components["schemas"]["CircuitBreakerConfigResponse"];
            /**
             * Failure Count
             * @description Current consecutive failure count
             */
            failure_count: number;
            /**
             * Last Failure Time
             * @description Monotonic time of last failure (seconds)
             */
            last_failure_time?: number | null;
            /**
             * Name
             * @description Circuit breaker name
             */
            name: string;
            /**
             * Opened At
             * @description Monotonic time when circuit opened (seconds)
             */
            opened_at?: number | null;
            /**
             * Rejected Calls
             * @description Calls rejected due to open circuit
             */
            rejected_calls: number;
            /** @description Current circuit state: closed (normal), open (failing), half_open (testing) */
            state: components["schemas"]["CircuitBreakerStateEnum"];
            /**
             * Success Count
             * @description Current consecutive success count (relevant in half-open)
             */
            success_count: number;
            /**
             * Total Calls
             * @description Total calls attempted through this circuit
             */
            total_calls: number;
        };
        /**
         * CircuitBreakerSummary
         * @description Summary of all circuit breakers in the system.
         *
         *     Provides counts by state and individual breaker states for monitoring.
         * @example {
         *       "breakers": {
         *         "clip": "closed",
         *         "enrichment": "closed",
         *         "florence": "open",
         *         "nemotron": "closed",
         *         "rtdetr": "closed"
         *       },
         *       "closed": 4,
         *       "half_open": 0,
         *       "open": 1,
         *       "total": 5
         *     }
         */
        CircuitBreakerSummary: {
            /**
             * Breakers
             * @description Individual circuit breaker states keyed by service name
             */
            breakers: {
                [key: string]: components["schemas"]["CircuitState"];
            };
            /**
             * Closed
             * @description Number of breakers in closed state
             */
            closed: number;
            /**
             * Half Open
             * @description Number of breakers in half-open state
             */
            half_open: number;
            /**
             * Open
             * @description Number of breakers in open state
             */
            open: number;
            /**
             * Total
             * @description Total number of circuit breakers
             */
            total: number;
        };
        /**
         * CircuitBreakersResponse
         * @description Response schema for circuit breakers status endpoint.
         * @example {
         *       "circuit_breakers": {
         *         "rtdetr": {
         *           "config": {
         *             "failure_threshold": 5,
         *             "half_open_max_calls": 3,
         *             "recovery_timeout": 30,
         *             "success_threshold": 2
         *           },
         *           "failure_count": 0,
         *           "name": "rtdetr",
         *           "rejected_calls": 0,
         *           "state": "closed",
         *           "success_count": 0,
         *           "total_calls": 100
         *         }
         *       },
         *       "open_count": 0,
         *       "timestamp": "2025-12-30T10:30:00Z",
         *       "total_count": 2
         *     }
         */
        CircuitBreakersResponse: {
            /**
             * Circuit Breakers
             * @description Status of all circuit breakers keyed by name
             */
            circuit_breakers: {
                [key: string]: components["schemas"]["CircuitBreakerStatusResponse"];
            };
            /**
             * Open Count
             * @description Number of circuit breakers currently open
             */
            open_count: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
            /**
             * Total Count
             * @description Total number of circuit breakers
             */
            total_count: number;
        };
        /**
         * CircuitState
         * @description Circuit breaker state for a service.
         *
         *     States:
         *     - closed: Normal operation, requests pass through
         *     - open: Service failing, requests fail immediately
         *     - half_open: Testing recovery, limited requests allowed
         * @enum {string}
         */
        CircuitState: "closed" | "open" | "half_open";
        /**
         * ClassBaselineEntry
         * @description Baseline entry for a specific object class at a specific hour.
         * @example {
         *       "frequency": 3.5,
         *       "hour": 17,
         *       "object_class": "person",
         *       "sample_count": 45
         *     }
         */
        ClassBaselineEntry: {
            /**
             * Frequency
             * @description Frequency of this class at this hour
             */
            frequency: number;
            /**
             * Hour
             * @description Hour of day (0-23)
             */
            hour: number;
            /**
             * Object Class
             * @description Object class (e.g., person, vehicle, animal)
             */
            object_class: string;
            /**
             * Sample Count
             * @description Number of samples for this class/hour combination
             */
            sample_count: number;
        };
        /**
         * ClassBaselineResponse
         * @description Response for camera class frequency baseline endpoint.
         * @example {
         *       "camera_id": "front_door",
         *       "entries": [
         *         {
         *           "frequency": 3.5,
         *           "hour": 17,
         *           "object_class": "person",
         *           "sample_count": 45
         *         },
         *         {
         *           "frequency": 2.1,
         *           "hour": 8,
         *           "object_class": "vehicle",
         *           "sample_count": 30
         *         }
         *       ],
         *       "most_common_class": "person",
         *       "total_samples": 150,
         *       "unique_classes": [
         *         "person",
         *         "vehicle",
         *         "animal"
         *       ]
         *     }
         */
        ClassBaselineResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Entries
             * @description Class baseline entries grouped by class and hour
             */
            entries?: components["schemas"]["ClassBaselineEntry"][];
            /**
             * Most Common Class
             * @description Most frequently detected object class
             */
            most_common_class?: string | null;
            /**
             * Total Samples
             * @description Total number of samples across all entries
             */
            total_samples: number;
            /**
             * Unique Classes
             * @description List of unique object classes detected for this camera
             */
            unique_classes?: string[];
        };
        /**
         * CleanupResponse
         * @description Response schema for data cleanup endpoint.
         *
         *     Returns statistics about the cleanup operation including counts of
         *     deleted records and files. When dry_run is True, the counts represent
         *     what would be deleted without actually deleting.
         * @example {
         *       "detections_deleted": 89,
         *       "dry_run": false,
         *       "events_deleted": 15,
         *       "gpu_stats_deleted": 2880,
         *       "images_deleted": 0,
         *       "logs_deleted": 150,
         *       "retention_days": 30,
         *       "space_reclaimed": 524288000,
         *       "thumbnails_deleted": 89,
         *       "timestamp": "2025-12-27T10:30:00Z"
         *     }
         */
        CleanupResponse: {
            /**
             * Detections Deleted
             * @description Number of detections deleted (or would be deleted in dry run)
             */
            detections_deleted: number;
            /**
             * Dry Run
             * @description Whether this was a dry run (no actual deletion performed)
             * @default false
             */
            dry_run: boolean;
            /**
             * Events Deleted
             * @description Number of events deleted (or would be deleted in dry run)
             */
            events_deleted: number;
            /**
             * Gpu Stats Deleted
             * @description Number of GPU stat records deleted (or would be deleted in dry run)
             */
            gpu_stats_deleted: number;
            /**
             * Images Deleted
             * @description Number of original image files deleted (or would be deleted in dry run)
             */
            images_deleted: number;
            /**
             * Logs Deleted
             * @description Number of log records deleted (or would be deleted in dry run)
             */
            logs_deleted: number;
            /**
             * Retention Days
             * @description Retention period used for cleanup
             */
            retention_days: number;
            /**
             * Space Reclaimed
             * @description Estimated disk space freed in bytes (or would be freed in dry run)
             */
            space_reclaimed: number;
            /**
             * Thumbnails Deleted
             * @description Number of thumbnail files deleted (or would be deleted in dry run)
             */
            thumbnails_deleted: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of cleanup operation
             */
            timestamp: string;
        };
        /**
         * CleanupStatusResponse
         * @description Response schema for cleanup service status endpoint.
         * @example {
         *       "cleanup_time": "03:00",
         *       "delete_images": false,
         *       "next_cleanup": "2025-12-31T03:00:00Z",
         *       "retention_days": 30,
         *       "running": true,
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        CleanupStatusResponse: {
            /**
             * Cleanup Time
             * @description Scheduled daily cleanup time in HH:MM format
             */
            cleanup_time: string;
            /**
             * Delete Images
             * @description Whether original images are deleted during cleanup
             */
            delete_images: boolean;
            /**
             * Next Cleanup
             * @description ISO timestamp of next scheduled cleanup (null if not running)
             */
            next_cleanup?: string | null;
            /**
             * Retention Days
             * @description Current retention period in days
             */
            retention_days: number;
            /**
             * Running
             * @description Whether the cleanup service is currently running
             */
            running: boolean;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * ClearDataRequest
         * @description Request schema for clearing data - requires confirmation.
         */
        ClearDataRequest: {
            /**
             * Confirm
             * @description Must be exactly 'DELETE_ALL_DATA' to confirm deletion
             */
            confirm: string;
        };
        /**
         * ClearDataResponse
         * @description Response schema for clear data endpoint.
         */
        ClearDataResponse: {
            /** Cameras Cleared */
            cameras_cleared: number;
            /** Detections Cleared */
            detections_cleared: number;
            /** Events Cleared */
            events_cleared: number;
        };
        /**
         * ClipGenerateRequest
         * @description Schema for clip generation request (POST /api/events/{event_id}/clip/generate).
         *
         *     Offset validation (NEM-1355):
         *     - start_offset_seconds: -30 to 3600 seconds
         *     - end_offset_seconds: -30 to 3600 seconds
         *     - end_offset_seconds must be >= start_offset_seconds
         * @example {
         *       "end_offset_seconds": 30,
         *       "force": false,
         *       "start_offset_seconds": -15
         *     }
         */
        ClipGenerateRequest: {
            /**
             * End Offset Seconds
             * @description Seconds relative to event start to end clip (range: -30 to 3600, must be >= start_offset_seconds)
             * @default 30
             */
            end_offset_seconds: number;
            /**
             * Force
             * @description Force regeneration even if clip already exists
             * @default false
             */
            force: boolean;
            /**
             * Start Offset Seconds
             * @description Seconds relative to event start to begin clip (negative = before event, range: -30 to 3600)
             * @default -15
             */
            start_offset_seconds: number;
        };
        /**
         * ClipGenerateResponse
         * @description Schema for clip generation response.
         * @example {
         *       "clip_url": "/api/media/clips/123_clip.mp4",
         *       "event_id": 123,
         *       "generated_at": "2026-01-03T10:30:00Z",
         *       "message": "Clip generated successfully",
         *       "status": "completed"
         *     }
         */
        ClipGenerateResponse: {
            /**
             * Clip Url
             * @description URL to access the clip (if completed)
             */
            clip_url?: string | null;
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Generated At
             * @description Timestamp when the clip was generated
             */
            generated_at?: string | null;
            /**
             * Message
             * @description Status message or error details
             */
            message?: string | null;
            /** @description Status of clip generation */
            status: components["schemas"]["ClipStatus"];
        };
        /**
         * ClipInfoResponse
         * @description Schema for clip info response (GET /api/events/{event_id}/clip).
         * @example {
         *       "clip_available": true,
         *       "clip_url": "/api/media/clips/123_clip.mp4",
         *       "duration_seconds": 30,
         *       "event_id": 123,
         *       "file_size_bytes": 5242880,
         *       "generated_at": "2026-01-03T10:30:00Z"
         *     }
         */
        ClipInfoResponse: {
            /**
             * Clip Available
             * @description Whether a clip is available for this event
             */
            clip_available: boolean;
            /**
             * Clip Url
             * @description URL to access the clip (if available)
             */
            clip_url?: string | null;
            /**
             * Duration Seconds
             * @description Duration of the clip in seconds
             */
            duration_seconds?: number | null;
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * File Size Bytes
             * @description File size of the clip in bytes
             */
            file_size_bytes?: number | null;
            /**
             * Generated At
             * @description Timestamp when the clip was generated
             */
            generated_at?: string | null;
        };
        /**
         * ClipStatus
         * @description Status of clip generation.
         * @enum {string}
         */
        ClipStatus: "pending" | "completed" | "failed";
        /**
         * ClothingEnrichment
         * @description Clothing classification and segmentation results.
         * @example {
         *       "has_bag": true,
         *       "has_face_covered": false,
         *       "is_service_uniform": false,
         *       "is_suspicious": false,
         *       "lower": "blue jeans",
         *       "upper": "red t-shirt"
         *     }
         */
        ClothingEnrichment: {
            /**
             * Clothing Items
             * @description List of detected clothing items
             */
            clothing_items?: string[] | null;
            /**
             * Has Bag
             * @description Whether person is carrying a bag
             */
            has_bag?: boolean | null;
            /**
             * Has Face Covered
             * @description Whether face is covered (hat/sunglasses/mask)
             */
            has_face_covered?: boolean | null;
            /**
             * Is Service Uniform
             * @description Whether wearing service uniform
             */
            is_service_uniform?: boolean | null;
            /**
             * Is Suspicious
             * @description Whether clothing is flagged as suspicious
             */
            is_suspicious?: boolean | null;
            /**
             * Lower
             * @description Lower body clothing description
             */
            lower?: string | null;
            /**
             * Upper
             * @description Upper body clothing description
             */
            upper?: string | null;
        };
        /**
         * ConfigResponse
         * @description Response schema for configuration endpoint.
         *
         *     Only includes public, non-sensitive configuration values.
         * @example {
         *       "app_name": "Home Security Intelligence",
         *       "batch_idle_timeout_seconds": 30,
         *       "batch_window_seconds": 90,
         *       "detection_confidence_threshold": 0.5,
         *       "grafana_url": "http://localhost:3002",
         *       "retention_days": 30,
         *       "version": "0.1.0"
         *     }
         */
        ConfigResponse: {
            /**
             * App Name
             * @description Application name
             */
            app_name: string;
            /**
             * Batch Idle Timeout Seconds
             * @description Idle timeout before processing incomplete batch
             */
            batch_idle_timeout_seconds: number;
            /**
             * Batch Window Seconds
             * @description Time window for batch processing detections
             */
            batch_window_seconds: number;
            /**
             * Detection Confidence Threshold
             * @description Minimum confidence threshold for detections (0.0-1.0)
             */
            detection_confidence_threshold: number;
            /**
             * Grafana Url
             * @description Grafana dashboard URL for frontend link
             */
            grafana_url: string;
            /**
             * Retention Days
             * @description Number of days to retain events and detections
             */
            retention_days: number;
            /**
             * Version
             * @description Application version
             */
            version: string;
        };
        /**
         * ConfigUpdateRequest
         * @description Request schema for PATCH /api/system/config.
         *
         *     Only supports a subset of processing-related settings.
         */
        ConfigUpdateRequest: {
            /**
             * Batch Idle Timeout Seconds
             * @description Idle timeout before processing incomplete batch
             */
            batch_idle_timeout_seconds?: number | null;
            /**
             * Batch Window Seconds
             * @description Time window for batch processing detections
             */
            batch_window_seconds?: number | null;
            /**
             * Detection Confidence Threshold
             * @description Minimum confidence threshold for detections (0.0-1.0)
             */
            detection_confidence_threshold?: number | null;
            /**
             * Retention Days
             * @description Number of days to retain events and detections
             */
            retention_days?: number | null;
        };
        /**
         * ContainerMetrics
         * @description Container health status.
         * @example {
         *       "health": "healthy",
         *       "name": "backend",
         *       "status": "running"
         *     }
         */
        ContainerMetrics: {
            /**
             * Health
             * @description Health status (healthy, unhealthy, starting)
             */
            health: string;
            /**
             * Name
             * @description Container name
             */
            name: string;
            /**
             * Status
             * @description Container status (running, stopped, restarting, etc.)
             */
            status: string;
        };
        /**
         * ContainerServiceStatus
         * @description Current status of a managed container service.
         *
         *     Status values:
         *     - RUNNING: Container is up and passing health checks
         *     - STARTING: Container is starting, not yet healthy
         *     - UNHEALTHY: Running but failing health checks
         *     - STOPPED: Container is not running
         *     - DISABLED: Exceeded failure limit, requires manual reset
         *     - NOT_FOUND: Container doesn't exist yet
         * @enum {string}
         */
        ContainerServiceStatus: "running" | "starting" | "unhealthy" | "stopped" | "disabled" | "not_found";
        /**
         * CurrentDeviation
         * @description Current activity deviation from established baseline.
         * @example {
         *       "contributing_factors": [
         *         "person_count_elevated",
         *         "unusual_hour"
         *       ],
         *       "interpretation": "slightly_above_normal",
         *       "score": 1.8
         *     }
         */
        CurrentDeviation: {
            /**
             * Contributing Factors
             * @description Factors contributing to current deviation
             */
            contributing_factors?: string[];
            /** @description Human-readable interpretation of the deviation */
            interpretation: components["schemas"]["DeviationInterpretation"];
            /**
             * Score
             * @description Deviation score (standard deviations from mean, can be negative)
             */
            score: number;
        };
        /**
         * CustomTestPromptRequest
         * @description Request to test a custom prompt against an existing event.
         *
         *     This is used for A/B testing in the Prompt Playground - testing a
         *     modified prompt without persisting results to the database.
         * @example {
         *       "custom_prompt": "You are a home security AI with enhanced context...",
         *       "event_id": 12345,
         *       "max_tokens": 2048,
         *       "model": "nemotron",
         *       "temperature": 0.7
         *     }
         */
        CustomTestPromptRequest: {
            /**
             * Custom Prompt
             * @description Custom prompt text to test
             */
            custom_prompt: string;
            /**
             * Event Id
             * @description Event ID to test the prompt against
             */
            event_id: number;
            /**
             * Max Tokens
             * @description Maximum tokens in response
             * @default 2048
             */
            max_tokens: number;
            /**
             * Model
             * @description Model name to use for testing
             * @default nemotron
             */
            model: string;
            /**
             * Temperature
             * @description LLM temperature setting
             * @default 0.7
             */
            temperature: number;
        };
        /**
         * CustomTestPromptResponse
         * @description Response from testing a custom prompt against an event.
         *
         *     Results are NOT persisted - this is for A/B testing only.
         * @example {
         *       "entities": [
         *         {
         *           "confidence": 0.95,
         *           "type": "person"
         *         }
         *       ],
         *       "flags": [],
         *       "processing_time_ms": 1250,
         *       "reasoning": "The detected person matches the expected delivery pattern based on time and approach direction.",
         *       "recommended_action": "No action required",
         *       "risk_level": "low",
         *       "risk_score": 45,
         *       "summary": "Delivery person detected at front door during expected hours",
         *       "tokens_used": 512
         *     }
         */
        CustomTestPromptResponse: {
            /**
             * Entities
             * @description Detected entities in the analysis
             */
            entities?: {
                [key: string]: unknown;
            }[];
            /**
             * Flags
             * @description Risk flags identified in the analysis
             */
            flags?: {
                [key: string]: unknown;
            }[];
            /**
             * Processing Time Ms
             * @description Time taken for inference in milliseconds
             */
            processing_time_ms: number;
            /**
             * Reasoning
             * @description LLM reasoning for the risk assessment
             */
            reasoning: string;
            /**
             * Recommended Action
             * @description Recommended action based on risk analysis
             * @default
             */
            recommended_action: string;
            /**
             * Risk Level
             * @description Risk level: low, medium, high, or critical
             */
            risk_level: string;
            /**
             * Risk Score
             * @description Computed risk score (0-100)
             */
            risk_score: number;
            /**
             * Summary
             * @description Brief summary of the event analysis
             */
            summary: string;
            /**
             * Tokens Used
             * @description Number of tokens used in inference
             */
            tokens_used: number;
        };
        /**
         * DLQClearResponse
         * @description Response schema for clearing a DLQ.
         * @example {
         *       "message": "Cleared 5 jobs from dlq:detection_queue",
         *       "queue_name": "dlq:detection_queue",
         *       "success": true
         *     }
         */
        DLQClearResponse: {
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Queue Name
             * @description Name of the cleared queue
             */
            queue_name: string;
            /**
             * Success
             * @description Whether the clear operation succeeded
             */
            success: boolean;
        };
        /**
         * DLQJobResponse
         * @description Response schema for a single job in the dead-letter queue.
         *
         *     Includes enriched error context (NEM-1474) for faster debugging:
         *     - error_type: Exception class name for categorization
         *     - stack_trace: Truncated stack trace for debugging
         *     - http_status: HTTP status code (for network errors)
         *     - response_body: Truncated AI service response (for debugging)
         *     - retry_delays: Delays applied between retry attempts
         *     - context: System state snapshot at failure time
         * @example {
         *       "attempt_count": 3,
         *       "context": {
         *         "analysis_queue_depth": 25,
         *         "detection_queue_depth": 150,
         *         "dlq_circuit_breaker_state": "closed"
         *       },
         *       "error": "Connection refused: detector service unavailable",
         *       "error_type": "ConnectionRefusedError",
         *       "first_failed_at": "2025-12-23T10:30:05.000000",
         *       "last_failed_at": "2025-12-23T10:30:15.000000",
         *       "original_job": {
         *         "camera_id": "front_door",
         *         "file_path": "/export/foscam/front_door/image_001.jpg",
         *         "timestamp": "2025-12-23T10:30:00.000000"
         *       },
         *       "queue_name": "detection_queue",
         *       "retry_delays": [
         *         1,
         *         2
         *       ],
         *       "stack_trace": "Traceback (most recent call last):\n  ..."
         *     }
         */
        DLQJobResponse: {
            /**
             * Attempt Count
             * @description Number of processing attempts made
             */
            attempt_count: number;
            /**
             * Context
             * @description System state snapshot at failure time (queue depths, circuit breaker states)
             */
            context?: {
                [key: string]: unknown;
            } | null;
            /**
             * Error
             * @description Error message from the last failure attempt
             */
            error: string;
            /**
             * Error Type
             * @description Exception class name (e.g., 'ConnectionRefusedError')
             */
            error_type?: string | null;
            /**
             * First Failed At
             * @description ISO timestamp of the first failure
             */
            first_failed_at: string;
            /**
             * Http Status
             * @description HTTP status code if the error was from a network request
             */
            http_status?: number | null;
            /**
             * Last Failed At
             * @description ISO timestamp of the last failure
             */
            last_failed_at: string;
            /**
             * Original Job
             * @description Original job payload that failed
             */
            original_job: {
                [key: string]: unknown;
            };
            /**
             * Queue Name
             * @description Name of the original queue where the job came from
             */
            queue_name: string;
            /**
             * Response Body
             * @description Truncated response body (max 2KB) from AI service
             */
            response_body?: string | null;
            /**
             * Retry Delays
             * @description Delays (in seconds) applied between retry attempts
             */
            retry_delays?: number[] | null;
            /**
             * Stack Trace
             * @description Truncated stack trace (max 4KB) for debugging
             */
            stack_trace?: string | null;
        };
        /**
         * DLQJobsResponse
         * @description Response schema for listing jobs in a DLQ.
         *
         *     Uses standard pagination envelope format (NEM-2178):
         *     - items: List of DLQ jobs (renamed from 'jobs')
         *     - pagination: Standard pagination metadata
         *     - queue_name: Name of the dead-letter queue
         * @example {
         *       "items": [
         *         {
         *           "attempt_count": 3,
         *           "error": "Connection refused",
         *           "first_failed_at": "2025-12-23T10:30:05.000000",
         *           "last_failed_at": "2025-12-23T10:30:15.000000",
         *           "original_job": {
         *             "camera_id": "front_door",
         *             "file_path": "/export/foscam/front_door/image_001.jpg",
         *             "timestamp": "2025-12-23T10:30:00.000000"
         *           },
         *           "queue_name": "detection_queue"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 100,
         *         "offset": 0,
         *         "total": 1
         *       },
         *       "queue_name": "dlq:detection_queue"
         *     }
         */
        DLQJobsResponse: {
            /**
             * Items
             * @description List of jobs in the queue
             */
            items: components["schemas"]["DLQJobResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
            /**
             * Queue Name
             * @description Name of the dead-letter queue
             */
            queue_name: string;
        };
        /**
         * DLQName
         * @description Available dead-letter queue names.
         * @enum {string}
         */
        DLQName: "dlq:detection_queue" | "dlq:analysis_queue";
        /**
         * DLQRequeueResponse
         * @description Response schema for requeuing a job from DLQ.
         * @example {
         *       "job": {
         *         "camera_id": "front_door",
         *         "file_path": "/export/foscam/front_door/image_001.jpg",
         *         "timestamp": "2025-12-23T10:30:00.000000"
         *       },
         *       "message": "Job requeued from dlq:detection_queue to detection_queue",
         *       "success": true
         *     }
         */
        DLQRequeueResponse: {
            /**
             * Job
             * @description The requeued job data (if successful)
             */
            job?: {
                [key: string]: unknown;
            } | null;
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Success
             * @description Whether the requeue operation succeeded
             */
            success: boolean;
        };
        /**
         * DLQStatsResponse
         * @description Response schema for DLQ statistics.
         * @example {
         *       "analysis_queue_count": 1,
         *       "detection_queue_count": 2,
         *       "total_count": 3
         *     }
         */
        DLQStatsResponse: {
            /**
             * Analysis Queue Count
             * @description Number of jobs in the analysis DLQ
             */
            analysis_queue_count: number;
            /**
             * Detection Queue Count
             * @description Number of jobs in the detection DLQ
             */
            detection_queue_count: number;
            /**
             * Total Count
             * @description Total number of jobs across all DLQs
             */
            total_count: number;
        };
        /**
         * DailyPattern
         * @description Activity pattern for a specific day of the week.
         * @example {
         *       "avg_detections": 45,
         *       "peak_hour": 17,
         *       "total_samples": 168
         *     }
         */
        DailyPattern: {
            /**
             * Avg Detections
             * @description Average number of detections for this day
             */
            avg_detections: number;
            /**
             * Peak Hour
             * @description Hour with most activity (0-23)
             */
            peak_hour: number;
            /**
             * Total Samples
             * @description Total samples for this day
             */
            total_samples: number;
        };
        /**
         * DatabaseMetrics
         * @description PostgreSQL database metrics.
         * @example {
         *       "cache_hit_ratio": 98.2,
         *       "connections_active": 5,
         *       "connections_max": 30,
         *       "status": "healthy",
         *       "transactions_per_min": 1200
         *     }
         */
        DatabaseMetrics: {
            /**
             * Cache Hit Ratio
             * @description Buffer cache hit ratio percentage
             */
            cache_hit_ratio: number;
            /**
             * Connections Active
             * @description Active connections
             */
            connections_active: number;
            /**
             * Connections Max
             * @description Maximum allowed connections
             */
            connections_max: number;
            /**
             * Status
             * @description Health status: healthy, unhealthy, unreachable
             */
            status: string;
            /**
             * Transactions Per Min
             * @description Transaction rate per minute
             */
            transactions_per_min: number;
        };
        /**
         * DebugCircuitBreakersResponse
         * @description Response for circuit breaker states.
         */
        DebugCircuitBreakersResponse: {
            /**
             * Circuit Breakers
             * @description All circuit breaker states keyed by name
             */
            circuit_breakers: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * DebugConfigResponse
         * @description Response for configuration inspection.
         */
        DebugConfigResponse: {
            /**
             * Config
             * @description Current configuration with sensitive values redacted
             */
            config: {
                [key: string]: unknown;
            };
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * DebugWebSocketBroadcasterStatus
         * @description Status of a WebSocket broadcaster.
         */
        DebugWebSocketBroadcasterStatus: {
            /**
             * Channel Name
             * @description Redis channel being listened to
             */
            channel_name?: string | null;
            /**
             * Circuit State
             * @description Circuit breaker state (CLOSED, OPEN, HALF_OPEN)
             */
            circuit_state: string;
            /**
             * Connection Count
             * @description Number of active connections
             */
            connection_count: number;
            /**
             * Is Degraded
             * @description Whether the broadcaster is in degraded mode
             */
            is_degraded: boolean;
            /**
             * Is Listening
             * @description Whether the broadcaster is listening for events
             */
            is_listening: boolean;
        };
        /**
         * DegradationModeEnum
         * @description System degradation modes.
         * @enum {string}
         */
        DegradationModeEnum: "normal" | "degraded" | "minimal" | "offline";
        /**
         * DegradationStatusResponse
         * @description Status information for the DegradationManager service.
         * @example {
         *       "available_features": [
         *         "detection",
         *         "analysis",
         *         "events",
         *         "media"
         *       ],
         *       "fallback_queues": {},
         *       "is_degraded": false,
         *       "memory_queue_size": 0,
         *       "mode": "normal",
         *       "redis_healthy": true,
         *       "services": [
         *         {
         *           "consecutive_failures": 0,
         *           "last_check": 1735500000,
         *           "name": "rtdetr",
         *           "status": "healthy"
         *         }
         *       ]
         *     }
         */
        DegradationStatusResponse: {
            /**
             * Available Features
             * @description Features available in current degradation mode
             */
            available_features?: string[];
            /**
             * Fallback Queues
             * @description Count of items in disk-based fallback queues by name
             */
            fallback_queues?: {
                [key: string]: number;
            };
            /**
             * Is Degraded
             * @description Whether system is in any degraded state
             */
            is_degraded: boolean;
            /**
             * Memory Queue Size
             * @description Number of jobs in in-memory fallback queue
             */
            memory_queue_size: number;
            /** @description Current degradation mode */
            mode: components["schemas"]["DegradationModeEnum"];
            /**
             * Redis Healthy
             * @description Whether Redis is healthy
             */
            redis_healthy: boolean;
            /**
             * Services
             * @description Health status of registered services
             */
            services?: components["schemas"]["ServiceHealthStatusResponse"][];
        };
        /**
         * DeletedCamerasListResponse
         * @description Schema for listing soft-deleted cameras (trash view).
         *
         *     NEM-1955: Provides a trash view of soft-deleted cameras that can be restored.
         *     Cameras are ordered by deleted_at descending (most recently deleted first).
         *     NEM-2075: Standardized pagination envelope with items + pagination structure.
         * @example {
         *       "items": [
         *         {
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "folder_path": "/export/foscam/front_door",
         *           "id": "front_door",
         *           "last_seen_at": "2025-12-23T12:00:00Z",
         *           "name": "Front Door Camera",
         *           "status": "offline"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        DeletedCamerasListResponse: {
            /**
             * Items
             * @description List of soft-deleted cameras
             */
            items: components["schemas"]["CameraResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * DeletedEventsListResponse
         * @description Schema for listing soft-deleted events (trash view).
         *
         *     NEM-1955: Provides a trash view of soft-deleted events that can be restored.
         *     Events are ordered by deleted_at descending (most recently deleted first).
         *     NEM-2075: Standardized pagination envelope with items + pagination structure.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "reasoning": "Analysis details",
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Person detected near front entrance",
         *           "thumbnail_url": "/api/media/detections/1"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        DeletedEventsListResponse: {
            /**
             * Items
             * @description List of soft-deleted events
             */
            items: components["schemas"]["EventResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * DepthEnrichment
         * @description Depth estimation results (placeholder for future Depth Anything V2).
         * @example {
         *       "confidence": 0.78,
         *       "estimated_distance_m": 4.2
         *     }
         */
        DepthEnrichment: {
            /**
             * Confidence
             * @description Estimation confidence
             */
            confidence?: number | null;
            /**
             * Estimated Distance M
             * @description Estimated distance in meters
             */
            estimated_distance_m?: number | null;
        };
        /**
         * DetectionBulkCreateItem
         * @description Schema for a single detection in a bulk create request.
         *
         *     Attributes:
         *         camera_id: Camera ID that captured this detection
         *         object_type: Type of detected object (person, vehicle, etc.)
         *         confidence: Detection confidence score (0.0-1.0)
         *         detected_at: Detection timestamp
         *         file_path: Path to the detection image
         *         bbox_x: Bounding box X coordinate
         *         bbox_y: Bounding box Y coordinate
         *         bbox_width: Bounding box width
         *         bbox_height: Bounding box height
         *         enrichment_data: Optional enrichment pipeline results
         */
        DetectionBulkCreateItem: {
            /**
             * Bbox Height
             * @description Bounding box height
             */
            bbox_height: number;
            /**
             * Bbox Width
             * @description Bounding box width
             */
            bbox_width: number;
            /**
             * Bbox X
             * @description Bounding box X coordinate
             */
            bbox_x: number;
            /**
             * Bbox Y
             * @description Bounding box Y coordinate
             */
            bbox_y: number;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Confidence
             * @description Confidence score (0.0-1.0)
             */
            confidence: number;
            /**
             * Detected At
             * Format: date-time
             * @description Detection timestamp
             */
            detected_at: string;
            /**
             * Enrichment Data
             * @description Enrichment pipeline results
             */
            enrichment_data?: {
                [key: string]: unknown;
            } | null;
            /**
             * File Path
             * @description Image file path
             */
            file_path: string;
            /**
             * Object Type
             * @description Object type (person, vehicle, etc.)
             */
            object_type: string;
        };
        /**
         * DetectionBulkCreateRequest
         * @description Request schema for bulk detection creation.
         *
         *     Attributes:
         *         detections: List of detections to create (max 100 per request)
         */
        DetectionBulkCreateRequest: {
            /**
             * Detections
             * @description Detections to create (max 100)
             */
            detections: components["schemas"]["DetectionBulkCreateItem"][];
        };
        /**
         * DetectionBulkCreateResponse
         * @description Response schema for bulk detection creation.
         *
         *     Extends BulkOperationResponse with created detection IDs.
         */
        DetectionBulkCreateResponse: {
            /**
             * Failed
             * @description Number of failed operations
             */
            failed: number;
            /**
             * Results
             * @description Per-item results
             */
            results?: components["schemas"]["BulkItemResult"][];
            /**
             * Skipped
             * @description Number of skipped operations
             * @default 0
             */
            skipped: number;
            /**
             * Succeeded
             * @description Number of successful operations
             */
            succeeded: number;
            /**
             * Total
             * @description Total number of items in the request
             */
            total: number;
        };
        /**
         * DetectionBulkDeleteRequest
         * @description Request schema for bulk detection deletion.
         *
         *     Note: Detection deletion is always hard delete as detections
         *     are raw data and soft-delete is not supported.
         *
         *     Attributes:
         *         detection_ids: List of detection IDs to delete (max 100 per request)
         */
        DetectionBulkDeleteRequest: {
            /**
             * Detection Ids
             * @description Detection IDs to delete (max 100)
             */
            detection_ids: number[];
        };
        /**
         * DetectionBulkUpdateItem
         * @description Schema for a single detection update in a bulk update request.
         *
         *     Attributes:
         *         id: Detection ID to update
         *         object_type: Updated object type
         *         confidence: Updated confidence score
         *         enrichment_data: Updated enrichment data
         */
        DetectionBulkUpdateItem: {
            /**
             * Confidence
             * @description Confidence score
             */
            confidence?: number | null;
            /**
             * Enrichment Data
             * @description Enrichment pipeline results
             */
            enrichment_data?: {
                [key: string]: unknown;
            } | null;
            /**
             * Id
             * @description Detection ID to update
             */
            id: number;
            /**
             * Object Type
             * @description Object type
             */
            object_type?: string | null;
        };
        /**
         * DetectionBulkUpdateRequest
         * @description Request schema for bulk detection updates.
         *
         *     Attributes:
         *         detections: List of detection updates (max 100 per request)
         */
        DetectionBulkUpdateRequest: {
            /**
             * Detections
             * @description Detection updates (max 100)
             */
            detections: components["schemas"]["DetectionBulkUpdateItem"][];
        };
        /**
         * DetectionLabelCount
         * @description Schema for a label with count.
         */
        DetectionLabelCount: {
            /** Count */
            count: number;
            /** Label */
            label: string;
        };
        /**
         * DetectionLabelsResponse
         * @description Schema for detection labels response.
         */
        DetectionLabelsResponse: {
            /** Labels */
            labels: components["schemas"]["DetectionLabelCount"][];
        };
        /**
         * DetectionListResponse
         * @description Schema for detection list response with standardized pagination envelope.
         *
         *     Uses the standard pagination envelope: {"items": [...], "pagination": {...}}
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         * @example {
         *       "items": [
         *         {
         *           "bbox_height": 400,
         *           "bbox_width": 200,
         *           "bbox_x": 100,
         *           "bbox_y": 150,
         *           "camera_id": "front_door",
         *           "confidence": 0.95,
         *           "detected_at": "2025-12-23T12:00:00Z",
         *           "file_path": "/export/foscam/front_door/20251223_120000.jpg",
         *           "file_type": "image/jpeg",
         *           "id": 1,
         *           "object_type": "person",
         *           "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=", // pragma: allowlist secret
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        DetectionListResponse: {
            /**
             * Deprecation Warning
             * @description Warning message when using deprecated offset pagination
             */
            deprecation_warning?: string | null;
            /**
             * Items
             * @description List of detections
             */
            items: components["schemas"]["DetectionResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * DetectionResponse
         * @description Schema for detection response.
         * @example {
         *       "bbox_height": 400,
         *       "bbox_width": 200,
         *       "bbox_x": 100,
         *       "bbox_y": 150,
         *       "camera_id": "front_door",
         *       "confidence": 0.95,
         *       "detected_at": "2025-12-23T12:00:00Z",
         *       "enrichment_data": {
         *         "errors": [],
         *         "person": {
         *           "action": "walking",
         *           "carrying": [
         *             "backpack"
         *           ],
         *           "clothing_description": "dark jacket",
         *           "is_suspicious": false
         *         },
         *         "vehicle": {
         *           "has_damage": false,
         *           "is_commercial": false,
         *           "vehicle_color": "blue",
         *           "vehicle_type": "sedan"
         *         },
         *         "weather": "sunny"
         *       },
         *       "file_path": "/export/foscam/front_door/20251223_120000.jpg",
         *       "file_type": "image/jpeg",
         *       "id": 1,
         *       "media_type": "image",
         *       "object_type": "person",
         *       "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
         *     }
         */
        DetectionResponse: {
            /**
             * Bbox Height
             * @description Bounding box height
             */
            bbox_height?: number | null;
            /**
             * Bbox Width
             * @description Bounding box width
             */
            bbox_width?: number | null;
            /**
             * Bbox X
             * @description Bounding box X coordinate
             */
            bbox_x?: number | null;
            /**
             * Bbox Y
             * @description Bounding box Y coordinate
             */
            bbox_y?: number | null;
            /**
             * Camera Id
             * @description Normalized camera ID (e.g., 'front_door')
             */
            camera_id: string;
            /**
             * Confidence
             * @description Detection confidence score (0-1)
             */
            confidence?: number | null;
            /**
             * Detected At
             * Format: date-time
             * @description Timestamp when detection was made
             */
            detected_at: string;
            /**
             * Duration
             * @description Video duration in seconds (video only)
             */
            duration?: number | null;
            /**
             * Enrichment Data
             * @description AI enrichment data including vehicle classification, pet identification, person attributes, license plates, weather, and image quality scores
             */
            enrichment_data?: {
                [key: string]: unknown;
            } | null;
            /**
             * File Path
             * @description Path to source image or video file
             */
            file_path: string;
            /**
             * File Type
             * @description MIME type of source file
             */
            file_type?: string | null;
            /**
             * Id
             * @description Detection ID
             */
            id: number;
            /**
             * Media Type
             * @description Media type: 'image' or 'video'
             * @default image
             */
            media_type: string | null;
            /**
             * Object Type
             * @description Type of detected object (person, car, etc.)
             */
            object_type?: string | null;
            /**
             * Thumbnail Path
             * @description Path to thumbnail image with bbox overlay
             */
            thumbnail_path?: string | null;
            /**
             * Video Codec
             * @description Video codec (e.g., h264, hevc)
             */
            video_codec?: string | null;
            /**
             * Video Height
             * @description Video resolution height
             */
            video_height?: number | null;
            /**
             * Video Width
             * @description Video resolution width
             */
            video_width?: number | null;
        };
        /**
         * DetectionSearchResponse
         * @description Schema for detection search response.
         */
        DetectionSearchResponse: {
            /** Limit */
            limit: number;
            /** Offset */
            offset: number;
            /**
             * Results
             * @description Search results
             */
            results: components["schemas"]["DetectionSearchResult"][];
            /**
             * Total Count
             * @description Total matching detections
             */
            total_count: number;
        };
        /**
         * DetectionSearchResult
         * @description Schema for a single detection search result.
         */
        DetectionSearchResult: {
            /** Bbox Height */
            bbox_height?: number | null;
            /** Bbox Width */
            bbox_width?: number | null;
            /** Bbox X */
            bbox_x?: number | null;
            /** Bbox Y */
            bbox_y?: number | null;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Confidence
             * @description Detection confidence score
             */
            confidence?: number | null;
            /**
             * Detected At
             * Format: date-time
             * @description Detection timestamp
             */
            detected_at: string;
            /** Enrichment Data */
            enrichment_data?: {
                [key: string]: unknown;
            } | null;
            /**
             * File Path
             * @description Path to source file
             */
            file_path: string;
            /**
             * Id
             * @description Detection ID
             */
            id: number;
            /**
             * Labels
             * @description Searchable labels
             */
            labels?: string[];
            /**
             * Object Type
             * @description Detected object type
             */
            object_type?: string | null;
            /**
             * Relevance Score
             * @description Search relevance score
             * @default 0
             */
            relevance_score: number;
            /**
             * Thumbnail Path
             * @description Path to thumbnail
             */
            thumbnail_path?: string | null;
        };
        /**
         * DetectionStatsResponse
         * @description Schema for detection statistics response.
         *
         *     Returns aggregate statistics about detections including counts by object class.
         *     Used by the AI Performance page to display detection class distribution.
         * @example {
         *       "average_confidence": 0.87,
         *       "detections_by_class": {
         *         "bicycle": 1,
         *         "car": 20,
         *         "person": 23,
         *         "truck": 6
         *       },
         *       "total_detections": 107
         *     }
         */
        DetectionStatsResponse: {
            /**
             * Average Confidence
             * @description Average confidence score across all detections
             */
            average_confidence?: number | null;
            /**
             * Detections By Class
             * @description Detection counts grouped by object class (e.g., person, car, truck)
             */
            detections_by_class: {
                [key: string]: number;
            };
            /**
             * Total Detections
             * @description Total number of detections
             */
            total_detections: number;
        };
        /**
         * DetectionSummary
         * @description Summary of a detection linked to an entity.
         *
         *     Represents a single detection occurrence for an entity, used in
         *     the entity detections list endpoint.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "confidence": 0.95,
         *       "detection_id": 123,
         *       "object_type": "person",
         *       "thumbnail_url": "/api/detections/123/image",
         *       "timestamp": "2025-12-23T10:00:00Z"
         *     }
         */
        DetectionSummary: {
            /**
             * Camera Id
             * @description Camera ID where detection occurred
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name?: string | null;
            /**
             * Confidence
             * @description Detection confidence score
             */
            confidence?: number | null;
            /**
             * Detection Id
             * @description Detection database ID
             */
            detection_id: number;
            /**
             * Object Type
             * @description Detected object type
             */
            object_type?: string | null;
            /**
             * Thumbnail Url
             * @description URL to detection thumbnail
             */
            thumbnail_url?: string | null;
            /**
             * Timestamp
             * Format: date-time
             * @description When the detection occurred
             */
            timestamp: string;
        };
        /**
         * DetectionTrendDataPoint
         * @description Schema for a single detection trend data point.
         * @example {
         *       "count": 25,
         *       "date": "2025-01-07"
         *     }
         */
        DetectionTrendDataPoint: {
            /**
             * Count
             * @description Number of detections on this date
             */
            count: number;
            /**
             * Date
             * Format: date
             * @description Date of the data point
             */
            date: string;
        };
        /**
         * DetectionTrendsResponse
         * @description Schema for detection trends aggregated by day.
         * @example {
         *       "data_points": [
         *         {
         *           "count": 20,
         *           "date": "2025-01-01"
         *         },
         *         {
         *           "count": 25,
         *           "date": "2025-01-02"
         *         },
         *         {
         *           "count": 18,
         *           "date": "2025-01-03"
         *         }
         *       ],
         *       "end_date": "2025-01-03",
         *       "start_date": "2025-01-01",
         *       "total_detections": 63
         *     }
         */
        DetectionTrendsResponse: {
            /**
             * Data Points
             * @description Detection counts aggregated by day
             */
            data_points: components["schemas"]["DetectionTrendDataPoint"][];
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
            /**
             * Total Detections
             * @description Total detections in date range
             */
            total_detections: number;
        };
        /**
         * DeviationInterpretation
         * @description Interpretation of current deviation from baseline.
         * @enum {string}
         */
        DeviationInterpretation: "far_below_normal" | "below_normal" | "normal" | "slightly_above_normal" | "above_normal" | "far_above_normal";
        /**
         * EnrichmentResponse
         * @description Structured enrichment data for a single detection.
         *
         *     Contains results from all vision models run during the enrichment pipeline.
         * @example {
         *       "clothing": {
         *         "lower": "blue jeans",
         *         "upper": "red t-shirt"
         *       },
         *       "detection_id": 12345,
         *       "enriched_at": "2026-01-03T10:30:00Z",
         *       "errors": [],
         *       "face": {
         *         "confidence": 0.88,
         *         "count": 1,
         *         "detected": true
         *       },
         *       "image_quality": {
         *         "is_blurry": false,
         *         "score": 0.85
         *       },
         *       "license_plate": {
         *         "confidence": 0.92,
         *         "detected": true,
         *         "text": "ABC-1234"
         *       },
         *       "processing_time_ms": 125.5,
         *       "vehicle": {
         *         "color": "silver",
         *         "confidence": 0.91,
         *         "type": "sedan"
         *       },
         *       "violence": {
         *         "detected": false,
         *         "score": 0.12
         *       },
         *       "weather": {
         *         "condition": "clear",
         *         "confidence": 0.95
         *       }
         *     }
         */
        EnrichmentResponse: {
            /**
             * Clothing
             * @description Clothing analysis results
             */
            clothing?: components["schemas"]["ClothingEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Depth
             * @description Depth estimation results
             */
            depth?: components["schemas"]["DepthEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Detection Id
             * @description Detection ID
             */
            detection_id: number;
            /**
             * Enriched At
             * @description Timestamp when enrichment was performed
             */
            enriched_at?: string | null;
            /**
             * Errors
             * @description Errors encountered during enrichment
             */
            errors?: string[];
            /**
             * Face
             * @description Face detection results
             */
            face?: components["schemas"]["FaceEnrichment"] | {
                [key: string]: unknown;
            };
            /**
             * Image Quality
             * @description Image quality assessment
             */
            image_quality?: components["schemas"]["ImageQualityEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * License Plate
             * @description License plate detection results
             */
            license_plate?: components["schemas"]["LicensePlateEnrichment"] | {
                [key: string]: unknown;
            };
            /**
             * Pet
             * @description Pet classification results
             */
            pet?: components["schemas"]["PetEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Pose
             * @description Pose estimation results
             */
            pose?: components["schemas"]["PoseEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Processing Time Ms
             * @description Enrichment processing time in milliseconds
             */
            processing_time_ms?: number | null;
            /**
             * Vehicle
             * @description Vehicle classification results
             */
            vehicle?: components["schemas"]["VehicleEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Violence
             * @description Violence detection results
             */
            violence?: components["schemas"]["ViolenceEnrichment"] | {
                [key: string]: unknown;
            };
            /**
             * Weather
             * @description Weather classification results
             */
            weather?: components["schemas"]["WeatherEnrichment"] | {
                [key: string]: unknown;
            } | null;
        };
        /**
         * EnrichmentStatusEnum
         * @description Status of enrichment pipeline execution for an event.
         *
         *     Values:
         *         full: All enrichment models succeeded
         *         partial: Some models succeeded, some failed
         *         failed: All models failed (no enrichment data)
         *         skipped: Enrichment was not attempted
         * @enum {string}
         */
        EnrichmentStatusEnum: "full" | "partial" | "failed" | "skipped";
        /**
         * EnrichmentStatusResponse
         * @description Schema for enrichment status in event responses (NEM-1672).
         *
         *     Provides visibility into which enrichment models succeeded/failed
         *     for a given event, instead of silently degrading.
         * @example {
         *       "errors": {
         *         "clothing": "Model not loaded"
         *       },
         *       "failed_models": [
         *         "clothing"
         *       ],
         *       "status": "partial",
         *       "success_rate": 0.75,
         *       "successful_models": [
         *         "violence",
         *         "weather",
         *         "face"
         *       ]
         *     }
         */
        EnrichmentStatusResponse: {
            /**
             * Errors
             * @description Model name to error message mapping
             */
            errors?: {
                [key: string]: string;
            };
            /**
             * Failed Models
             * @description List of enrichment models that failed
             */
            failed_models?: string[];
            /** @description Overall enrichment status (full, partial, failed, skipped) */
            status: components["schemas"]["EnrichmentStatusEnum"];
            /**
             * Success Rate
             * @description Success rate (0.0 to 1.0)
             */
            success_rate: number;
            /**
             * Successful Models
             * @description List of enrichment models that succeeded
             */
            successful_models?: string[];
        };
        /**
         * EntityAppearance
         * @description Schema for a single entity appearance at a specific time and camera.
         *
         *     Represents one sighting of an entity, including the detection it came from
         *     and additional attributes extracted from the image.
         * @example {
         *       "attributes": {
         *         "carrying": "backpack",
         *         "clothing": "blue jacket"
         *       },
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "detection_id": "det_abc123",
         *       "similarity_score": 0.92,
         *       "thumbnail_url": "/api/detections/123/image",
         *       "timestamp": "2025-12-23T14:30:00Z"
         *     }
         */
        EntityAppearance: {
            /**
             * Attributes
             * @description Additional attributes extracted from the detection (clothing, carrying, etc.)
             */
            attributes?: {
                [key: string]: unknown;
            };
            /**
             * Camera Id
             * @description Camera ID where entity was seen
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name?: string | null;
            /**
             * Detection Id
             * @description Detection ID from original detection
             */
            detection_id: string;
            /**
             * Similarity Score
             * @description Similarity score to the entity's reference embedding
             */
            similarity_score?: number | null;
            /**
             * Thumbnail Url
             * @description URL to thumbnail image of this appearance
             */
            thumbnail_url?: string | null;
            /**
             * Timestamp
             * Format: date-time
             * @description When the entity was detected
             */
            timestamp: string;
        };
        /**
         * EntityDetail
         * @description Schema for detailed entity information including appearance history.
         *
         *     Extends EntitySummary with the full list of appearances.
         * @example {
         *       "appearance_count": 3,
         *       "appearances": [
         *         {
         *           "attributes": {
         *             "clothing": "blue jacket"
         *           },
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_id": "det_001",
         *           "similarity_score": 1,
         *           "thumbnail_url": "/api/detections/1/image",
         *           "timestamp": "2025-12-23T10:00:00Z"
         *         },
         *         {
         *           "attributes": {
         *             "carrying": "bag",
         *             "clothing": "blue jacket"
         *           },
         *           "camera_id": "backyard",
         *           "camera_name": "Backyard",
         *           "detection_id": "det_002",
         *           "similarity_score": 0.94,
         *           "thumbnail_url": "/api/detections/2/image",
         *           "timestamp": "2025-12-23T12:15:00Z"
         *         }
         *       ],
         *       "cameras_seen": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "entity_type": "person",
         *       "first_seen": "2025-12-23T10:00:00Z",
         *       "id": "entity_abc123",
         *       "last_seen": "2025-12-23T14:30:00Z",
         *       "thumbnail_url": "/api/detections/123/image"
         *     }
         */
        EntityDetail: {
            /**
             * Appearance Count
             * @description Total number of appearances
             */
            appearance_count: number;
            /**
             * Appearances
             * @description List of all appearances for this entity
             */
            appearances?: components["schemas"]["EntityAppearance"][];
            /**
             * Cameras Seen
             * @description List of camera IDs where entity was detected
             */
            cameras_seen?: string[];
            /**
             * Entity Type
             * @description Type of entity: 'person' or 'vehicle'
             */
            entity_type: string;
            /**
             * First Seen
             * Format: date-time
             * @description Timestamp of first appearance
             */
            first_seen: string;
            /**
             * Id
             * @description Unique entity identifier
             */
            id: string;
            /**
             * Last Seen
             * Format: date-time
             * @description Timestamp of most recent appearance
             */
            last_seen: string;
            /**
             * Thumbnail Url
             * @description URL to the most recent thumbnail image
             */
            thumbnail_url?: string | null;
        };
        /**
         * EntityDetectionsResponse
         * @description Response for entity detections list endpoint.
         *
         *     Returns all detections linked to a specific entity with pagination.
         * @example {
         *       "detections": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "confidence": 0.95,
         *           "detection_id": 123,
         *           "object_type": "person",
         *           "thumbnail_url": "/api/detections/123/image",
         *           "timestamp": "2025-12-23T10:00:00Z"
         *         }
         *       ],
         *       "entity_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "entity_type": "person",
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 5
         *       }
         *     }
         */
        EntityDetectionsResponse: {
            /**
             * Detections
             * @description List of detections for this entity
             */
            detections?: components["schemas"]["DetectionSummary"][];
            /**
             * Entity Id
             * @description UUID of the entity
             */
            entity_id: string;
            /**
             * Entity Type
             * @description Type of entity
             */
            entity_type: string;
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationInfo"];
        };
        /**
         * EntityHistoryResponse
         * @description Schema for entity appearance history response.
         * @example {
         *       "appearances": [
         *         {
         *           "attributes": {},
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_id": "det_001",
         *           "similarity_score": 1,
         *           "thumbnail_url": "/api/detections/1/image",
         *           "timestamp": "2025-12-23T10:00:00Z"
         *         }
         *       ],
         *       "count": 1,
         *       "entity_id": "entity_abc123",
         *       "entity_type": "person"
         *     }
         */
        EntityHistoryResponse: {
            /**
             * Appearances
             * @description List of appearances in chronological order
             */
            appearances: components["schemas"]["EntityAppearance"][];
            /**
             * Count
             * @description Total number of appearances
             */
            count: number;
            /**
             * Entity Id
             * @description Entity identifier
             */
            entity_id: string;
            /**
             * Entity Type
             * @description Type of entity
             */
            entity_type: string;
        };
        /**
         * EntityListResponse
         * @description Schema for paginated entity list response (NEM-2075 pagination envelope).
         *
         *     Uses standardized pagination envelope with 'items' and 'pagination' fields.
         * @example {
         *       "items": [
         *         {
         *           "appearance_count": 5,
         *           "cameras_seen": [
         *             "front_door",
         *             "backyard"
         *           ],
         *           "entity_type": "person",
         *           "first_seen": "2025-12-23T10:00:00Z",
         *           "id": "entity_abc123",
         *           "last_seen": "2025-12-23T14:30:00Z",
         *           "thumbnail_url": "/api/detections/123/image"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        EntityListResponse: {
            /**
             * Items
             * @description List of tracked entities
             */
            items: components["schemas"]["EntitySummary"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationInfo"];
        };
        /**
         * EntityMatchItem
         * @description Schema for a single entity match result.
         *
         *     Represents a matching entity found through re-identification,
         *     including similarity score and time gap.
         * @example {
         *       "attributes": {
         *         "clothing": "blue jacket"
         *       },
         *       "camera_id": "backyard",
         *       "camera_name": "Backyard",
         *       "entity_id": "det_abc123",
         *       "entity_type": "person",
         *       "similarity_score": 0.92,
         *       "thumbnail_url": "/api/detections/123/image",
         *       "time_gap_seconds": 3600,
         *       "timestamp": "2025-12-23T10:00:00Z"
         *     }
         */
        EntityMatchItem: {
            /**
             * Attributes
             * @description Additional attributes extracted from the detection
             */
            attributes?: {
                [key: string]: unknown;
            };
            /**
             * Camera Id
             * @description Camera ID where entity was seen
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name?: string | null;
            /**
             * Entity Id
             * @description Detection ID of the matched entity
             */
            entity_id: string;
            /**
             * Entity Type
             * @description Type of entity: 'person' or 'vehicle'
             */
            entity_type: string;
            /**
             * Similarity Score
             * @description Cosine similarity score (0-1)
             */
            similarity_score: number;
            /**
             * Thumbnail Url
             * @description URL to thumbnail image
             */
            thumbnail_url?: string | null;
            /**
             * Time Gap Seconds
             * @description Time gap in seconds between query and match
             */
            time_gap_seconds: number;
            /**
             * Timestamp
             * Format: date-time
             * @description When the entity was detected
             */
            timestamp: string;
        };
        /**
         * EntityMatchResponse
         * @description Schema for entity match query response.
         *
         *     Returns entities matching a specific detection's embedding,
         *     used for showing re-ID matches in the EventDetailModal.
         * @example {
         *       "entity_type": "person",
         *       "matches": [
         *         {
         *           "attributes": {
         *             "clothing": "blue jacket"
         *           },
         *           "camera_id": "backyard",
         *           "camera_name": "Backyard",
         *           "entity_id": "det_002",
         *           "entity_type": "person",
         *           "similarity_score": 0.92,
         *           "thumbnail_url": "/api/detections/2/image",
         *           "time_gap_seconds": 3600,
         *           "timestamp": "2025-12-23T09:00:00Z"
         *         }
         *       ],
         *       "query_detection_id": "det_001",
         *       "threshold": 0.85,
         *       "total_matches": 1
         *     }
         */
        EntityMatchResponse: {
            /**
             * Entity Type
             * @description Type of entity searched
             */
            entity_type: string;
            /**
             * Matches
             * @description List of matching entities sorted by similarity
             */
            matches?: components["schemas"]["EntityMatchItem"][];
            /**
             * Query Detection Id
             * @description Detection ID used for the query
             */
            query_detection_id: string;
            /**
             * Threshold
             * @description Similarity threshold used for matching
             */
            threshold: number;
            /**
             * Total Matches
             * @description Total number of matches found
             */
            total_matches: number;
        };
        /**
         * EntityStatsResponse
         * @description Response for entity statistics endpoint.
         *
         *     Returns aggregated statistics about tracked entities.
         * @example {
         *       "by_camera": {
         *         "backyard": 42,
         *         "driveway": 68,
         *         "front_door": 85,
         *         "garage": 12
         *       },
         *       "by_type": {
         *         "animal": 12,
         *         "other": 0,
         *         "package": 0,
         *         "person": 150,
         *         "vehicle": 45
         *       },
         *       "repeat_visitors": 89,
         *       "time_range": {
         *         "since": "2025-12-23T00:00:00Z",
         *         "until": "2025-12-23T23:59:59Z"
         *       },
         *       "total_appearances": 1523,
         *       "total_entities": 207
         *     }
         */
        EntityStatsResponse: {
            /**
             * By Camera
             * @description Entity counts grouped by camera
             */
            by_camera?: {
                [key: string]: number;
            };
            /**
             * By Type
             * @description Entity counts grouped by entity type
             */
            by_type?: {
                [key: string]: number;
            };
            /**
             * Repeat Visitors
             * @description Count of entities seen more than once
             */
            repeat_visitors: number;
            /**
             * Time Range
             * @description Time range for the statistics query
             */
            time_range?: {
                [key: string]: string | null;
            } | null;
            /**
             * Total Appearances
             * @description Sum of all detection counts across entities
             */
            total_appearances: number;
            /**
             * Total Entities
             * @description Count of unique entities
             */
            total_entities: number;
        };
        /**
         * EntitySummary
         * @description Schema for entity summary in list responses.
         *
         *     Provides an overview of a tracked entity without the full appearance history.
         * @example {
         *       "appearance_count": 5,
         *       "cameras_seen": [
         *         "front_door",
         *         "backyard",
         *         "driveway"
         *       ],
         *       "entity_type": "person",
         *       "first_seen": "2025-12-23T10:00:00Z",
         *       "id": "entity_abc123",
         *       "last_seen": "2025-12-23T14:30:00Z",
         *       "thumbnail_url": "/api/detections/123/image"
         *     }
         */
        EntitySummary: {
            /**
             * Appearance Count
             * @description Total number of appearances
             */
            appearance_count: number;
            /**
             * Cameras Seen
             * @description List of camera IDs where entity was detected
             */
            cameras_seen?: string[];
            /**
             * Entity Type
             * @description Type of entity: 'person' or 'vehicle'
             */
            entity_type: string;
            /**
             * First Seen
             * Format: date-time
             * @description Timestamp of first appearance
             */
            first_seen: string;
            /**
             * Id
             * @description Unique entity identifier
             */
            id: string;
            /**
             * Last Seen
             * Format: date-time
             * @description Timestamp of most recent appearance
             */
            last_seen: string;
            /**
             * Thumbnail Url
             * @description URL to the most recent thumbnail image
             */
            thumbnail_url?: string | null;
        };
        /**
         * EntityTypeFilter
         * @description Entity types for API query filtering.
         *
         *     A subset of EntityTypeEnum used for filtering in API endpoints.
         *     Currently only person and vehicle are supported for re-identification.
         * @enum {string}
         */
        EntityTypeFilter: "person" | "vehicle";
        /**
         * EventAuditResponse
         * @description Full audit response for a single event.
         * @example {
         *       "audited_at": "2026-01-03T10:30:00Z",
         *       "consistency_diff": 3,
         *       "consistency_risk_score": 62,
         *       "contributions": {
         *         "baseline": false,
         *         "clip": false,
         *         "clothing": true,
         *         "cross_camera": false,
         *         "florence": true,
         *         "image_quality": true,
         *         "pet": false,
         *         "rtdetr": true,
         *         "vehicle": false,
         *         "violence": false,
         *         "weather": true,
         *         "zones": true
         *       },
         *       "enrichment_utilization": 0.85,
         *       "event_id": 12345,
         *       "id": 456,
         *       "improvements": {
         *         "confusing_sections": [],
         *         "format_suggestions": [],
         *         "missing_context": [
         *           "Time since last motion event"
         *         ],
         *         "model_gaps": [],
         *         "unused_data": []
         *       },
         *       "is_fully_evaluated": true,
         *       "prompt_length": 2048,
         *       "prompt_token_estimate": 512,
         *       "scores": {
         *         "consistency": 4,
         *         "context_usage": 4.2,
         *         "overall": 4.1,
         *         "reasoning_coherence": 4.5,
         *         "risk_justification": 3.8
         *       },
         *       "self_eval_critique": "More historical context would improve analysis."
         *     }
         */
        EventAuditResponse: {
            /**
             * Audited At
             * Format: date-time
             */
            audited_at: string;
            /** Consistency Diff */
            consistency_diff?: number | null;
            /** Consistency Risk Score */
            consistency_risk_score?: number | null;
            contributions: components["schemas"]["ModelContributions"];
            /** Enrichment Utilization */
            enrichment_utilization: number;
            /** Event Id */
            event_id: number;
            /** Id */
            id: number;
            improvements: components["schemas"]["PromptImprovements"];
            /** Is Fully Evaluated */
            is_fully_evaluated: boolean;
            /** Prompt Length */
            prompt_length: number;
            /** Prompt Token Estimate */
            prompt_token_estimate: number;
            scores: components["schemas"]["QualityScores"];
            /** Self Eval Critique */
            self_eval_critique?: string | null;
        };
        /**
         * EventBulkCreateItem
         * @description Schema for a single event in a bulk create request.
         *
         *     Attributes:
         *         batch_id: Batch ID that generated this event (tracks detection grouping)
         *         camera_id: Camera ID that generated this event
         *         started_at: Event start timestamp
         *         ended_at: Optional event end timestamp
         *         risk_score: Risk score from 0-100
         *         risk_level: Risk level (low, medium, high, critical)
         *         summary: Brief event summary
         *         reasoning: Detailed reasoning from LLM analysis
         *         detection_ids: List of detection IDs associated with this event
         */
        EventBulkCreateItem: {
            /**
             * Batch Id
             * @description Batch ID that generated this event
             */
            batch_id: string;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Detection Ids
             * @description Associated detection IDs
             */
            detection_ids?: number[];
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning
             */
            reasoning?: string | null;
            /**
             * Risk Level
             * @description Risk level
             */
            risk_level: string;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score: number;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Summary
             * @description Event summary
             */
            summary: string;
        };
        /**
         * EventBulkCreateRequest
         * @description Request schema for bulk event creation.
         *
         *     Attributes:
         *         events: List of events to create (max 100 per request)
         */
        EventBulkCreateRequest: {
            /**
             * Events
             * @description Events to create (max 100)
             */
            events: components["schemas"]["EventBulkCreateItem"][];
        };
        /**
         * EventBulkCreateResponse
         * @description Response schema for bulk event creation.
         *
         *     Extends BulkOperationResponse with created event IDs.
         */
        EventBulkCreateResponse: {
            /**
             * Failed
             * @description Number of failed operations
             */
            failed: number;
            /**
             * Results
             * @description Per-item results
             */
            results?: components["schemas"]["BulkItemResult"][];
            /**
             * Skipped
             * @description Number of skipped operations
             * @default 0
             */
            skipped: number;
            /**
             * Succeeded
             * @description Number of successful operations
             */
            succeeded: number;
            /**
             * Total
             * @description Total number of items in the request
             */
            total: number;
        };
        /**
         * EventBulkDeleteRequest
         * @description Request schema for bulk event deletion.
         *
         *     Attributes:
         *         event_ids: List of event IDs to delete (max 100 per request)
         *         soft_delete: If true, mark as deleted instead of removing
         */
        EventBulkDeleteRequest: {
            /**
             * Event Ids
             * @description Event IDs to delete (max 100)
             */
            event_ids: number[];
            /**
             * Soft Delete
             * @description Soft delete (default) vs hard delete
             * @default true
             */
            soft_delete: boolean;
        };
        /**
         * EventBulkUpdateItem
         * @description Schema for a single event update in a bulk update request.
         *
         *     Attributes:
         *         id: Event ID to update
         *         reviewed: Mark event as reviewed/dismissed
         *         notes: Optional notes for the event
         */
        EventBulkUpdateItem: {
            /**
             * Id
             * @description Event ID to update
             */
            id: number;
            /**
             * Notes
             * @description Notes
             */
            notes?: string | null;
            /**
             * Reviewed
             * @description Mark as reviewed
             */
            reviewed?: boolean | null;
        };
        /**
         * EventBulkUpdateRequest
         * @description Request schema for bulk event updates.
         *
         *     Attributes:
         *         events: List of event updates (max 100 per request)
         */
        EventBulkUpdateRequest: {
            /**
             * Events
             * @description Event updates (max 100)
             */
            events: components["schemas"]["EventBulkUpdateItem"][];
        };
        /**
         * EventEnrichmentsResponse
         * @description Enrichment data for all detections in an event with pagination support.
         * @example {
         *       "count": 2,
         *       "enrichments": [
         *         {
         *           "detection_id": 1,
         *           "enriched_at": "2026-01-03T10:30:00Z",
         *           "face": {
         *             "count": 0,
         *             "detected": false
         *           },
         *           "license_plate": {
         *             "detected": true,
         *             "text": "ABC-1234"
         *           },
         *           "violence": {
         *             "detected": false,
         *             "score": 0
         *           }
         *         },
         *         {
         *           "detection_id": 2,
         *           "enriched_at": "2026-01-03T10:30:05Z",
         *           "face": {
         *             "count": 1,
         *             "detected": true
         *           },
         *           "license_plate": {
         *             "detected": false
         *           },
         *           "violence": {
         *             "detected": false,
         *             "score": 0
         *           }
         *         }
         *       ],
         *       "event_id": 100,
         *       "has_more": false,
         *       "limit": 50,
         *       "offset": 0,
         *       "total": 10
         *     }
         */
        EventEnrichmentsResponse: {
            /**
             * Count
             * @description Number of enrichments in this response (page size)
             */
            count: number;
            /**
             * Enrichments
             * @description Enrichment data per detection
             */
            enrichments: components["schemas"]["EnrichmentResponse"][];
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Has More
             * @description Whether there are more results available
             */
            has_more: boolean;
            /**
             * Limit
             * @description Maximum number of results requested
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
            /**
             * Total
             * @description Total number of detections with enrichment data for this event
             */
            total: number;
        };
        /**
         * EventFeedbackCreate
         * @description Schema for creating event feedback.
         *
         *     Used when submitting user feedback about an event's classification.
         * @example {
         *       "event_id": 123,
         *       "feedback_type": "false_positive",
         *       "notes": "This was my neighbor's car, not a threat."
         *     }
         */
        EventFeedbackCreate: {
            /**
             * Event Id
             * @description ID of the event this feedback is for
             */
            event_id: number;
            /** @description Type of feedback (accurate, false_positive, missed_threat, severity_wrong) */
            feedback_type: components["schemas"]["FeedbackType"];
            /**
             * Notes
             * @description Optional notes explaining the feedback
             */
            notes?: string | null;
        };
        /**
         * EventFeedbackResponse
         * @description Schema for event feedback response.
         *
         *     Returned when retrieving feedback for an event.
         * @example {
         *       "created_at": "2025-01-01T12:00:00Z",
         *       "event_id": 123,
         *       "feedback_type": "false_positive",
         *       "id": 1,
         *       "notes": "This was my neighbor's car, not a threat."
         *     }
         */
        EventFeedbackResponse: {
            /**
             * Created At
             * Format: date-time
             * @description When feedback was submitted
             */
            created_at: string;
            /**
             * Event Id
             * @description Event ID this feedback belongs to
             */
            event_id: number;
            /**
             * Feedback Type
             * @description Type of feedback provided
             */
            feedback_type: components["schemas"]["FeedbackType"] | string;
            /**
             * Id
             * @description Feedback record ID
             */
            id: number;
            /**
             * Notes
             * @description Optional notes from user
             */
            notes?: string | null;
        };
        /**
         * EventListResponse
         * @description Schema for event list response with pagination.
         *
         *     NEM-2075: Standardized pagination envelope with items + pagination structure.
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Use cursor-based pagination for better performance with large datasets.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "reasoning": "Person approaching entrance during daytime",
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Person detected near front entrance",
         *           "thumbnail_url": "/api/media/detections/1"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=", // pragma: allowlist secret
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        EventListResponse: {
            /**
             * Deprecation Warning
             * @description Warning message when using deprecated offset pagination
             */
            deprecation_warning?: string | null;
            /**
             * Items
             * @description List of events
             */
            items: components["schemas"]["EventResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * EventRegistryResponse
         * @description Response containing the complete WebSocket event registry.
         * @example {
         *       "channels": [
         *         "detections",
         *         "events",
         *         "alerts",
         *         "cameras",
         *         "jobs",
         *         "system"
         *       ],
         *       "deprecated_count": 3,
         *       "event_types": [],
         *       "total_count": 25
         *     }
         */
        EventRegistryResponse: {
            /**
             * Channels
             * @description List of all available WebSocket channels
             */
            channels: string[];
            /**
             * Deprecated Count
             * @description Number of deprecated event types
             */
            deprecated_count: number;
            /**
             * Event Types
             * @description List of all available event types
             */
            event_types: components["schemas"]["EventTypeInfo"][];
            /**
             * Total Count
             * @description Total number of event types
             */
            total_count: number;
        };
        /**
         * EventResponse
         * @description Schema for event response.
         * @example {
         *       "camera_id": "front_door",
         *       "detection_count": 5,
         *       "detection_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "ended_at": "2025-12-23T12:02:30Z",
         *       "enrichment_status": {
         *         "errors": {},
         *         "failed_models": [],
         *         "status": "full",
         *         "success_rate": 1,
         *         "successful_models": [
         *           "violence",
         *           "weather",
         *           "face",
         *           "clothing"
         *         ]
         *       },
         *       "id": 1,
         *       "llm_prompt": "<|im_start|>system\nYou are a home security risk analyzer...",
         *       "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
         *       "reviewed": false,
         *       "risk_level": "medium",
         *       "risk_score": 75,
         *       "started_at": "2025-12-23T12:00:00Z",
         *       "summary": "Person detected near front entrance",
         *       "thumbnail_url": "/api/media/detections/1"
         *     }
         */
        EventResponse: {
            /**
             * Camera Id
             * @description Normalized camera ID (e.g., 'front_door')
             */
            camera_id: string;
            /**
             * Detection Count
             * @description Number of detections in this event
             * @default 0
             */
            detection_count: number;
            /**
             * Detection Ids
             * @description List of detection IDs associated with this event
             */
            detection_ids?: number[];
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /** @description Enrichment pipeline status (NEM-1672) - shows which models succeeded/failed */
            enrichment_status?: components["schemas"]["EnrichmentStatusResponse"] | null;
            /**
             * Id
             * @description Event ID
             */
            id: number;
            /**
             * Llm Prompt
             * @description Full prompt sent to Nemotron LLM (for debugging/improvement)
             */
            llm_prompt?: string | null;
            /**
             * Notes
             * @description User notes for the event
             */
            notes?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning for risk score
             */
            reasoning?: string | null;
            /**
             * Reviewed
             * @description Whether event has been reviewed
             * @default false
             */
            reviewed: boolean;
            /**
             * Risk Level
             * @description Risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score?: number | null;
            /**
             * Snooze Until
             * @description Timestamp until which alerts for this event are snoozed (NEM-2359)
             */
            snooze_until?: string | null;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Summary
             * @description LLM-generated event summary
             */
            summary?: string | null;
            /**
             * Thumbnail Url
             * @description URL to thumbnail image (first detection's media)
             */
            thumbnail_url?: string | null;
        };
        /**
         * EventStatsResponse
         * @description Schema for aggregated event statistics.
         * @example {
         *       "events_by_camera": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "event_count": 30
         *         },
         *         {
         *           "camera_id": "back_door",
         *           "camera_name": "Back Door",
         *           "event_count": 14
         *         }
         *       ],
         *       "events_by_risk_level": {
         *         "critical": 2,
         *         "high": 5,
         *         "low": 25,
         *         "medium": 12
         *       },
         *       "total_events": 44
         *     }
         */
        EventStatsResponse: {
            /**
             * Events By Camera
             * @description Events grouped by camera
             */
            events_by_camera: components["schemas"]["EventsByCamera"][];
            /** @description Events grouped by risk level */
            events_by_risk_level: components["schemas"]["EventsByRiskLevel"];
            /**
             * Total Events
             * @description Total number of events
             */
            total_events: number;
        };
        /**
         * EventTypeInfo
         * @description Information about a single WebSocket event type.
         * @example {
         *       "channel": "detections",
         *       "deprecated": false,
         *       "description": "New detection from AI pipeline",
         *       "example": {
         *         "confidence": 0.95,
         *         "detection_id": "123",
         *         "label": "person"
         *       },
         *       "payload_schema": {
         *         "confidence": {
         *           "type": "number"
         *         },
         *         "detection_id": {
         *           "format": "uuid",
         *           "type": "string"
         *         },
         *         "label": {
         *           "type": "string"
         *         }
         *       },
         *       "type": "detection.new"
         *     }
         */
        EventTypeInfo: {
            /**
             * Channel
             * @description WebSocket channel this event is broadcast on
             */
            channel?: string | null;
            /**
             * Deprecated
             * @description Whether this event type is deprecated
             * @default false
             */
            deprecated: boolean;
            /**
             * Description
             * @description Human-readable description
             */
            description: string;
            /**
             * Example
             * @description Example payload
             */
            example?: {
                [key: string]: unknown;
            } | null;
            /**
             * Payload Schema
             * @description JSON Schema for the event payload
             */
            payload_schema: {
                [key: string]: unknown;
            };
            /**
             * Replacement
             * @description Replacement event type if deprecated
             */
            replacement?: string | null;
            /**
             * Type
             * @description Event type identifier
             */
            type: string;
        };
        /**
         * EventUpdate
         * @description Schema for updating an event (PATCH).
         * @example {
         *       "notes": "Verified - delivery person",
         *       "reviewed": true,
         *       "snooze_until": "2025-12-24T12:00:00Z"
         *     }
         */
        EventUpdate: {
            /**
             * Notes
             * @description User notes for the event
             */
            notes?: string | null;
            /**
             * Reviewed
             * @description Mark event as reviewed or not reviewed
             */
            reviewed?: boolean | null;
            /**
             * Snooze Until
             * @description Set or clear the alert snooze timestamp (NEM-2359)
             */
            snooze_until?: string | null;
        };
        /**
         * EventsByCamera
         * @description Schema for events count by camera.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "event_count": 15
         *     }
         */
        EventsByCamera: {
            /**
             * Camera Id
             * @description Normalized camera ID (e.g., 'front_door')
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera name
             */
            camera_name: string;
            /**
             * Event Count
             * @description Number of events for this camera
             */
            event_count: number;
        };
        /**
         * EventsByRiskLevel
         * @description Schema for events count by risk level.
         * @example {
         *       "critical": 2,
         *       "high": 5,
         *       "low": 25,
         *       "medium": 12
         *     }
         */
        EventsByRiskLevel: {
            /**
             * Critical
             * @description Number of critical risk events
             * @default 0
             */
            critical: number;
            /**
             * High
             * @description Number of high risk events
             * @default 0
             */
            high: number;
            /**
             * Low
             * @description Number of low risk events
             * @default 0
             */
            low: number;
            /**
             * Medium
             * @description Number of medium risk events
             * @default 0
             */
            medium: number;
        };
        /**
         * ExportDownloadResponse
         * @description Schema for export file download metadata.
         *
         *     Returned when checking if a file is ready for download.
         *     The actual file is served via a separate streaming endpoint.
         * @example {
         *       "content_type": "text/csv",
         *       "download_url": "/api/exports/550e8400-e29b-41d4-a716-446655440000/download",
         *       "filename": "events_export_20250112_143000.csv",
         *       "ready": true,
         *       "size_bytes": 125432
         *     }
         */
        ExportDownloadResponse: {
            /**
             * Content Type
             * @description MIME type of the file
             */
            content_type?: string | null;
            /**
             * Download Url
             * @description URL to download the file
             */
            download_url?: string | null;
            /**
             * Filename
             * @description Exported filename
             */
            filename?: string | null;
            /**
             * Ready
             * @description Whether the file is ready for download
             */
            ready: boolean;
            /**
             * Size Bytes
             * @description File size in bytes
             */
            size_bytes?: number | null;
        };
        /**
         * ExportFormat
         * @description Supported export formats.
         * @enum {string}
         */
        ExportFormat: "csv" | "json" | "zip";
        /**
         * ExportFormatEnum
         * @description Export file formats.
         * @enum {string}
         */
        ExportFormatEnum: "csv" | "json" | "zip" | "excel";
        /**
         * ExportJobCancelResponse
         * @description Schema for export job cancellation response.
         * @example {
         *       "cancelled": true,
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Export job cancelled by user",
         *       "status": "failed"
         *     }
         */
        ExportJobCancelResponse: {
            /**
             * Cancelled
             * @description Whether cancellation was successful
             */
            cancelled: boolean;
            /**
             * Job Id
             * @description Job ID that was cancelled
             */
            job_id: string;
            /**
             * Message
             * @description Cancellation status message
             */
            message: string;
            /** @description New job status after cancellation */
            status: components["schemas"]["ExportJobStatusEnum"];
        };
        /**
         * ExportJobCreate
         * @description Schema for creating an export job.
         *
         *     Create a new background export job with optional filtering parameters.
         *     The job will be processed asynchronously and can be monitored via
         *     the job status endpoint.
         * @example {
         *       "camera_id": "front_door",
         *       "end_date": "2025-01-12T23:59:59Z",
         *       "export_format": "csv",
         *       "export_type": "events",
         *       "risk_level": "high",
         *       "start_date": "2025-01-01T00:00:00Z"
         *     }
         */
        ExportJobCreate: {
            /**
             * Camera Id
             * @description Filter by camera ID
             */
            camera_id?: string | null;
            /**
             * End Date
             * @description Filter events ending before this date (ISO format)
             */
            end_date?: string | null;
            /**
             * @description Output file format (csv, json, zip, excel)
             * @default csv
             */
            export_format: components["schemas"]["ExportFormatEnum"];
            /**
             * @description Type of data to export (events, alerts, full_backup)
             * @default events
             */
            export_type: components["schemas"]["ExportTypeEnum"];
            /**
             * Reviewed
             * @description Filter by reviewed status (true=reviewed, false=unreviewed, null=all)
             */
            reviewed?: boolean | null;
            /**
             * Risk Level
             * @description Filter by risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Start Date
             * @description Filter events starting from this date (ISO format)
             */
            start_date?: string | null;
        };
        /**
         * ExportJobListResponse
         * @description Schema for export job list response with pagination.
         * @example {
         *       "items": [
         *         {
         *           "completed_at": "2025-01-12T14:35:00Z",
         *           "created_at": "2025-01-12T14:30:00Z",
         *           "export_format": "csv",
         *           "export_type": "events",
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "progress": {
         *             "current_step": "Complete",
         *             "processed_items": 1230,
         *             "progress_percent": 100,
         *             "total_items": 1230
         *           },
         *           "result": {
         *             "event_count": 1230,
         *             "format": "csv",
         *             "output_path": "/api/exports/download/events_export_20250112_143000.csv",
         *             "output_size_bytes": 125432
         *           },
         *           "started_at": "2025-01-12T14:30:01Z",
         *           "status": "completed"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        ExportJobListResponse: {
            /**
             * Items
             * @description List of export jobs
             */
            items: components["schemas"]["ExportJobResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * ExportJobProgress
         * @description Schema for export job progress information.
         *
         *     Detailed progress information for an export job, including
         *     timing, item counts, and current step.
         * @example {
         *       "current_step": "Processing events...",
         *       "estimated_completion": "2025-01-12T14:35:00Z",
         *       "processed_items": 245,
         *       "progress_percent": 20,
         *       "total_items": 1230
         *     }
         */
        ExportJobProgress: {
            /**
             * Current Step
             * @description Current processing step description
             */
            current_step?: string | null;
            /**
             * Estimated Completion
             * @description Estimated completion time (ISO format)
             */
            estimated_completion?: string | null;
            /**
             * Processed Items
             * @description Number of items processed so far
             * @default 0
             */
            processed_items: number;
            /**
             * Progress Percent
             * @description Progress percentage (0-100)
             * @default 0
             */
            progress_percent: number;
            /**
             * Total Items
             * @description Total items to process (null if unknown)
             */
            total_items?: number | null;
        };
        /**
         * ExportJobRequest
         * @description Request to start an export job.
         * @example {
         *       "end_date": "2024-01-15T23:59:59Z",
         *       "format": "csv",
         *       "risk_level": "high",
         *       "start_date": "2024-01-01T00:00:00Z"
         *     }
         */
        ExportJobRequest: {
            /**
             * Camera Id
             * @description Filter by camera ID
             */
            camera_id?: string | null;
            /**
             * End Date
             * @description Filter by end date (ISO format)
             */
            end_date?: string | null;
            /**
             * @description Export format
             * @default csv
             */
            format: components["schemas"]["ExportFormat"];
            /**
             * Reviewed
             * @description Filter by reviewed status
             */
            reviewed?: boolean | null;
            /**
             * Risk Level
             * @description Filter by risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Start Date
             * @description Filter by start date (ISO format)
             */
            start_date?: string | null;
        };
        /**
         * ExportJobResponse
         * @description Schema for export job status response.
         *
         *     Complete status information for an export job, including
         *     progress, timing, result, and any error information.
         * @example {
         *       "created_at": "2025-01-12T14:30:00Z",
         *       "export_format": "csv",
         *       "export_type": "events",
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "progress": {
         *         "current_step": "Processing events...",
         *         "estimated_completion": "2025-01-12T14:35:00Z",
         *         "processed_items": 245,
         *         "progress_percent": 20,
         *         "total_items": 1230
         *       },
         *       "started_at": "2025-01-12T14:30:01Z",
         *       "status": "running"
         *     }
         */
        ExportJobResponse: {
            /**
             * Completed At
             * @description Job completion timestamp
             */
            completed_at?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description Job creation timestamp
             */
            created_at: string;
            /**
             * Error Message
             * @description Error message (populated when failed)
             */
            error_message?: string | null;
            /**
             * Export Format
             * @description Export file format
             */
            export_format: string;
            /**
             * Export Type
             * @description Type of export
             */
            export_type: string;
            /**
             * Id
             * @description Unique export job identifier
             */
            id: string;
            /** @description Progress information */
            progress?: components["schemas"]["ExportJobProgress"];
            /** @description Export result (populated when completed) */
            result?: components["schemas"]["ExportJobResult"] | null;
            /**
             * Started At
             * @description Job start timestamp
             */
            started_at?: string | null;
            /** @description Current job status */
            status: components["schemas"]["ExportJobStatusEnum"];
        };
        /**
         * ExportJobResult
         * @description Schema for completed export job result.
         *
         *     Information about the completed export, including download path
         *     and file statistics.
         * @example {
         *       "event_count": 1230,
         *       "format": "csv",
         *       "output_path": "/api/exports/download/events_export_20250112_143000.csv",
         *       "output_size_bytes": 125432
         *     }
         */
        ExportJobResult: {
            /**
             * Event Count
             * @description Number of records exported
             * @default 0
             */
            event_count: number;
            /**
             * Format
             * @description Export format used
             */
            format: string;
            /**
             * Output Path
             * @description Download path for the exported file
             */
            output_path?: string | null;
            /**
             * Output Size Bytes
             * @description File size in bytes
             */
            output_size_bytes?: number | null;
        };
        /**
         * ExportJobStartResponse
         * @description Response when creating an export job.
         *
         *     Returns the job ID that can be used to track progress via
         *     GET /api/exports/{job_id}.
         * @example {
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Export job created. Use GET /api/exports/{job_id} to track progress.",
         *       "status": "pending"
         *     }
         */
        ExportJobStartResponse: {
            /**
             * Job Id
             * @description Unique job identifier for tracking progress
             */
            job_id: string;
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * @description Initial job status (always pending)
             * @default pending
             */
            status: components["schemas"]["ExportJobStatusEnum"];
        };
        /**
         * ExportJobStatusEnum
         * @description Export job status values.
         * @enum {string}
         */
        ExportJobStatusEnum: "pending" | "running" | "completed" | "failed";
        /**
         * ExportTypeEnum
         * @description Types of exports available.
         * @enum {string}
         */
        ExportTypeEnum: "events" | "alerts" | "full_backup";
        /**
         * ExporterStatus
         * @description Status information for a single Prometheus exporter.
         *
         *     Represents the health status of an exporter that provides metrics
         *     to Prometheus (e.g., redis-exporter, json-exporter, blackbox-exporter).
         * @example {
         *       "endpoint": "http://redis-exporter:9121",
         *       "last_scrape": "2026-01-13T10:30:00Z",
         *       "name": "redis-exporter",
         *       "status": "up"
         *     }
         */
        ExporterStatus: {
            /**
             * Endpoint
             * @description Scrape endpoint URL for this exporter
             */
            endpoint?: string | null;
            /**
             * Error
             * @description Error message if exporter is down
             */
            error?: string | null;
            /**
             * Last Scrape
             * @description Timestamp of last successful scrape (if available)
             */
            last_scrape?: string | null;
            /**
             * Name
             * @description Exporter name (e.g., 'redis-exporter', 'json-exporter')
             */
            name: string;
            /** @description Current status: up, down, or unknown */
            status: components["schemas"]["ExporterStatusEnum"];
        };
        /**
         * ExporterStatusEnum
         * @description Exporter status states.
         * @enum {string}
         */
        ExporterStatusEnum: "up" | "down" | "unknown";
        /**
         * FaceEnrichment
         * @description Face detection results.
         * @example {
         *       "confidence": 0.88,
         *       "count": 1,
         *       "detected": true
         *     }
         */
        FaceEnrichment: {
            /**
             * Confidence
             * @description Highest face confidence
             */
            confidence?: number | null;
            /**
             * Count
             * @description Number of faces detected
             * @default 0
             */
            count: number;
            /**
             * Detected
             * @description Whether faces were detected
             * @default false
             */
            detected: boolean;
        };
        /**
         * FeedbackStatsResponse
         * @description Schema for aggregate feedback statistics.
         *
         *     Returns counts of feedback by type and by camera to help
         *     calibrate the AI model's risk assessment.
         * @example {
         *       "by_camera": {
         *         "back_yard": 30,
         *         "front_door": 50,
         *         "garage": 20
         *       },
         *       "by_type": {
         *         "accurate": 10,
         *         "false_positive": 40,
         *         "missed_threat": 30,
         *         "severity_wrong": 20
         *       },
         *       "total_feedback": 100
         *     }
         */
        FeedbackStatsResponse: {
            /**
             * By Camera
             * @description Count of feedback entries grouped by camera ID
             */
            by_camera: {
                [key: string]: number;
            };
            /**
             * By Type
             * @description Count of feedback entries grouped by feedback type
             */
            by_type: {
                [key: string]: number;
            };
            /**
             * Total Feedback
             * @description Total number of feedback entries
             */
            total_feedback: number;
        };
        /**
         * FeedbackType
         * @description Types of feedback users can provide on events.
         *
         *     Values:
         *         ACCURATE: Event was correctly classified with appropriate severity
         *         FALSE_POSITIVE: Event was incorrectly flagged as concerning
         *         MISSED_THREAT: System failed to detect a concerning event
         *         SEVERITY_WRONG: Event was flagged but with incorrect severity level
         * @enum {string}
         */
        FeedbackType: "accurate" | "false_positive" | "missed_threat" | "severity_wrong";
        /**
         * FileWatcherStatusResponse
         * @description Status information for the FileWatcher service.
         * @example {
         *       "camera_root": "/export/foscam",
         *       "observer_type": "native",
         *       "pending_tasks": 3,
         *       "running": true
         *     }
         */
        FileWatcherStatusResponse: {
            /**
             * Camera Root
             * @description Root directory being watched for camera uploads
             */
            camera_root: string;
            /**
             * Observer Type
             * @description Type of filesystem observer (native or polling)
             */
            observer_type: string;
            /**
             * Pending Tasks
             * @description Number of files pending processing (debouncing)
             */
            pending_tasks: number;
            /**
             * Running
             * @description Whether the file watcher is currently running
             */
            running: boolean;
        };
        /**
         * FrontendLogCreate
         * @description Schema for frontend log submission.
         * @example {
         *       "component": "RiskGauge",
         *       "extra": {
         *         "last_error": "Connection refused",
         *         "reconnect_attempts": 3
         *       },
         *       "level": "ERROR",
         *       "message": "WebSocket connection lost",
         *       "url": "https://localhost:5173/dashboard",
         *       "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0"
         *     }
         */
        FrontendLogCreate: {
            /**
             * Component
             * @description Frontend component name (e.g., 'RiskGauge', 'CameraGrid')
             */
            component: string;
            /**
             * Extra
             * @description Additional context (JSON-serializable)
             */
            extra?: {
                [key: string]: unknown;
            } | null;
            /**
             * Level
             * @description Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
             */
            level: string;
            /**
             * Message
             * @description Log message content
             */
            message: string;
            /**
             * Url
             * @description Page URL where log occurred
             */
            url?: string | null;
            /**
             * User Agent
             * @description Browser user agent string
             */
            user_agent?: string | null;
        };
        /**
         * FullHealthResponse
         * @description Comprehensive health check response for GET /api/system/health/full.
         *
         *     Aggregates health status from all services:
         *     - Infrastructure (postgres, redis)
         *     - AI services (rtdetr, nemotron, florence, clip, enrichment)
         *     - Circuit breakers
         *     - Background workers
         *
         *     HTTP Status Codes:
         *     - 200: System is healthy or degraded (can still serve traffic)
         *     - 503: Critical services are unhealthy (should not receive traffic)
         * @example {
         *       "ai_services": [
         *         {
         *           "circuit_state": "closed",
         *           "display_name": "RT-DETRv2 Object Detection",
         *           "last_check": "2026-01-08T10:30:00Z",
         *           "name": "rtdetr",
         *           "response_time_ms": 45.2,
         *           "status": "healthy",
         *           "url": "http://ai-detector:8090"
         *         }
         *       ],
         *       "circuit_breakers": {
         *         "breakers": {
         *           "nemotron": "closed",
         *           "rtdetr": "closed"
         *         },
         *         "closed": 5,
         *         "half_open": 0,
         *         "open": 0,
         *         "total": 5
         *       },
         *       "message": "All systems operational",
         *       "postgres": {
         *         "message": "Database operational",
         *         "name": "postgres",
         *         "status": "healthy"
         *       },
         *       "ready": true,
         *       "redis": {
         *         "details": {
         *           "redis_version": "7.4.0"
         *         },
         *         "message": "Redis connected",
         *         "name": "redis",
         *         "status": "healthy"
         *       },
         *       "status": "healthy",
         *       "timestamp": "2026-01-08T10:30:00Z",
         *       "version": "0.1.0",
         *       "workers": [
         *         {
         *           "critical": true,
         *           "name": "file_watcher",
         *           "running": true
         *         }
         *       ]
         *     }
         */
        FullHealthResponse: {
            /**
             * Ai Services
             * @description Health status of all AI services
             */
            ai_services: components["schemas"]["AIServiceHealthStatus"][];
            /** @description Circuit breaker summary */
            circuit_breakers: components["schemas"]["CircuitBreakerSummary"];
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /** @description PostgreSQL health status */
            postgres: components["schemas"]["InfrastructureHealthStatus"];
            /**
             * Ready
             * @description Whether system is ready to receive traffic
             */
            ready: boolean;
            /** @description Redis health status */
            redis: components["schemas"]["InfrastructureHealthStatus"];
            /** @description Overall system health status */
            status: components["schemas"]["ServiceHealthState"];
            /**
             * Timestamp
             * Format: date-time
             * @description Response timestamp
             */
            timestamp: string;
            /**
             * Version
             * @description Application version
             */
            version: string;
            /**
             * Workers
             * @description Background worker statuses
             */
            workers: components["schemas"]["WorkerHealthStatus"][];
        };
        /**
         * GPUStatsHistoryResponse
         * @description Response schema for GPU stats history endpoint.
         *
         *     Uses standard pagination envelope format (NEM-2178):
         *     - items: GPU stats samples (renamed from 'samples')
         *     - pagination: Standard pagination metadata
         * @example {
         *       "items": [
         *         {
         *           "gpu_name": "NVIDIA RTX A5500",
         *           "inference_fps": 30.5,
         *           "memory_total": 24000,
         *           "memory_used": 12000,
         *           "power_usage": 150,
         *           "recorded_at": "2025-12-27T10:30:00Z",
         *           "temperature": 65,
         *           "utilization": 75.5
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 300,
         *         "total": 1
         *       }
         *     }
         */
        GPUStatsHistoryResponse: {
            /**
             * Items
             * @description GPU stats samples (chronological order)
             */
            items: components["schemas"]["GPUStatsSample"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * GPUStatsResponse
         * @description Response schema for GPU statistics endpoint.
         * @example {
         *       "gpu_name": "NVIDIA RTX A5500",
         *       "inference_fps": 30.5,
         *       "memory_total": 24000,
         *       "memory_used": 12000,
         *       "power_usage": 150,
         *       "temperature": 65,
         *       "utilization": 75.5
         *     }
         */
        GPUStatsResponse: {
            /**
             * Gpu Name
             * @description GPU device name (e.g., 'NVIDIA RTX A5500')
             */
            gpu_name?: string | null;
            /**
             * Inference Fps
             * @description Inference frames per second
             */
            inference_fps?: number | null;
            /**
             * Memory Total
             * @description Total GPU memory in MB
             */
            memory_total?: number | null;
            /**
             * Memory Used
             * @description GPU memory used in MB
             */
            memory_used?: number | null;
            /**
             * Power Usage
             * @description GPU power usage in watts
             */
            power_usage?: number | null;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature?: number | null;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization?: number | null;
        };
        /**
         * GPUStatsSample
         * @description Single time-series sample of GPU statistics.
         */
        GPUStatsSample: {
            /**
             * Gpu Name
             * @description GPU device name
             */
            gpu_name?: string | null;
            /**
             * Inference Fps
             * @description Inference frames per second
             */
            inference_fps?: number | null;
            /**
             * Memory Total
             * @description Total GPU memory in MB
             */
            memory_total?: number | null;
            /**
             * Memory Used
             * @description GPU memory used in MB
             */
            memory_used?: number | null;
            /**
             * Power Usage
             * @description GPU power usage in watts
             */
            power_usage?: number | null;
            /**
             * Recorded At
             * Format: date-time
             * @description When the GPU sample was recorded (UTC)
             */
            recorded_at: string;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature?: number | null;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization?: number | null;
        };
        /**
         * GpuMetrics
         * @description GPU metrics from nvidia-smi / pynvml.
         * @example {
         *       "name": "NVIDIA RTX A5500",
         *       "power_watts": 31,
         *       "temperature": 38,
         *       "utilization": 38,
         *       "vram_total_gb": 24,
         *       "vram_used_gb": 22.7
         *     }
         */
        GpuMetrics: {
            /**
             * Name
             * @description GPU device name (e.g., 'NVIDIA RTX A5500')
             */
            name: string;
            /**
             * Power Watts
             * @description GPU power usage in Watts
             */
            power_watts: number;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature: number;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization: number;
            /**
             * Vram Total Gb
             * @description Total VRAM in GB
             */
            vram_total_gb: number;
            /**
             * Vram Used Gb
             * @description VRAM used in GB
             */
            vram_used_gb: number;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * HealthCheckServiceStatus
         * @description Status information for a service component in health checks.
         *
         *     Note: Renamed from ServiceStatus to avoid name collision with
         *     backend.api.schemas.services.ServiceStatus (orchestrator enum).
         */
        HealthCheckServiceStatus: {
            /**
             * Details
             * @description Additional service-specific details (may contain nested objects)
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
            /**
             * Status
             * @description Service status: healthy, unhealthy, or not_initialized
             */
            status: string;
        };
        /**
         * HealthEventResponse
         * @description Schema for a health event in the failure history.
         *
         *     Represents a single health-related event such as a failure, recovery, or restart.
         * @example {
         *       "event_type": "failure",
         *       "message": "Health check failed: connection refused",
         *       "service": "redis",
         *       "timestamp": "2025-12-23T10:30:00Z"
         *     }
         */
        HealthEventResponse: {
            /**
             * Event Type
             * @description Type of event: 'failure', 'recovery', or 'restart'
             */
            event_type: string;
            /**
             * Message
             * @description Optional descriptive message about the event
             */
            message?: string | null;
            /**
             * Service
             * @description Name of the service this event relates to
             */
            service: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the event occurred (UTC)
             */
            timestamp: string;
        };
        /**
         * HealthResponse
         * @description Response schema for health check endpoint.
         * @example {
         *       "recent_events": [
         *         {
         *           "event_type": "recovery",
         *           "message": "Service recovered",
         *           "service": "redis",
         *           "timestamp": "2025-12-23T10:25:00Z"
         *         },
         *         {
         *           "event_type": "failure",
         *           "message": "Health check failed",
         *           "service": "redis",
         *           "timestamp": "2025-12-23T10:20:00Z"
         *         }
         *       ],
         *       "services": {
         *         "ai": {
         *           "message": "AI services operational",
         *           "status": "healthy"
         *         },
         *         "database": {
         *           "message": "Database operational",
         *           "status": "healthy"
         *         },
         *         "redis": {
         *           "details": {
         *             "redis_version": "7.0.0"
         *           },
         *           "message": "Redis connected",
         *           "status": "healthy"
         *         }
         *       },
         *       "status": "healthy",
         *       "timestamp": "2025-12-23T10:30:00"
         *     }
         */
        HealthResponse: {
            /**
             * Recent Events
             * @description Recent health events for debugging intermittent issues
             */
            recent_events?: components["schemas"]["HealthEventResponse"][];
            /**
             * Services
             * @description Status of individual services (database, redis, ai)
             */
            services: {
                [key: string]: components["schemas"]["HealthCheckServiceStatus"];
            };
            /**
             * Status
             * @description Overall system status: healthy, degraded, or unhealthy
             */
            status: string;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of health check
             */
            timestamp: string;
        };
        /**
         * HostMetrics
         * @description Host system metrics from psutil.
         * @example {
         *       "cpu_percent": 12,
         *       "disk_total_gb": 500,
         *       "disk_used_gb": 156,
         *       "ram_total_gb": 32,
         *       "ram_used_gb": 8.2
         *     }
         */
        HostMetrics: {
            /**
             * Cpu Percent
             * @description CPU utilization percentage
             */
            cpu_percent: number;
            /**
             * Disk Total Gb
             * @description Total disk in GB
             */
            disk_total_gb: number;
            /**
             * Disk Used Gb
             * @description Disk used in GB
             */
            disk_used_gb: number;
            /**
             * Ram Total Gb
             * @description Total RAM in GB
             */
            ram_total_gb: number;
            /**
             * Ram Used Gb
             * @description RAM used in GB
             */
            ram_used_gb: number;
        };
        /**
         * HourlyPattern
         * @description Activity pattern for a specific hour.
         * @example {
         *       "avg_detections": 2.5,
         *       "sample_count": 30,
         *       "std_dev": 0.8
         *     }
         */
        HourlyPattern: {
            /**
             * Avg Detections
             * @description Average number of detections during this hour
             */
            avg_detections: number;
            /**
             * Sample Count
             * @description Number of samples used for this calculation
             */
            sample_count: number;
            /**
             * Std Dev
             * @description Standard deviation of detection count
             */
            std_dev: number;
        };
        /**
         * ImageQualityEnrichment
         * @description Image quality assessment results.
         * @example {
         *       "is_blurry": false,
         *       "is_low_quality": false,
         *       "quality_issues": [],
         *       "score": 0.85
         *     }
         */
        ImageQualityEnrichment: {
            /**
             * Is Blurry
             * @description Whether image is blurry
             */
            is_blurry?: boolean | null;
            /**
             * Is Low Quality
             * @description Whether image has low quality
             */
            is_low_quality?: boolean | null;
            /**
             * Quality Change Detected
             * @description Whether sudden quality change was detected
             */
            quality_change_detected?: boolean | null;
            /**
             * Quality Issues
             * @description List of detected quality issues
             */
            quality_issues?: string[] | null;
            /**
             * Score
             * @description Quality score (0-100)
             */
            score?: number | null;
        };
        /**
         * InferenceMetrics
         * @description AI inference latency and throughput metrics.
         * @example {
         *       "nemotron_latency_ms": {
         *         "avg": 2100,
         *         "p95": 4800,
         *         "p99": 8200
         *       },
         *       "pipeline_latency_ms": {
         *         "avg": 3200,
         *         "p95": 6100
         *       },
         *       "queues": {
         *         "analysis": 0,
         *         "detection": 0
         *       },
         *       "rtdetr_latency_ms": {
         *         "avg": 45,
         *         "p95": 82,
         *         "p99": 120
         *       },
         *       "throughput": {
         *         "events_per_min": 2.1,
         *         "images_per_min": 12.4
         *       }
         *     }
         */
        InferenceMetrics: {
            /**
             * Nemotron Latency Ms
             * @description Nemotron latency stats (avg, p95, p99)
             */
            nemotron_latency_ms: {
                [key: string]: number;
            };
            /**
             * Pipeline Latency Ms
             * @description Full pipeline latency stats (avg, p95)
             */
            pipeline_latency_ms: {
                [key: string]: number;
            };
            /**
             * Queues
             * @description Queue depths (detection, analysis)
             */
            queues: {
                [key: string]: number;
            };
            /**
             * Rtdetr Latency Ms
             * @description RT-DETRv2 latency stats (avg, p95, p99)
             */
            rtdetr_latency_ms: {
                [key: string]: number;
            };
            /**
             * Throughput
             * @description Throughput metrics (images_per_min, events_per_min)
             */
            throughput: {
                [key: string]: number;
            };
        };
        /**
         * InfrastructureHealthStatus
         * @description Health status for infrastructure services (postgres, redis).
         *
         *     Provides detailed status including connection info and any error details.
         * @example {
         *       "message": "Database operational",
         *       "name": "postgres",
         *       "status": "healthy"
         *     }
         */
        InfrastructureHealthStatus: {
            /**
             * Details
             * @description Additional details (e.g., redis version)
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * Message
             * @description Status message or error description
             */
            message: string;
            /**
             * Name
             * @description Service name (e.g., 'postgres', 'redis')
             */
            name: string;
            /** @description Current health state */
            status: components["schemas"]["ServiceHealthState"];
        };
        /**
         * JobAbortResponse
         * @description Response model for job abort request.
         * @example {
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Job abort requested - worker notified",
         *       "status": "failed"
         *     }
         */
        JobAbortResponse: {
            /**
             * Job Id
             * @description Job ID that is being aborted
             */
            job_id: string;
            /**
             * Message
             * @description Abort status message
             */
            message: string;
            /** @description New job status (aborting/failed) */
            status: components["schemas"]["JobStatusEnum"];
        };
        /**
         * JobAttemptResponse
         * @description A single job execution attempt record.
         * @example {
         *       "attempt_number": 1,
         *       "duration_seconds": 89,
         *       "ended_at": "2024-01-15T10:31:30Z",
         *       "result": {
         *         "processed": 1000
         *       },
         *       "started_at": "2024-01-15T10:30:01Z",
         *       "status": "succeeded",
         *       "worker_id": "worker-1"
         *     }
         */
        JobAttemptResponse: {
            /**
             * Attempt Number
             * @description Sequential attempt number (1-based)
             */
            attempt_number: number;
            /**
             * Duration Seconds
             * @description Duration in seconds if completed
             */
            duration_seconds?: number | null;
            /**
             * Ended At
             * @description When this attempt ended
             */
            ended_at?: string | null;
            /**
             * Error
             * @description Error message if failed
             */
            error?: string | null;
            /**
             * Result
             * @description Result data if successful
             */
            result?: {
                [key: string]: unknown;
            } | null;
            /**
             * Started At
             * Format: date-time
             * @description When this attempt started
             */
            started_at: string;
            /**
             * Status
             * @description Status of this attempt (started, succeeded, failed, cancelled)
             */
            status: string;
            /**
             * Worker Id
             * @description ID of worker that processed this attempt
             */
            worker_id?: string | null;
        };
        /**
         * JobCancelResponse
         * @description Response model for job cancellation request.
         * @example {
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Job cancellation requested",
         *       "status": "failed"
         *     }
         */
        JobCancelResponse: {
            /**
             * Job Id
             * @description Job ID that was cancelled
             */
            job_id: string;
            /**
             * Message
             * @description Cancellation status message
             */
            message: string;
            /** @description New job status after cancellation */
            status: components["schemas"]["JobStatusEnum"];
        };
        /**
         * JobDetailResponse
         * @description Detailed response model for a single job.
         *
         *     Provides comprehensive information about a job including progress details,
         *     timing information, retry status, and execution metadata.
         *
         *     NEM-2390: GET /api/jobs/{job_id} detail endpoint response.
         * @example {
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "job_type": "ai_analysis",
         *       "metadata": {
         *         "input_params": {
         *           "event_ids": [
         *             "evt-1",
         *             "evt-2"
         *           ]
         *         },
         *         "worker_id": "worker-001"
         *       },
         *       "priority": 1,
         *       "progress": {
         *         "current_step": "Analyzing detections",
         *         "items_processed": 450,
         *         "items_total": 1000,
         *         "percent": 45
         *       },
         *       "queue_name": "high_priority",
         *       "retry_info": {
         *         "attempt_number": 1,
         *         "max_attempts": 3,
         *         "previous_errors": []
         *       },
         *       "status": "running",
         *       "timing": {
         *         "created_at": "2024-01-15T10:30:00Z",
         *         "duration_seconds": 45.5,
         *         "estimated_remaining_seconds": 55,
         *         "started_at": "2024-01-15T10:30:01Z"
         *       }
         *     }
         */
        JobDetailResponse: {
            /**
             * Error
             * @description Error message (if failed)
             */
            error?: string | null;
            /**
             * Id
             * @description Unique job identifier
             */
            id: string;
            /**
             * Job Type
             * @description Type of job (e.g., 'export', 'ai_analysis')
             */
            job_type: string;
            /** @description Job execution metadata */
            metadata: components["schemas"]["JobMetadata"];
            /**
             * Priority
             * @description Job priority (0=lowest, 10=highest)
             * @default 0
             */
            priority: number;
            /** @description Detailed progress information */
            progress: components["schemas"]["JobProgressDetail"];
            /**
             * Queue Name
             * @description Name of the job queue
             */
            queue_name?: string | null;
            /**
             * Result
             * @description Job result data (if completed)
             */
            result?: unknown | null;
            /** @description Retry attempt information */
            retry_info: components["schemas"]["JobRetryInfo"];
            /** @description Current job status */
            status: components["schemas"]["JobStatusEnum"];
            /** @description Job timing and duration information */
            timing: components["schemas"]["JobTiming"];
        };
        /**
         * JobHistoryResponse
         * @description Complete job history with transitions and attempts.
         *
         *     NEM-2396: GET /api/jobs/{job_id}/history endpoint response.
         * @example {
         *       "attempts": [
         *         {
         *           "attempt_number": 1,
         *           "duration_seconds": 89,
         *           "ended_at": "2024-01-15T10:31:30Z",
         *           "result": {
         *             "events_exported": 1000
         *           },
         *           "started_at": "2024-01-15T10:30:01Z",
         *           "status": "succeeded",
         *           "worker_id": "worker-1"
         *         }
         *       ],
         *       "completed_at": "2024-01-15T10:31:30Z",
         *       "created_at": "2024-01-15T10:30:00Z",
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "job_type": "export",
         *       "started_at": "2024-01-15T10:30:01Z",
         *       "status": "completed",
         *       "transitions": [
         *         {
         *           "at": "2024-01-15T10:30:00Z",
         *           "to": "queued",
         *           "triggered_by": "api"
         *         },
         *         {
         *           "at": "2024-01-15T10:30:01Z",
         *           "details": {
         *             "worker_id": "worker-1"
         *           },
         *           "from": "queued",
         *           "to": "running",
         *           "triggered_by": "worker"
         *         },
         *         {
         *           "at": "2024-01-15T10:31:30Z",
         *           "from": "running",
         *           "to": "completed",
         *           "triggered_by": "worker"
         *         }
         *       ]
         *     }
         */
        JobHistoryResponse: {
            /**
             * Attempts
             * @description Execution attempts in order
             */
            attempts?: components["schemas"]["JobAttemptResponse"][];
            /**
             * Completed At
             * @description When the job finished
             */
            completed_at?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description When the job was created
             */
            created_at: string;
            /**
             * Job Id
             * @description Unique job identifier
             */
            job_id: string;
            /**
             * Job Type
             * @description Type of job (e.g., 'export', 'cleanup')
             */
            job_type: string;
            /**
             * Started At
             * @description When job execution started
             */
            started_at?: string | null;
            /**
             * Status
             * @description Current job status
             */
            status: string;
            /**
             * Transitions
             * @description State transitions in chronological order
             */
            transitions?: components["schemas"]["JobTransitionResponse"][];
        };
        /**
         * JobListResponse
         * @description Response model for listing jobs with pagination.
         *
         *     Uses the standardized pagination envelope format (NEM-2178).
         * @example {
         *       "items": [
         *         {
         *           "created_at": "2024-01-15T10:30:00Z",
         *           "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *           "job_type": "export",
         *           "message": "Exporting events: 450/1000",
         *           "progress": 45,
         *           "started_at": "2024-01-15T10:30:01Z",
         *           "status": "running"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": true,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 100
         *       }
         *     }
         */
        JobListResponse: {
            /**
             * Items
             * @description List of jobs
             */
            items: components["schemas"]["JobResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * JobLogEntryResponse
         * @description A single job log entry.
         * @example {
         *       "attempt_number": 1,
         *       "context": {
         *         "event_count": 1000
         *       },
         *       "level": "INFO",
         *       "message": "Starting export of 1000 events",
         *       "timestamp": "2024-01-15T10:30:05Z"
         *     }
         */
        JobLogEntryResponse: {
            /**
             * Attempt Number
             * @description Which attempt generated this log
             * @default 1
             */
            attempt_number: number;
            /**
             * Context
             * @description Additional context data
             */
            context?: {
                [key: string]: unknown;
            } | null;
            /**
             * Level
             * @description Log level (DEBUG, INFO, WARNING, ERROR)
             */
            level: string;
            /**
             * Message
             * @description Log message
             */
            message: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the log entry was created
             */
            timestamp: string;
        };
        /**
         * JobLogsResponse
         * @description Response for job logs endpoint.
         *
         *     NEM-2396: GET /api/jobs/{job_id}/logs endpoint response.
         * @example {
         *       "has_more": false,
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "logs": [
         *         {
         *           "attempt_number": 1,
         *           "level": "INFO",
         *           "message": "Job started",
         *           "timestamp": "2024-01-15T10:30:01Z"
         *         },
         *         {
         *           "attempt_number": 1,
         *           "context": {
         *             "progress": 0
         *           },
         *           "level": "INFO",
         *           "message": "Processing events: 0/1000",
         *           "timestamp": "2024-01-15T10:30:05Z"
         *         },
         *         {
         *           "attempt_number": 1,
         *           "context": {
         *             "events_exported": 1000
         *           },
         *           "level": "INFO",
         *           "message": "Export completed successfully",
         *           "timestamp": "2024-01-15T10:31:30Z"
         *         }
         *       ],
         *       "total": 3
         *     }
         */
        JobLogsResponse: {
            /**
             * Has More
             * @description Whether more logs exist beyond the limit
             * @default false
             */
            has_more: boolean;
            /**
             * Job Id
             * @description Unique job identifier
             */
            job_id: string;
            /**
             * Logs
             * @description Log entries in chronological order
             */
            logs?: components["schemas"]["JobLogEntryResponse"][];
            /**
             * Total
             * @description Total number of log entries returned
             */
            total: number;
        };
        /**
         * JobMetadata
         * @description Metadata about job execution.
         *
         *     Contains input parameters and execution context.
         * @example {
         *       "input_params": {
         *         "camera_id": "cam-1",
         *         "format": "csv"
         *       },
         *       "worker_id": "worker-abc-123"
         *     }
         */
        JobMetadata: {
            /**
             * Input Params
             * @description Input parameters provided when job was created
             */
            input_params?: {
                [key: string]: unknown;
            } | null;
            /**
             * Worker Id
             * @description ID of the worker executing the job
             */
            worker_id?: string | null;
        };
        /**
         * JobProgressDetail
         * @description Detailed progress information for a job.
         *
         *     Provides granular progress tracking beyond a simple percentage.
         * @example {
         *       "current_step": "Processing events",
         *       "items_processed": 450,
         *       "items_total": 1000,
         *       "percent": 45
         *     }
         */
        JobProgressDetail: {
            /**
             * Current Step
             * @description Current processing step description
             */
            current_step?: string | null;
            /**
             * Items Processed
             * @description Number of items processed so far
             */
            items_processed?: number | null;
            /**
             * Items Total
             * @description Total number of items to process
             */
            items_total?: number | null;
            /**
             * Percent
             * @description Progress percentage (0-100)
             */
            percent: number;
        };
        /**
         * JobResponse
         * @description Response model for job status.
         * @example {
         *       "created_at": "2024-01-15T10:30:00Z",
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "job_type": "export",
         *       "message": "Exporting events: 450/1000",
         *       "progress": 45,
         *       "started_at": "2024-01-15T10:30:01Z",
         *       "status": "running"
         *     }
         */
        JobResponse: {
            /**
             * Completed At
             * @description ISO 8601 timestamp when job finished
             */
            completed_at?: string | null;
            /**
             * Created At
             * @description ISO 8601 timestamp when job was created
             */
            created_at: string;
            /**
             * Error
             * @description Error message (if failed)
             */
            error?: string | null;
            /**
             * Job Id
             * @description Unique job identifier
             */
            job_id: string;
            /**
             * Job Type
             * @description Type of job (e.g., 'export')
             */
            job_type: string;
            /**
             * Message
             * @description Human-readable status message
             */
            message?: string | null;
            /**
             * Progress
             * @description Progress percentage (0-100)
             */
            progress: number;
            /**
             * Result
             * @description Job result data (if completed)
             */
            result?: unknown | null;
            /**
             * Started At
             * @description ISO 8601 timestamp when job started
             */
            started_at?: string | null;
            /** @description Current job status */
            status: components["schemas"]["JobStatusEnum"];
        };
        /**
         * JobRetryInfo
         * @description Retry information for a job.
         *
         *     Tracks retry attempts and failure history.
         * @example {
         *       "attempt_number": 2,
         *       "max_attempts": 3,
         *       "next_retry_at": "2024-01-15T10:35:00Z",
         *       "previous_errors": [
         *         "Connection timeout"
         *       ]
         *     }
         */
        JobRetryInfo: {
            /**
             * Attempt Number
             * @description Current attempt number (1-indexed)
             */
            attempt_number: number;
            /**
             * Max Attempts
             * @description Maximum number of retry attempts allowed
             */
            max_attempts: number;
            /**
             * Next Retry At
             * @description When the next retry will occur (if applicable)
             */
            next_retry_at?: string | null;
            /**
             * Previous Errors
             * @description List of error messages from previous attempts
             */
            previous_errors?: string[];
        };
        /**
         * JobSearchAggregations
         * @description Aggregation counts for job search results.
         * @example {
         *       "by_status": {
         *         "completed": 100,
         *         "failed": 35,
         *         "pending": 10,
         *         "running": 5
         *       },
         *       "by_type": {
         *         "ai_analysis": 120,
         *         "cleanup": 10,
         *         "export": 20
         *       }
         *     }
         */
        JobSearchAggregations: {
            /**
             * By Status
             * @description Count of matching jobs by status
             */
            by_status?: {
                [key: string]: number;
            };
            /**
             * By Type
             * @description Count of matching jobs by job type
             */
            by_type?: {
                [key: string]: number;
            };
        };
        /**
         * JobSearchResponse
         * @description Response model for job search with aggregations.
         *
         *     Extends the standard list response with aggregation data for faceted search.
         *
         *     NEM-2392: GET /api/jobs/search endpoint response.
         * @example {
         *       "aggregations": {
         *         "by_status": {
         *           "completed": 100,
         *           "failed": 35,
         *           "pending": 10,
         *           "running": 5
         *         },
         *         "by_type": {
         *           "backup": 10,
         *           "cleanup": 20,
         *           "export": 120
         *         }
         *       },
         *       "data": [
         *         {
         *           "completed_at": "2024-01-15T10:31:30Z",
         *           "created_at": "2024-01-15T10:30:00Z",
         *           "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *           "job_type": "export",
         *           "message": "Export completed successfully",
         *           "progress": 100,
         *           "result": {
         *             "file_path": "/exports/data.csv"
         *           },
         *           "started_at": "2024-01-15T10:30:01Z",
         *           "status": "completed"
         *         }
         *       ],
         *       "meta": {
         *         "has_more": true,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 150
         *       }
         *     }
         */
        JobSearchResponse: {
            /** @description Aggregation counts for faceted filtering */
            aggregations: components["schemas"]["JobSearchAggregations"];
            /**
             * Data
             * @description List of matching jobs
             */
            data: components["schemas"]["JobResponse"][];
            /** @description Pagination metadata */
            meta: components["schemas"]["PaginationMeta"];
        };
        /**
         * JobStatsResponse
         * @description Response model for job statistics.
         *
         *     Provides aggregate statistics about jobs including counts by status,
         *     counts by type, and timing information.
         * @example {
         *       "average_duration_seconds": 45.5,
         *       "by_status": [
         *         {
         *           "count": 75,
         *           "status": "completed"
         *         },
         *         {
         *           "count": 5,
         *           "status": "running"
         *         },
         *         {
         *           "count": 10,
         *           "status": "pending"
         *         },
         *         {
         *           "count": 10,
         *           "status": "failed"
         *         }
         *       ],
         *       "by_type": [
         *         {
         *           "count": 60,
         *           "job_type": "export"
         *         },
         *         {
         *           "count": 30,
         *           "job_type": "cleanup"
         *         },
         *         {
         *           "count": 10,
         *           "job_type": "backup"
         *         }
         *       ],
         *       "oldest_pending_job_age_seconds": 120,
         *       "total_jobs": 100
         *     }
         */
        JobStatsResponse: {
            /**
             * Average Duration Seconds
             * @description Average job duration in seconds (for completed jobs)
             */
            average_duration_seconds?: number | null;
            /**
             * By Status
             * @description Job counts by status
             */
            by_status: components["schemas"]["JobStatusCount"][];
            /**
             * By Type
             * @description Job counts by type
             */
            by_type: components["schemas"]["JobTypeCount"][];
            /**
             * Oldest Pending Job Age Seconds
             * @description Age of the oldest pending job in seconds
             */
            oldest_pending_job_age_seconds?: number | null;
            /**
             * Total Jobs
             * @description Total number of jobs tracked
             */
            total_jobs: number;
        };
        /**
         * JobStatusCount
         * @description Count of jobs by status.
         * @example {
         *       "count": 42,
         *       "status": "completed"
         *     }
         */
        JobStatusCount: {
            /**
             * Count
             * @description Number of jobs with this status
             */
            count: number;
            /** @description Job status */
            status: components["schemas"]["JobStatusEnum"];
        };
        /**
         * JobStatusEnum
         * @description Status of a background job.
         * @enum {string}
         */
        JobStatusEnum: "pending" | "running" | "completed" | "failed";
        /**
         * JobTargetSummary
         * @description Summary of target health for a specific Prometheus job.
         * @example {
         *       "down": 0,
         *       "job": "hsi-backend-metrics",
         *       "total": 1,
         *       "unknown": 0,
         *       "up": 1
         *     }
         */
        JobTargetSummary: {
            /**
             * Down
             * @description Number of targets that are down
             */
            down: number;
            /**
             * Job
             * @description Prometheus job name
             */
            job: string;
            /**
             * Total
             * @description Total number of targets in this job
             */
            total: number;
            /**
             * Unknown
             * @description Number of targets with unknown status
             * @default 0
             */
            unknown: number;
            /**
             * Up
             * @description Number of targets that are up
             */
            up: number;
        };
        /**
         * JobTiming
         * @description Timing information for a job.
         *
         *     Tracks job lifecycle timestamps and duration calculations.
         * @example {
         *       "created_at": "2024-01-15T10:30:00Z",
         *       "duration_seconds": 45.5,
         *       "estimated_remaining_seconds": 55,
         *       "started_at": "2024-01-15T10:30:01Z"
         *     }
         */
        JobTiming: {
            /**
             * Completed At
             * @description When the job completed or failed
             */
            completed_at?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description When the job was created
             */
            created_at: string;
            /**
             * Duration Seconds
             * @description Total duration in seconds (if started)
             */
            duration_seconds?: number | null;
            /**
             * Estimated Remaining Seconds
             * @description Estimated time remaining (if running)
             */
            estimated_remaining_seconds?: number | null;
            /**
             * Started At
             * @description When job execution started
             */
            started_at?: string | null;
        };
        /**
         * JobTransitionResponse
         * @description A single state transition record in job history.
         * @example {
         *       "at": "2024-01-15T10:30:00Z",
         *       "details": {
         *         "user": "system"
         *       },
         *       "to": "queued",
         *       "triggered_by": "api"
         *     }
         */
        JobTransitionResponse: {
            /**
             * At
             * Format: date-time
             * @description Timestamp of the transition
             */
            at: string;
            /**
             * Details
             * @description Additional transition details
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * From
             * @description Previous status (null for initial)
             */
            from?: string | null;
            /**
             * To
             * @description New status after transition
             */
            to: string;
            /**
             * Triggered By
             * @description What triggered the transition (api, worker, system, etc)
             */
            triggered_by: string;
        };
        /**
         * JobTypeCount
         * @description Count of jobs by type.
         * @example {
         *       "count": 25,
         *       "job_type": "export"
         *     }
         */
        JobTypeCount: {
            /**
             * Count
             * @description Number of jobs of this type
             */
            count: number;
            /**
             * Job Type
             * @description Job type name
             */
            job_type: string;
        };
        /**
         * JobTypeInfo
         * @description Information about a job type.
         * @example {
         *       "description": "Export events to CSV, JSON, or ZIP format",
         *       "name": "export"
         *     }
         */
        JobTypeInfo: {
            /**
             * Description
             * @description Human-readable description of the job type
             */
            description: string;
            /**
             * Name
             * @description Job type name (e.g., 'export', 'cleanup')
             */
            name: string;
        };
        /**
         * JobTypesResponse
         * @description Response model for listing job types.
         * @example {
         *       "job_types": [
         *         {
         *           "description": "Export events to CSV, JSON, or ZIP format",
         *           "name": "export"
         *         },
         *         {
         *           "description": "Clean up old data and temporary files",
         *           "name": "cleanup"
         *         }
         *       ]
         *     }
         */
        JobTypesResponse: {
            /**
             * Job Types
             * @description List of available job types
             */
            job_types: components["schemas"]["JobTypeInfo"][];
        };
        /**
         * LatencyHistorySnapshot
         * @description Single time-bucket snapshot of pipeline latency metrics.
         */
        LatencyHistorySnapshot: {
            /**
             * Stages
             * @description Latency stats for each pipeline stage (None if no samples)
             */
            stages: {
                [key: string]: components["schemas"]["LatencyHistoryStageStats"] | null;
            };
            /**
             * Timestamp
             * @description Bucket start time (ISO format)
             */
            timestamp: string;
        };
        /**
         * LatencyHistoryStageStats
         * @description Latency statistics for a single stage in a history snapshot.
         */
        LatencyHistoryStageStats: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms: number;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency
             */
            p50_ms: number;
            /**
             * P95 Ms
             * @description 95th percentile latency
             */
            p95_ms: number;
            /**
             * P99 Ms
             * @description 99th percentile latency
             */
            p99_ms: number;
            /**
             * Sample Count
             * @description Number of samples in this bucket
             */
            sample_count: number;
        };
        /**
         * LeaderboardResponse
         * @description Model leaderboard response.
         * @example {
         *       "entries": [
         *         {
         *           "contribution_rate": 0.98,
         *           "event_count": 1200,
         *           "model_name": "rtdetr",
         *           "quality_correlation": 0.85
         *         },
         *         {
         *           "contribution_rate": 0.85,
         *           "event_count": 1050,
         *           "model_name": "florence",
         *           "quality_correlation": 0.72
         *         }
         *       ],
         *       "period_days": 30
         *     }
         */
        LeaderboardResponse: {
            /** Entries */
            entries: components["schemas"]["ModelLeaderboardEntry"][];
            /** Period Days */
            period_days: number;
        };
        /**
         * LicensePlateEnrichment
         * @description License plate detection and OCR results.
         * @example {
         *       "bbox": [
         *         100,
         *         200,
         *         300,
         *         250
         *       ],
         *       "confidence": 0.92,
         *       "detected": true,
         *       "ocr_confidence": 0.88,
         *       "text": "ABC-1234"
         *     }
         */
        LicensePlateEnrichment: {
            /**
             * Bbox
             * @description Bounding box [x1, y1, x2, y2]
             */
            bbox?: number[] | null;
            /**
             * Confidence
             * @description Detection confidence
             */
            confidence?: number | null;
            /**
             * Detected
             * @description Whether a license plate was detected
             * @default false
             */
            detected: boolean;
            /**
             * Ocr Confidence
             * @description OCR confidence
             */
            ocr_confidence?: number | null;
            /**
             * Text
             * @description OCR-extracted plate text
             */
            text?: string | null;
        };
        /**
         * LogEntry
         * @description Schema for a single log entry.
         * @example {
         *       "camera_id": "front_door",
         *       "component": "backend.services.detector",
         *       "detection_id": 456,
         *       "duration_ms": 150,
         *       "event_id": 123,
         *       "extra": {
         *         "confidence_avg": 0.87,
         *         "detections_count": 3
         *       },
         *       "id": 1,
         *       "level": "INFO",
         *       "message": "Detection completed for front_door camera",
         *       "request_id": "req-550e8400-e29b-41d4",
         *       "source": "backend",
         *       "timestamp": "2026-01-03T10:30:00Z"
         *     }
         */
        LogEntry: {
            /**
             * Camera Id
             * @description Associated camera ID (alphanumeric, underscore, hyphen only)
             */
            camera_id?: string | null;
            /**
             * Component
             * @description Component/module name (e.g., 'backend.services.detector')
             */
            component: string;
            /**
             * Detection Id
             * @description Associated detection ID
             */
            detection_id?: number | null;
            /**
             * Duration Ms
             * @description Operation duration in milliseconds
             */
            duration_ms?: number | null;
            /**
             * Event Id
             * @description Associated event ID
             */
            event_id?: number | null;
            /**
             * Extra
             * @description Additional structured data (JSON-serializable)
             */
            extra?: {
                [key: string]: unknown;
            } | null;
            /**
             * Id
             * @description Log entry ID
             */
            id: number;
            /**
             * Level
             * @description Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
             */
            level: string;
            /**
             * Message
             * @description Log message content
             */
            message: string;
            /**
             * Request Id
             * @description Request correlation ID for tracing
             */
            request_id?: string | null;
            /**
             * Source
             * @description Log source (backend, frontend)
             * @default backend
             */
            source: string;
            /**
             * Timestamp
             * Format: date-time
             * @description Log timestamp (UTC)
             */
            timestamp: string;
        };
        /**
         * LogLevelRequest
         * @description Request to change log level.
         */
        LogLevelRequest: {
            /**
             * Level
             * @description New log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
             */
            level: string;
        };
        /**
         * LogLevelResponse
         * @description Response for log level operations.
         */
        LogLevelResponse: {
            /**
             * Level
             * @description Current log level
             */
            level: string;
            /**
             * Previous Level
             * @description Previous log level (on change)
             */
            previous_level?: string | null;
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * LogStats
         * @description Schema for log statistics (dashboard).
         * @example {
         *       "by_component": {
         *         "backend.api.routes": 300,
         *         "backend.services.analyzer": 400,
         *         "backend.services.detector": 800
         *       },
         *       "by_level": {
         *         "CRITICAL": 0,
         *         "DEBUG": 500,
         *         "ERROR": 12,
         *         "INFO": 900,
         *         "WARNING": 45
         *       },
         *       "errors_today": 12,
         *       "top_component": "backend.services.detector",
         *       "total_today": 1500,
         *       "warnings_today": 45
         *     }
         */
        LogStats: {
            /**
             * By Component
             * @description Counts by component
             */
            by_component: {
                [key: string]: number;
            };
            /**
             * By Level
             * @description Counts by level
             */
            by_level: {
                [key: string]: number;
            };
            /**
             * Errors Today
             * @description Error count today
             */
            errors_today: number;
            /**
             * Top Component
             * @description Most active component
             */
            top_component?: string | null;
            /**
             * Total Today
             * @description Total logs today
             */
            total_today: number;
            /**
             * Warnings Today
             * @description Warning count today
             */
            warnings_today: number;
        };
        /**
         * LogsResponse
         * @description Schema for paginated logs response (NEM-2075 pagination envelope).
         *
         *     Uses standardized pagination envelope with 'items' and 'pagination' fields.
         *     Supports both cursor-based pagination (recommended) and offset pagination.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "component": "backend.services.detector",
         *           "detection_id": 456,
         *           "duration_ms": 150,
         *           "event_id": 123,
         *           "id": 1,
         *           "level": "INFO",
         *           "message": "Detection completed",
         *           "source": "backend",
         *           "timestamp": "2026-01-03T10:30:00Z"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjYtMDEtMDNUMTA6MzA6MDBaIn0=", // pragma: allowlist secret
         *         "total": 1
         *       }
         *     }
         */
        LogsResponse: {
            /**
             * Items
             * @description List of log entries
             */
            items: components["schemas"]["LogEntry"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationInfo"];
        };
        /**
         * MediaErrorResponse
         * @description Error response for media access failures.
         * @example {
         *       "error": "File not found",
         *       "path": "/export/foscam/front_door/image_001.jpg"
         *     }
         */
        MediaErrorResponse: {
            /**
             * Error
             * @description Error message describing what went wrong
             */
            error: string;
            /**
             * Path
             * @description The path that was attempted to be accessed
             */
            path: string;
        };
        /**
         * MetricsCollectionStatus
         * @description Status of metrics collection from Prometheus.
         * @example {
         *       "collecting": true,
         *       "last_successful_scrape": "2026-01-13T10:30:00Z",
         *       "scrape_interval_seconds": 15,
         *       "total_series": 15000
         *     }
         */
        MetricsCollectionStatus: {
            /**
             * Collecting
             * @description Whether Prometheus is actively collecting metrics
             */
            collecting: boolean;
            /**
             * Last Successful Scrape
             * @description Timestamp of most recent successful scrape across all targets
             */
            last_successful_scrape?: string | null;
            /**
             * Scrape Interval Seconds
             * @description Configured global scrape interval in seconds
             * @default 15
             */
            scrape_interval_seconds: number;
            /**
             * Total Series
             * @description Total number of time series in Prometheus (if available)
             */
            total_series?: number | null;
        };
        /**
         * ModelContributions
         * @description Model contribution flags.
         * @example {
         *       "baseline": false,
         *       "clip": false,
         *       "clothing": true,
         *       "cross_camera": false,
         *       "florence": true,
         *       "image_quality": true,
         *       "pet": false,
         *       "rtdetr": true,
         *       "vehicle": false,
         *       "violence": false,
         *       "weather": true,
         *       "zones": true
         *     }
         */
        ModelContributions: {
            /**
             * Baseline
             * @description Baseline comparison
             * @default false
             */
            baseline: boolean;
            /**
             * Clip
             * @description CLIP embeddings
             * @default false
             */
            clip: boolean;
            /**
             * Clothing
             * @description Clothing analysis
             * @default false
             */
            clothing: boolean;
            /**
             * Cross Camera
             * @description Cross-camera correlation
             * @default false
             */
            cross_camera: boolean;
            /**
             * Florence
             * @description Florence-2 vision attributes
             * @default false
             */
            florence: boolean;
            /**
             * Image Quality
             * @description Image quality assessment
             * @default false
             */
            image_quality: boolean;
            /**
             * Pet
             * @description Pet classification
             * @default false
             */
            pet: boolean;
            /**
             * Rtdetr
             * @description RT-DETR object detection
             * @default false
             */
            rtdetr: boolean;
            /**
             * Vehicle
             * @description Vehicle classification
             * @default false
             */
            vehicle: boolean;
            /**
             * Violence
             * @description Violence detection
             * @default false
             */
            violence: boolean;
            /**
             * Weather
             * @description Weather classification
             * @default false
             */
            weather: boolean;
            /**
             * Zones
             * @description Zone analysis
             * @default false
             */
            zones: boolean;
        };
        /**
         * ModelLatencyHistoryResponse
         * @description Response schema for Model Zoo latency history endpoint.
         *
         *     Returns time-series latency data for a specific Model Zoo model.
         *     Used to populate the dropdown-controlled latency chart.
         * @example {
         *       "bucket_seconds": 60,
         *       "display_name": "YOLO11 License Plate",
         *       "has_data": true,
         *       "model_name": "yolo11-license-plate",
         *       "snapshots": [
         *         {
         *           "stats": {
         *             "avg_ms": 45,
         *             "p50_ms": 42,
         *             "p95_ms": 68,
         *             "sample_count": 15
         *           },
         *           "timestamp": "2026-01-04T10:00:00+00:00"
         *         }
         *       ],
         *       "timestamp": "2026-01-04T10:30:00Z",
         *       "window_minutes": 60
         *     }
         */
        ModelLatencyHistoryResponse: {
            /**
             * Bucket Seconds
             * @description Bucket size for aggregation
             */
            bucket_seconds: number;
            /**
             * Display Name
             * @description Human-readable display name
             */
            display_name: string;
            /**
             * Has Data
             * @description Whether any latency data exists for this model
             */
            has_data: boolean;
            /**
             * Model Name
             * @description Name of the model this data is for
             */
            model_name: string;
            /**
             * Snapshots
             * @description Chronologically ordered latency snapshots
             */
            snapshots: components["schemas"]["ModelLatencyHistorySnapshot"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp when history was retrieved
             */
            timestamp: string;
            /**
             * Window Minutes
             * @description Time window covered by the history
             */
            window_minutes: number;
        };
        /**
         * ModelLatencyHistorySnapshot
         * @description Single time-bucket snapshot of Model Zoo model latency.
         */
        ModelLatencyHistorySnapshot: {
            /** @description Latency statistics for this time bucket (None if no data) */
            stats?: components["schemas"]["ModelLatencyStageStats"] | null;
            /**
             * Timestamp
             * @description Bucket start time (ISO format)
             */
            timestamp: string;
        };
        /**
         * ModelLatencyStageStats
         * @description Latency statistics for a Model Zoo model at a point in time.
         */
        ModelLatencyStageStats: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms: number;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms: number;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms: number;
            /**
             * Sample Count
             * @description Number of samples in this time bucket
             */
            sample_count: number;
        };
        /**
         * ModelLeaderboardEntry
         * @description Single entry in model leaderboard.
         * @example {
         *       "contribution_rate": 0.85,
         *       "event_count": 1050,
         *       "model_name": "florence",
         *       "quality_correlation": 0.72
         *     }
         */
        ModelLeaderboardEntry: {
            /** Contribution Rate */
            contribution_rate: number;
            /** Event Count */
            event_count: number;
            /** Model Name */
            model_name: string;
            /** Quality Correlation */
            quality_correlation: number | null;
        };
        /**
         * ModelPromptResponse
         * @description Response for a single model's prompt configuration.
         * @example {
         *       "config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "You are a home security AI...",
         *         "temperature": 0.7
         *       },
         *       "model_name": "nemotron",
         *       "updated_at": "2026-01-03T10:30:00Z",
         *       "version": 3
         *     }
         */
        ModelPromptResponse: {
            /**
             * Config
             * @description Current configuration for this model
             */
            config: {
                [key: string]: unknown;
            };
            /**
             * Model Name
             * @description Name of the AI model
             */
            model_name: string;
            /**
             * Updated At
             * Format: date-time
             * @description When last updated
             */
            updated_at: string;
            /**
             * Version
             * @description Current version number
             */
            version: number;
        };
        /**
         * ModelRegistryResponse
         * @description Response schema for model registry endpoint.
         *
         *     Returns comprehensive information about all models in the Model Zoo
         *     including VRAM budget, current usage, and individual model statuses.
         * @example {
         *       "loading_strategy": "sequential",
         *       "max_concurrent_models": 1,
         *       "models": [],
         *       "vram_available_mb": 1350,
         *       "vram_budget_mb": 1650,
         *       "vram_used_mb": 300
         *     }
         */
        ModelRegistryResponse: {
            /**
             * Loading Strategy
             * @description Model loading strategy (sequential = one at a time)
             * @default sequential
             */
            loading_strategy: string;
            /**
             * Max Concurrent Models
             * @description Maximum number of models that can be loaded concurrently
             * @default 1
             */
            max_concurrent_models: number;
            /**
             * Models
             * @description List of all models in the registry with their status
             */
            models: components["schemas"]["ModelStatusResponse"][];
            /**
             * Vram Available Mb
             * @description Available VRAM for loading additional models
             */
            vram_available_mb: number;
            /**
             * Vram Budget Mb
             * @description Total VRAM budget available for Model Zoo models (excludes Nemotron and RT-DETRv2)
             */
            vram_budget_mb: number;
            /**
             * Vram Used Mb
             * @description Currently used VRAM by loaded models
             */
            vram_used_mb: number;
        };
        /**
         * ModelStatusEnum
         * @description Model loading status.
         * @enum {string}
         */
        ModelStatusEnum: "loaded" | "unloaded" | "disabled" | "loading" | "error";
        /**
         * ModelStatusResponse
         * @description Status information for a single model in the Model Zoo.
         *
         *     Provides detailed information about a model including:
         *     - Identity: name, display_name, category
         *     - Configuration: vram_mb, enabled, available, path
         *     - Runtime status: status, load_count
         * @example {
         *       "available": false,
         *       "category": "detection",
         *       "display_name": "YOLO11 License Plate",
         *       "enabled": true,
         *       "load_count": 0,
         *       "name": "yolo11-license-plate",
         *       "path": "/models/model-zoo/yolo11-license-plate/license-plate-finetune-v1n.pt",
         *       "status": "unloaded",
         *       "vram_mb": 300
         *     }
         */
        ModelStatusResponse: {
            /**
             * Available
             * @description Whether the model has been successfully loaded at least once
             */
            available: boolean;
            /**
             * Category
             * @description Model category (detection, recognition, ocr, embedding, etc.)
             */
            category: string;
            /**
             * Display Name
             * @description Human-readable display name for the model
             */
            display_name: string;
            /**
             * Enabled
             * @description Whether the model is enabled for use
             */
            enabled: boolean;
            /**
             * Load Count
             * @description Current reference count for loaded model (0 if not loaded)
             * @default 0
             */
            load_count: number;
            /**
             * Name
             * @description Unique identifier for the model (e.g., 'yolo11-license-plate')
             */
            name: string;
            /**
             * Path
             * @description HuggingFace repo path or local file path for the model
             */
            path: string;
            /** @description Current loading status: loaded, unloaded, disabled, loading, error */
            status: components["schemas"]["ModelStatusEnum"];
            /**
             * Vram Mb
             * @description Estimated VRAM usage in megabytes when loaded
             */
            vram_mb: number;
        };
        /**
         * ModelZooStatusItem
         * @description Status information for a single Model Zoo model.
         *
         *     Used in the compact status card display for Model Zoo models.
         */
        ModelZooStatusItem: {
            /**
             * Category
             * @description Model category (detection, classification, segmentation, etc.)
             */
            category: string;
            /**
             * Display Name
             * @description Human-readable display name
             */
            display_name: string;
            /**
             * Enabled
             * @description Whether the model is enabled for use
             */
            enabled: boolean;
            /**
             * Last Used At
             * @description Timestamp of last model usage (null if never used)
             */
            last_used_at?: string | null;
            /**
             * Name
             * @description Model identifier (e.g., 'yolo11-license-plate')
             */
            name: string;
            /** @description Current status: loaded (green), unloaded (gray), disabled (yellow) */
            status: components["schemas"]["ModelStatusEnum"];
            /**
             * Vram Mb
             * @description VRAM usage in megabytes when loaded
             */
            vram_mb: number;
        };
        /**
         * ModelZooStatusResponse
         * @description Response schema for Model Zoo status endpoint.
         *
         *     Returns status information for all 18 Model Zoo models organized by category.
         *     Used to populate the compact status cards in the UI.
         * @example {
         *       "disabled_count": 3,
         *       "loaded_count": 0,
         *       "models": [
         *         {
         *           "category": "detection",
         *           "display_name": "YOLO11 License Plate",
         *           "enabled": true,
         *           "name": "yolo11-license-plate",
         *           "status": "unloaded",
         *           "vram_mb": 300
         *         }
         *       ],
         *       "timestamp": "2026-01-04T10:30:00Z",
         *       "total_models": 18,
         *       "vram_budget_mb": 1650,
         *       "vram_used_mb": 0
         *     }
         */
        ModelZooStatusResponse: {
            /**
             * Disabled Count
             * @description Number of disabled models
             */
            disabled_count: number;
            /**
             * Loaded Count
             * @description Number of currently loaded models
             */
            loaded_count: number;
            /**
             * Models
             * @description List of all Model Zoo models with their current status
             */
            models: components["schemas"]["ModelZooStatusItem"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
            /**
             * Total Models
             * @description Total number of models in the registry
             */
            total_models: number;
            /**
             * Vram Budget Mb
             * @description Total VRAM budget for Model Zoo
             */
            vram_budget_mb: number;
            /**
             * Vram Used Mb
             * @description Currently used VRAM
             */
            vram_used_mb: number;
        };
        /**
         * MonitoringHealthResponse
         * @description Response schema for monitoring stack health endpoint.
         *
         *     Provides comprehensive health status of the monitoring infrastructure:
         *     - Prometheus server reachability and status
         *     - Scrape target health summary by job
         *     - Exporter status (redis-exporter, json-exporter, blackbox-exporter)
         *     - Metrics collection status
         *
         *     This endpoint helps operators quickly identify issues with the
         *     monitoring stack without accessing Prometheus UI directly.
         * @example {
         *       "exporters": [
         *         {
         *           "endpoint": "http://redis-exporter:9121",
         *           "last_scrape": "2026-01-13T10:30:00Z",
         *           "name": "redis-exporter",
         *           "status": "up"
         *         },
         *         {
         *           "endpoint": "http://json-exporter:7979",
         *           "last_scrape": "2026-01-13T10:30:00Z",
         *           "name": "json-exporter",
         *           "status": "up"
         *         }
         *       ],
         *       "healthy": true,
         *       "issues": [],
         *       "metrics_collection": {
         *         "collecting": true,
         *         "last_successful_scrape": "2026-01-13T10:30:00Z",
         *         "scrape_interval_seconds": 15,
         *         "total_series": 15000
         *       },
         *       "prometheus_reachable": true,
         *       "prometheus_url": "http://prometheus:9090",
         *       "targets_summary": [
         *         {
         *           "down": 0,
         *           "job": "hsi-backend-metrics",
         *           "total": 1,
         *           "unknown": 0,
         *           "up": 1
         *         },
         *         {
         *           "down": 0,
         *           "job": "redis",
         *           "total": 1,
         *           "unknown": 0,
         *           "up": 1
         *         },
         *         {
         *           "down": 0,
         *           "job": "blackbox-http-health",
         *           "total": 1,
         *           "unknown": 0,
         *           "up": 1
         *         }
         *       ],
         *       "timestamp": "2026-01-13T10:30:00Z"
         *     }
         */
        MonitoringHealthResponse: {
            /**
             * Exporters
             * @description Status of known exporters
             */
            exporters: components["schemas"]["ExporterStatus"][];
            /**
             * Healthy
             * @description Overall monitoring stack health: True if Prometheus reachable and majority of targets up
             */
            healthy: boolean;
            /**
             * Issues
             * @description List of identified issues with the monitoring stack
             */
            issues?: string[];
            /** @description Metrics collection status */
            metrics_collection: components["schemas"]["MetricsCollectionStatus"];
            /**
             * Prometheus Reachable
             * @description Whether Prometheus server is reachable
             */
            prometheus_reachable: boolean;
            /**
             * Prometheus Url
             * @description Configured Prometheus server URL
             */
            prometheus_url: string;
            /**
             * Targets Summary
             * @description Summary of target health by job
             */
            targets_summary: components["schemas"]["JobTargetSummary"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of health check
             */
            timestamp: string;
        };
        /**
         * MonitoringTargetsResponse
         * @description Response schema for detailed monitoring targets endpoint.
         *
         *     Returns complete information about all Prometheus scrape targets
         *     including their health status, labels, and scrape timing.
         * @example {
         *       "down": 0,
         *       "jobs": [
         *         "hsi-backend-metrics",
         *         "redis"
         *       ],
         *       "targets": [
         *         {
         *           "health": "up",
         *           "instance": "backend:8000",
         *           "job": "hsi-backend-metrics",
         *           "labels": {
         *             "service": "home-security-intelligence"
         *           },
         *           "last_scrape": "2026-01-13T10:30:00Z",
         *           "scrape_duration_seconds": 0.025
         *         },
         *         {
         *           "health": "up",
         *           "instance": "redis-exporter:9121",
         *           "job": "redis",
         *           "labels": {},
         *           "last_scrape": "2026-01-13T10:30:00Z",
         *           "scrape_duration_seconds": 0.015
         *         }
         *       ],
         *       "timestamp": "2026-01-13T10:30:00Z",
         *       "total": 2,
         *       "up": 2
         *     }
         */
        MonitoringTargetsResponse: {
            /**
             * Down
             * @description Number of targets that are down
             */
            down: number;
            /**
             * Jobs
             * @description List of unique job names
             */
            jobs: string[];
            /**
             * Targets
             * @description Detailed status of all scrape targets
             */
            targets: components["schemas"]["TargetHealth"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of targets query
             */
            timestamp: string;
            /**
             * Total
             * @description Total number of targets
             */
            total: number;
            /**
             * Up
             * @description Number of targets that are up
             */
            up: number;
        };
        /**
         * NemotronMetrics
         * @description Metrics for Nemotron LLM.
         * @example {
         *       "context_size": 4096,
         *       "slots_active": 1,
         *       "slots_total": 2,
         *       "status": "healthy"
         *     }
         */
        NemotronMetrics: {
            /**
             * Context Size
             * @description Context window size in tokens
             */
            context_size: number;
            /**
             * Slots Active
             * @description Number of active inference slots
             */
            slots_active: number;
            /**
             * Slots Total
             * @description Total available inference slots
             */
            slots_total: number;
            /**
             * Status
             * @description Health status: healthy, unhealthy, unreachable
             */
            status: string;
        };
        /**
         * NotificationChannel
         * @description Notification channel types.
         * @enum {string}
         */
        NotificationChannel: "email" | "webhook" | "push";
        /**
         * NotificationConfigResponse
         * @description Schema for notification configuration status.
         * @example {
         *       "available_channels": [
         *         "email",
         *         "webhook"
         *       ],
         *       "default_email_recipients": [
         *         "user@example.com"
         *       ],
         *       "default_webhook_url": "https://example.com/webhook",
         *       "email_configured": true,
         *       "notification_enabled": true,
         *       "push_configured": false,
         *       "smtp_from_address": "alerts@example.com",
         *       "smtp_host": "smtp.example.com",
         *       "smtp_port": 587,
         *       "smtp_use_tls": true,
         *       "webhook_configured": true,
         *       "webhook_timeout_seconds": 30
         *     }
         */
        NotificationConfigResponse: {
            /**
             * Available Channels
             * @description List of channels that are properly configured
             */
            available_channels: components["schemas"]["NotificationChannel"][];
            /**
             * Default Email Recipients
             * @description Default email recipients
             */
            default_email_recipients?: string[];
            /**
             * Default Webhook Url
             * @description Default webhook URL
             */
            default_webhook_url?: string | null;
            /**
             * Email Configured
             * @description Whether email (SMTP) is configured
             */
            email_configured: boolean;
            /**
             * Notification Enabled
             * @description Whether notifications are enabled
             */
            notification_enabled: boolean;
            /**
             * Push Configured
             * @description Whether push notifications are configured
             */
            push_configured: boolean;
            /**
             * Smtp From Address
             * @description Configured sender email
             */
            smtp_from_address?: string | null;
            /**
             * Smtp Host
             * @description Configured SMTP host (if any)
             */
            smtp_host?: string | null;
            /**
             * Smtp Port
             * @description Configured SMTP port
             */
            smtp_port?: number | null;
            /**
             * Smtp Use Tls
             * @description Whether TLS is enabled for SMTP
             */
            smtp_use_tls?: boolean | null;
            /**
             * Webhook Configured
             * @description Whether webhook is configured
             */
            webhook_configured: boolean;
            /**
             * Webhook Timeout Seconds
             * @description Webhook request timeout
             */
            webhook_timeout_seconds?: number | null;
        };
        /**
         * NotificationPreferencesResponse
         * @description Schema for notification preferences response.
         * @example {
         *       "enabled": true,
         *       "id": 1,
         *       "risk_filters": [
         *         "critical",
         *         "high",
         *         "medium"
         *       ],
         *       "sound": "default"
         *     }
         */
        NotificationPreferencesResponse: {
            /**
             * Enabled
             * @description Whether notifications are globally enabled
             */
            enabled: boolean;
            /**
             * Id
             * @description Preferences ID (always 1, singleton)
             * @default 1
             */
            id: number;
            /**
             * Risk Filters
             * @description Risk levels that trigger notifications (critical, high, medium, low)
             */
            risk_filters: string[];
            /**
             * Sound
             * @description Notification sound (none, default, alert, chime, urgent)
             */
            sound: string;
        };
        /**
         * NotificationPreferencesUpdate
         * @description Schema for updating notification preferences.
         * @example {
         *       "enabled": true,
         *       "risk_filters": [
         *         "critical",
         *         "high"
         *       ],
         *       "sound": "alert"
         *     }
         */
        NotificationPreferencesUpdate: {
            /**
             * Enabled
             * @description Whether notifications are globally enabled
             */
            enabled?: boolean | null;
            /**
             * Risk Filters
             * @description Risk levels that trigger notifications (critical, high, medium, low)
             */
            risk_filters?: string[] | null;
            /**
             * Sound
             * @description Notification sound (none, default, alert, chime, urgent)
             */
            sound?: string | null;
        };
        /**
         * ObjectBaseline
         * @description Baseline statistics for a specific object class.
         * @example {
         *       "avg_hourly": 2.3,
         *       "peak_hour": 17,
         *       "total_detections": 550
         *     }
         */
        ObjectBaseline: {
            /**
             * Avg Hourly
             * @description Average hourly detection count for this object type
             */
            avg_hourly: number;
            /**
             * Peak Hour
             * @description Hour with most detections of this type (0-23)
             */
            peak_hour: number;
            /**
             * Total Detections
             * @description Total detections of this type in the baseline period
             */
            total_detections: number;
        };
        /**
         * ObjectDistributionDataPoint
         * @description Schema for a single object distribution data point.
         * @example {
         *       "count": 120,
         *       "object_type": "person",
         *       "percentage": 45.5
         *     }
         */
        ObjectDistributionDataPoint: {
            /**
             * Count
             * @description Number of detections for this object type
             */
            count: number;
            /**
             * Object Type
             * @description Detected object type (e.g., 'person', 'car')
             */
            object_type: string;
            /**
             * Percentage
             * @description Percentage of total detections (0-100)
             */
            percentage: number;
        };
        /**
         * ObjectDistributionResponse
         * @description Schema for detection counts by object type.
         * @example {
         *       "end_date": "2025-01-07",
         *       "object_types": [
         *         {
         *           "count": 120,
         *           "object_type": "person",
         *           "percentage": 45.5
         *         },
         *         {
         *           "count": 80,
         *           "object_type": "car",
         *           "percentage": 30.3
         *         },
         *         {
         *           "count": 64,
         *           "object_type": "dog",
         *           "percentage": 24.2
         *         }
         *       ],
         *       "start_date": "2025-01-01",
         *       "total_detections": 264
         *     }
         */
        ObjectDistributionResponse: {
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Object Types
             * @description Detection counts by object type
             */
            object_types: components["schemas"]["ObjectDistributionDataPoint"][];
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
            /**
             * Total Detections
             * @description Total detections in date range
             */
            total_detections: number;
        };
        /**
         * OldestJobInfo
         * @description Information about the oldest job in a queue.
         * @example {
         *       "id": "job_12345",
         *       "queued_at": "2025-12-23T10:30:00.000000",
         *       "wait_seconds": 45.2
         *     }
         */
        OldestJobInfo: {
            /**
             * Id
             * @description Job identifier (if available)
             */
            id?: string | null;
            /**
             * Queued At
             * @description Timestamp when the job was queued
             */
            queued_at?: string | null;
            /**
             * Wait Seconds
             * @description How long the oldest job has been waiting in seconds
             */
            wait_seconds: number;
        };
        /**
         * OrphanCleanupRequest
         * @description Request schema for orphan cleanup endpoint.
         */
        OrphanCleanupRequest: {
            /**
             * Dry Run
             * @description If True, only report what would be deleted without actually deleting
             * @default true
             */
            dry_run: boolean;
            /**
             * Max Delete Gb
             * @description Maximum gigabytes to delete in one run (0.1-100)
             * @default 10
             */
            max_delete_gb: number;
            /**
             * Min Age Hours
             * @description Minimum age in hours before a file can be deleted (1-720)
             * @default 24
             */
            min_age_hours: number;
        };
        /**
         * OrphanCleanupResponse
         * @description Response schema for orphan cleanup endpoint.
         */
        OrphanCleanupResponse: {
            /** Deleted Bytes */
            deleted_bytes: number;
            /** Deleted Bytes Formatted */
            deleted_bytes_formatted: string;
            /** Deleted Files */
            deleted_files: number;
            /** Dry Run */
            dry_run: boolean;
            /** Duration Seconds */
            duration_seconds: number;
            /** Failed Count */
            failed_count: number;
            /** Failed Deletions */
            failed_deletions: string[];
            /** Orphaned Files */
            orphaned_files: number;
            /** Scanned Files */
            scanned_files: number;
            /** Skipped Size Limit */
            skipped_size_limit: number;
            /** Skipped Young */
            skipped_young: number;
        };
        /**
         * OrphanedFileCleanupResponse
         * @description Response schema for orphaned file cleanup endpoint.
         *
         *     Returns statistics about orphaned files found (and optionally deleted).
         *     Orphaned files are files on disk not referenced in the database.
         * @example {
         *       "dry_run": true,
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "orphaned_count": 25,
         *       "orphaned_files": [
         *         "/data/thumbnails/orphaned1.jpg",
         *         "/data/thumbnails/orphaned2.jpg"
         *       ],
         *       "timestamp": "2025-12-30T10:30:00Z",
         *       "total_size": 524288000,
         *       "total_size_formatted": "500.00 MB"
         *     }
         */
        OrphanedFileCleanupResponse: {
            /**
             * Dry Run
             * @description Whether this was a dry run (no actual deletion performed)
             */
            dry_run: boolean;
            /**
             * Job Id
             * @description Background job ID for tracking progress
             */
            job_id?: string | null;
            /**
             * Orphaned Count
             * @description Number of orphaned files found (or deleted if dry_run=False)
             */
            orphaned_count: number;
            /**
             * Orphaned Files
             * @description List of orphaned file paths (limited to first 100)
             */
            orphaned_files?: string[];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of cleanup operation
             */
            timestamp: string;
            /**
             * Total Size
             * @description Total size of orphaned files in bytes
             */
            total_size: number;
            /**
             * Total Size Formatted
             * @description Human-readable total size (e.g., '1.5 GB')
             */
            total_size_formatted: string;
        };
        /**
         * PaginationInfo
         * @description Pagination metadata for list responses (NEM-2075).
         */
        PaginationInfo: {
            /**
             * Cursor
             * @description Current cursor position
             */
            cursor?: string | null;
            /**
             * Has More
             * @description Whether more results are available
             * @default false
             */
            has_more: boolean;
            /**
             * Limit
             * @description Page size (1-1000)
             */
            limit: number;
            /**
             * Next Cursor
             * @description Cursor for next page
             */
            next_cursor?: string | null;
            /**
             * Offset
             * @description Page offset (0-based, for offset pagination)
             */
            offset?: number | null;
            /**
             * Total
             * @description Total count matching filters
             */
            total: number;
        };
        /**
         * PaginationMeta
         * @description Pagination metadata for list responses.
         *
         *     Contains information about the current page and total results.
         *     Supports both offset-based and cursor-based pagination.
         * @example {
         *       "has_more": true,
         *       "limit": 50,
         *       "next_cursor": "eyJpZCI6IDUwfQ",
         *       "offset": 0,
         *       "total": 150
         *     }
         */
        PaginationMeta: {
            /**
             * Cursor
             * @description Current cursor position (cursor-based pagination)
             */
            cursor?: string | null;
            /**
             * Has More
             * @description Whether more items are available beyond this page
             */
            has_more: boolean;
            /**
             * Limit
             * @description Maximum number of items returned per page
             */
            limit: number;
            /**
             * Next Cursor
             * @description Cursor for the next page of results
             */
            next_cursor?: string | null;
            /**
             * Offset
             * @description Number of items skipped (offset-based pagination)
             */
            offset?: number | null;
            /**
             * Total
             * @description Total number of items matching the query
             */
            total: number;
        };
        /**
         * PerformanceAlert
         * @description Alert when metric exceeds threshold.
         * @example {
         *       "message": "GPU temperature high: 82C",
         *       "metric": "gpu_temperature",
         *       "severity": "warning",
         *       "threshold": 80,
         *       "value": 82
         *     }
         */
        PerformanceAlert: {
            /**
             * Message
             * @description Human-readable alert message
             */
            message: string;
            /**
             * Metric
             * @description Metric name that triggered the alert
             */
            metric: string;
            /**
             * Severity
             * @description Alert severity: warning or critical
             */
            severity: string;
            /**
             * Threshold
             * @description Threshold that was exceeded
             */
            threshold: number;
            /**
             * Value
             * @description Current metric value
             */
            value: number;
        };
        /**
         * PerformanceHistoryResponse
         * @description Response containing historical performance data.
         *
         *     Used by GET /api/system/performance/history endpoint.
         * @example {
         *       "count": 0,
         *       "snapshots": [],
         *       "time_range": "5m"
         *     }
         */
        PerformanceHistoryResponse: {
            /**
             * Count
             * @description Number of snapshots returned
             */
            count: number;
            /**
             * Snapshots
             * @description List of performance snapshots ordered chronologically
             */
            snapshots: components["schemas"]["PerformanceUpdate"][];
            /** @description Time range of the history */
            time_range: components["schemas"]["TimeRange"];
        };
        /**
         * PerformanceUpdate
         * @description Complete performance update sent via WebSocket.
         *
         *     This is the main payload broadcast to frontend clients every 5 seconds.
         *     All fields are optional to allow partial updates.
         * @example {
         *       "ai_models": {
         *         "rtdetr": {
         *           "device": "cuda:0",
         *           "model": "rtdetr",
         *           "status": "healthy",
         *           "vram_gb": 0.17
         *         }
         *       },
         *       "alerts": [],
         *       "gpu": {
         *         "name": "NVIDIA RTX A5500",
         *         "power_watts": 31,
         *         "temperature": 38,
         *         "utilization": 38,
         *         "vram_total_gb": 24,
         *         "vram_used_gb": 22.7
         *       },
         *       "host": {
         *         "cpu_percent": 12,
         *         "disk_total_gb": 500,
         *         "disk_used_gb": 156,
         *         "ram_total_gb": 32,
         *         "ram_used_gb": 8.2
         *       },
         *       "timestamp": "2025-12-31T10:30:00Z"
         *     }
         */
        PerformanceUpdate: {
            /**
             * Ai Models
             * @description AI model metrics keyed by model name
             */
            ai_models?: {
                [key: string]: components["schemas"]["AiModelMetrics"] | components["schemas"]["NemotronMetrics"];
            };
            /**
             * Alerts
             * @description Active performance alerts
             */
            alerts?: components["schemas"]["PerformanceAlert"][];
            /**
             * Containers
             * @description Container health statuses
             */
            containers?: components["schemas"]["ContainerMetrics"][];
            /**
             * Databases
             * @description Database metrics keyed by name
             */
            databases?: {
                [key: string]: components["schemas"]["DatabaseMetrics"] | components["schemas"]["RedisMetrics"];
            };
            /** @description GPU metrics */
            gpu?: components["schemas"]["GpuMetrics"] | null;
            /** @description Host system metrics */
            host?: components["schemas"]["HostMetrics"] | null;
            /** @description AI inference latency and throughput */
            inference?: components["schemas"]["InferenceMetrics"] | null;
            /** @description Nemotron-specific metrics */
            nemotron?: components["schemas"]["NemotronMetrics"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description When this update was generated (UTC)
             */
            timestamp?: string;
        };
        /**
         * PetEnrichment
         * @description Pet classification results for false positive reduction.
         * @example {
         *       "confidence": 0.94,
         *       "detected": true,
         *       "is_household_pet": true,
         *       "type": "dog"
         *     }
         */
        PetEnrichment: {
            /**
             * Confidence
             * @description Classification confidence
             */
            confidence?: number | null;
            /**
             * Detected
             * @description Whether a pet was detected
             * @default false
             */
            detected: boolean;
            /**
             * Is Household Pet
             * @description Whether classified as household pet
             */
            is_household_pet?: boolean | null;
            /**
             * Type
             * @description Pet type (cat, dog)
             */
            type?: string | null;
        };
        /**
         * PipelineErrorsResponse
         * @description Response for pipeline errors retrieval.
         */
        PipelineErrorsResponse: {
            /**
             * Errors
             * @description List of recent pipeline errors
             */
            errors: components["schemas"]["RecentError"][];
            /**
             * Limit
             * @description Maximum errors requested
             */
            limit: number;
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
            /**
             * Total
             * @description Total number of errors returned
             */
            total: number;
        };
        /**
         * PipelineLatencies
         * @description Latency statistics for all pipeline stages.
         *
         *     Pipeline stages:
         *     - watch: File watcher detecting new images (file event -> queue)
         *     - detect: RT-DETRv2 object detection (image -> detections)
         *     - batch: Batch aggregation window (detections -> batch)
         *     - analyze: Nemotron LLM risk analysis (batch -> event)
         * @example {
         *       "analyze": {
         *         "avg_ms": 5000,
         *         "max_ms": 15000,
         *         "min_ms": 2000,
         *         "p50_ms": 4500,
         *         "p95_ms": 12000,
         *         "p99_ms": 14000,
         *         "sample_count": 100
         *       },
         *       "batch": {
         *         "avg_ms": 30000,
         *         "max_ms": 90000,
         *         "min_ms": 5000,
         *         "p50_ms": 25000,
         *         "p95_ms": 80000,
         *         "p99_ms": 88000,
         *         "sample_count": 100
         *       },
         *       "detect": {
         *         "avg_ms": 200,
         *         "max_ms": 800,
         *         "min_ms": 100,
         *         "p50_ms": 180,
         *         "p95_ms": 600,
         *         "p99_ms": 750,
         *         "sample_count": 500
         *       },
         *       "watch": {
         *         "avg_ms": 10,
         *         "max_ms": 50,
         *         "min_ms": 5,
         *         "p50_ms": 8,
         *         "p95_ms": 40,
         *         "p99_ms": 48,
         *         "sample_count": 500
         *       }
         *     }
         */
        PipelineLatencies: {
            /** @description LLM analysis stage latency (Nemotron inference) */
            analyze?: components["schemas"]["StageLatency"] | null;
            /** @description Batch aggregation window time */
            batch?: components["schemas"]["StageLatency"] | null;
            /** @description Object detection stage latency (RT-DETRv2 inference) */
            detect?: components["schemas"]["StageLatency"] | null;
            /** @description File watcher stage latency (file event to queue) */
            watch?: components["schemas"]["StageLatency"] | null;
        };
        /**
         * PipelineLatencyHistoryResponse
         * @description Response schema for pipeline latency history endpoint.
         *
         *     Provides time-series latency data for charting and trend analysis.
         *     Each snapshot contains aggregated metrics for a time bucket.
         * @example {
         *       "bucket_seconds": 60,
         *       "snapshots": [
         *         {
         *           "stages": {
         *             "watch_to_detect": {
         *               "avg_ms": 50,
         *               "p50_ms": 45,
         *               "p95_ms": 120,
         *               "p99_ms": 150,
         *               "sample_count": 15
         *             }
         *           },
         *           "timestamp": "2025-12-28T10:00:00+00:00"
         *         }
         *       ],
         *       "timestamp": "2025-12-28T10:30:00Z",
         *       "window_minutes": 60
         *     }
         */
        PipelineLatencyHistoryResponse: {
            /**
             * Bucket Seconds
             * @description Bucket size for aggregation
             */
            bucket_seconds: number;
            /**
             * Snapshots
             * @description Chronologically ordered latency snapshots
             */
            snapshots: components["schemas"]["LatencyHistorySnapshot"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp when history was retrieved
             */
            timestamp: string;
            /**
             * Window Minutes
             * @description Time window covered by the history
             */
            window_minutes: number;
        };
        /**
         * PipelineLatencyResponse
         * @description Response schema for pipeline latency endpoint.
         *
         *     Provides latency metrics for each stage transition in the AI pipeline:
         *     - watch_to_detect: Time from file watcher detecting image to RT-DETR processing start
         *     - detect_to_batch: Time from detection completion to batch aggregation
         *     - batch_to_analyze: Time from batch completion to Nemotron analysis start
         *     - total_pipeline: Total end-to-end processing time
         * @example {
         *       "batch_to_analyze": {
         *         "avg_ms": 5000,
         *         "max_ms": 15000,
         *         "min_ms": 2000,
         *         "p50_ms": 4500,
         *         "p95_ms": 12000,
         *         "p99_ms": 14000,
         *         "sample_count": 100
         *       },
         *       "detect_to_batch": {
         *         "avg_ms": 100,
         *         "max_ms": 500,
         *         "min_ms": 20,
         *         "p50_ms": 80,
         *         "p95_ms": 400,
         *         "p99_ms": 480,
         *         "sample_count": 500
         *       },
         *       "timestamp": "2025-12-28T10:30:00Z",
         *       "total_pipeline": {
         *         "avg_ms": 35000,
         *         "max_ms": 120000,
         *         "min_ms": 10000,
         *         "p50_ms": 30000,
         *         "p95_ms": 100000,
         *         "p99_ms": 110000,
         *         "sample_count": 100
         *       },
         *       "watch_to_detect": {
         *         "avg_ms": 50,
         *         "max_ms": 200,
         *         "min_ms": 10,
         *         "p50_ms": 40,
         *         "p95_ms": 150,
         *         "p99_ms": 180,
         *         "sample_count": 500
         *       },
         *       "window_minutes": 60
         *     }
         */
        PipelineLatencyResponse: {
            /** @description Latency from batch to Nemotron analysis */
            batch_to_analyze?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Latency from detection to batch aggregation */
            detect_to_batch?: components["schemas"]["PipelineStageLatency"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of latency snapshot
             */
            timestamp: string;
            /** @description Total end-to-end pipeline latency */
            total_pipeline?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Latency from file detection to RT-DETR processing */
            watch_to_detect?: components["schemas"]["PipelineStageLatency"] | null;
            /**
             * Window Minutes
             * @description Time window used for calculating statistics
             */
            window_minutes: number;
        };
        /**
         * PipelineStageLatency
         * @description Latency statistics for a single pipeline transition stage.
         *
         *     Tracks time between pipeline stages:
         *     - watch_to_detect: File detection to RT-DETR processing
         *     - detect_to_batch: Detection to batch aggregation
         *     - batch_to_analyze: Batch to Nemotron analysis
         *     - total_pipeline: End-to-end latency
         * @example {
         *       "avg_ms": 150.5,
         *       "max_ms": 500,
         *       "min_ms": 50,
         *       "p50_ms": 120,
         *       "p95_ms": 400,
         *       "p99_ms": 480,
         *       "sample_count": 100
         *     }
         */
        PipelineStageLatency: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms?: number | null;
            /**
             * Max Ms
             * @description Maximum latency in milliseconds
             */
            max_ms?: number | null;
            /**
             * Min Ms
             * @description Minimum latency in milliseconds
             */
            min_ms?: number | null;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms?: number | null;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms?: number | null;
            /**
             * P99 Ms
             * @description 99th percentile latency in milliseconds
             */
            p99_ms?: number | null;
            /**
             * Sample Count
             * @description Number of samples used to calculate statistics
             */
            sample_count: number;
        };
        /**
         * PipelineStateResponse
         * @description Response for pipeline state inspection.
         */
        PipelineStateResponse: {
            /**
             * Correlation Id
             * @description Correlation ID from request
             */
            correlation_id?: string | null;
            /** @description Current queue depths */
            queue_depths: components["schemas"]["QueueDepths"];
            /**
             * Recent Errors
             * @description Recent errors (last 10)
             */
            recent_errors?: components["schemas"]["RecentError"][];
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
            /** @description Worker status */
            workers: components["schemas"]["PipelineWorkersStatus"];
        };
        /**
         * PipelineStatusResponse
         * @description Combined status of all pipeline operations.
         *
         *     Provides visibility into:
         *     - FileWatcher: Monitoring camera directories for new uploads
         *     - BatchAggregator: Grouping detections into time-based batches
         *     - DegradationManager: Graceful degradation and service health
         * @example {
         *       "batch_aggregator": {
         *         "active_batches": 1,
         *         "batch_window_seconds": 90,
         *         "batches": [],
         *         "idle_timeout_seconds": 30
         *       },
         *       "degradation": {
         *         "available_features": [
         *           "detection",
         *           "analysis",
         *           "events",
         *           "media"
         *         ],
         *         "fallback_queues": {},
         *         "is_degraded": false,
         *         "memory_queue_size": 0,
         *         "mode": "normal",
         *         "redis_healthy": true,
         *         "services": []
         *       },
         *       "file_watcher": {
         *         "camera_root": "/export/foscam",
         *         "observer_type": "native",
         *         "pending_tasks": 0,
         *         "running": true
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        PipelineStatusResponse: {
            /** @description BatchAggregator service status (null if not running) */
            batch_aggregator?: components["schemas"]["BatchAggregatorStatusResponse"] | null;
            /** @description DegradationManager service status (null if not initialized) */
            degradation?: components["schemas"]["DegradationStatusResponse"] | null;
            /** @description FileWatcher service status (null if not running) */
            file_watcher?: components["schemas"]["FileWatcherStatusResponse"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * PipelineWorkerStatus
         * @description Status of a pipeline worker.
         */
        PipelineWorkerStatus: {
            /**
             * Error Count
             * @description Number of recent errors
             * @default 0
             */
            error_count: number;
            /**
             * Last Activity
             * @description ISO timestamp of last activity
             */
            last_activity?: string | null;
            /**
             * Name
             * @description Worker name
             */
            name: string;
            /**
             * Running
             * @description Whether worker is currently running
             */
            running: boolean;
        };
        /**
         * PipelineWorkersStatus
         * @description Status of all pipeline workers.
         */
        PipelineWorkersStatus: {
            /** @description Analyzer worker status */
            analyzer: components["schemas"]["PipelineWorkerStatus"];
            /** @description Detector worker status */
            detector: components["schemas"]["PipelineWorkerStatus"];
            /** @description File watcher status */
            file_watcher: components["schemas"]["PipelineWorkerStatus"];
        };
        /**
         * PoseEnrichment
         * @description Pose estimation results (placeholder for future ViTPose integration).
         * @example {
         *       "action": "walking",
         *       "confidence": 0.82,
         *       "keypoints": [
         *         [
         *           100,
         *           150,
         *           0.9
         *         ],
         *         [
         *           120,
         *           160,
         *           0.85
         *         ]
         *       ]
         *     }
         */
        PoseEnrichment: {
            /**
             * Action
             * @description Recognized action (walking, running, etc.)
             */
            action?: string | null;
            /**
             * Confidence
             * @description Action confidence
             */
            confidence?: number | null;
            /**
             * Keypoints
             * @description Body keypoints [[x, y, conf], ...]
             */
            keypoints?: number[][] | null;
        };
        /**
         * ProfileStartResponse
         * @description Response for starting profiling.
         */
        ProfileStartResponse: {
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Started At
             * @description ISO timestamp when profiling started
             */
            started_at: string;
            /**
             * Status
             * @description Profiling status ('started' or 'already_running')
             */
            status: string;
        };
        /**
         * ProfileStatsResponse
         * @description Response for profiling statistics.
         */
        ProfileStatsResponse: {
            /**
             * Is Profiling
             * @description Whether profiling is currently active
             */
            is_profiling: boolean;
            /**
             * Last Profile Path
             * @description Path to last saved profile
             */
            last_profile_path?: string | null;
            /**
             * Stats Text
             * @description Human-readable profiling statistics
             */
            stats_text?: string | null;
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * ProfileStopResponse
         * @description Response for stopping profiling.
         */
        ProfileStopResponse: {
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Profile Path
             * @description Path to saved profile file
             */
            profile_path?: string | null;
            /**
             * Status
             * @description Profiling status ('stopped' or 'not_running')
             */
            status: string;
            /**
             * Stopped At
             * @description ISO timestamp when profiling stopped
             */
            stopped_at: string;
        };
        /**
         * PromptConfigRequest
         * @description Request to update a model's prompt configuration (database-backed).
         *
         *     Used by the Prompt Playground "Save" functionality to persist
         *     prompt configurations to the database.
         * @example {
         *       "maxTokens": 2048,
         *       "systemPrompt": "You are a home security AI assistant...",
         *       "temperature": 0.7
         *     }
         */
        PromptConfigRequest: {
            /**
             * Maxtokens
             * @description Maximum tokens in response (100-8192)
             * @default 2048
             */
            maxTokens: number;
            /**
             * Systemprompt
             * @description Full system prompt text for the model
             */
            systemPrompt: string;
            /**
             * Temperature
             * @description LLM temperature setting (0-2)
             * @default 0.7
             */
            temperature: number;
        };
        /**
         * PromptConfigResponse
         * @description Response containing a model's prompt configuration (database-backed).
         *
         *     Returned when retrieving or updating prompt configurations.
         * @example {
         *       "maxTokens": 2048,
         *       "model": "nemotron",
         *       "systemPrompt": "You are a home security AI assistant...",
         *       "temperature": 0.7,
         *       "updatedAt": "2026-01-03T10:30:00Z",
         *       "version": 3
         *     }
         */
        PromptConfigResponse: {
            /**
             * Maxtokens
             * @description Maximum tokens in response (100-8192)
             */
            maxTokens: number;
            /**
             * Model
             * @description Model name
             */
            model: string;
            /**
             * Systemprompt
             * @description Full system prompt text for the model
             */
            systemPrompt: string;
            /**
             * Temperature
             * @description LLM temperature setting (0-2)
             */
            temperature: number;
            /**
             * Updatedat
             * Format: date-time
             * @description When the configuration was last updated
             */
            updatedAt: string;
            /**
             * Version
             * @description Configuration version number
             */
            version: number;
        };
        /**
         * PromptExportResponse
         * @description Response containing all prompt configurations for export.
         * @example {
         *       "exported_at": "2026-01-03T10:30:00Z",
         *       "prompts": {
         *         "florence2": {
         *           "vqa_queries": [
         *             "What is this person wearing?"
         *           ]
         *         },
         *         "nemotron": {
         *           "max_tokens": 2048,
         *           "system_prompt": "You are a home security AI...",
         *           "temperature": 0.7
         *         }
         *       },
         *       "version": "1.0"
         *     }
         */
        PromptExportResponse: {
            /**
             * Exported At
             * Format: date-time
             * @description When the export was created
             */
            exported_at: string;
            /**
             * Prompts
             * @description All model configurations keyed by model name
             */
            prompts: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
            /**
             * Version
             * @description Export format version
             * @default 1.0
             */
            version: string;
        };
        /**
         * PromptHistoryEntry
         * @description A single entry in prompt version history.
         * @example {
         *       "config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "Previous version of prompt...",
         *         "temperature": 0.7
         *       },
         *       "created_at": "2026-01-02T14:00:00Z",
         *       "created_by": "admin",
         *       "description": "Initial prompt configuration",
         *       "version": 2
         *     }
         */
        PromptHistoryEntry: {
            /**
             * Config
             * @description Configuration at this version
             */
            config: {
                [key: string]: unknown;
            };
            /**
             * Created At
             * Format: date-time
             * @description When this version was created
             */
            created_at: string;
            /**
             * Created By
             * @description Who created this version
             * @default system
             */
            created_by: string;
            /**
             * Description
             * @description Description of changes
             */
            description?: string | null;
            /**
             * Version
             * @description Version number
             */
            version: number;
        };
        /**
         * PromptHistoryResponse
         * @description Response containing version history for a model's prompts.
         * @example {
         *       "model_name": "nemotron",
         *       "total_versions": 3,
         *       "versions": [
         *         {
         *           "config": {
         *             "system_prompt": "...",
         *             "temperature": 0.8
         *           },
         *           "created_at": "2026-01-03T10:30:00Z",
         *           "created_by": "admin",
         *           "description": "Added weather context",
         *           "version": 3
         *         },
         *         {
         *           "config": {
         *             "system_prompt": "...",
         *             "temperature": 0.7
         *           },
         *           "created_at": "2026-01-02T14:00:00Z",
         *           "created_by": "system",
         *           "description": "Initial configuration",
         *           "version": 2
         *         }
         *       ]
         *     }
         */
        PromptHistoryResponse: {
            /** Model Name */
            model_name: string;
            /** Total Versions */
            total_versions: number;
            /** Versions */
            versions: components["schemas"]["PromptHistoryEntry"][];
        };
        /**
         * PromptImportRequest
         * @description Request to import prompt configurations.
         * @example {
         *       "overwrite": true,
         *       "prompts": {
         *         "nemotron": {
         *           "max_tokens": 2048,
         *           "system_prompt": "Imported system prompt...",
         *           "temperature": 0.7
         *         }
         *       }
         *     }
         */
        PromptImportRequest: {
            /**
             * Overwrite
             * @description Whether to overwrite existing configurations
             * @default false
             */
            overwrite: boolean;
            /**
             * Prompts
             * @description Model configurations to import, keyed by model name
             */
            prompts: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
        };
        /**
         * PromptImportResponse
         * @description Response after importing prompt configurations.
         * @example {
         *       "errors": [],
         *       "imported_count": 3,
         *       "message": "Successfully imported 3 prompt configurations",
         *       "skipped_count": 1
         *     }
         */
        PromptImportResponse: {
            /**
             * Errors
             * @description Any errors encountered
             */
            errors?: string[];
            /**
             * Imported Count
             * @description Number of models imported
             */
            imported_count: number;
            /** Message */
            message: string;
            /**
             * Skipped Count
             * @description Number of models skipped
             */
            skipped_count: number;
        };
        /**
         * PromptImprovements
         * @description Prompt improvement suggestions from self-evaluation.
         * @example {
         *       "confusing_sections": [
         *         "Zone overlap handling unclear"
         *       ],
         *       "format_suggestions": [
         *         "Add structured detection summary"
         *       ],
         *       "missing_context": [
         *         "Time since last motion event",
         *         "Weather conditions"
         *       ],
         *       "model_gaps": [
         *         "Pet detection model not active"
         *       ],
         *       "unused_data": [
         *         "Vehicle color data not utilized"
         *       ]
         *     }
         */
        PromptImprovements: {
            /** Confusing Sections */
            confusing_sections?: string[];
            /** Format Suggestions */
            format_suggestions?: string[];
            /** Missing Context */
            missing_context?: string[];
            /** Model Gaps */
            model_gaps?: string[];
            /** Unused Data */
            unused_data?: string[];
        };
        /**
         * PromptRestoreRequest
         * @description Request to restore a specific version of a prompt.
         * @example {
         *       "description": "Restoring to version 2 due to regression in analysis quality"
         *     }
         */
        PromptRestoreRequest: {
            /**
             * Description
             * @description Optional description for the restore action
             */
            description?: string | null;
        };
        /**
         * PromptRestoreResponse
         * @description Response after restoring a prompt version.
         * @example {
         *       "message": "Successfully restored version 2 as new version 4",
         *       "model_name": "nemotron",
         *       "new_version": 4,
         *       "restored_version": 2
         *     }
         */
        PromptRestoreResponse: {
            /** Message */
            message: string;
            /** Model Name */
            model_name: string;
            /** New Version */
            new_version: number;
            /** Restored Version */
            restored_version: number;
        };
        /**
         * PromptTestRequest
         * @description Request to test a modified prompt against an event.
         * @example {
         *       "config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "Modified prompt for testing...",
         *         "temperature": 0.7
         *       },
         *       "event_id": 12345,
         *       "model": "nemotron"
         *     }
         */
        PromptTestRequest: {
            /**
             * Config
             * @description Modified configuration to test
             */
            config: {
                [key: string]: unknown;
            };
            /**
             * Event Id
             * @description Event ID to test against
             */
            event_id: number;
            /**
             * Model
             * @description Model name to test (nemotron, florence2, etc.)
             */
            model: string;
        };
        /**
         * PromptTestResponse
         * @description Response from testing a modified prompt.
         * @example {
         *       "after": {
         *         "risk_level": "low",
         *         "score": 45,
         *         "summary": "Regular visitor detected - matches known delivery pattern"
         *       },
         *       "before": {
         *         "risk_level": "medium",
         *         "score": 65,
         *         "summary": "Person detected at front door during evening hours"
         *       },
         *       "improved": true,
         *       "inference_time_ms": 1250
         *     }
         */
        PromptTestResponse: {
            /** @description Results from modified prompt */
            after: components["schemas"]["PromptTestResultAfter"];
            /** @description Results from original prompt */
            before: components["schemas"]["PromptTestResultBefore"];
            /**
             * Improved
             * @description Whether the modification improved results
             */
            improved: boolean;
            /**
             * Inference Time Ms
             * @description Time taken for inference in ms
             */
            inference_time_ms: number;
        };
        /**
         * PromptTestResultAfter
         * @description Result from the modified prompt.
         * @example {
         *       "risk_level": "low",
         *       "score": 45,
         *       "summary": "Regular visitor detected - matches known delivery pattern"
         *     }
         */
        PromptTestResultAfter: {
            /**
             * Risk Level
             * @description Risk level (low, medium, high, critical)
             */
            risk_level: string;
            /**
             * Score
             * @description Risk score from modified prompt
             */
            score: number;
            /**
             * Summary
             * @description Summary from modified analysis
             */
            summary: string;
        };
        /**
         * PromptTestResultBefore
         * @description Result from the original (current) prompt.
         * @example {
         *       "risk_level": "medium",
         *       "score": 65,
         *       "summary": "Person detected at front door during evening hours"
         *     }
         */
        PromptTestResultBefore: {
            /**
             * Risk Level
             * @description Risk level (low, medium, high, critical)
             */
            risk_level: string;
            /**
             * Score
             * @description Risk score from original prompt
             */
            score: number;
            /**
             * Summary
             * @description Summary from original analysis
             */
            summary: string;
        };
        /**
         * PromptUpdateRequest
         * @description Request to update a model's prompt configuration.
         * @example {
         *       "config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "Updated system prompt with new context...",
         *         "temperature": 0.8
         *       },
         *       "description": "Added weather context to improve analysis"
         *     }
         */
        PromptUpdateRequest: {
            /**
             * Config
             * @description New configuration for the model
             */
            config: {
                [key: string]: unknown;
            };
            /**
             * Description
             * @description Description of the changes
             */
            description?: string | null;
        };
        /**
         * PromptUpdateResponse
         * @description Response after updating a model's prompt.
         * @example {
         *       "config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "Updated system prompt...",
         *         "temperature": 0.8
         *       },
         *       "message": "Prompt configuration updated successfully",
         *       "model_name": "nemotron",
         *       "version": 4
         *     }
         */
        PromptUpdateResponse: {
            /** Config */
            config: {
                [key: string]: unknown;
            };
            /** Message */
            message: string;
            /** Model Name */
            model_name: string;
            /** Version */
            version: number;
        };
        /**
         * QualityScores
         * @description Self-evaluation quality scores (1-5 scale).
         * @example {
         *       "consistency": 4,
         *       "context_usage": 4.2,
         *       "overall": 4.1,
         *       "reasoning_coherence": 4.5,
         *       "risk_justification": 3.8
         *     }
         */
        QualityScores: {
            /** Consistency */
            consistency?: number | null;
            /** Context Usage */
            context_usage?: number | null;
            /** Overall */
            overall?: number | null;
            /** Reasoning Coherence */
            reasoning_coherence?: number | null;
            /** Risk Justification */
            risk_justification?: number | null;
        };
        /**
         * QueueDepths
         * @description Queue depth information for pipeline queues.
         * @example {
         *       "analysis_queue": 2,
         *       "detection_queue": 5
         *     }
         */
        QueueDepths: {
            /**
             * Analysis Queue
             * @description Number of batches in analysis queue waiting for Nemotron LLM analysis
             */
            analysis_queue: number;
            /**
             * Detection Queue
             * @description Number of items in detection queue waiting for RT-DETRv2 processing
             */
            detection_queue: number;
        };
        /**
         * QueueHealthStatus
         * @description Health status for a queue based on depth and wait time.
         * @enum {string}
         */
        QueueHealthStatus: "healthy" | "warning" | "critical";
        /**
         * QueueStatus
         * @description Status of a single job queue.
         * @example {
         *       "depth": 15,
         *       "name": "ai_analysis",
         *       "oldest_job": {
         *         "id": "job_12345",
         *         "queued_at": "2025-12-23T10:30:00.000000",
         *         "wait_seconds": 45.2
         *       },
         *       "running": 2,
         *       "status": "healthy",
         *       "throughput": {
         *         "avg_processing_seconds": 4.8,
         *         "jobs_per_minute": 12.5
         *       },
         *       "workers": 4
         *     }
         */
        QueueStatus: {
            /**
             * Depth
             * @description Number of jobs waiting in the queue
             */
            depth: number;
            /**
             * Name
             * @description Queue name
             */
            name: string;
            /** @description Information about the oldest job waiting (if any) */
            oldest_job?: components["schemas"]["OldestJobInfo"] | null;
            /**
             * Running
             * @description Number of jobs currently being processed
             */
            running: number;
            /** @description Health status of the queue */
            status: components["schemas"]["QueueHealthStatus"];
            /** @description Throughput metrics for the queue */
            throughput: components["schemas"]["ThroughputMetrics"];
            /**
             * Workers
             * @description Number of workers available for this queue
             */
            workers: number;
        };
        /**
         * QueueStatusSummary
         * @description Summary statistics across all queues.
         * @example {
         *       "overall_status": "healthy",
         *       "total_queued": 45,
         *       "total_running": 8,
         *       "total_workers": 12
         *     }
         */
        QueueStatusSummary: {
            /** @description Overall health status (worst status across all queues) */
            overall_status: components["schemas"]["QueueHealthStatus"];
            /**
             * Total Queued
             * @description Total number of jobs waiting across all queues
             */
            total_queued: number;
            /**
             * Total Running
             * @description Total number of jobs currently being processed
             */
            total_running: number;
            /**
             * Total Workers
             * @description Total number of workers across all queues
             */
            total_workers: number;
        };
        /**
         * QueuesStatusResponse
         * @description Response schema for GET /api/queues/status endpoint.
         * @example {
         *       "queues": [
         *         {
         *           "depth": 15,
         *           "name": "ai_analysis",
         *           "oldest_job": {
         *             "id": "job_12345",
         *             "queued_at": "2025-12-23T10:30:00.000000",
         *             "wait_seconds": 45.2
         *           },
         *           "running": 2,
         *           "status": "healthy",
         *           "throughput": {
         *             "avg_processing_seconds": 4.8,
         *             "jobs_per_minute": 12.5
         *           },
         *           "workers": 4
         *         },
         *         {
         *           "depth": 55,
         *           "name": "detection",
         *           "running": 3,
         *           "status": "warning",
         *           "throughput": {
         *             "avg_processing_seconds": 7.3,
         *             "jobs_per_minute": 8.2
         *           },
         *           "workers": 4
         *         }
         *       ],
         *       "summary": {
         *         "overall_status": "warning",
         *         "total_queued": 70,
         *         "total_running": 5,
         *         "total_workers": 8
         *       }
         *     }
         */
        QueuesStatusResponse: {
            /**
             * Queues
             * @description Status of each queue
             */
            queues: components["schemas"]["QueueStatus"][];
            /** @description Summary statistics across all queues */
            summary: components["schemas"]["QueueStatusSummary"];
        };
        /**
         * QuietHoursPeriodCreate
         * @description Schema for creating a quiet hours period.
         * @example {
         *       "days": [
         *         "monday",
         *         "tuesday",
         *         "wednesday",
         *         "thursday",
         *         "friday"
         *       ],
         *       "end_time": "06:00:00",
         *       "label": "Night Time",
         *       "start_time": "22:00:00"
         *     }
         */
        QuietHoursPeriodCreate: {
            /**
             * Days
             * @description Days of week when period is active
             */
            days?: string[];
            /**
             * End Time
             * Format: time
             * @description End time (HH:MM:SS)
             */
            end_time: string;
            /**
             * Label
             * @description Period label
             */
            label: string;
            /**
             * Start Time
             * Format: time
             * @description Start time (HH:MM:SS)
             */
            start_time: string;
        };
        /**
         * QuietHoursPeriodResponse
         * @description Schema for quiet hours period response.
         * @example {
         *       "days": [
         *         "monday",
         *         "tuesday",
         *         "wednesday",
         *         "thursday",
         *         "friday"
         *       ],
         *       "end_time": "06:00:00",
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "label": "Night Time",
         *       "start_time": "22:00:00"
         *     }
         */
        QuietHoursPeriodResponse: {
            /**
             * Days
             * @description Days of week when period is active
             */
            days: string[];
            /**
             * End Time
             * Format: time
             * @description End time
             */
            end_time: string;
            /**
             * Id
             * @description Period UUID
             */
            id: string;
            /**
             * Label
             * @description Period label
             */
            label: string;
            /**
             * Start Time
             * Format: time
             * @description Start time
             */
            start_time: string;
        };
        /**
         * QuietHoursPeriodsListResponse
         * @description Schema for quiet hours periods list response with pagination.
         * @example {
         *       "items": [
         *         {
         *           "days": [
         *             "monday",
         *             "tuesday",
         *             "wednesday",
         *             "thursday",
         *             "friday"
         *           ],
         *           "end_time": "06:00:00",
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "label": "Night Time",
         *           "start_time": "22:00:00"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        QuietHoursPeriodsListResponse: {
            /**
             * Items
             * @description List of quiet hours periods
             */
            items: components["schemas"]["QuietHoursPeriodResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * RUMBatchRequest
         * @description Batch request for multiple Core Web Vitals metrics.
         *
         *     The frontend batches metrics to reduce API calls. Each batch may contain
         *     metrics from different pages or navigation events.
         *
         *     Attributes:
         *         metrics: List of Core Web Vital metrics to ingest
         *         session_id: Optional session identifier for correlating metrics
         *         user_agent: Optional user agent string for device/browser analysis
         * @example {
         *       "metrics": [
         *         {
         *           "delta": 2500,
         *           "id": "v1-1234567890123-1234567890123",
         *           "name": "LCP",
         *           "rating": "good",
         *           "value": 2500
         *         },
         *         {
         *           "delta": 0.02,
         *           "id": "v1-1234567890123-1234567890124",
         *           "name": "CLS",
         *           "rating": "good",
         *           "value": 0.05
         *         }
         *       ],
         *       "session_id": "sess-12345"
         *     }
         */
        RUMBatchRequest: {
            /**
             * Metrics
             * @description List of metrics to ingest (non-empty)
             */
            metrics: components["schemas"]["WebVitalMetric"][];
            /**
             * Session Id
             * @description Optional session identifier
             */
            session_id?: string | null;
            /**
             * User Agent
             * @description Optional user agent string
             */
            user_agent?: string | null;
        };
        /**
         * RUMIngestResponse
         * @description Response from the RUM metrics ingestion endpoint.
         *
         *     Attributes:
         *         success: Whether the ingestion was successful
         *         metrics_count: Number of metrics successfully ingested
         *         message: Human-readable status message
         *         errors: List of any errors encountered during ingestion
         * @example {
         *       "errors": [],
         *       "message": "Successfully ingested 5 metrics",
         *       "metrics_count": 5,
         *       "success": true
         *     }
         */
        RUMIngestResponse: {
            /**
             * Errors
             * @description List of any errors encountered
             */
            errors?: string[];
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Metrics Count
             * @description Number of metrics successfully ingested
             */
            metrics_count: number;
            /**
             * Success
             * @description Whether ingestion was successful
             */
            success: boolean;
        };
        /**
         * ReadinessResponse
         * @description Response schema for readiness probe endpoint.
         *
         *     Readiness probes indicate whether the application is ready to receive
         *     traffic and process requests. This checks all dependencies:
         *     - Database connectivity
         *     - Redis connectivity
         *     - AI services availability
         *     - Background worker status
         * @example {
         *       "ready": true,
         *       "services": {
         *         "ai": {
         *           "message": "AI services operational",
         *           "status": "healthy"
         *         },
         *         "database": {
         *           "message": "Database operational",
         *           "status": "healthy"
         *         },
         *         "redis": {
         *           "details": {
         *             "redis_version": "7.0.0"
         *           },
         *           "message": "Redis connected",
         *           "status": "healthy"
         *         }
         *       },
         *       "status": "ready",
         *       "timestamp": "2025-12-23T10:30:00",
         *       "workers": [
         *         {
         *           "name": "gpu_monitor",
         *           "running": true
         *         },
         *         {
         *           "name": "cleanup_service",
         *           "running": true
         *         }
         *       ]
         *     }
         */
        ReadinessResponse: {
            /**
             * Ai Warmth Status
             * @description Warmth status of AI models (NEM-1670). Keys are model names (e.g., 'rtdetr', 'nemotron'), values are states: 'cold', 'warming', 'warm'
             */
            ai_warmth_status?: {
                [key: string]: string;
            } | null;
            /**
             * Ready
             * @description Overall readiness status: True if system can process requests
             */
            ready: boolean;
            /**
             * Services
             * @description Status of infrastructure services (database, redis, ai)
             */
            services: {
                [key: string]: components["schemas"]["HealthCheckServiceStatus"];
            };
            /**
             * Status
             * @description Status string: 'ready', 'degraded', or 'not_ready'
             */
            status: string;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of readiness check
             */
            timestamp: string;
            /**
             * Workers
             * @description Status of background workers
             */
            workers?: components["schemas"]["WorkerStatus"][];
        };
        /**
         * RecentError
         * @description Recent error information.
         */
        RecentError: {
            /**
             * Component
             * @description Component that generated error
             */
            component: string;
            /**
             * Error Type
             * @description Type of error
             */
            error_type: string;
            /**
             * Message
             * @description Error message
             */
            message?: string | null;
            /**
             * Timestamp
             * @description ISO timestamp of error
             */
            timestamp: string;
        };
        /**
         * RecommendationItem
         * @description Single recommendation item.
         * @example {
         *       "category": "missing_context",
         *       "frequency": 25,
         *       "priority": "high",
         *       "suggestion": "Add time since last motion event to prompt"
         *     }
         */
        RecommendationItem: {
            /** Category */
            category: string;
            /** Frequency */
            frequency: number;
            /** Priority */
            priority: string;
            /** Suggestion */
            suggestion: string;
        };
        /**
         * RecommendationsResponse
         * @description Aggregated recommendations response.
         * @example {
         *       "recommendations": [
         *         {
         *           "category": "missing_context",
         *           "frequency": 25,
         *           "priority": "high",
         *           "suggestion": "Add time since last motion event"
         *         },
         *         {
         *           "category": "model_gaps",
         *           "frequency": 12,
         *           "priority": "medium",
         *           "suggestion": "Enable pet detection model"
         *         }
         *       ],
         *       "total_events_analyzed": 500
         *     }
         */
        RecommendationsResponse: {
            /** Recommendations */
            recommendations: components["schemas"]["RecommendationItem"][];
            /** Total Events Analyzed */
            total_events_analyzed: number;
        };
        /**
         * RecordingResponse
         * @description Response for a single recording.
         */
        RecordingResponse: {
            /**
             * Body Truncated
             * @description Whether body was truncated
             * @default false
             */
            body_truncated: boolean;
            /**
             * Duration Ms
             * @description Request duration in milliseconds
             */
            duration_ms: number;
            /**
             * Method
             * @description HTTP method
             */
            method: string;
            /**
             * Path
             * @description Request path
             */
            path: string;
            /**
             * Recording Id
             * @description Unique recording ID
             */
            recording_id: string;
            /**
             * Status Code
             * @description HTTP response status code
             */
            status_code: number;
            /**
             * Timestamp
             * @description ISO timestamp when recorded
             */
            timestamp: string;
        };
        /**
         * RecordingsListResponse
         * @description Response for listing recordings.
         */
        RecordingsListResponse: {
            /**
             * Recordings
             * @description List of recordings
             */
            recordings: components["schemas"]["RecordingResponse"][];
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
            /**
             * Total
             * @description Total number of recordings
             */
            total: number;
        };
        /**
         * RedisInfoResponse
         * @description Response for Redis connection stats.
         */
        RedisInfoResponse: {
            /**
             * Info
             * @description Redis INFO command output
             */
            info?: {
                [key: string]: unknown;
            } | null;
            /**
             * Pubsub
             * @description Pub/sub channel information
             */
            pubsub?: {
                [key: string]: unknown;
            } | null;
            /**
             * Status
             * @description Redis connection status (connected, unavailable)
             */
            status: string;
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * RedisMetrics
         * @description Redis cache metrics.
         * @example {
         *       "blocked_clients": 0,
         *       "connected_clients": 8,
         *       "hit_ratio": 99.5,
         *       "memory_mb": 1.5,
         *       "status": "healthy"
         *     }
         */
        RedisMetrics: {
            /**
             * Blocked Clients
             * @description Number of blocked clients
             */
            blocked_clients: number;
            /**
             * Connected Clients
             * @description Number of connected clients
             */
            connected_clients: number;
            /**
             * Hit Ratio
             * @description Cache hit ratio percentage
             */
            hit_ratio: number;
            /**
             * Memory Mb
             * @description Memory used in MB
             */
            memory_mb: number;
            /**
             * Status
             * @description Health status: healthy, unhealthy, unreachable
             */
            status: string;
        };
        /**
         * ReplayResponse
         * @description Response for request replay.
         */
        ReplayResponse: {
            /**
             * Original Status Code
             * @description Original response status code
             */
            original_status_code: number;
            /**
             * Recording Id
             * @description ID of the replayed recording
             */
            recording_id: string;
            /**
             * Replay Metadata
             * @description Metadata about the replay
             */
            replay_metadata: {
                [key: string]: unknown;
            };
            /**
             * Replay Response
             * @description Response from replayed request
             */
            replay_response: unknown;
            /**
             * Replay Status Code
             * @description Replay response status code
             */
            replay_status_code: number;
            /**
             * Timestamp
             * @description ISO timestamp of replay
             */
            timestamp: string;
        };
        /**
         * RiskHistoryDataPoint
         * @description Schema for a single risk history data point.
         * @example {
         *       "critical": 1,
         *       "date": "2025-01-07",
         *       "high": 2,
         *       "low": 10,
         *       "medium": 5
         *     }
         */
        RiskHistoryDataPoint: {
            /**
             * Critical
             * @description Count of critical risk events
             * @default 0
             */
            critical: number;
            /**
             * Date
             * Format: date
             * @description Date of the data point
             */
            date: string;
            /**
             * High
             * @description Count of high risk events
             * @default 0
             */
            high: number;
            /**
             * Low
             * @description Count of low risk events
             * @default 0
             */
            low: number;
            /**
             * Medium
             * @description Count of medium risk events
             * @default 0
             */
            medium: number;
        };
        /**
         * RiskHistoryResponse
         * @description Schema for risk score distribution over time.
         * @example {
         *       "data_points": [
         *         {
         *           "critical": 1,
         *           "date": "2025-01-01",
         *           "high": 2,
         *           "low": 10,
         *           "medium": 5
         *         },
         *         {
         *           "critical": 0,
         *           "date": "2025-01-02",
         *           "high": 3,
         *           "low": 12,
         *           "medium": 4
         *         }
         *       ],
         *       "end_date": "2025-01-02",
         *       "start_date": "2025-01-01"
         *     }
         */
        RiskHistoryResponse: {
            /**
             * Data Points
             * @description Risk level counts aggregated by day
             */
            data_points: components["schemas"]["RiskHistoryDataPoint"][];
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
        };
        /**
         * RuleTestEventResult
         * @description Schema for a single event's test result.
         * @example {
         *       "camera_id": "front_door",
         *       "event_id": 123,
         *       "matched_conditions": [
         *         "risk_score >= 70",
         *         "object_type in ['person']"
         *       ],
         *       "matches": true,
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_score": 75,
         *       "started_at": "2025-12-28T22:15:00Z"
         *     }
         */
        RuleTestEventResult: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Matched Conditions
             * @description List of conditions that matched
             */
            matched_conditions?: string[];
            /**
             * Matches
             * @description Whether the rule matched this event
             */
            matches: boolean;
            /**
             * Object Types
             * @description Detected object types
             */
            object_types?: string[];
            /**
             * Risk Score
             * @description Event risk score
             */
            risk_score?: number | null;
            /**
             * Started At
             * @description Event start timestamp
             */
            started_at?: string | null;
        };
        /**
         * RuleTestRequest
         * @description Schema for testing a rule against historical events.
         * @example {
         *       "event_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "test_time": "2025-12-28T22:30:00Z"
         *     }
         */
        RuleTestRequest: {
            /**
             * Event Ids
             * @description Specific event IDs to test against. If not provided, tests against recent events.
             */
            event_ids?: number[] | null;
            /**
             * Limit
             * @description Maximum number of recent events to test (if event_ids not provided)
             * @default 10
             */
            limit: number;
            /**
             * Test Time
             * @description Override current time for schedule testing (ISO format)
             */
            test_time?: string | null;
        };
        /**
         * RuleTestResponse
         * @description Schema for rule test response.
         * @example {
         *       "events_matched": 3,
         *       "events_tested": 10,
         *       "match_rate": 0.3,
         *       "results": [
         *         {
         *           "camera_id": "front_door",
         *           "event_id": 123,
         *           "matched_conditions": [
         *             "risk_score >= 70",
         *             "object_type in ['person']"
         *           ],
         *           "matches": true,
         *           "object_types": [
         *             "person"
         *           ],
         *           "risk_score": 75,
         *           "started_at": "2025-12-28T22:15:00Z"
         *         }
         *       ],
         *       "rule_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "rule_name": "Night Intruder Alert"
         *     }
         */
        RuleTestResponse: {
            /**
             * Events Matched
             * @description Number of events that matched the rule
             */
            events_matched: number;
            /**
             * Events Tested
             * @description Number of events tested
             */
            events_tested: number;
            /**
             * Match Rate
             * @description Proportion of events that matched (0.0-1.0)
             */
            match_rate: number;
            /**
             * Results
             * @description Per-event test results
             */
            results: components["schemas"]["RuleTestEventResult"][];
            /**
             * Rule Id
             * @description Rule ID that was tested
             */
            rule_id: string;
            /**
             * Rule Name
             * @description Rule name
             */
            rule_name: string;
        };
        /**
         * SceneChangeAcknowledgeResponse
         * @description Response schema for acknowledging a scene change.
         *
         *     Confirms that a scene change has been acknowledged.
         * @example {
         *       "acknowledged": true,
         *       "acknowledged_at": "2026-01-03T11:00:00Z",
         *       "id": 1
         *     }
         */
        SceneChangeAcknowledgeResponse: {
            /**
             * Acknowledged
             * @description Acknowledgement status (always True)
             * @default true
             */
            acknowledged: boolean;
            /**
             * Acknowledged At
             * Format: date-time
             * @description When the change was acknowledged
             */
            acknowledged_at: string;
            /**
             * Id
             * @description Scene change ID
             */
            id: number;
        };
        /**
         * SceneChangeListResponse
         * @description Response schema for listing scene changes.
         *
         *     Returns a list of scene changes for a camera with cursor-based pagination.
         * @example {
         *       "camera_id": "front_door",
         *       "has_more": true,
         *       "next_cursor": "2026-01-03T09:30:00Z",
         *       "scene_changes": [
         *         {
         *           "acknowledged": false,
         *           "change_type": "view_blocked",
         *           "detected_at": "2026-01-03T10:30:00Z",
         *           "id": 1,
         *           "similarity_score": 0.23
         *         }
         *       ],
         *       "total_changes": 1
         *     }
         */
        SceneChangeListResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Has More
             * @description Whether there are more results available
             * @default false
             */
            has_more: boolean;
            /**
             * Next Cursor
             * @description Cursor for fetching the next page (ISO 8601 timestamp)
             */
            next_cursor?: string | null;
            /**
             * Scene Changes
             * @description List of scene changes
             */
            scene_changes?: components["schemas"]["SceneChangeResponse"][];
            /**
             * Total Changes
             * @description Number of scene changes returned
             * @default 0
             */
            total_changes: number;
        };
        /**
         * SceneChangeResponse
         * @description Response schema for a single scene change.
         *
         *     Represents a detected camera view change that may indicate
         *     tampering, angle changes, or blocked views.
         * @example {
         *       "acknowledged": false,
         *       "change_type": "view_blocked",
         *       "detected_at": "2026-01-03T10:30:00Z",
         *       "file_path": "/export/foscam/front_door/image.jpg",
         *       "id": 1,
         *       "similarity_score": 0.23
         *     }
         */
        SceneChangeResponse: {
            /**
             * Acknowledged
             * @description Whether the change has been acknowledged
             * @default false
             */
            acknowledged: boolean;
            /**
             * Acknowledged At
             * @description When the change was acknowledged
             */
            acknowledged_at?: string | null;
            /**
             * Change Type
             * @description Type of change: view_blocked, angle_changed, view_tampered, unknown
             */
            change_type: string;
            /**
             * Detected At
             * Format: date-time
             * @description When the scene change was detected
             */
            detected_at: string;
            /**
             * File Path
             * @description Path to the image that triggered detection
             */
            file_path?: string | null;
            /**
             * Id
             * @description Unique scene change ID
             */
            id: number;
            /**
             * Similarity Score
             * @description SSIM similarity score (0-1, lower means more different)
             */
            similarity_score: number;
        };
        /**
         * SearchResponse
         * @description Schema for search response with pagination.
         * @example {
         *       "limit": 50,
         *       "offset": 0,
         *       "results": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "object_types": "person, vehicle",
         *           "reasoning": "Unknown individual approaching entrance during nighttime",
         *           "relevance_score": 0.85,
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Suspicious person detected near front entrance"
         *         }
         *       ],
         *       "total_count": 42
         *     }
         */
        SearchResponse: {
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
            /**
             * Results
             * @description List of search results
             */
            results: components["schemas"]["SearchResult"][];
            /**
             * Total Count
             * @description Total number of matching events
             */
            total_count: number;
        };
        /**
         * SearchResult
         * @description Schema for a single search result.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "detection_count": 5,
         *       "detection_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "ended_at": "2025-12-23T12:02:30Z",
         *       "id": 1,
         *       "object_types": "person, vehicle",
         *       "reasoning": "Unknown individual approaching entrance during nighttime hours",
         *       "relevance_score": 0.85,
         *       "reviewed": false,
         *       "risk_level": "medium",
         *       "risk_score": 75,
         *       "started_at": "2025-12-23T12:00:00Z",
         *       "summary": "Suspicious person detected near front entrance"
         *     }
         */
        SearchResult: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera display name
             */
            camera_name?: string | null;
            /**
             * Detection Count
             * @description Number of detections in this event
             * @default 0
             */
            detection_count: number;
            /**
             * Detection Ids
             * @description List of detection IDs associated with this event
             */
            detection_ids?: number[];
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /**
             * Id
             * @description Event ID
             */
            id: number;
            /**
             * Object Types
             * @description Comma-separated detected object types
             */
            object_types?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning for risk score
             */
            reasoning?: string | null;
            /**
             * Relevance Score
             * @description Full-text search relevance score (higher is more relevant)
             * @default 0
             */
            relevance_score: number;
            /**
             * Reviewed
             * @description Whether event has been reviewed
             * @default false
             */
            reviewed: boolean;
            /**
             * Risk Level
             * @description Risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score?: number | null;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Summary
             * @description LLM-generated event summary
             */
            summary?: string | null;
        };
        /**
         * SeedCamerasRequest
         * @description Request schema for seeding cameras.
         */
        SeedCamerasRequest: {
            /**
             * Clear Existing
             * @description Remove existing cameras first
             * @default false
             */
            clear_existing: boolean;
            /**
             * Count
             * @description Number of cameras to create (1-6)
             * @default 6
             */
            count: number;
            /**
             * Create Folders
             * @description Create camera folders on filesystem
             * @default false
             */
            create_folders: boolean;
        };
        /**
         * SeedCamerasResponse
         * @description Response schema for seed cameras endpoint.
         */
        SeedCamerasResponse: {
            /** Cameras */
            cameras: {
                [key: string]: unknown;
            }[];
            /** Cleared */
            cleared: number;
            /** Created */
            created: number;
        };
        /**
         * SeedEventsRequest
         * @description Request schema for seeding events.
         */
        SeedEventsRequest: {
            /**
             * Clear Existing
             * @description Remove existing events and detections
             * @default false
             */
            clear_existing: boolean;
            /**
             * Count
             * @description Number of events to create (1-100)
             * @default 15
             */
            count: number;
        };
        /**
         * SeedEventsResponse
         * @description Response schema for seed events endpoint.
         */
        SeedEventsResponse: {
            /** Detections Cleared */
            detections_cleared: number;
            /** Detections Created */
            detections_created: number;
            /** Events Cleared */
            events_cleared: number;
            /** Events Created */
            events_created: number;
        };
        /**
         * ServiceActionResponse
         * @description Response for service action endpoints (restart, enable, disable, start).
         *
         *     Returned after POST /api/system/services/{name}/restart, enable, disable, or start.
         * @example {
         *       "message": "Service restarted successfully",
         *       "service": {
         *         "category": "ai",
         *         "container_id": "abc123...",
         *         "display_name": "RT-DETRv2",
         *         "enabled": true,
         *         "failure_count": 0,
         *         "image": "ghcr.io/.../rtdetr:latest",
         *         "last_restart_at": "2026-01-05T15:50:00Z",
         *         "name": "ai-detector",
         *         "port": 8090,
         *         "restart_count": 3,
         *         "status": "starting"
         *       },
         *       "success": true
         *     }
         */
        ServiceActionResponse: {
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
            /** @description Updated service information after the action */
            service: components["schemas"]["ServiceInfo"];
            /**
             * Success
             * @description Whether the action completed successfully
             */
            success: boolean;
        };
        /**
         * ServiceCategory
         * @description Service category for classification and restart policy.
         *
         *     Categories determine restart behavior and priority:
         *     - INFRASTRUCTURE: Critical services (PostgreSQL, Redis) with aggressive restart
         *     - AI: AI/ML services with standard backoff
         *     - MONITORING: Optional monitoring services with lenient restart
         * @enum {string}
         */
        ServiceCategory: "infrastructure" | "ai" | "monitoring";
        /**
         * ServiceHealthState
         * @description Health state for a service in the full health check.
         *
         *     States:
         *     - healthy: Service is fully operational
         *     - unhealthy: Service is down or experiencing critical issues
         *     - degraded: Service is partially operational
         *     - unknown: Service status cannot be determined
         * @enum {string}
         */
        ServiceHealthState: "healthy" | "unhealthy" | "degraded" | "unknown";
        /**
         * ServiceHealthStatusResponse
         * @description Health status of a registered service.
         */
        ServiceHealthStatusResponse: {
            /**
             * Consecutive Failures
             * @description Count of consecutive health check failures
             */
            consecutive_failures: number;
            /**
             * Error Message
             * @description Last error message if unhealthy
             */
            error_message?: string | null;
            /**
             * Last Check
             * @description Monotonic time of last health check
             */
            last_check?: number | null;
            /**
             * Name
             * @description Service name
             */
            name: string;
            /**
             * Status
             * @description Health status (healthy, unhealthy, unknown)
             */
            status: string;
        };
        /**
         * ServiceInfo
         * @description Information about a single managed service.
         *
         *     Contains identity, configuration, and runtime status for a container
         *     managed by the orchestrator.
         * @example {
         *       "category": "ai",
         *       "container_id": "abc123def456",
         *       "display_name": "RT-DETRv2",
         *       "enabled": true,
         *       "failure_count": 0,
         *       "image": "ghcr.io/.../rtdetr:latest",
         *       "last_restart_at": "2026-01-05T10:30:00Z",
         *       "name": "ai-detector",
         *       "port": 8090,
         *       "restart_count": 2,
         *       "status": "running",
         *       "uptime_seconds": 3600
         *     }
         */
        ServiceInfo: {
            /** @description Service category: infrastructure, ai, or monitoring */
            category: components["schemas"]["ServiceCategory"];
            /**
             * Container Id
             * @description Docker container ID (short form)
             */
            container_id?: string | null;
            /**
             * Display Name
             * @description Human-readable display name (e.g., 'RT-DETRv2', 'PostgreSQL')
             */
            display_name: string;
            /**
             * Enabled
             * @description Whether auto-restart is enabled for this service
             * @default true
             */
            enabled: boolean;
            /**
             * Failure Count
             * @description Consecutive health check failure count
             * @default 0
             */
            failure_count: number;
            /**
             * Image
             * @description Container image (e.g., 'postgres:16-alpine', 'ghcr.io/.../rtdetr:latest')
             */
            image?: string | null;
            /**
             * Last Restart At
             * @description Timestamp of last restart (null if never restarted)
             */
            last_restart_at?: string | null;
            /**
             * Name
             * @description Service identifier (e.g., 'ai-detector', 'postgres', 'grafana')
             */
            name: string;
            /**
             * Port
             * @description Primary service port
             */
            port: number;
            /**
             * Restart Count
             * @description Total restarts since backend boot
             * @default 0
             */
            restart_count: number;
            /** @description Current service status: running, starting, unhealthy, stopped, disabled, not_found */
            status: components["schemas"]["ContainerServiceStatus"];
            /**
             * Uptime Seconds
             * @description Seconds since container started (null if not running)
             */
            uptime_seconds?: number | null;
        };
        /**
         * ServicesResponse
         * @description Response for GET /api/system/services.
         *
         *     Returns a list of all managed services with their current status
         *     and category-level summaries.
         * @example {
         *       "by_category": {
         *         "ai": {
         *           "healthy": 3,
         *           "total": 5,
         *           "unhealthy": 2
         *         },
         *         "infrastructure": {
         *           "healthy": 2,
         *           "total": 2,
         *           "unhealthy": 0
         *         },
         *         "monitoring": {
         *           "healthy": 4,
         *           "total": 4,
         *           "unhealthy": 0
         *         }
         *       },
         *       "services": [
         *         {
         *           "category": "infrastructure",
         *           "container_id": "def456...",
         *           "display_name": "PostgreSQL",
         *           "enabled": true,
         *           "failure_count": 0,
         *           "image": "postgres:16-alpine",
         *           "name": "postgres",
         *           "port": 5432,
         *           "restart_count": 0,
         *           "status": "running",
         *           "uptime_seconds": 86400
         *         },
         *         {
         *           "category": "ai",
         *           "container_id": "abc123...",
         *           "display_name": "RT-DETRv2",
         *           "enabled": true,
         *           "failure_count": 0,
         *           "image": "ghcr.io/.../rtdetr:latest",
         *           "last_restart_at": "2026-01-05T10:30:00Z",
         *           "name": "ai-detector",
         *           "port": 8090,
         *           "restart_count": 2,
         *           "status": "running",
         *           "uptime_seconds": 3600
         *         }
         *       ],
         *       "timestamp": "2026-01-05T15:45:00Z"
         *     }
         */
        ServicesResponse: {
            /**
             * By Category
             * @description Health summary by category (infrastructure, ai, monitoring)
             */
            by_category: {
                [key: string]: components["schemas"]["CategorySummary"];
            };
            /**
             * Services
             * @description List of all managed services with current status
             */
            services: components["schemas"]["ServiceInfo"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * SeverityDefinitionResponse
         * @description Definition of a single severity level.
         * @example {
         *       "color": "#f97316",
         *       "description": "Concerning activity, review soon",
         *       "label": "High",
         *       "max_score": 84,
         *       "min_score": 60,
         *       "priority": 1,
         *       "severity": "high"
         *     }
         */
        SeverityDefinitionResponse: {
            /**
             * Color
             * @description Hex color code for UI display (e.g., '#22c55e')
             */
            color: string;
            /**
             * Description
             * @description Description of when this severity applies
             */
            description: string;
            /**
             * Label
             * @description Human-readable label for the severity level
             */
            label: string;
            /**
             * Max Score
             * @description Maximum risk score for this severity (inclusive)
             */
            max_score: number;
            /**
             * Min Score
             * @description Minimum risk score for this severity (inclusive)
             */
            min_score: number;
            /**
             * Priority
             * @description Sort priority (0 = highest priority, 3 = lowest)
             */
            priority: number;
            /** @description The severity level identifier */
            severity: components["schemas"]["SeverityEnum"];
        };
        /**
         * SeverityEnum
         * @description Severity levels for API responses.
         * @enum {string}
         */
        SeverityEnum: "low" | "medium" | "high" | "critical";
        /**
         * SeverityMetadataResponse
         * @description Response schema for severity metadata endpoint.
         *
         *     Provides complete information about severity levels including:
         *     - All severity definitions with thresholds and colors
         *     - Current threshold configuration
         *     - Useful for frontend to display severity information consistently
         * @example {
         *       "definitions": [
         *         {
         *           "color": "#22c55e",
         *           "description": "Routine activity, no concern",
         *           "label": "Low",
         *           "max_score": 29,
         *           "min_score": 0,
         *           "priority": 3,
         *           "severity": "low"
         *         },
         *         {
         *           "color": "#eab308",
         *           "description": "Notable activity, worth reviewing",
         *           "label": "Medium",
         *           "max_score": 59,
         *           "min_score": 30,
         *           "priority": 2,
         *           "severity": "medium"
         *         },
         *         {
         *           "color": "#f97316",
         *           "description": "Concerning activity, review soon",
         *           "label": "High",
         *           "max_score": 84,
         *           "min_score": 60,
         *           "priority": 1,
         *           "severity": "high"
         *         },
         *         {
         *           "color": "#ef4444",
         *           "description": "Immediate attention required",
         *           "label": "Critical",
         *           "max_score": 100,
         *           "min_score": 85,
         *           "priority": 0,
         *           "severity": "critical"
         *         }
         *       ],
         *       "thresholds": {
         *         "high_max": 84,
         *         "low_max": 29,
         *         "medium_max": 59
         *       }
         *     }
         */
        SeverityMetadataResponse: {
            /**
             * Definitions
             * @description List of all severity level definitions
             */
            definitions: components["schemas"]["SeverityDefinitionResponse"][];
            /** @description Current severity threshold configuration */
            thresholds: components["schemas"]["SeverityThresholds"];
        };
        /**
         * SeverityThresholds
         * @description Current severity threshold configuration.
         * @example {
         *       "high_max": 84,
         *       "low_max": 29,
         *       "medium_max": 59
         *     }
         */
        SeverityThresholds: {
            /**
             * High Max
             * @description Maximum risk score for HIGH severity (medium_max+1 to this value = HIGH)
             */
            high_max: number;
            /**
             * Low Max
             * @description Maximum risk score for LOW severity (0 to this value = LOW)
             */
            low_max: number;
            /**
             * Medium Max
             * @description Maximum risk score for MEDIUM severity (low_max+1 to this value = MEDIUM)
             */
            medium_max: number;
        };
        /**
         * SeverityThresholdsUpdateRequest
         * @description Request schema for updating severity thresholds.
         *
         *     The thresholds must form contiguous ranges from 0-100:
         *     - LOW: 0 to low_max (inclusive)
         *     - MEDIUM: low_max+1 to medium_max (inclusive)
         *     - HIGH: medium_max+1 to high_max (inclusive)
         *     - CRITICAL: high_max+1 to 100 (inclusive)
         *
         *     Validation rules:
         *     - 0 < low_max < medium_max < high_max < 100
         *     - This ensures all ranges are valid and cover 0-100 without gaps or overlaps
         * @example {
         *       "high_max": 84,
         *       "low_max": 29,
         *       "medium_max": 59
         *     }
         */
        SeverityThresholdsUpdateRequest: {
            /**
             * High Max
             * @description Maximum risk score for HIGH severity (3-99)
             */
            high_max: number;
            /**
             * Low Max
             * @description Maximum risk score for LOW severity (1-98)
             */
            low_max: number;
            /**
             * Medium Max
             * @description Maximum risk score for MEDIUM severity (2-99)
             */
            medium_max: number;
        };
        /**
         * SourceFilter
         * @description Data source for entity queries.
         *
         *     Controls which storage backend to query for entities:
         *     - redis: Only query Redis hot cache (24h window)
         *     - postgres: Only query PostgreSQL (30d retention)
         *     - both: Query both and merge results (default)
         * @enum {string}
         */
        SourceFilter: "redis" | "postgres" | "both";
        /**
         * StageLatency
         * @description Latency statistics for a single pipeline stage.
         * @example {
         *       "avg_ms": 150.5,
         *       "max_ms": 500,
         *       "min_ms": 50,
         *       "p50_ms": 120,
         *       "p95_ms": 400,
         *       "p99_ms": 480,
         *       "sample_count": 100
         *     }
         */
        StageLatency: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms?: number | null;
            /**
             * Max Ms
             * @description Maximum latency in milliseconds
             */
            max_ms?: number | null;
            /**
             * Min Ms
             * @description Minimum latency in milliseconds
             */
            min_ms?: number | null;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms?: number | null;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms?: number | null;
            /**
             * P99 Ms
             * @description 99th percentile latency in milliseconds
             */
            p99_ms?: number | null;
            /**
             * Sample Count
             * @description Number of samples used to calculate statistics
             */
            sample_count: number;
        };
        /**
         * StorageCategoryStats
         * @description Storage statistics for a single category.
         */
        StorageCategoryStats: {
            /**
             * File Count
             * @description Number of files in this category
             */
            file_count: number;
            /**
             * Size Bytes
             * @description Total size in bytes for this category
             */
            size_bytes: number;
        };
        /**
         * StorageStatsResponse
         * @description Response schema for storage statistics endpoint.
         *
         *     Provides detailed storage usage information including:
         *     - Disk usage for the storage volume
         *     - Breakdown by data category (thumbnails, images, clips)
         *     - Database record counts
         * @example {
         *       "clips": {
         *         "file_count": 50,
         *         "size_bytes": 500000000
         *       },
         *       "detections_count": 892,
         *       "disk_free_bytes": 429496729600,
         *       "disk_total_bytes": 536870912000,
         *       "disk_usage_percent": 20,
         *       "disk_used_bytes": 107374182400,
         *       "events_count": 156,
         *       "gpu_stats_count": 2880,
         *       "images": {
         *         "file_count": 10000,
         *         "size_bytes": 5000000000
         *       },
         *       "logs_count": 5000,
         *       "thumbnails": {
         *         "file_count": 1500,
         *         "size_bytes": 75000000
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        StorageStatsResponse: {
            /** @description Storage used by event video clips */
            clips: components["schemas"]["StorageCategoryStats"];
            /**
             * Detections Count
             * @description Total number of detections in database
             */
            detections_count: number;
            /**
             * Disk Free Bytes
             * @description Free disk space in bytes
             */
            disk_free_bytes: number;
            /**
             * Disk Total Bytes
             * @description Total disk space available in bytes
             */
            disk_total_bytes: number;
            /**
             * Disk Usage Percent
             * @description Disk usage percentage (0-100)
             */
            disk_usage_percent: number;
            /**
             * Disk Used Bytes
             * @description Total disk space used in bytes
             */
            disk_used_bytes: number;
            /**
             * Events Count
             * @description Total number of events in database
             */
            events_count: number;
            /**
             * Gpu Stats Count
             * @description Total number of GPU stats records in database
             */
            gpu_stats_count: number;
            /** @description Storage used by original camera images */
            images: components["schemas"]["StorageCategoryStats"];
            /**
             * Logs Count
             * @description Total number of log entries in database
             */
            logs_count: number;
            /** @description Storage used by detection thumbnails */
            thumbnails: components["schemas"]["StorageCategoryStats"];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of storage stats snapshot
             */
            timestamp: string;
        };
        /**
         * SupervisedWorkerInfo
         * @description Information about a supervised worker.
         *
         *     Provides detailed status and restart metrics for a single worker
         *     managed by the WorkerSupervisor.
         * @example {
         *       "last_started_at": "2026-01-13T10:30:00Z",
         *       "max_restarts": 5,
         *       "name": "detection_worker",
         *       "restart_count": 0,
         *       "status": "running"
         *     }
         */
        SupervisedWorkerInfo: {
            /**
             * Error
             * @description Last error message if worker crashed
             */
            error?: string | null;
            /**
             * Last Crashed At
             * @description When the worker last crashed
             */
            last_crashed_at?: string | null;
            /**
             * Last Started At
             * @description When the worker was last started
             */
            last_started_at?: string | null;
            /**
             * Max Restarts
             * @description Maximum allowed restart attempts before failing
             */
            max_restarts: number;
            /**
             * Name
             * @description Unique identifier for the worker
             */
            name: string;
            /**
             * Restart Count
             * @description Number of times the worker has been restarted
             */
            restart_count: number;
            /** @description Current health status of the worker */
            status: components["schemas"]["SupervisedWorkerStatusEnum"];
        };
        /**
         * SupervisedWorkerStatusEnum
         * @description Status enum for supervised workers.
         * @enum {string}
         */
        SupervisedWorkerStatusEnum: "running" | "stopped" | "crashed" | "restarting" | "failed";
        /**
         * SystemStatsResponse
         * @description Response schema for system statistics endpoint.
         * @example {
         *       "total_cameras": 4,
         *       "total_detections": 892,
         *       "total_events": 156,
         *       "uptime_seconds": 86400.5
         *     }
         */
        SystemStatsResponse: {
            /**
             * Total Cameras
             * @description Total number of cameras in the system
             */
            total_cameras: number;
            /**
             * Total Detections
             * @description Total number of detections recorded
             */
            total_detections: number;
            /**
             * Total Events
             * @description Total number of events recorded
             */
            total_events: number;
            /**
             * Uptime Seconds
             * @description Application uptime in seconds
             */
            uptime_seconds: number;
        };
        /**
         * TargetHealth
         * @description Health status for a single Prometheus scrape target.
         * @example {
         *       "health": "up",
         *       "instance": "backend:8000",
         *       "job": "hsi-backend-metrics",
         *       "labels": {
         *         "service": "home-security-intelligence"
         *       },
         *       "last_scrape": "2026-01-13T10:30:00Z",
         *       "scrape_duration_seconds": 0.025
         *     }
         */
        TargetHealth: {
            /**
             * Health
             * @description Target health: 'up' or 'down'
             */
            health: string;
            /**
             * Instance
             * @description Target instance identifier (typically host:port)
             */
            instance: string;
            /**
             * Job
             * @description Job name this target belongs to
             */
            job: string;
            /**
             * Labels
             * @description Labels associated with this target
             */
            labels?: {
                [key: string]: string;
            };
            /**
             * Last Error
             * @description Error from last failed scrape (if any)
             */
            last_error?: string | null;
            /**
             * Last Scrape
             * @description Timestamp of last scrape attempt
             */
            last_scrape?: string | null;
            /**
             * Scrape Duration Seconds
             * @description Duration of last scrape in seconds
             */
            scrape_duration_seconds?: number | null;
        };
        /**
         * TelemetryResponse
         * @description Response schema for pipeline telemetry endpoint.
         *
         *     Provides real-time visibility into:
         *     - Queue depths: How many items are waiting in detection/analysis queues
         *     - Stage latencies: How long each pipeline stage is taking
         *
         *     This helps operators:
         *     - Identify pipeline bottlenecks
         *     - Detect backlog situations
         *     - Monitor processing performance
         *     - Debug pipeline stalls
         * @example {
         *       "latencies": {
         *         "detect": {
         *           "avg_ms": 200,
         *           "max_ms": 800,
         *           "min_ms": 100,
         *           "p50_ms": 180,
         *           "p95_ms": 600,
         *           "p99_ms": 750,
         *           "sample_count": 500
         *         },
         *         "watch": {
         *           "avg_ms": 10,
         *           "max_ms": 50,
         *           "min_ms": 5,
         *           "p50_ms": 8,
         *           "p95_ms": 40,
         *           "p99_ms": 48,
         *           "sample_count": 500
         *         }
         *       },
         *       "queues": {
         *         "analysis_queue": 2,
         *         "detection_queue": 5
         *       },
         *       "timestamp": "2025-12-27T10:30:00Z"
         *     }
         */
        TelemetryResponse: {
            /** @description Latency statistics for each pipeline stage */
            latencies?: components["schemas"]["PipelineLatencies"] | null;
            /** @description Current queue depths for detection and analysis queues */
            queues: components["schemas"]["QueueDepths"];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of telemetry snapshot
             */
            timestamp: string;
        };
        /**
         * TestNotificationResponse
         * @description Schema for test notification result.
         * @example {
         *       "channel": "email",
         *       "message": "Test email sent successfully to test@example.com",
         *       "success": true
         *     }
         */
        TestNotificationResponse: {
            /** @description Channel that was tested */
            channel: components["schemas"]["NotificationChannel"];
            /**
             * Error
             * @description Error message if test failed
             */
            error?: string | null;
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
            /**
             * Success
             * @description Whether the test was successful
             */
            success: boolean;
        };
        /**
         * ThroughputMetrics
         * @description Throughput metrics for a queue.
         * @example {
         *       "avg_processing_seconds": 4.8,
         *       "jobs_per_minute": 12.5
         *     }
         */
        ThroughputMetrics: {
            /**
             * Avg Processing Seconds
             * @description Average time to process a job in seconds
             */
            avg_processing_seconds: number;
            /**
             * Jobs Per Minute
             * @description Average number of jobs processed per minute
             */
            jobs_per_minute: number;
        };
        /**
         * TimeRange
         * @description Time range options for historical data.
         * @enum {string}
         */
        TimeRange: "5m" | "15m" | "60m";
        /**
         * UserCalibrationResponse
         * @description Schema for user calibration response.
         *
         *     Returned when retrieving or modifying calibration settings.
         *     Includes feedback counts to show calibration history.
         * @example {
         *       "created_at": "2025-01-01T12:00:00Z",
         *       "decay_factor": 0.1,
         *       "false_positive_count": 5,
         *       "high_threshold": 85,
         *       "id": 1,
         *       "low_threshold": 30,
         *       "medium_threshold": 60,
         *       "missed_threat_count": 3,
         *       "updated_at": "2025-01-01T12:00:00Z",
         *       "user_id": "default"
         *     }
         */
        UserCalibrationResponse: {
            /**
             * Created At
             * Format: date-time
             * @description When calibration was created
             */
            created_at: string;
            /**
             * Decay Factor
             * @description Learning rate for threshold adjustment (0.0-1.0)
             */
            decay_factor: number;
            /**
             * False Positive Count
             * @description Number of false positive feedbacks received
             */
            false_positive_count: number;
            /**
             * High Threshold
             * @description Score threshold for high risk (0-100)
             */
            high_threshold: number;
            /**
             * Id
             * @description Calibration record ID
             */
            id: number;
            /**
             * Low Threshold
             * @description Score threshold for low risk (0-100)
             */
            low_threshold: number;
            /**
             * Medium Threshold
             * @description Score threshold for medium risk (0-100)
             */
            medium_threshold: number;
            /**
             * Missed Threat Count
             * @description Number of missed threat feedbacks received
             */
            missed_threat_count: number;
            /**
             * Updated At
             * Format: date-time
             * @description When calibration was last modified
             */
            updated_at: string;
            /**
             * User Id
             * @description User identifier
             */
            user_id: string;
        };
        /**
         * UserCalibrationUpdate
         * @description Schema for updating user calibration settings.
         *
         *     All fields are optional - only provided fields will be updated.
         *     When all three thresholds are provided, ordering is validated
         *     (low < medium < high).
         * @example {
         *       "decay_factor": 0.15,
         *       "high_threshold": 80,
         *       "low_threshold": 25,
         *       "medium_threshold": 55
         *     }
         */
        UserCalibrationUpdate: {
            /**
             * Decay Factor
             * @description Learning rate for threshold adjustment (0.0-1.0)
             */
            decay_factor?: number | null;
            /**
             * High Threshold
             * @description Score threshold for high risk classification (0-100)
             */
            high_threshold?: number | null;
            /**
             * Low Threshold
             * @description Score threshold for low risk classification (0-100)
             */
            low_threshold?: number | null;
            /**
             * Medium Threshold
             * @description Score threshold for medium risk classification (0-100)
             */
            medium_threshold?: number | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * VehicleEnrichment
         * @description Vehicle classification results.
         * @example {
         *       "color": "silver",
         *       "confidence": 0.91,
         *       "is_commercial": false,
         *       "type": "sedan"
         *     }
         */
        VehicleEnrichment: {
            /**
             * Color
             * @description Vehicle color (if detected)
             */
            color?: string | null;
            /**
             * Confidence
             * @description Classification confidence
             */
            confidence?: number | null;
            /**
             * Damage Detected
             * @description Whether vehicle damage was detected
             */
            damage_detected?: boolean | null;
            /**
             * Damage Types
             * @description Types of damage detected
             */
            damage_types?: string[] | null;
            /**
             * Is Commercial
             * @description Whether vehicle is commercial/delivery
             */
            is_commercial?: boolean | null;
            /**
             * Type
             * @description Vehicle type (sedan, suv, truck, etc.)
             */
            type?: string | null;
        };
        /**
         * ViolenceEnrichment
         * @description Violence detection results.
         * @example {
         *       "confidence": 0.88,
         *       "detected": false,
         *       "score": 0.12
         *     }
         */
        ViolenceEnrichment: {
            /**
             * Confidence
             * @description Model confidence
             */
            confidence?: number | null;
            /**
             * Detected
             * @description Whether violence was detected
             * @default false
             */
            detected: boolean;
            /**
             * Score
             * @description Violence probability score
             * @default 0
             */
            score: number;
        };
        /**
         * WeatherEnrichment
         * @description Weather classification results.
         * @example {
         *       "condition": "clear",
         *       "confidence": 0.95
         *     }
         */
        WeatherEnrichment: {
            /**
             * Condition
             * @description Weather condition (clear, rain, fog, etc.)
             */
            condition?: string | null;
            /**
             * Confidence
             * @description Classification confidence
             */
            confidence?: number | null;
        };
        /**
         * WebSocketBroadcasterStatus
         * @description Status of a WebSocket broadcaster's circuit breaker.
         */
        WebSocketBroadcasterStatus: {
            /**
             * Failure Count
             * @description Current consecutive failure count
             */
            failure_count: number;
            /**
             * Is Degraded
             * @description Whether the broadcaster is in degraded mode
             */
            is_degraded: boolean;
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
            /** @description Current circuit state: closed (normal), open (failing), half_open (testing), unavailable (not initialized) */
            state: components["schemas"]["CircuitBreakerStateEnum"];
        };
        /**
         * WebSocketConnectionsResponse
         * @description Response for WebSocket connection states.
         */
        WebSocketConnectionsResponse: {
            /** @description Event broadcaster status */
            event_broadcaster: components["schemas"]["DebugWebSocketBroadcasterStatus"];
            /** @description System broadcaster status */
            system_broadcaster: components["schemas"]["DebugWebSocketBroadcasterStatus"];
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * WebSocketHealthResponse
         * @description Response schema for WebSocket health endpoint.
         * @example {
         *       "event_broadcaster": {
         *         "failure_count": 0,
         *         "is_degraded": false,
         *         "state": "closed"
         *       },
         *       "system_broadcaster": {
         *         "failure_count": 0,
         *         "is_degraded": false,
         *         "state": "closed"
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        WebSocketHealthResponse: {
            /** @description Status of the event broadcaster circuit breaker */
            event_broadcaster?: components["schemas"]["WebSocketBroadcasterStatus"] | null;
            /** @description Status of the system broadcaster circuit breaker */
            system_broadcaster?: components["schemas"]["WebSocketBroadcasterStatus"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of health check
             */
            timestamp: string;
        };
        /**
         * WebVitalMetric
         * @description A single Core Web Vital metric measurement from the frontend.
         *
         *     This schema matches the structure returned by the web-vitals library's
         *     onLCP, onFID, onINP, onCLS, onTTFB, and onFCP functions.
         *
         *     Attributes:
         *         name: The Core Web Vital metric name (LCP, FID, INP, CLS, TTFB, FCP)
         *         value: The metric value (milliseconds for most, dimensionless for CLS)
         *         rating: Performance rating based on thresholds (good, needs-improvement, poor)
         *         delta: The delta since the last report (for CLS this accumulates)
         *         id: Unique identifier for this metric instance
         *         navigationType: The type of navigation (navigate, reload, back_forward, prerender)
         *         path: The page path where the metric was measured
         * @example {
         *       "delta": 2500,
         *       "id": "v1-1234567890123-1234567890123",
         *       "name": "LCP",
         *       "navigationType": "navigate",
         *       "path": "/dashboard",
         *       "rating": "good",
         *       "value": 2500
         *     }
         */
        WebVitalMetric: {
            /**
             * Delta
             * @description Delta since last report
             */
            delta: number;
            /**
             * Id
             * @description Unique metric identifier from web-vitals
             */
            id: string;
            /** @description Core Web Vital metric name */
            name: components["schemas"]["WebVitalName"];
            /**
             * Navigationtype
             * @description Navigation type (navigate, reload, back_forward, prerender)
             */
            navigationType?: string | null;
            /**
             * Path
             * @description Page path where metric was measured
             */
            path?: string | null;
            /**
             * Rating
             * @description Performance rating
             * @enum {string}
             */
            rating: "good" | "needs-improvement" | "poor";
            /**
             * Value
             * @description Metric value (ms for most, dimensionless for CLS)
             */
            value: number;
        };
        /**
         * WebVitalName
         * @description Supported Core Web Vitals metric names.
         *
         *     These correspond to the metrics collected by the web-vitals library.
         * @enum {string}
         */
        WebVitalName: "LCP" | "FID" | "INP" | "CLS" | "TTFB" | "FCP";
        /**
         * WebhookTestNotificationRequest
         * @description Schema for testing notification configuration.
         * @example {
         *       "channel": "email",
         *       "email_recipients": [
         *         "test@example.com"
         *       ]
         *     }
         */
        WebhookTestNotificationRequest: {
            /** @description Channel to test */
            channel: components["schemas"]["NotificationChannel"];
            /**
             * Email Recipients
             * @description Email recipients for email test
             */
            email_recipients?: string[] | null;
            /**
             * Webhook Url
             * @description Webhook URL for webhook test. Must be HTTPS and not point to private IPs.
             */
            webhook_url?: string | null;
        };
        /**
         * WorkerHealthStatus
         * @description Health status for a background worker.
         *
         *     Workers are background processes that perform periodic or event-driven tasks.
         * @example {
         *       "critical": true,
         *       "name": "file_watcher",
         *       "running": true
         *     }
         */
        WorkerHealthStatus: {
            /**
             * Critical
             * @description Whether this worker is critical for system operation
             */
            critical: boolean;
            /**
             * Name
             * @description Worker name (e.g., 'file_watcher')
             */
            name: string;
            /**
             * Running
             * @description Whether the worker is currently running
             */
            running: boolean;
        };
        /**
         * WorkerStatus
         * @description Status information for a background worker/service.
         */
        WorkerStatus: {
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
            /**
             * Name
             * @description Worker/service name
             */
            name: string;
            /**
             * Running
             * @description Whether the worker is currently running
             */
            running: boolean;
        };
        /**
         * WorkerSupervisorStatusResponse
         * @description Response schema for worker supervisor status endpoint.
         *
         *     Provides overall supervisor status and detailed information about
         *     all supervised workers including their health status and restart metrics.
         * @example {
         *       "running": true,
         *       "timestamp": "2026-01-13T10:35:00Z",
         *       "worker_count": 4,
         *       "workers": [
         *         {
         *           "last_started_at": "2026-01-13T10:30:00Z",
         *           "max_restarts": 5,
         *           "name": "detection_worker",
         *           "restart_count": 0,
         *           "status": "running"
         *         },
         *         {
         *           "error": "Connection timeout",
         *           "last_crashed_at": "2026-01-13T10:30:30Z",
         *           "last_started_at": "2026-01-13T10:31:00Z",
         *           "max_restarts": 5,
         *           "name": "analysis_worker",
         *           "restart_count": 1,
         *           "status": "running"
         *         }
         *       ]
         *     }
         */
        WorkerSupervisorStatusResponse: {
            /**
             * Running
             * @description Whether the supervisor is currently running
             */
            running: boolean;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status query
             */
            timestamp: string;
            /**
             * Worker Count
             * @description Total number of registered workers
             */
            worker_count: number;
            /**
             * Workers
             * @description Detailed status of all supervised workers
             */
            workers?: components["schemas"]["SupervisedWorkerInfo"][];
        };
        /**
         * ZoneCreate
         * @description Schema for creating a new zone.
         * @example {
         *       "color": "#3B82F6",
         *       "coordinates": [
         *         [
         *           0.1,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.8
         *         ],
         *         [
         *           0.1,
         *           0.8
         *         ]
         *       ],
         *       "enabled": true,
         *       "name": "Front Door",
         *       "priority": 1,
         *       "shape": "rectangle",
         *       "zone_type": "entry_point"
         *     }
         */
        ZoneCreate: {
            /**
             * Color
             * @description Hex color for UI display
             * @default #3B82F6
             */
            color: string;
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates: number[][];
            /**
             * Enabled
             * @description Whether zone is active
             * @default true
             */
            enabled: boolean;
            /**
             * Name
             * @description Zone name
             */
            name: string;
            /**
             * Priority
             * @description Priority for overlapping zones (higher = more important)
             * @default 0
             */
            priority: number;
            /**
             * @description Shape of the zone
             * @default rectangle
             */
            shape: components["schemas"]["ZoneShape"];
            /**
             * @description Type of zone
             * @default other
             */
            zone_type: components["schemas"]["ZoneType"];
        };
        /**
         * ZoneListResponse
         * @description Schema for zone list response.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "color": "#3B82F6",
         *           "coordinates": [
         *             [
         *               0.1,
         *               0.2
         *             ],
         *             [
         *               0.3,
         *               0.2
         *             ],
         *             [
         *               0.3,
         *               0.8
         *             ],
         *             [
         *               0.1,
         *               0.8
         *             ]
         *           ],
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "enabled": true,
         *           "id": "123e4567-e89b-12d3-a456-426614174000",
         *           "name": "Front Door",
         *           "priority": 1,
         *           "shape": "rectangle",
         *           "updated_at": "2025-12-23T12:00:00Z",
         *           "zone_type": "entry_point"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        ZoneListResponse: {
            /**
             * Items
             * @description List of zones
             */
            items: components["schemas"]["ZoneResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * ZoneResponse
         * @description Schema for zone response.
         * @example {
         *       "camera_id": "front_door",
         *       "color": "#3B82F6",
         *       "coordinates": [
         *         [
         *           0.1,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.8
         *         ],
         *         [
         *           0.1,
         *           0.8
         *         ]
         *       ],
         *       "created_at": "2025-12-23T10:00:00Z",
         *       "enabled": true,
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "name": "Front Door",
         *       "priority": 1,
         *       "shape": "rectangle",
         *       "updated_at": "2025-12-23T12:00:00Z",
         *       "zone_type": "entry_point"
         *     }
         */
        ZoneResponse: {
            /**
             * Camera Id
             * @description Camera ID this zone belongs to
             */
            camera_id: string;
            /**
             * Color
             * @description Hex color for UI display
             */
            color: string;
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates: number[][];
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when zone was created
             */
            created_at: string;
            /**
             * Enabled
             * @description Whether zone is active
             */
            enabled: boolean;
            /**
             * Id
             * @description Zone UUID
             */
            id: string;
            /**
             * Name
             * @description Zone name
             */
            name: string;
            /**
             * Priority
             * @description Priority for overlapping zones
             */
            priority: number;
            /** @description Shape of the zone */
            shape: components["schemas"]["ZoneShape"];
            /**
             * Updated At
             * Format: date-time
             * @description Timestamp when zone was last updated
             */
            updated_at: string;
            /** @description Type of zone */
            zone_type: components["schemas"]["ZoneType"];
        };
        /**
         * ZoneShape
         * @description Shape of the zone polygon.
         * @enum {string}
         */
        ZoneShape: "rectangle" | "polygon";
        /**
         * ZoneType
         * @description Type of zone for semantic categorization.
         * @enum {string}
         */
        ZoneType: "entry_point" | "driveway" | "sidewalk" | "yard" | "other";
        /**
         * ZoneUpdate
         * @description Schema for updating an existing zone.
         * @example {
         *       "enabled": false,
         *       "name": "Front Door - Updated"
         *     }
         */
        ZoneUpdate: {
            /**
             * Color
             * @description Hex color for UI display
             */
            color?: string | null;
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates?: number[][] | null;
            /**
             * Enabled
             * @description Whether zone is active
             */
            enabled?: boolean | null;
            /**
             * Name
             * @description Zone name
             */
            name?: string | null;
            /**
             * Priority
             * @description Priority for overlapping zones (higher = more important)
             */
            priority?: number | null;
            /** @description Shape of the zone */
            shape?: components["schemas"]["ZoneShape"] | null;
            /** @description Type of zone */
            zone_type?: components["schemas"]["ZoneType"] | null;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    root__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    cleanup_orphans_api_admin_cleanup_orphans_post: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrphanCleanupRequest"];
            };
        };
        responses: {
            /** @description Orphan cleanup completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrphanCleanupResponse"];
                };
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    seed_cameras_api_admin_seed_cameras_post: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeedCamerasRequest"];
            };
        };
        responses: {
            /** @description Cameras created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeedCamerasResponse"];
                };
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    clear_seeded_data_api_admin_seed_clear_delete: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ClearDataRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClearDataResponse"];
                };
            };
            /** @description Bad request - Confirmation required */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    seed_events_api_admin_seed_events_post: {
        parameters: {
            query?: never;
            header?: {
                "x-admin-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeedEventsRequest"];
            };
        };
        responses: {
            /** @description Events and detections created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeedEventsResponse"];
                };
            };
            /** @description Bad request - No cameras found */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    trigger_batch_audit_api_ai_audit_batch_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BatchAuditRequest"];
            };
        };
        responses: {
            /** @description Batch audit job created successfully */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchAuditJobResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_batch_audit_status_api_ai_audit_batch__job_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchAuditJobStatusResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_event_audit_api_ai_audit_events__event_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventAuditResponse"];
                };
            };
            /** @description Event or audit not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    evaluate_event_api_ai_audit_events__event_id__evaluate_post: {
        parameters: {
            query?: {
                /** @description Force re-evaluation even if already evaluated */
                force?: boolean;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventAuditResponse"];
                };
            };
            /** @description Event or audit not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_model_leaderboard_api_ai_audit_leaderboard_get: {
        parameters: {
            query?: {
                /** @description Number of days to include */
                days?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LeaderboardResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_prompt_config_api_ai_audit_prompt_config__model__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                model: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_prompt_config_api_ai_audit_prompt_config__model__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                model: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PromptConfigRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_all_prompts_api_ai_audit_prompts_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AllPromptsResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    export_prompts_api_ai_audit_prompts_export_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptExportResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_all_prompts_history_api_ai_audit_prompts_history_get: {
        parameters: {
            query?: {
                /** @description Max versions per model */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: components["schemas"]["PromptHistoryResponse"];
                    };
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_model_history_api_ai_audit_prompts_history__model__get: {
        parameters: {
            query?: {
                /** @description Max versions to return */
                limit?: number;
                /** @description Number of versions to skip */
                offset?: number;
            };
            header?: never;
            path: {
                model: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptHistoryResponse"];
                };
            };
            /** @description Model not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    restore_prompt_version_api_ai_audit_prompts_history__version__post: {
        parameters: {
            query: {
                /** @description Model name to restore version for */
                model: string;
            };
            header?: never;
            path: {
                version: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["PromptRestoreRequest"] | null;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptRestoreResponse"];
                };
            };
            /** @description Model or version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    import_prompts_api_ai_audit_prompts_import_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PromptImportRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptImportResponse"];
                };
            };
            /** @description Bad request - No prompts provided */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    test_prompt_api_ai_audit_prompts_test_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PromptTestRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptTestResponse"];
                };
            };
            /** @description Bad request - Invalid configuration */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Model or event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_model_prompt_api_ai_audit_prompts__model__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                model: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelPromptResponse"];
                };
            };
            /** @description Model not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    update_model_prompt_api_ai_audit_prompts__model__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                model: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PromptUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptUpdateResponse"];
                };
            };
            /** @description Bad request - Invalid configuration */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Model not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_recommendations_api_ai_audit_recommendations_get: {
        parameters: {
            query?: {
                /** @description Number of days to include */
                days?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecommendationsResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_audit_stats_api_ai_audit_stats_get: {
        parameters: {
            query?: {
                /** @description Number of days to include */
                days?: number;
                /** @description Filter by camera ID */
                camera_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditStatsResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    test_custom_prompt_api_ai_audit_test_prompt_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomTestPromptRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomTestPromptResponse"];
                };
            };
            /** @description Bad request - Invalid or too long prompt */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Request timeout */
            408: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description AI service unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_rules_api_alerts_rules_get: {
        parameters: {
            query?: {
                /** @description Filter by enabled status */
                enabled?: boolean | null;
                /** @description Filter by severity level */
                severity?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    create_rule_api_alerts_rules_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertRuleCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_rule_api_alerts_rules__rule_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Alert rule not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    update_rule_api_alerts_rules__rule_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertRuleUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_rule_api_alerts_rules__rule_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Alert rule not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    test_rule_api_alerts_rules__rule_id__test_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RuleTestRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RuleTestResponse"];
                };
            };
            /** @description Alert rule not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    acknowledge_alert_api_alerts__alert_id__acknowledge_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                alert_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertResponse"];
                };
            };
            /** @description Alert not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Alert cannot be acknowledged (wrong status or concurrent modification) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    dismiss_alert_api_alerts__alert_id__dismiss_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                alert_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertResponse"];
                };
            };
            /** @description Alert not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Alert cannot be dismissed (wrong status or concurrent modification) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_camera_uptime_api_analytics_camera_uptime_get: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraUptimeResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_detection_trends_api_analytics_detection_trends_get: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionTrendsResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_object_distribution_api_analytics_object_distribution_get: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ObjectDistributionResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_risk_history_api_analytics_risk_history_get: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RiskHistoryResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_audit_logs_api_audit_get: {
        parameters: {
            query?: {
                /** @description Filter by action type */
                action?: string | null;
                /** @description Filter by resource type */
                resource_type?: string | null;
                /** @description Filter by resource ID */
                resource_id?: string | null;
                /** @description Filter by actor */
                actor?: string | null;
                /** @description Filter by status (success/failure) */
                status?: string | null;
                /** @description Filter from date (ISO format) */
                start_date?: string | null;
                /** @description Filter to date (ISO format) */
                end_date?: string | null;
                /** @description Page size */
                limit?: number;
                /** @description Number of results to skip (deprecated, use cursor) */
                offset?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string | null;
                /** @description Include total count in response. Defaults to False for performance. Total count queries are expensive for large datasets. For cursor-based pagination, has_more and next_cursor provide sufficient information without the total count. */
                include_total_count?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogListResponse"];
                };
            };
            /** @description Invalid date range or cursor */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_audit_stats_api_audit_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogStats"];
                };
            };
            /** @description Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_audit_log_api_audit__audit_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                audit_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogResponse"];
                };
            };
            /** @description Audit log not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_calibration_api_calibration_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserCalibrationResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    update_calibration_api_calibration_put: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserCalibrationUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserCalibrationResponse"];
                };
            };
            /** @description Validation error (invalid threshold ordering) */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    patch_calibration_api_calibration_patch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserCalibrationUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserCalibrationResponse"];
                };
            };
            /** @description Validation error (invalid threshold ordering) */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_calibration_defaults_api_calibration_defaults_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CalibrationDefaultsResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    reset_calibration_api_calibration_reset_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CalibrationResetResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_cameras_api_cameras_get: {
        parameters: {
            query?: {
                /** @description Filter by camera status */
                status?: string | null;
                /** @description Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, name, folder_path, status, created_at, last_seen_at */
                fields?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_camera_api_cameras_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_deleted_cameras_api_cameras_deleted_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of soft-deleted cameras */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeletedCamerasListResponse"];
                };
            };
        };
    };
    validate_camera_paths_api_cameras_validation_paths_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraPathValidationResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_camera_api_cameras__camera_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_camera_api_cameras__camera_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_camera_api_cameras__camera_id__patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_baseline_api_cameras__camera_id__baseline_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BaselineSummaryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_activity_baseline_api_cameras__camera_id__baseline_activity_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ActivityBaselineResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_baseline_anomalies_api_cameras__camera_id__baseline_anomalies_get: {
        parameters: {
            query?: {
                /** @description Number of days to look back */
                days?: number;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AnomalyListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_class_baseline_api_cameras__camera_id__baseline_classes_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClassBaselineResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    restore_camera_api_cameras__camera_id__restore_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Camera restored successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Camera is not deleted */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_scene_changes_api_cameras__camera_id__scene_changes_get: {
        parameters: {
            query?: {
                /** @description Filter by acknowledgement status */
                acknowledged?: boolean | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Cursor for pagination (detected_at timestamp) */
                cursor?: string | null;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SceneChangeListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    acknowledge_scene_change_api_cameras__camera_id__scene_changes__scene_change_id__acknowledge_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                scene_change_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SceneChangeAcknowledgeResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_camera_snapshot_api_cameras__camera_id__snapshot_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Snapshot served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Camera or snapshot not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_zones_api_cameras__camera_id__zones_get: {
        parameters: {
            query?: {
                /** @description Filter by enabled status */
                enabled?: boolean | null;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_zone_api_cameras__camera_id__zones_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_zone_api_cameras__camera_id__zones__zone_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_zone_api_cameras__camera_id__zones__zone_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_zone_api_cameras__camera_id__zones__zone_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_circuit_breakers_api_debug_circuit_breakers_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DebugCircuitBreakersResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_config_api_debug_config_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DebugConfigResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_log_level_api_debug_log_level_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogLevelResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    set_log_level_api_debug_log_level_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LogLevelRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogLevelResponse"];
                };
            };
            /** @description Bad request - Invalid log level */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_pipeline_errors_api_debug_pipeline_errors_get: {
        parameters: {
            query?: {
                limit?: number;
                component?: string | null;
                error_type?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineErrorsResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_pipeline_state_api_debug_pipeline_state_get: {
        parameters: {
            query?: {
                error_limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineStateResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    start_profiling_api_debug_profile_start_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProfileStartResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_profile_stats_api_debug_profile_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProfileStatsResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    stop_profiling_api_debug_profile_stop_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProfileStopResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_recordings_api_debug_recordings_get: {
        parameters: {
            query?: {
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecordingsListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_recording_api_debug_recordings__recording_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                recording_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_recording_api_debug_recordings__recording_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                recording_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_redis_info_api_debug_redis_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RedisInfoResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    replay_request_api_debug_replay__recording_id__post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                recording_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReplayResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_websocket_connections_api_debug_websocket_connections_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebSocketConnectionsResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_detections_api_detections_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by object type */
                object_type?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Minimum confidence score */
                min_confidence?: number | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip (deprecated, use cursor) */
                offset?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string | null;
                /** @description Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, file_path, file_type, detected_at, object_type, confidence, bbox_x, bbox_y, bbox_width, bbox_height, thumbnail_path, media_type, duration, video_codec, video_width, video_height, enrichment_data */
                fields?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    bulk_create_detections_api_detections_bulk_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DetectionBulkCreateRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionBulkCreateResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    bulk_delete_detections_api_detections_bulk_delete: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DetectionBulkDeleteRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkOperationResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    bulk_update_detections_api_detections_bulk_patch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DetectionBulkUpdateRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkOperationResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_detection_labels_api_detections_labels_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionLabelsResponse"];
                };
            };
        };
    };
    search_detections_api_detections_search_get: {
        parameters: {
            query: {
                q: string;
                labels?: string[] | null;
                min_confidence?: number | null;
                camera_id?: string | null;
                start_date?: string | null;
                end_date?: string | null;
                limit?: number;
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionSearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_detection_stats_api_detections_stats_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_detection_api_detections__detection_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_detection_enrichment_api_detections__detection_id__enrichment_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EnrichmentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_detection_image_api_detections__detection_id__image_get: {
        parameters: {
            query?: {
                /** @description Return full-size original image instead of thumbnail */
                full?: boolean;
            };
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Image served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection or image not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to generate thumbnail */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_detection_thumbnail_api_detections__detection_id__thumbnail_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "image/jpeg": unknown;
                    "image/png": unknown;
                };
            };
            /** @description Detection or thumbnail not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to generate thumbnail */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    stream_detection_video_api_detections__detection_id__video_get: {
        parameters: {
            query?: never;
            header?: {
                Range?: string | null;
            };
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Full video content */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Partial video content (range request) */
            206: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection is not a video */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection or video file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Range not satisfiable */
            416: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_video_thumbnail_api_detections__detection_id__video_thumbnail_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Thumbnail served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection is not a video */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection or video not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to generate thumbnail */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_dlq_jobs_api_dlq_jobs__queue_name__get: {
        parameters: {
            query?: {
                /** @description Start index (0-based) */
                start?: number;
                /** @description Maximum number of jobs to return */
                limit?: number;
            };
            header?: never;
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQJobsResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    requeue_all_dlq_jobs_api_dlq_requeue_all__queue_name__post: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQRequeueResponse"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    requeue_dlq_job_api_dlq_requeue__queue_name__post: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQRequeueResponse"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_dlq_stats_api_dlq_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQStatsResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    clear_dlq_api_dlq__queue_name__delete: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQClearResponse"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_entities_api_entities_get: {
        parameters: {
            query?: {
                /** @description Filter by entity type: 'person' or 'vehicle' */
                entity_type?: components["schemas"]["EntityTypeFilter"] | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter entities seen since this time */
                since?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_entity_matches_api_entities_matches__detection_id__get: {
        parameters: {
            query?: {
                /** @description Type of entity to search for matches */
                entity_type?: components["schemas"]["EntityTypeFilter"];
                /** @description Minimum similarity threshold for matches */
                threshold?: number;
            };
            header?: never;
            path: {
                detection_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityMatchResponse"];
                };
            };
            /** @description Detection not found or no embedding stored */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Redis service unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_entity_stats_api_entities_stats_get: {
        parameters: {
            query?: {
                /** @description Filter entities seen since this time */
                since?: string | null;
                /** @description Filter entities seen until this time */
                until?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_entities_v2_api_entities_v2_get: {
        parameters: {
            query?: {
                /** @description Filter by entity type: 'person' or 'vehicle' */
                entity_type?: components["schemas"]["EntityTypeFilter"] | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter entities seen since this time */
                since?: string | null;
                /** @description Filter entities seen until this time */
                until?: string | null;
                /** @description Data source: 'redis', 'postgres', or 'both' */
                source?: components["schemas"]["SourceFilter"];
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_entity_v2_api_entities_v2__entity_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityDetail"];
                };
            };
            /** @description Entity not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_entity_detections_api_entities_v2__entity_id__detections_get: {
        parameters: {
            query?: {
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityDetectionsResponse"];
                };
            };
            /** @description Entity not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_entity_api_entities__entity_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityDetail"];
                };
            };
            /** @description Entity not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_entity_history_api_entities__entity_id__history_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityHistoryResponse"];
                };
            };
            /** @description Entity not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_events_api_events_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by risk level (low, medium, high, critical) */
                risk_level?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
                /** @description Filter by detected object type */
                object_type?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip (deprecated, use cursor) */
                offset?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string | null;
                /** @description Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, started_at, ended_at, risk_score, risk_level, summary, reasoning, reviewed, detection_count, detection_ids, thumbnail_url */
                fields?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    analyze_batch_streaming_api_events_analyze__batch_id__stream_get: {
        parameters: {
            query?: {
                /** @description Camera ID for the batch */
                camera_id?: string | null;
                /** @description Comma-separated detection IDs (optional) */
                detection_ids?: string | null;
            };
            header?: never;
            path: {
                batch_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    bulk_create_events_api_events_bulk_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventBulkCreateRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventBulkCreateResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    bulk_delete_events_api_events_bulk_delete: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventBulkDeleteRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkOperationResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    bulk_update_events_api_events_bulk_patch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventBulkUpdateRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkOperationResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    list_deleted_events_api_events_deleted_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of soft-deleted events */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeletedEventsListResponse"];
                };
            };
        };
    };
    export_events_api_events_export_get: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by risk level (low, medium, high, critical) */
                risk_level?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Exported events file */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": string;
                    /** @example event_id,camera_name,started_at,... */
                    "text/csv": string;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    start_export_job_api_events_export_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExportJobRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobStartResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    search_events_endpoint_api_events_search_get: {
        parameters: {
            query: {
                /** @description Search query string */
                q: string;
                /** @description Filter by camera ID (comma-separated for multiple) */
                camera_id?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by risk levels (comma-separated: low,medium,high,critical) */
                severity?: string | null;
                /** @description Alias for severity - filter by risk levels (comma-separated: low,medium,high,critical) */
                risk_level?: string | null;
                /** @description Filter by object types (comma-separated: person,vehicle,animal) */
                object_type?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_stats_api_events_stats_get: {
        parameters: {
            query?: {
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_api_events__event_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_event_api_events__event_id__delete: {
        parameters: {
            query?: {
                /** @description Cascade soft delete to related detections */
                cascade?: boolean;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event already deleted */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_event_api_events__event_id__patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_clip_api_events__event_id__clip_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClipInfoResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    generate_event_clip_api_events__event_id__clip_generate_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ClipGenerateRequest"];
            };
        };
        responses: {
            /** @description Clip already exists */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClipGenerateResponse"];
                };
            };
            /** @description Clip created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClipGenerateResponse"];
                };
            };
            /** @description Cannot generate clip - event has no detections */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_detections_api_events__event_id__detections_get: {
        parameters: {
            query?: {
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_event_enrichments_api_events__event_id__enrichments_get: {
        parameters: {
            query?: {
                /** @description Maximum number of enrichments to return */
                limit?: number;
                /** @description Number of enrichments to skip */
                offset?: number;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventEnrichmentsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    restore_event_api_events__event_id__restore_post: {
        parameters: {
            query?: {
                /** @description Cascade restore to related detections */
                cascade?: boolean;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event restored successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event is not deleted */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_exports_api_exports_get: {
        parameters: {
            query?: {
                /** @description Filter by job status */
                status?: components["schemas"]["ExportJobStatusEnum"] | null;
                /** @description Maximum number of jobs to return */
                limit?: number;
                /** @description Number of jobs to skip (for pagination) */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    start_export_api_exports_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExportJobCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobStartResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_export_status_api_exports__job_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobResponse"];
                };
            };
            /** @description Export job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cancel_export_api_exports__job_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobCancelResponse"];
                };
            };
            /** @description Export job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Job cannot be cancelled (already completed or failed) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    download_export_api_exports__job_id__download_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Export not yet complete */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Export job or file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_download_info_api_exports__job_id__download_info_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportDownloadResponse"];
                };
            };
            /** @description Export job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_feedback_api_feedback_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventFeedbackCreate"];
            };
        };
        responses: {
            /** @description Feedback created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventFeedbackResponse"];
                };
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Feedback already exists for this event */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_event_feedback_api_feedback_event__event_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Feedback found */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventFeedbackResponse"];
                };
            };
            /** @description No feedback found for this event */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_feedback_stats_api_feedback_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Statistics retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FeedbackStatsResponse"];
                };
            };
        };
    };
    list_jobs_api_jobs_get: {
        parameters: {
            query?: {
                /** @description Filter by job type (e.g., 'export', 'cleanup') */
                job_type?: string | null;
                /** @description Filter by job status */
                status?: components["schemas"]["JobStatusEnum"] | null;
                /** @description Maximum number of jobs to return */
                limit?: number;
                /** @description Number of jobs to skip (for pagination) */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    bulk_cancel_jobs_api_jobs_bulk_cancel_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BulkCancelRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkCancelResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    search_jobs_api_jobs_search_get: {
        parameters: {
            query?: {
                /** @description Free text search across job type, error message, and metadata */
                q?: string | null;
                /** @description Comma-separated status values to filter (e.g., 'running,pending') */
                status?: string | null;
                /** @description Comma-separated job types to filter (e.g., 'export,cleanup') */
                job_type?: string | null;
                /** @description Queue name filter (reserved for future use) */
                queue?: string | null;
                /** @description Filter jobs created after this ISO timestamp */
                created_after?: string | null;
                /** @description Filter jobs created before this ISO timestamp */
                created_before?: string | null;
                /** @description Filter jobs completed after this ISO timestamp */
                completed_after?: string | null;
                /** @description Filter jobs completed before this ISO timestamp */
                completed_before?: string | null;
                /** @description If true, only jobs with errors; if false, only jobs without errors */
                has_error?: boolean | null;
                /** @description Minimum job duration in seconds (only completed jobs) */
                min_duration?: number | null;
                /** @description Maximum job duration in seconds (only completed jobs) */
                max_duration?: number | null;
                /** @description Maximum number of jobs to return */
                limit?: number;
                /** @description Number of jobs to skip (for pagination) */
                offset?: number;
                /** @description Field to sort by (created_at, started_at, completed_at, progress, job_type, status) */
                sort?: string;
                /** @description Sort direction (asc or desc) */
                order?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobSearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_job_stats_api_jobs_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobStatsResponse"];
                };
            };
        };
    };
    list_job_types_api_jobs_types_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobTypesResponse"];
                };
            };
        };
    };
    get_job_status_api_jobs__job_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_job_api_jobs__job_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobCancelResponse"];
                };
            };
            /** @description Job cannot be cancelled or aborted */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    abort_job_api_jobs__job_id__abort_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobAbortResponse"];
                };
            };
            /** @description Job is not running (use cancel for queued jobs) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cancel_job_api_jobs__job_id__cancel_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobCancelResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Job cannot be cancelled (already completed or failed) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_job_detail_api_jobs__job_id__detail_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobDetailResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_job_history_api_jobs__job_id__history_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobHistoryResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_job_logs_api_jobs__job_id__logs_get: {
        parameters: {
            query?: {
                /** @description Minimum log level to return (DEBUG, INFO, WARNING, ERROR) */
                level?: string | null;
                /** @description Return logs from this timestamp onwards (ISO format) */
                since?: string | null;
                /** @description Maximum number of log entries to return */
                limit?: number;
            };
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobLogsResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_logs_api_logs_get: {
        parameters: {
            query?: {
                /** @description Filter by log level */
                level?: string | null;
                /** @description Filter by component name */
                component?: string | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by source (backend, frontend) */
                source?: string | null;
                /** @description Search in message text */
                search?: string | null;
                /** @description Filter from date (ISO format) */
                start_date?: string | null;
                /** @description Filter to date (ISO format) */
                end_date?: string | null;
                /** @description Page size */
                limit?: number;
                /** @description Number of results to skip (deprecated, use cursor) */
                offset?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string | null;
                /** @description Include total count in response. Defaults to False for performance. Total count queries are expensive for large datasets. For cursor-based pagination, has_more and next_cursor provide sufficient information without the total count. */
                include_total_count?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogsResponse"];
                };
            };
            /** @description Invalid date range or cursor */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    create_frontend_log_api_logs_frontend_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FrontendLogCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_log_stats_api_logs_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogStats"];
                };
            };
            /** @description Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_log_api_logs__log_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                log_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogEntry"];
                };
            };
            /** @description Log entry not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    serve_camera_file_api_media_cameras__camera_id___filename__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    serve_clip_api_media_clips__filename__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Clip served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    serve_thumbnail_api_media_thumbnails__filename__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Thumbnail served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    serve_media_compat_api_media__path__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    metrics_api_metrics_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Prometheus metrics in exposition format */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_notification_preferences_api_notification_preferences__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationPreferencesResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    update_notification_preferences_api_notification_preferences__put: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotificationPreferencesUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationPreferencesResponse"];
                };
            };
            /** @description Bad request - Invalid sound or risk level value */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_all_camera_settings_api_notification_preferences_cameras_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraNotificationSettingsListResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_camera_setting_api_notification_preferences_cameras__camera_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraNotificationSettingResponse"];
                };
            };
            /** @description Camera notification setting not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    update_camera_setting_api_notification_preferences_cameras__camera_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraNotificationSettingUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraNotificationSettingResponse"];
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_quiet_hours_api_notification_preferences_quiet_hours_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QuietHoursPeriodsListResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    create_quiet_hours_period_api_notification_preferences_quiet_hours_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QuietHoursPeriodCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QuietHoursPeriodResponse"];
                };
            };
            /** @description Bad request - Invalid time range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    delete_quiet_hours_period_api_notification_preferences_quiet_hours__period_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                period_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Quiet hours period not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_notification_config_api_notification_config_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationConfigResponse"];
                };
            };
        };
    };
    test_notification_api_notification_test_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookTestNotificationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TestNotificationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_queues_status_api_queues_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Queue status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "queues": [
                     *         {
                     *           "depth": 15,
                     *           "name": "ai_analysis",
                     *           "oldest_job": {
                     *             "id": "job_12345",
                     *             "queued_at": "2025-12-23T10:30:00.000000",
                     *             "wait_seconds": 45.2
                     *           },
                     *           "running": 2,
                     *           "status": "healthy",
                     *           "throughput": {
                     *             "avg_processing_seconds": 4.8,
                     *             "jobs_per_minute": 12.5
                     *           },
                     *           "workers": 4
                     *         }
                     *       ],
                     *       "summary": {
                     *         "overall_status": "healthy",
                     *         "total_queued": 15,
                     *         "total_running": 2,
                     *         "total_workers": 4
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["QueuesStatusResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ingest_rum_metrics_api_rum_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RUMBatchRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RUMIngestResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_anomaly_config_api_system_anomaly_config_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AnomalyConfig"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    update_anomaly_config_api_system_anomaly_config_patch: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AnomalyConfigUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AnomalyConfig"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_circuit_breakers_api_system_circuit_breakers_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CircuitBreakersResponse"];
                };
            };
        };
    };
    reset_circuit_breaker_api_system_circuit_breakers__name__reset_post: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CircuitBreakerResetResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    trigger_cleanup_api_system_cleanup_post: {
        parameters: {
            query?: {
                dry_run?: boolean;
            };
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanupResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    run_orphaned_file_cleanup_api_system_cleanup_orphaned_files_post: {
        parameters: {
            query?: {
                /** @description If True, only report what would be deleted without deleting. Default is True for safety. */
                dry_run?: boolean;
            };
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrphanedFileCleanupResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_cleanup_status_api_system_cleanup_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanupStatusResponse"];
                };
            };
        };
    };
    get_config_api_system_config_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConfigResponse"];
                };
            };
        };
    };
    patch_config_api_system_config_patch: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConfigUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConfigResponse"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_gpu_stats_api_system_gpu_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GPUStatsResponse"];
                };
            };
        };
    };
    get_gpu_stats_history_api_system_gpu_history_get: {
        parameters: {
            query?: {
                since?: string | null;
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GPUStatsHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_health_api_system_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
        };
    };
    get_full_health_api_system_health_full_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description System is healthy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FullHealthResponse"];
                };
            };
            /** @description One or more critical services are unhealthy */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_readiness_api_system_health_ready_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReadinessResponse"];
                };
            };
        };
    };
    get_websocket_health_api_system_health_websocket_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebSocketHealthResponse"];
                };
            };
        };
    };
    get_model_zoo_latency_history_api_system_model_zoo_latency_history_get: {
        parameters: {
            query: {
                /** @description Model name to get latency history for (e.g., 'yolo11-license-plate') */
                model: string;
                /** @description Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours) */
                since?: number;
                /** @description Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour) */
                bucket_seconds?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelLatencyHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_model_zoo_status_api_system_model_zoo_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelZooStatusResponse"];
                };
            };
        };
    };
    get_models_api_system_models_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelRegistryResponse"];
                };
            };
        };
    };
    get_model_api_system_models__model_name__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                model_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelStatusResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_monitoring_health_api_system_monitoring_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoringHealthResponse"];
                };
            };
        };
    };
    get_monitoring_targets_api_system_monitoring_targets_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoringTargetsResponse"];
                };
            };
        };
    };
    get_performance_metrics_api_system_performance_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PerformanceUpdate"];
                };
            };
        };
    };
    get_performance_history_api_system_performance_history_get: {
        parameters: {
            query?: {
                time_range?: components["schemas"]["TimeRange"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PerformanceHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_pipeline_status_api_system_pipeline_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineStatusResponse"];
                };
            };
        };
    };
    get_pipeline_latency_api_system_pipeline_latency_get: {
        parameters: {
            query?: {
                window_minutes?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineLatencyResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_pipeline_latency_history_api_system_pipeline_latency_history_get: {
        parameters: {
            query?: {
                /** @description Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours) */
                since?: number;
                /** @description Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour) */
                bucket_seconds?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineLatencyHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_services_api_system_services_get: {
        parameters: {
            query?: {
                category?: components["schemas"]["ServiceCategory"] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServicesResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    disable_service_api_system_services__name__disable_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceActionResponse"];
                };
            };
            /** @description Service not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    enable_service_api_system_services__name__enable_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceActionResponse"];
                };
            };
            /** @description Service not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    restart_service_api_system_services__name__restart_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceActionResponse"];
                };
            };
            /** @description Bad request - Service is disabled */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Service not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    start_service_api_system_services__name__start_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceActionResponse"];
                };
            };
            /** @description Bad request - Service already running or disabled */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Service not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_severity_metadata_api_system_severity_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeverityMetadataResponse"];
                };
            };
        };
    };
    update_severity_thresholds_api_system_severity_put: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeverityThresholdsUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeverityMetadataResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_stats_api_system_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemStatsResponse"];
                };
            };
        };
    };
    get_storage_stats_api_system_storage_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StorageStatsResponse"];
                };
            };
        };
    };
    get_supervisor_status_api_system_supervisor_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkerSupervisorStatusResponse"];
                };
            };
        };
    };
    reset_worker_api_system_supervisor_reset__worker_name__post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                worker_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string | boolean;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_telemetry_api_system_telemetry_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TelemetryResponse"];
                };
            };
        };
    };
    list_websocket_event_types_api_system_websocket_events_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventRegistryResponse"];
                };
            };
        };
    };
    health_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    ready_ready_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
