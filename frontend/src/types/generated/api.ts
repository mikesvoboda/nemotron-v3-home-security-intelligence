/* eslint-disable @typescript-eslint/no-redundant-type-constituents */
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Root
         * @description Health check endpoint.
         */
        get: operations["root"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/action-events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Action Events
         * @description List action events with optional filtering and pagination.
         *
         *     Args:
         *         camera_id: Filter by camera ID
         *         track_id: Filter by track ID
         *         action: Filter by action label (exact match)
         *         is_suspicious: Filter by suspicious flag
         *         min_confidence: Filter by minimum confidence score
         *         start_time: Filter by timestamp >= start_time
         *         end_time: Filter by timestamp <= end_time
         *         limit: Maximum number of results to return
         *         offset: Number of results to skip for pagination
         *         db: Database session
         *
         *     Returns:
         *         ActionEventListResponse with events and pagination info
         */
        get: operations["action-events_list_action_events"];
        put?: never;
        /**
         * Create Action Event
         * @description Create a new action event manually.
         *
         *     This endpoint allows creating action events without running analysis,
         *     useful for importing results from external systems or testing.
         *
         *     Args:
         *         event_data: Action event data
         *         db: Database session
         *
         *     Returns:
         *         Created ActionEventResponse
         */
        post: operations["action-events_create_action_event"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/action-events/analyze": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Analyze Action
         * @description Trigger action analysis on a set of video frames.
         *
         *     This endpoint loads frames from disk, runs X-CLIP classification,
         *     and optionally saves the result to the database.
         *
         *     The X-CLIP model analyzes frame sequences to detect security-relevant
         *     actions like walking, running, climbing, loitering, etc.
         *
         *     Args:
         *         request: Analysis request with frame paths and options
         *         db: Database session
         *
         *     Returns:
         *         ActionAnalyzeResponse with detected action and scores
         *
         *     Raises:
         *         HTTPException: 400 if no valid frames, 503 if model unavailable
         */
        post: operations["action-events_analyze_action"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/action-events/camera/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Action Events
         * @description Get action events for a specific camera.
         *
         *     Convenience endpoint for camera-specific queries.
         *
         *     Args:
         *         camera_id: Camera ID to filter by
         *         start_time: Filter by timestamp >= start_time
         *         end_time: Filter by timestamp <= end_time
         *         limit: Maximum number of results to return
         *         offset: Number of results to skip for pagination
         *         db: Database session
         *
         *     Returns:
         *         ActionEventListResponse with events and pagination info
         */
        get: operations["action-events_get_camera_action_events"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/action-events/suspicious": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Suspicious Actions
         * @description List suspicious action events only.
         *
         *     Returns action events where is_suspicious=True, along with
         *     counts of suspicious vs total events.
         *
         *     Args:
         *         camera_id: Filter by camera ID
         *         min_confidence: Filter by minimum confidence score
         *         start_time: Filter by timestamp >= start_time
         *         end_time: Filter by timestamp <= end_time
         *         limit: Maximum number of results to return
         *         offset: Number of results to skip for pagination
         *         db: Database session
         *
         *     Returns:
         *         SuspiciousActionsResponse with suspicious events and counts
         */
        get: operations["action-events_list_suspicious_actions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/action-events/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Action Event
         * @description Get a specific action event by ID.
         *
         *     Args:
         *         event_id: Action event ID
         *         db: Database session
         *
         *     Returns:
         *         ActionEventResponse
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["action-events_get_action_event"];
        put?: never;
        post?: never;
        /**
         * Delete Action Event
         * @description Delete an action event.
         *
         *     Args:
         *         event_id: Action event ID to delete
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        delete: operations["action-events_delete_action_event"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/cleanup/orphans": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cleanup Orphans
         * @description Manually trigger orphaned file cleanup.
         *
         *     Scans camera upload directories for files that have no corresponding
         *     database records and optionally deletes them.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *
         *     Safety features:
         *     - dry_run=True by default (no actual deletions)
         *     - min_age_hours threshold prevents deleting files being processed
         *     - max_delete_gb limits total deletion per run
         *
         *     Args:
         *         request: Cleanup configuration (dry_run, min_age_hours, max_delete_gb)
         *         http_request: FastAPI request for audit logging
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of cleanup operation with statistics
         */
        post: operations["admin_cleanup_orphans"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/maintenance/clear-cache": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Clear Cache
         * @description Clear all cached data from Redis.
         *
         *     Invalidates all cache entries including:
         *     - Events cache
         *     - Cameras cache
         *     - System status cache
         *     - Stats cache
         *     - Detections cache
         *     - Alerts cache
         *     - Summaries cache
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *
         *     Args:
         *         http_request: FastAPI request for audit logging
         *         db: Database session for audit logging
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of cache clear operation
         */
        post: operations["admin_clear_cache"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/maintenance/flush-queues": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Flush Queues
         * @description Flush all processing queues in Redis.
         *
         *     Clears the following queues:
         *     - Detection queue (incoming detection jobs)
         *     - Analysis queue (LLM analysis jobs)
         *     - DLQ detection queue (failed detection jobs)
         *     - DLQ analysis queue (failed analysis jobs)
         *
         *     WARNING: This will discard any pending items in the queues.
         *     Items will need to be reprocessed from scratch.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *
         *     Args:
         *         http_request: FastAPI request for audit logging
         *         db: Database session for audit logging
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of queue flush operation
         */
        post: operations["admin_flush_queues"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seed Cameras
         * @description Seed test cameras into the database.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *
         *     Args:
         *         request: Seed configuration (count, clear_existing, create_folders)
         *         http_request: FastAPI request for audit logging
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of seeded cameras
         */
        post: operations["admin_seed_cameras"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/clear": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Seeded Data
         * @description Clear all seeded data (cameras, events, detections).
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *     Requires JSON body confirmation to prevent accidental data deletion:
         *     {"confirm": "DELETE_ALL_DATA"}
         *
         *     Args:
         *         body: Request body with confirmation string
         *         request: FastAPI request for audit logging
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of cleared data counts
         *
         *     Raises:
         *         HTTPException: 400 if confirmation string is incorrect
         */
        delete: operations["admin_clear_seeded_data"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seed Events
         * @description Seed mock events and detections into the database.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *     Requires cameras to exist first.
         *
         *     Args:
         *         request: Seed configuration (count, clear_existing)
         *         http_request: FastAPI request for audit logging
         *         db: Database session
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of seeded events and detections
         */
        post: operations["admin_seed_events"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/admin/seed/pipeline-latency": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seed Pipeline Latency
         * @description Seed the pipeline latency tracker with mock historical data.
         *
         *     This populates the in-memory PipelineLatencyTracker with realistic
         *     latency samples for UI testing and development. Data is distributed
         *     across the specified time span with realistic variance.
         *
         *     SECURITY: Requires DEBUG=true AND ADMIN_ENABLED=true.
         *     If ADMIN_API_KEY is set, requires X-Admin-API-Key header.
         *
         *     Typical latency ranges (ms):
         *     - watch_to_detect: 50-200ms (file processing + YOLO26 inference)
         *     - detect_to_batch: 10-50ms (detection aggregation)
         *     - batch_to_analyze: 5000-15000ms (Nemotron LLM analysis)
         *     - total_pipeline: 5100-15300ms (end-to-end)
         *
         *     Args:
         *         request: Configuration for sample generation
         *         http_request: FastAPI request for audit logging
         *         db: Database session for audit logging
         *         _admin: Admin access validation (via dependency)
         *
         *     Returns:
         *         Summary of seeded latency data
         */
        post: operations["admin_seed_pipeline_latency"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Batch Audit
         * @description Trigger batch audit processing for multiple events.
         *
         *     This endpoint returns immediately with a job ID that can be used to
         *     track progress via GET /api/ai-audit/batch/{job_id}. Events are
         *     processed asynchronously in the background.
         *
         *     Args:
         *         request: Batch audit request with filtering criteria
         *         background_tasks: FastAPI background tasks
         *         db: Database session
         *         job_tracker: Job tracker for progress tracking
         *
         *     Returns:
         *         BatchAuditJobResponse with job ID for tracking progress
         */
        post: operations["ai-audit_trigger_batch_audit"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/batch/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Batch Audit Status
         * @description Get the status of a batch audit job.
         *
         *     Provides progress information for an ongoing or completed batch audit,
         *     including the number of events processed and any errors.
         *
         *     Args:
         *         job_id: The job ID returned by trigger_batch_audit
         *         job_tracker: Job tracker for retrieving job status
         *
         *     Returns:
         *         BatchAuditJobStatusResponse with current progress
         *
         *     Raises:
         *         HTTPException: 404 if job not found
         */
        get: operations["ai-audit_get_batch_audit_status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/events/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Audit
         * @description Get audit information for a specific event.
         *
         *     Retrieves the AI pipeline audit record for the given event, including
         *     model contributions, quality scores, and prompt improvement suggestions.
         *
         *     Args:
         *         event_id: The ID of the event to get audit for
         *         db: Database session
         *
         *     Returns:
         *         EventAuditResponse containing full audit details
         *
         *     Raises:
         *         HTTPException: 404 if event or audit not found
         */
        get: operations["ai-audit_get_event_audit"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/events/{event_id}/evaluate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Evaluate Event
         * @description Trigger full evaluation for a specific event's audit.
         *
         *     Runs the complete self-evaluation pipeline (self-critique, rubric scoring,
         *     consistency check, prompt improvement) for the given event.
         *
         *     Args:
         *         event_id: The ID of the event to evaluate
         *         request: HTTP request for audit logging
         *         force: If True, re-evaluate even if already evaluated
         *         db: Database session
         *
         *     Returns:
         *         EventAuditResponse with updated evaluation results
         *
         *     Raises:
         *         HTTPException: 404 if event or audit not found
         */
        post: operations["ai-audit_evaluate_event"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/leaderboard": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Leaderboard
         * @description Get model leaderboard ranked by contribution rate.
         *
         *     Returns a ranked list of AI models by their contribution rate,
         *     along with quality correlation data.
         *
         *     Args:
         *         days: Number of days to include (1-90, default 7)
         *         db: Database session
         *
         *     Returns:
         *         LeaderboardResponse with ranked model entries
         */
        get: operations["ai-audit_get_model_leaderboard"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/recommendations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Recommendations
         * @description Get aggregated prompt improvement recommendations.
         *
         *     Analyzes all audits to produce actionable recommendations for
         *     improving the AI pipeline prompt templates.
         *
         *     Args:
         *         days: Number of days to analyze (1-90, default 7)
         *         db: Database session
         *
         *     Returns:
         *         RecommendationsResponse with prioritized recommendations
         */
        get: operations["ai-audit_get_recommendations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ai-audit/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Stats
         * @description Get aggregate AI audit statistics.
         *
         *     Returns aggregate statistics including total events, quality scores,
         *     model contribution rates, and audit trends over the specified period.
         *
         *     Args:
         *         days: Number of days to include in statistics (1-90, default 7)
         *         camera_id: Optional camera ID to filter stats
         *         db: Database session
         *
         *     Returns:
         *         AuditStatsResponse with aggregate statistics
         */
        get: operations["ai-audit_get_audit_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Rules
         * @description List all alert rules with optional filtering and pagination.
         *
         *     Args:
         *         enabled: Filter by enabled status
         *         severity: Filter by severity level (low, medium, high, critical)
         *         limit: Maximum number of results to return
         *         offset: Number of results to skip for pagination
         *         db: Database session
         *
         *     Returns:
         *         AlertRuleListResponse with rules and pagination info
         */
        get: operations["alert-rules_list_rules"];
        put?: never;
        /**
         * Create Rule
         * @description Create a new alert rule.
         *
         *     Args:
         *         rule_data: Rule creation data
         *         db: Database session
         *         cache: Cache service for cache invalidation (NEM-1952)
         *
         *     Returns:
         *         Created AlertRule
         */
        post: operations["alert-rules_create_rule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules/{rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Rule
         * @description Get a specific alert rule by ID.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         db: Database session
         *
         *     Returns:
         *         AlertRule
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        get: operations["alert-rules_get_rule"];
        /**
         * Update Rule
         * @description Update an existing alert rule.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         rule_data: Rule update data
         *         db: Database session
         *         cache: Cache service for cache invalidation (NEM-1952)
         *
         *     Returns:
         *         Updated AlertRule
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        put: operations["alert-rules_update_rule"];
        post?: never;
        /**
         * Delete Rule
         * @description Delete an alert rule.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         db: Database session
         *         cache: Cache service for cache invalidation (NEM-1952)
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        delete: operations["alert-rules_delete_rule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/rules/{rule_id}/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Rule
         * @description Test a rule against historical events.
         *
         *     This endpoint allows testing rule configuration without actually
         *     creating alerts. Useful for validating rules before enabling them.
         *
         *     Args:
         *         rule_id: Rule UUID
         *         test_data: Test configuration (event IDs, time override)
         *         db: Database session
         *         engine: AlertRuleEngine injected via Depends()
         *
         *     Returns:
         *         RuleTestResponse with per-event match results
         *
         *     Raises:
         *         HTTPException: 404 if rule not found
         */
        post: operations["alert-rules_test_rule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/{alert_id}/acknowledge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Acknowledge Alert
         * @description Acknowledge an alert.
         *
         *     Marks an alert as acknowledged and broadcasts the state change via WebSocket.
         *     Only alerts with status PENDING or DELIVERED can be acknowledged.
         *
         *     Uses optimistic locking to prevent race conditions when multiple requests
         *     attempt to modify the same alert concurrently. If a concurrent modification
         *     is detected, returns HTTP 409 Conflict.
         *
         *     NEM-2582: WebSocket broadcast now uses background task with retry logic
         *     to ensure delivery without blocking the main request.
         *
         *     Args:
         *         alert_id: Alert UUID
         *         background_tasks: FastAPI background tasks for non-blocking broadcast
         *         db: Database session
         *
         *     Returns:
         *         Updated AlertResponse
         *
         *     Raises:
         *         HTTPException: 404 if alert not found, 409 if alert cannot be acknowledged
         *                       or if concurrent modification detected
         */
        post: operations["alerts_acknowledge_alert"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/alerts/{alert_id}/dismiss": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Dismiss Alert
         * @description Dismiss an alert.
         *
         *     Marks an alert as dismissed and broadcasts the state change via WebSocket.
         *     Only alerts with status PENDING, DELIVERED, or ACKNOWLEDGED can be dismissed.
         *
         *     Uses optimistic locking to prevent race conditions when multiple requests
         *     attempt to modify the same alert concurrently. If a concurrent modification
         *     is detected, returns HTTP 409 Conflict.
         *
         *     NEM-2582: WebSocket broadcast now uses background task with retry logic
         *     to ensure delivery without blocking the main request.
         *
         *     Args:
         *         alert_id: Alert UUID
         *         background_tasks: FastAPI background tasks for non-blocking broadcast
         *         db: Database session
         *
         *     Returns:
         *         Updated AlertResponse
         *
         *     Raises:
         *         HTTPException: 404 if alert not found, 409 if alert cannot be dismissed
         *                       or if concurrent modification detected
         */
        post: operations["alerts_dismiss_alert"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/line-zones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a new line zone
         * @description Create a new line zone for a camera.
         *
         *     Line zones are virtual tripwires that detect and count objects
         *     crossing from one side to the other. They are defined by start
         *     and end coordinates (in pixels).
         *
         *     Args:
         *         data: Line zone creation data including camera_id and coordinates.
         *         db: Database session.
         *
         *     Returns:
         *         The created LineZone with initial counts set to zero.
         *
         *     Raises:
         *         HTTPException: 404 if camera not found.
         */
        post: operations["analytics-zones_create_line_zone"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/line-zones/camera/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all line zones for a camera
         * @description Get all line zones for a camera.
         *
         *     Args:
         *         camera_id: ID of the camera to get zones for.
         *         db: Database session.
         *
         *     Returns:
         *         List of LineZone objects for the camera.
         *
         *     Raises:
         *         HTTPException: 404 if camera not found.
         */
        get: operations["analytics-zones_get_line_zones_by_camera"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/line-zones/{zone_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a line zone by ID
         * @description Get a line zone by ID.
         *
         *     Args:
         *         zone_id: The unique identifier of the line zone.
         *         db: Database session.
         *
         *     Returns:
         *         The LineZone with current crossing counts.
         *
         *     Raises:
         *         HTTPException: 404 if line zone not found.
         */
        get: operations["analytics-zones_get_line_zone"];
        put?: never;
        post?: never;
        /**
         * Delete a line zone
         * @description Delete a line zone.
         *
         *     Args:
         *         zone_id: ID of the line zone to delete.
         *         db: Database session.
         *
         *     Raises:
         *         HTTPException: 404 if line zone not found.
         */
        delete: operations["analytics-zones_delete_line_zone"];
        options?: never;
        head?: never;
        /**
         * Update a line zone
         * @description Update a line zone.
         *
         *     Only the fields present in the request body are updated.
         *
         *     Args:
         *         zone_id: ID of the line zone to update.
         *         data: Update data with optional fields.
         *         db: Database session.
         *
         *     Returns:
         *         The updated LineZone.
         *
         *     Raises:
         *         HTTPException: 404 if line zone not found.
         */
        patch: operations["analytics-zones_update_line_zone"];
        trace?: never;
    };
    "/api/analytics-zones/line-zones/{zone_id}/reset-counts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset crossing counts for a line zone
         * @description Reset crossing counts for a line zone.
         *
         *     Sets both in_count and out_count to zero.
         *
         *     Args:
         *         zone_id: ID of the line zone.
         *         db: Database session.
         *
         *     Returns:
         *         The LineZone with reset counts.
         *
         *     Raises:
         *         HTTPException: 404 if line zone not found.
         */
        post: operations["analytics-zones_reset_line_zone_counts"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/polygon-zones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a new polygon zone
         * @description Create a new polygon zone for a camera.
         *
         *     Polygon zones monitor activity within defined areas.
         *     Supports various zone types for different monitoring scenarios.
         *
         *     Args:
         *         data: Polygon zone creation data including camera_id and polygon.
         *         db: Database session.
         *
         *     Returns:
         *         The created PolygonZone with initial count set to zero.
         *
         *     Raises:
         *         HTTPException: 404 if camera not found.
         */
        post: operations["analytics-zones_create_polygon_zone"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/polygon-zones/camera/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all polygon zones for a camera
         * @description Get all polygon zones for a camera.
         *
         *     Args:
         *         camera_id: ID of the camera to get zones for.
         *         db: Database session.
         *         active_only: If True, only return zones where is_active=True.
         *             Defaults to True.
         *
         *     Returns:
         *         List of PolygonZone objects for the camera.
         *
         *     Raises:
         *         HTTPException: 404 if camera not found.
         */
        get: operations["analytics-zones_get_polygon_zones_by_camera"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/polygon-zones/{zone_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a polygon zone by ID
         * @description Get a polygon zone by ID.
         *
         *     Args:
         *         zone_id: The unique identifier of the polygon zone.
         *         db: Database session.
         *
         *     Returns:
         *         The PolygonZone with current object count.
         *
         *     Raises:
         *         HTTPException: 404 if polygon zone not found.
         */
        get: operations["analytics-zones_get_polygon_zone"];
        put?: never;
        post?: never;
        /**
         * Delete a polygon zone
         * @description Delete a polygon zone.
         *
         *     Args:
         *         zone_id: ID of the polygon zone to delete.
         *         db: Database session.
         *
         *     Raises:
         *         HTTPException: 404 if polygon zone not found.
         */
        delete: operations["analytics-zones_delete_polygon_zone"];
        options?: never;
        head?: never;
        /**
         * Update a polygon zone
         * @description Update a polygon zone.
         *
         *     Only the fields present in the request body are updated.
         *
         *     Args:
         *         zone_id: ID of the polygon zone to update.
         *         data: Update data with optional fields.
         *         db: Database session.
         *
         *     Returns:
         *         The updated PolygonZone.
         *
         *     Raises:
         *         HTTPException: 404 if polygon zone not found.
         */
        patch: operations["analytics-zones_update_polygon_zone"];
        trace?: never;
    };
    "/api/analytics-zones/polygon-zones/{zone_id}/check-loitering": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Check for loitering in a polygon zone
         * @description Check for loitering in a polygon zone.
         *
         *     Identifies objects that have been dwelling in the zone longer than
         *     the specified threshold. Returns alerts for all objects exceeding
         *     the threshold, marking them as triggered in the database.
         *
         *     Args:
         *         zone_id: ID of the polygon zone.
         *         request: Loitering check request with threshold.
         *         db: Database session.
         *
         *     Returns:
         *         Loitering alerts for objects exceeding the threshold.
         *
         *     Raises:
         *         HTTPException: 404 if polygon zone not found.
         */
        post: operations["analytics-zones_check_loitering"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/polygon-zones/{zone_id}/dwell-history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get dwell time history for a polygon zone
         * @description Get historical dwell time records for a polygon zone.
         *
         *     Returns all dwell time records that overlap with the specified time window.
         *     By default, retrieves the last 24 hours of data.
         *
         *     Args:
         *         zone_id: ID of the polygon zone.
         *         db: Database session.
         *         start_time: Start of the time window (defaults to 24 hours ago).
         *         end_time: End of the time window (defaults to now).
         *         include_active: Whether to include currently active records.
         *
         *     Returns:
         *         Historical dwell time records.
         *
         *     Raises:
         *         HTTPException: 404 if polygon zone not found.
         */
        get: operations["analytics-zones_get_dwell_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/polygon-zones/{zone_id}/dwell-statistics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get dwell time statistics for a polygon zone
         * @description Get dwell time statistics for a polygon zone.
         *
         *     Returns aggregated statistics including average, min, max dwell times
         *     and the number of loitering alerts triggered in the time window.
         *
         *     Args:
         *         zone_id: ID of the polygon zone.
         *         db: Database session.
         *         start_time: Start of the statistics window (defaults to 24 hours ago).
         *         end_time: End of the statistics window (defaults to now).
         *
         *     Returns:
         *         Dwell time statistics for the zone.
         *
         *     Raises:
         *         HTTPException: 404 if polygon zone not found.
         */
        get: operations["analytics-zones_get_dwell_statistics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/polygon-zones/{zone_id}/dwellers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get active dwellers in a polygon zone
         * @description Get all objects currently dwelling in a polygon zone.
         *
         *     Returns objects that have entered the zone but have not yet exited.
         *     Each object includes the current dwell time calculated at request time.
         *
         *     Args:
         *         zone_id: ID of the polygon zone.
         *         db: Database session.
         *
         *     Returns:
         *         List of active dwellers with current dwell times.
         *
         *     Raises:
         *         HTTPException: 404 if polygon zone not found.
         */
        get: operations["analytics-zones_get_active_dwellers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics-zones/polygon-zones/{zone_id}/toggle-active": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Toggle the active status of a polygon zone
         * @description Toggle the active status of a polygon zone.
         *
         *     Toggles is_active between True and False.
         *
         *     Args:
         *         zone_id: ID of the polygon zone.
         *         db: Database session.
         *
         *     Returns:
         *         The PolygonZone with updated active status.
         *
         *     Raises:
         *         HTTPException: 404 if polygon zone not found.
         */
        post: operations["analytics-zones_toggle_polygon_zone_active"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/camera-uptime": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Uptime
         * @description Get uptime percentage per camera.
         *
         *     Returns uptime percentage and detection count for each camera.
         *     Uptime is calculated based on the number of days with at least one detection
         *     divided by the total days in the date range.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         db: Database session
         *
         *     Returns:
         *         CameraUptimeResponse with per-camera uptime data
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["analytics_get_camera_uptime"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/detection-trends": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Trends
         * @description Get detection counts aggregated by day.
         *
         *     Returns daily detection counts for the specified date range.
         *     Creates one data point per day even if there are no detections.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         db: Database session
         *
         *     Returns:
         *         DetectionTrendsResponse with daily detection counts
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["analytics_get_detection_trends"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/object-distribution": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Object Distribution
         * @description Get detection counts by object type.
         *
         *     Returns detection counts grouped by object type with percentages.
         *     Only includes detections with non-null object_type.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         db: Database session
         *
         *     Returns:
         *         ObjectDistributionResponse with object type counts and percentages
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["analytics_get_object_distribution"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/risk-history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Risk History
         * @description Get risk score distribution over time.
         *
         *     Returns daily counts of events grouped by risk level (low, medium, high, critical).
         *     Creates one data point per day even if there are no events.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         db: Database session
         *
         *     Returns:
         *         RiskHistoryResponse with daily risk level counts
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["analytics_get_risk_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/risk-score-distribution": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Risk Score Distribution
         * @description Get risk score distribution as a histogram.
         *
         *     Returns counts of events grouped into score buckets (e.g., 0-10, 10-20, ..., 90-100).
         *     Only includes events with non-null risk_score.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         bucket_size: Size of each bucket (default 10 for buckets 0-10, 10-20, etc.)
         *         db: Database session
         *
         *     Returns:
         *         RiskScoreDistributionResponse with histogram buckets
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["analytics_get_risk_score_distribution"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/risk-score-trends": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Risk Score Trends
         * @description Get average risk score trends over time.
         *
         *     Returns daily average risk scores for the specified date range.
         *     Creates one data point per day even if there are no events.
         *
         *     Args:
         *         start_date: Start date (inclusive)
         *         end_date: End date (inclusive)
         *         db: Database session
         *
         *     Returns:
         *         RiskScoreTrendsResponse with daily average scores and event counts
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["analytics_get_risk_score_trends"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Audit Logs
         * @description List audit logs with optional filtering and cursor-based pagination.
         *
         *     This endpoint is intended for admin use to review security-sensitive operations.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Cursor-based pagination offers better performance for large datasets.
         *
         *     **Performance Note:** Total count queries are expensive for large datasets. By default,
         *     the total count is not calculated (returns 0). Use `include_total_count=true` only when
         *     the total count is needed (e.g., for displaying "X of Y results" in UI). For pagination,
         *     `has_more` and `next_cursor` provide sufficient information.
         *
         *     Args:
         *         action: Optional action type to filter by
         *         resource_type: Optional resource type to filter by
         *         resource_id: Optional specific resource ID to filter by
         *         actor: Optional actor to filter by
         *         status_filter: Optional status to filter by (success/failure)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         limit: Maximum number of results to return (1-1000, default 100)
         *         offset: Number of results to skip (deprecated, use cursor instead)
         *         cursor: Pagination cursor from previous response's next_cursor field
         *         include_total_count: Whether to calculate total count (default False for performance)
         *         db: Database session
         *
         *     Returns:
         *         AuditLogListResponse containing filtered logs and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         *         HTTPException: 400 if cursor is invalid
         */
        get: operations["audit_list_audit_logs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Stats
         * @description Get audit log statistics for dashboard.
         *
         *     Returns aggregated statistics about audit logs including:
         *     - Total log count
         *     - Logs today
         *     - Breakdown by action type
         *     - Breakdown by resource type
         *     - Breakdown by status
         *     - Recently active actors
         *
         *     This endpoint is optimized to use a single aggregation query for counts
         *     (total, today, by_action, by_resource_type, by_status) plus one query
         *     for recent actors, reducing database round-trips from 6 to 2.
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         AuditLogStats with aggregated statistics
         */
        get: operations["audit_get_audit_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/audit/{audit_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Audit Log
         * @description Get a specific audit log entry by ID.
         *
         *     Args:
         *         audit_id: Audit log ID
         *         db: Database session
         *
         *     Returns:
         *         AuditLog record
         *
         *     Raises:
         *         HTTPException: 404 if audit log not found
         */
        get: operations["audit_get_audit_log"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/calibration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Calibration
         * @description Get the current user's calibration settings.
         *
         *     Returns the calibration thresholds for the default user.
         *     If no calibration exists, one is automatically created with default values.
         *
         *     Returns:
         *         CalibrationResponse with current threshold settings
         */
        get: operations["calibration_get_calibration"];
        /**
         * Update Calibration
         * @description Update calibration thresholds (full replacement semantics).
         *
         *     Allows partial updates - only provided fields will be changed.
         *     Validates that threshold ordering is maintained (low < medium < high).
         *
         *     Note: For REST semantics, use PATCH for partial updates. This PUT endpoint
         *     is kept for backward compatibility and behaves identically to PATCH.
         *
         *     Args:
         *         update_data: Fields to update (partial updates supported)
         *         db: Database session
         *
         *     Returns:
         *         Updated CalibrationResponse
         *
         *     Raises:
         *         HTTPException: 422 if threshold ordering would be violated
         */
        put: operations["calibration_update_calibration"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Patch Calibration
         * @description Partially update calibration thresholds.
         *
         *     Allows partial updates - only provided fields will be changed.
         *     Validates that threshold ordering is maintained (low < medium < high).
         *
         *     Args:
         *         update_data: Fields to update (partial updates supported)
         *         db: Database session
         *
         *     Returns:
         *         Updated CalibrationResponse
         *
         *     Raises:
         *         HTTPException: 422 if threshold ordering would be violated
         */
        patch: operations["calibration_patch_calibration"];
        trace?: never;
    };
    "/api/calibration/defaults": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Calibration Defaults
         * @description Get default calibration threshold values.
         *
         *     Returns the default values used when creating new calibrations
         *     or when resetting to defaults. This endpoint is useful for
         *     displaying defaults in the UI or documentation.
         *
         *     Returns:
         *         CalibrationDefaultsResponse with default threshold values
         */
        get: operations["calibration_get_calibration_defaults"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/calibration/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset Calibration
         * @description Reset calibration to default thresholds.
         *
         *     Resets all thresholds to their default values:
         *     - low_threshold: 30
         *     - medium_threshold: 60
         *     - high_threshold: 85
         *     - decay_factor: 0.1
         *
         *     Note: Feedback counts (correct_count, false_positive_count, missed_threat_count,
         *     severity_wrong_count) are NOT reset by this operation.
         *
         *     Returns:
         *         CalibrationResetResponse with success message and reset calibration data
         */
        post: operations["calibration_reset_calibration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Cameras
         * @description List all cameras with optional status filter.
         *
         *     Uses Redis cache with cache-aside pattern to improve performance
         *     and generate cache hit metrics.
         *
         *     Sparse Fieldsets (NEM-1434):
         *     Use the `fields` parameter to request only specific fields in the response,
         *     reducing payload size. Example: ?fields=id,name,status
         *
         *     Args:
         *         status_filter: Optional status to filter cameras by (online, offline, error)
         *         fields: Comma-separated list of fields to include (sparse fieldsets)
         *         db: Database session
         *         cache: Cache service injected via FastAPI DI
         *
         *     Returns:
         *         CameraListResponse containing list of cameras and total count
         *
         *     Raises:
         *         HTTPException: 400 if invalid fields are requested
         */
        get: operations["cameras_list_cameras"];
        put?: never;
        /**
         * Create Camera
         * @description Create a new camera.
         *
         *     Args:
         *         camera_data: Camera creation data
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Created camera object with generated ID
         *
         *     Raises:
         *         HTTPException: 409 if camera with same name or folder_path already exists
         */
        post: operations["cameras_create_camera"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all soft-deleted cameras
         * @description List all soft-deleted cameras for trash view.
         *
         *     Returns cameras that have been soft-deleted (deleted_at is not null),
         *     ordered by deleted_at descending (most recently deleted first).
         *
         *     This endpoint enables a "trash" view where users can see deleted cameras
         *     and optionally restore them.
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         DeletedCamerasListResponse containing list of deleted cameras and count
         */
        get: operations["cameras_list_deleted_cameras"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/validation/paths": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Validate Camera Paths
         * @description Validate all camera folder paths against the configured base path.
         *
         *     This endpoint checks each camera's folder_path to determine:
         *     1. Whether the path is under the configured FOSCAM_BASE_PATH
         *     2. Whether the directory exists on disk
         *     3. Whether the directory contains any images or video files
         *
         *     NEM-2446: Video files (.mkv, .mp4, etc.) are now valid for snapshot
         *     extraction, so cameras with only video files pass validation.
         *
         *     Use this to diagnose cameras that show "No snapshot available" errors.
         *
         *     Returns:
         *         CameraPathValidationResponse with validation results for all cameras
         */
        get: operations["cameras_validate_camera_paths"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera
         * @description Get a specific camera by ID.
         *
         *     Args:
         *         camera_id: Normalized camera ID (e.g., "front_door", "backyard")
         *         db: Database session
         *
         *     Returns:
         *         CameraResponse with camera data
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["cameras_get_camera"];
        put?: never;
        post?: never;
        /**
         * Delete Camera
         * @description Delete a camera.
         *
         *     This operation cascades to all related detections and events.
         *
         *     Args:
         *         camera_id: Normalized camera ID (e.g., "front_door", "backyard")
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        delete: operations["cameras_delete_camera"];
        options?: never;
        head?: never;
        /**
         * Update Camera
         * @description Update an existing camera.
         *
         *     Args:
         *         camera_id: Normalized camera ID (e.g., "front_door", "backyard")
         *         camera_data: Camera update data (all fields optional)
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         Updated camera object
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        patch: operations["cameras_update_camera"];
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Baseline
         * @description Get baseline activity data for a camera.
         *
         *     Returns comprehensive baseline statistics including:
         *     - Hourly activity patterns (0-23 hours)
         *     - Daily patterns (by day of week)
         *     - Object-specific baselines
         *     - Current deviation from baseline
         *
         *     Args:
         *         camera_id: ID of the camera
         *         db: Database session
         *         baseline_service: BaselineService injected via Depends()
         *
         *     Returns:
         *         BaselineSummaryResponse with all baseline data
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["cameras_get_camera_baseline"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline/activity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Activity Baseline
         * @description Get raw activity baseline data for a camera.
         *
         *     Returns up to 168 entries (24 hours x 7 days) representing the full
         *     weekly activity heatmap. Each entry contains the average count and
         *     sample count for that hour/day combination.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         db: Database session
         *         baseline_service: BaselineService injected via Depends()
         *
         *     Returns:
         *         ActivityBaselineResponse with entries for the heatmap
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["cameras_get_camera_activity_baseline"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline/anomalies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Baseline Anomalies
         * @description Get recent anomaly events for a camera.
         *
         *     Returns a list of anomaly events detected within the specified time period.
         *     Anomalies are detections that significantly deviate from the established
         *     baseline activity patterns.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         days: Number of days to look back (default: 7, max: 90)
         *         db: Database session
         *         baseline_service: BaselineService injected via Depends()
         *
         *     Returns:
         *         AnomalyListResponse with list of anomaly events
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["cameras_get_camera_baseline_anomalies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/baseline/classes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Class Baseline
         * @description Get class frequency baseline data for a camera.
         *
         *     Returns baseline entries grouped by object class and hour, showing
         *     the frequency of each object type at different times of day.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         db: Database session
         *         baseline_service: BaselineService injected via Depends()
         *
         *     Returns:
         *         ClassBaselineResponse with entries for each class/hour combination
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["cameras_get_camera_class_baseline"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/restore": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restore a soft-deleted camera
         * @description Restore a soft-deleted camera.
         *
         *     Clears the deleted_at timestamp on a soft-deleted camera, making it
         *     visible again in normal queries.
         *
         *     Args:
         *         camera_id: ID of the camera to restore
         *         db: Database session
         *         cache: Cache service for invalidation
         *
         *     Returns:
         *         CameraResponse with the restored camera data
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         *         HTTPException: 400 if camera is not deleted (nothing to restore)
         */
        post: operations["cameras_restore_camera"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/scene-changes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Scene Changes
         * @description Get scene changes for a camera with cursor-based pagination.
         *
         *     Returns a list of detected scene changes that may indicate camera
         *     tampering, angle changes, or blocked views. Uses cursor-based pagination
         *     for efficient navigation through large datasets.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         acknowledged: Filter by acknowledgement status (None = all)
         *         limit: Maximum number of results (default: 50, max: 100)
         *         cursor: Cursor for pagination (detected_at timestamp from previous response)
         *         db: Database session
         *
         *     Returns:
         *         SceneChangeListResponse with list of scene changes and pagination info
         *
         *     Raises:
         *         HTTPException: 404 if camera not found
         */
        get: operations["cameras_get_camera_scene_changes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/scene-changes/{scene_change_id}/acknowledge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Acknowledge Scene Change
         * @description Acknowledge a scene change alert.
         *
         *     Marks a scene change as acknowledged to indicate it has been reviewed.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         scene_change_id: ID of the scene change to acknowledge
         *         request: FastAPI request for audit logging
         *         db: Database session
         *
         *     Returns:
         *         SceneChangeAcknowledgeResponse confirming acknowledgement
         *
         *     Raises:
         *         HTTPException: 404 if camera or scene change not found
         */
        post: operations["cameras_acknowledge_scene_change"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/snapshot": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Snapshot
         * @description Return the latest image for a camera (best-effort snapshot).
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves static image content accessed directly by browsers via <img> tags
         *     2. It has its own security controls (path traversal protection, file type allowlist)
         *     3. It has rate limiting to prevent abuse
         *
         *     This endpoint uses the camera's configured `folder_path` and returns the most recently
         *     modified image file under that directory.
         *
         *     NEM-2446: Now supports video-only cameras by extracting and caching frames.
         */
        get: operations["cameras_get_camera_snapshot"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/zones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Zones
         * @description List all zones for a camera with optional filtering.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         db: Database session
         *         enabled: Optional filter for enabled/disabled zones
         *
         *     Returns:
         *         ZoneListResponse containing list of zones and total count
         */
        get: operations["zones_list_zones"];
        put?: never;
        /**
         * Create Zone
         * @description Create a new zone for a camera.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_data: Zone creation data
         *         db: Database session
         *
         *     Returns:
         *         Created zone object with generated ID
         */
        post: operations["zones_create_zone"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/cameras/{camera_id}/zones/{zone_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Zone
         * @description Get a specific zone by ID.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone
         *         db: Database session
         *
         *     Returns:
         *         CameraZone object
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        get: operations["zones_get_zone"];
        /**
         * Update Zone
         * @description Update an existing zone.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone to update
         *         zone_data: Zone update data (all fields optional)
         *         db: Database session
         *
         *     Returns:
         *         Updated zone object
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        put: operations["zones_update_zone"];
        post?: never;
        /**
         * Delete Zone
         * @description Delete a zone.
         *
         *     Args:
         *         camera_id: ID of the camera
         *         zone_id: ID of the zone to delete
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        delete: operations["zones_delete_zone"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/circuit-breakers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Circuit Breakers
         * @description Get all circuit breaker states.
         *
         *     Returns the current state and metrics for all registered circuit breakers,
         *     including failure counts, success counts, and configuration.
         *
         *     NEM-1642: Debug endpoint for circuit breaker diagnostics
         */
        get: operations["debug_get_circuit_breakers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Config
         * @description Get current configuration with sensitive values redacted.
         *
         *     Returns all configuration settings with passwords, API keys, and other
         *     sensitive values replaced with [REDACTED]. URLs containing passwords
         *     will have only the password portion redacted, preserving the structure.
         *
         *     NEM-1642: Debug endpoint for configuration inspection
         */
        get: operations["debug_get_config"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/log-level": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Log Level
         * @description Get current log level.
         *
         *     NEM-1471: Log level inspection endpoint
         */
        get: operations["debug_get_log_level"];
        put?: never;
        /**
         * Set Log Level
         * @description Set log level at runtime for debugging.
         *
         *     Allows changing the log level without restarting the application.
         *     Useful for temporarily enabling DEBUG logging to investigate issues.
         *
         *     NEM-1471: Log level runtime override
         *
         *     Args:
         *         request: Log level request with new level
         *
         *     Returns:
         *         Current and previous log level
         *
         *     Raises:
         *         HTTPException: If the log level is invalid
         */
        post: operations["debug_set_log_level"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/memory": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Memory Stats
         * @description Get detailed memory statistics for debugging memory issues.
         *
         *     Returns process memory usage, garbage collector stats, and the top
         *     object types consuming memory. Useful for detecting memory leaks.
         *
         *     Args:
         *         top_n: Number of top object types to return (default: 20)
         *         force_gc: Force garbage collection before measuring (default: False)
         *
         *     Returns:
         *         Detailed memory statistics
         */
        get: operations["debug_get_memory_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/memory/gc": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Gc
         * @description Trigger garbage collection and return stats.
         *
         *     Forces a full garbage collection cycle and returns the number of
         *     objects collected. Useful for testing if memory can be reclaimed.
         *
         *     Returns:
         *         GC collection statistics
         */
        post: operations["debug_trigger_gc"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/memory/tracemalloc/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Tracemalloc
         * @description Start tracemalloc memory tracing.
         *
         *     Enables detailed memory allocation tracking. This adds some overhead
         *     but allows tracking where memory is being allocated.
         *
         *     Args:
         *         nframes: Number of stack frames to capture (default: 25)
         *
         *     Returns:
         *         Status of tracemalloc
         */
        post: operations["debug_start_tracemalloc"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/memory/tracemalloc/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stop Tracemalloc
         * @description Stop tracemalloc memory tracing.
         *
         *     Stops memory allocation tracking and clears the trace data.
         *
         *     Returns:
         *         Final memory statistics before stopping
         */
        post: operations["debug_stop_tracemalloc"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/pipeline-errors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Errors
         * @description Get recent pipeline errors from the AI analysis pipeline.
         *
         *     Retrieves errors stored in Redis for debugging pipeline issues.
         *     Supports optional filtering by component and error type.
         *
         *     Args:
         *         limit: Maximum number of errors to return (default: 10, max: 100)
         *         component: Optional filter by component (e.g., "detector", "analyzer")
         *         error_type: Optional filter by error type (e.g., "connection_error")
         *
         *     Returns:
         *         List of recent pipeline errors with metadata
         *
         *     NEM-2485: Pipeline errors retrieval endpoint for Debug API
         */
        get: operations["debug_get_pipeline_errors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/pipeline-state": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline State
         * @description Get current state of the AI processing pipeline.
         *
         *     Returns queue depths, worker status, and recent errors for debugging
         *     pipeline issues and monitoring system health.
         *
         *     Args:
         *         error_limit: Maximum number of recent errors to return (default: 10, max: 100)
         *
         *     NEM-1470: Debug endpoint for pipeline state inspection
         *     NEM-2485: Complete pipeline errors retrieval implementation
         */
        get: operations["debug_get_pipeline_state"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/profile/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Profiling
         * @description Start performance profiling.
         *
         *     Begins collecting profiling data for performance analysis.
         *     Profile data is saved to disk when stop is called.
         *
         *     NEM-1644: Debug endpoint for performance profiling
         *
         *     Returns:
         *         Profiling start status
         */
        post: operations["debug_start_profiling"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/profile/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Profile Stats
         * @description Get current profiling statistics.
         *
         *     Returns the current profiling state and statistics from the last
         *     completed profiling session.
         *
         *     NEM-1644: Debug endpoint for performance profiling
         *
         *     Returns:
         *         Profiling status and statistics
         */
        get: operations["debug_get_profile_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/profile/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stop Profiling
         * @description Stop performance profiling and save results.
         *
         *     Stops the profiler and saves the profile data to a .prof file.
         *     The file can be analyzed with snakeviz or py-spy.
         *
         *     NEM-1644: Debug endpoint for performance profiling
         *
         *     Returns:
         *         Profiling stop status with path to saved profile
         */
        post: operations["debug_stop_profiling"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/recordings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Recordings
         * @description List available request recordings.
         *
         *     Returns a list of recorded requests, sorted by timestamp (newest first).
         *     Use the recording_id to replay a specific request.
         *
         *     NEM-1646: Request recording and replay for debugging
         *
         *     Args:
         *         limit: Maximum number of recordings to return (default: 50)
         *
         *     Returns:
         *         List of recordings with metadata
         */
        get: operations["debug_list_recordings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/recordings/{recording_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Recording
         * @description Get details of a specific recording.
         *
         *     Returns the full recording data including headers, body, and response.
         *
         *     NEM-1646: Request recording and replay for debugging
         *
         *     Args:
         *         recording_id: ID of the recording to retrieve
         *
         *     Returns:
         *         Full recording data
         *
         *     Raises:
         *         HTTPException: 404 if recording not found
         */
        get: operations["debug_get_recording"];
        put?: never;
        post?: never;
        /**
         * Delete Recording
         * @description Delete a specific recording.
         *
         *     NEM-1646: Request recording management
         *
         *     Args:
         *         recording_id: ID of the recording to delete
         *
         *     Returns:
         *         Confirmation message
         *
         *     Raises:
         *         HTTPException: 404 if recording not found
         */
        delete: operations["debug_delete_recording"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/redis/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Redis Info
         * @description Get Redis connection stats and pub/sub channel information.
         *
         *     Returns Redis server info, memory usage, connection stats, and
         *     active pub/sub channels with their subscriber counts.
         *
         *     NEM-1642: Debug endpoint for Redis diagnostics
         */
        get: operations["debug_get_redis_info"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/replay/{recording_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Replay Request
         * @description Replay a recorded request for debugging.
         *
         *     Reconstructs the original request from the recording and executes it
         *     against the current application. This is useful for:
         *     - Reproducing production issues locally
         *     - Testing fixes for error scenarios
         *     - Debugging intermittent failures
         *
         *     SECURITY: This endpoint is only available when debug=True and requires
         *     the request to pass through the debug mode gate.
         *
         *     NEM-1646: Request recording and replay for debugging
         *
         *     Args:
         *         recording_id: ID of the recording to replay
         *
         *     Returns:
         *         Replay response with original and new status codes
         *
         *     Raises:
         *         HTTPException: 404 if recording not found
         */
        post: operations["debug_replay_request"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/debug/websocket/connections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Websocket Connections
         * @description Get active WebSocket connection states.
         *
         *     Returns connection counts and health status for both the event broadcaster
         *     (security event stream) and system broadcaster (system status stream).
         *
         *     NEM-1642: Debug endpoint for WebSocket diagnostics
         */
        get: operations["debug_get_websocket_connections"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Detections
         * @description List detections with optional filtering and cursor-based pagination.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Cursor-based pagination offers better performance for large datasets.
         *
         *     Sparse Fieldsets (NEM-1434):
         *     Use the `fields` parameter to request only specific fields in the response,
         *     reducing payload size. Example: ?fields=id,camera_id,object_type,confidence
         *
         *     Args:
         *         camera_id: Optional camera ID to filter by
         *         object_type: Optional object type to filter by (person, car, etc.)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         min_confidence: Optional minimum confidence score (0-1)
         *         limit: Maximum number of results to return (1-100, default 50)
         *         offset: Number of results to skip (deprecated, use cursor instead)
         *         cursor: Pagination cursor from previous response's next_cursor field
         *         fields: Comma-separated list of fields to include (sparse fieldsets)
         *         db: Database session
         *
         *     Returns:
         *         DetectionListResponse containing filtered detections and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         *         HTTPException: 400 if cursor is invalid
         *         HTTPException: 400 if invalid fields are requested
         */
        get: operations["detections_list_detections"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/bulk": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Bulk create detections
         * @description Create multiple detections in a single request.
         *
         *     Supports partial success - some detections may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk create request with up to 100 detections
         *         db: Database session
         *         cache: Cache service for invalidation (NEM-1951)
         *
         *     Returns:
         *         DetectionBulkCreateResponse with per-item results
         */
        post: operations["detections_bulk_create_detections"];
        /**
         * Bulk delete detections
         * @description Delete multiple detections in a single request.
         *
         *     Supports partial success - some deletions may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Note: Detection deletion is always hard delete as detections are raw data
         *     and soft-delete is not supported.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk delete request with up to 100 detection IDs
         *         db: Database session
         *         cache: Cache service for invalidation (NEM-1951)
         *
         *     Returns:
         *         BulkOperationResponse with per-item results
         */
        delete: operations["detections_bulk_delete_detections"];
        options?: never;
        head?: never;
        /**
         * Bulk update detections
         * @description Update multiple detections in a single request.
         *
         *     Supports partial success - some updates may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk update request with up to 100 detection updates
         *         db: Database session
         *         cache: Cache service for invalidation (NEM-1951)
         *
         *     Returns:
         *         BulkOperationResponse with per-item results
         */
        patch: operations["detections_bulk_update_detections"];
        trace?: never;
    };
    "/api/detections/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export Detections
         * @description Export detections as CSV or JSON file for external analysis.
         *
         *     Supports content negotiation via HTTP Accept header:
         *     - `Accept: text/csv` or `Accept: application/csv` - CSV format (default)
         *     - `Accept: application/json` - JSON format
         *
         *     This endpoint is rate-limited to 10 requests per minute per client IP.
         *
         *     Exports detections with the following fields:
         *     - Detection ID, camera name, detection timestamp
         *     - Object type, confidence score
         *     - Bounding box coordinates (x, y, width, height)
         *     - File path, media type
         *
         *     Args:
         *         request: FastAPI request object (includes Accept header for format selection)
         *         camera_id: Optional camera ID to filter by
         *         object_type: Optional object type to filter by (person, vehicle, animal, etc.)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         min_confidence: Optional minimum confidence threshold (0.0-1.0)
         *         db: Database session
         *         _rate_limit: Rate limiter dependency
         *
         *     Returns:
         *         StreamingResponse with CSV or JSON Response containing exported detections
         *
         *     Raises:
         *         HTTPException: 429 if rate limit exceeded
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["detections_export_detections"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Detection Labels
         * @description Get all unique detection labels with counts.
         */
        get: operations["detections_list_detection_labels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Detections
         * @description Search detections using full-text search.
         */
        get: operations["detections_search_detections"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Stats
         * @description Get aggregate detection statistics including class distribution and trends.
         *
         *     Returns:
         *     - Total detection count
         *     - Detection counts grouped by object class (person, car, truck, etc.)
         *     - Average confidence score across all detections
         *     - Detection trends for the last 7 days (for Grafana time series)
         *
         *     Used by the AI Performance page to display detection class distribution charts
         *     and by the Grafana Analytics dashboard for detection trend visualization.
         *
         *     Optimized to use a single query with window functions instead of 3 separate queries
         *     (NEM-1321). The query combines:
         *     - Per-class counts via GROUP BY
         *     - Total count via SUM(COUNT(*)) OVER() window function
         *     - Per-class avg confidence, then combined using weighted average formula
         *
         *     Args:
         *         camera_id: Optional camera ID filter (for camera-specific stats)
         *         db: Database session
         *
         *     Returns:
         *         DetectionStatsResponse with aggregate detection statistics and trends
         */
        get: operations["detections_get_detection_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection
         * @description Get a specific detection by ID.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         Detection object
         *
         *     Raises:
         *         HTTPException: 404 if detection not found
         */
        get: operations["detections_get_detection"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/enrichment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Enrichment
         * @description Get structured enrichment data for a detection.
         *
         *     Returns results from the 18+ vision models run during the enrichment pipeline:
         *     - License plate detection and OCR
         *     - Face detection
         *     - Vehicle classification and damage detection
         *     - Clothing analysis (FashionCLIP and SegFormer)
         *     - Violence detection
         *     - Image quality assessment
         *     - Pet classification
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *
         *     Returns:
         *         EnrichmentResponse with structured vision model results
         *
         *     Raises:
         *         HTTPException: 404 if detection not found
         */
        get: operations["detections_get_detection_enrichment"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Detection Image
         * @description Get detection image with bounding box overlay, or full-size original.
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves static image content accessed directly by browsers via <img> tags
         *     2. Detection IDs are not predictable (integer IDs require prior knowledge)
         *     3. It has rate limiting to prevent abuse
         *
         *     By default, returns the thumbnail image with bounding box drawn around the
         *     detected object. If thumbnail doesn't exist, generates it on the fly from
         *     the source image or video.
         *
         *     For video detections, extracts a frame from the video using ffmpeg.
         *
         *     When full=true is passed, returns the original source image without any
         *     bounding box overlay. This is used for the full-size image lightbox viewer.
         *     Note: For video detections with full=true, returns the first frame as an image.
         *
         *     Args:
         *         detection_id: Detection ID
         *         full: If true, return the original full-size image instead of thumbnail
         *         db: Database session
         *         thumbnail_generator: ThumbnailGenerator injected via Depends()
         *         video_processor: VideoProcessor injected via Depends() for video detections
         *
         *     Returns:
         *         JPEG image (thumbnail with bounding box, or full-size original)
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or image file doesn't exist
         *         HTTPException: 500 if image generation fails
         */
        get: operations["detections_get_detection_image"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/thumbnail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get detection thumbnail
         * @description Serve the cropped thumbnail image with bounding box overlay.
         */
        get: operations["detections_get_detection_thumbnail"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Stream Detection Video
         * @description Stream detection video with HTTP Range request support and transcoding.
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves video content accessed directly by browsers via <video> tags
         *     2. Detection IDs are not predictable (integer IDs require prior knowledge)
         *     3. It has rate limiting to prevent abuse
         *
         *     NEM-2681: Videos are automatically transcoded to browser-compatible H.264/MP4
         *     format. Transcoded videos are cached to avoid re-transcoding on subsequent
         *     requests. Videos that are already browser-compatible (H.264 MP4) are served
         *     directly without transcoding.
         *
         *     Supports partial content requests for video seeking and efficient playback.
         *     Returns 206 Partial Content for range requests, 200 OK for full content.
         *
         *     Args:
         *         detection_id: Detection ID
         *         range_header: HTTP Range header for partial content requests
         *         db: Database session
         *         transcoding_service: Service for transcoding videos to browser-compatible format
         *
         *     Returns:
         *         StreamingResponse with browser-compatible video content
         *
         *     Raises:
         *         HTTPException: 400 if detection is not a video
         *         HTTPException: 404 if detection not found or video file not found
         *         HTTPException: 416 if range is not satisfiable
         *         HTTPException: 500 if transcoding fails
         */
        get: operations["detections_stream_detection_video"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/detections/{detection_id}/video/thumbnail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Video Thumbnail
         * @description Get thumbnail frame from a video detection.
         *
         *     This endpoint is exempt from API key authentication because:
         *     1. It serves static image content accessed directly by browsers via <img> tags
         *     2. Detection IDs are not predictable (integer IDs require prior knowledge)
         *     3. It has rate limiting to prevent abuse
         *
         *     Extracts and returns a thumbnail frame from the video. If thumbnail
         *     doesn't exist, generates it on the fly using ffmpeg.
         *
         *     Args:
         *         detection_id: Detection ID
         *         db: Database session
         *         video_processor: VideoProcessor injected via Depends()
         *
         *     Returns:
         *         JPEG thumbnail image
         *
         *     Raises:
         *         HTTPException: 404 if detection not found or not a video
         *         HTTPException: 500 if thumbnail generation fails
         */
        get: operations["detections_get_video_thumbnail"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/jobs/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Dlq Jobs
         * @description List jobs in a specific dead-letter queue with enriched error context.
         *
         *     Returns jobs in the specified DLQ without removing them.
         *     Use pagination parameters to control the result set.
         *
         *     Each job includes enriched error context (NEM-1474):
         *     - error_type: Exception class name for categorization
         *     - stack_trace: Truncated stack trace for debugging
         *     - http_status: HTTP status code (for network errors)
         *     - response_body: Truncated AI service response
         *     - retry_delays: Delays applied between retry attempts
         *     - context: System state snapshot at failure time
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         start: Start index for pagination
         *         limit: Maximum number of jobs to return
         *         redis: Redis client
         *
         *     Returns:
         *         DLQJobsResponse with list of jobs including error context (NEM-2178 pagination envelope)
         */
        get: operations["dlq_get_dlq_jobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/requeue-all/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Requeue All Dlq Jobs
         * @description Requeue all jobs from a DLQ back to their original processing queue.
         *
         *     Removes all jobs from the specified DLQ and adds them back to the
         *     original processing queue for retry. Limited to settings.max_requeue_iterations
         *     to prevent resource exhaustion.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         redis: Redis client
         *
         *     Returns:
         *         DLQRequeueResponse with operation result and count
         */
        post: operations["dlq_requeue_all_dlq_jobs"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/requeue/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Requeue Dlq Job
         * @description Requeue the oldest job from a DLQ back to its original processing queue.
         *
         *     Removes the oldest job from the specified DLQ and adds it back to the
         *     original processing queue for retry.
         *
         *     Args:
         *         queue_name: Name of the DLQ (detection or analysis)
         *         redis: Redis client
         *
         *     Returns:
         *         DLQRequeueResponse with operation result
         */
        post: operations["dlq_requeue_dlq_job"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Dlq Stats
         * @description Get dead-letter queue statistics.
         *
         *     Returns the number of jobs in each DLQ and the total count.
         *
         *     Returns:
         *         DLQStatsResponse with queue counts
         */
        get: operations["dlq_get_dlq_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/dlq/{queue_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Dlq
         * @description Clear all jobs from a dead-letter queue.
         *
         *     WARNING: This permanently removes all jobs from the specified DLQ.
         *     Use with caution.
         *
         *     Args:
         *         queue_name: Name of the DLQ to clear
         *         redis: Redis client
         *
         *     Returns:
         *         DLQClearResponse with operation result
         */
        delete: operations["dlq_clear_dlq"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Entities
         * @description List tracked entities with optional filtering.
         *
         *     Returns a paginated list of entities from PostgreSQL. Entities are
         *     tracked via re-identification and stored in the database.
         *
         *     Args:
         *         entity_type: Filter by entity type ('person' or 'vehicle')
         *         camera_id: Filter by camera ID
         *         since: Filter entities seen since this timestamp
         *         limit: Maximum number of results (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         entity_repo: Entity repository dependency for PostgreSQL queries
         *
         *     Returns:
         *         EntityListResponse with filtered entities and pagination info
         */
        get: operations["entities_list_entities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/matches/{detection_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity Matches
         * @description Find entities matching a specific detection's embedding.
         *
         *     Searches for entities similar to the specified detection's embedding
         *     across all cameras. Used to show re-ID matches in the EventDetailModal.
         *
         *     NOTE: This endpoint continues to use Redis for real-time similarity matching.
         *
         *     Args:
         *         detection_id: Detection ID to find matches for
         *         entity_type: Type of entity to search ('person' or 'vehicle')
         *         threshold: Minimum cosine similarity threshold (default 0.85)
         *         reid_service: Re-identification service dependency
         *
         *     Returns:
         *         EntityMatchResponse with matching entities sorted by similarity
         *
         *     Raises:
         *         HTTPException: 404 if detection embedding not found, 503 if Redis unavailable
         */
        get: operations["entities_get_entity_matches"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity Stats
         * @description Get aggregated entity statistics.
         *
         *     Returns statistics about tracked entities including counts by type,
         *     camera, and repeat visitors.
         *
         *     Args:
         *         since: Filter entities seen since this timestamp
         *         until: Filter entities seen until this timestamp
         *         entity_repo: Entity repository dependency
         *
         *     Returns:
         *         EntityStatsResponse with aggregated statistics
         */
        get: operations["entities_get_entity_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/trusted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Trusted Entities
         * @description List all trusted entities.
         *
         *     Returns a paginated list of entities that have been marked as trusted.
         *     Trusted entities are those that have been classified as known/safe,
         *     such as family members, regular visitors, or delivery personnel.
         *
         *     Args:
         *         entity_type: Filter by entity type ('person' or 'vehicle')
         *         limit: Maximum number of results (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         entity_repo: Entity repository dependency for PostgreSQL queries
         *
         *     Returns:
         *         TrustedEntityListResponse with filtered trusted entities and pagination info
         */
        get: operations["entities_list_trusted_entities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/untrusted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Untrusted Entities
         * @description List all untrusted entities.
         *
         *     Returns a paginated list of entities that have been marked as untrusted.
         *     Untrusted entities are those that have been classified as unknown or suspicious,
         *     requiring additional monitoring.
         *
         *     Args:
         *         entity_type: Filter by entity type ('person' or 'vehicle')
         *         limit: Maximum number of results (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         entity_repo: Entity repository dependency for PostgreSQL queries
         *
         *     Returns:
         *         TrustedEntityListResponse with filtered untrusted entities and pagination info
         */
        get: operations["entities_list_untrusted_entities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/v2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Entities V2
         * @description List tracked entities with historical query support.
         *
         *     Returns a paginated list of entities from Redis (hot cache) and/or
         *     PostgreSQL (historical data). Use the source parameter to control
         *     which backend to query.
         *
         *     Args:
         *         entity_type: Filter by entity type ('person' or 'vehicle')
         *         camera_id: Filter by camera ID
         *         since: Filter entities seen since this timestamp
         *         until: Filter entities seen until this timestamp
         *         source: Data source ('redis', 'postgres', 'both') - default 'both'
         *         limit: Maximum number of results (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         reid_service: Re-identification service dependency
         *         hybrid_storage: Hybrid storage service dependency
         *
         *     Returns:
         *         EntityListResponse with filtered entities and pagination info
         */
        get: operations["entities_list_entities_v2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/v2/{entity_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity V2
         * @description Get detailed information about a specific entity from PostgreSQL.
         *
         *     Returns the canonical PostgreSQL entity record with full history.
         *     For real-time Redis entities, use the original /api/entities/{entity_id} endpoint.
         *
         *     Args:
         *         entity_id: UUID of the entity
         *         hybrid_storage: Hybrid storage service dependency
         *
         *     Returns:
         *         EntityDetail with full entity information
         *
         *     Raises:
         *         HTTPException: 404 if entity not found
         */
        get: operations["entities_get_entity_v2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/v2/{entity_id}/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity Detections
         * @description List all detections linked to an entity.
         *
         *     Returns paginated detections associated with the specified entity.
         *
         *     Args:
         *         entity_id: UUID of the entity
         *         limit: Maximum number of results (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         entity_repo: Entity repository dependency
         *
         *     Returns:
         *         EntityDetectionsResponse with linked detections and pagination info
         *
         *     Raises:
         *         HTTPException: 404 if entity not found
         */
        get: operations["entities_get_entity_detections"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/{entity_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity
         * @description Get detailed information about a specific entity.
         *
         *     Returns the entity's summary information along with all recorded appearances
         *     from PostgreSQL.
         *
         *     Args:
         *         entity_id: UUID of the entity
         *         entity_repo: Entity repository dependency for PostgreSQL queries
         *
         *     Returns:
         *         EntityDetail with full entity information
         *
         *     Raises:
         *         HTTPException: 404 if entity not found
         */
        get: operations["entities_get_entity"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/{entity_id}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Entity History
         * @description Get the appearance timeline for a specific entity.
         *
         *     Returns a chronological list of all appearances for the entity
         *     across all cameras from PostgreSQL.
         *
         *     Args:
         *         entity_id: UUID of the entity
         *         entity_repo: Entity repository dependency for PostgreSQL queries
         *
         *     Returns:
         *         EntityHistoryResponse with appearance timeline
         *
         *     Raises:
         *         HTTPException: 404 if entity not found
         */
        get: operations["entities_get_entity_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/entities/{entity_id}/trust": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Entity Trust
         * @description Update an entity's trust classification status.
         *
         *     Allows marking entities as trusted (known/safe), untrusted (suspicious),
         *     or unclassified (default). Includes optional notes for documenting
         *     the classification decision.
         *
         *     Args:
         *         entity_id: UUID of the entity to update
         *         trust_update: Trust status update request containing trust_status and optional notes
         *         entity_repo: Entity repository dependency for PostgreSQL queries
         *
         *     Returns:
         *         EntityTrustResponse with updated trust information
         *
         *     Raises:
         *         HTTPException: 404 if entity not found
         */
        patch: operations["entities_update_entity_trust"];
        trace?: never;
    };
    "/api/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Events
         * @description List events with optional filtering and cursor-based pagination.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Cursor-based pagination offers better performance for large datasets.
         *
         *     By default, soft-deleted events (events with deleted_at set) are excluded from results.
         *     Use include_deleted=true to include them.
         *
         *     Sparse Fieldsets (NEM-1434):
         *     Use the `fields` parameter to request only specific fields in the response,
         *     reducing payload size. Example: ?fields=id,camera_id,risk_level,summary,reviewed
         *
         *     Args:
         *         camera_id: Optional camera ID to filter by
         *         risk_level: Optional risk level to filter by (low, medium, high, critical)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         reviewed: Optional filter by reviewed status
         *         object_type: Optional object type to filter by (person, vehicle, animal, etc.)
         *         limit: Maximum number of results to return (1-100, default 50)
         *         offset: Number of results to skip (deprecated, use cursor instead)
         *         cursor: Pagination cursor from previous response's next_cursor field
         *         fields: Comma-separated list of fields to include (sparse fieldsets)
         *         include_deleted: Include soft-deleted events in results (default False)
         *         db: Database session
         *
         *     Returns:
         *         EventListResponse containing filtered events and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         *         HTTPException: 400 if cursor is invalid
         *         HTTPException: 400 if invalid fields are requested
         */
        get: operations["events_list_events"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/analyze/{batch_id}/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Analyze Batch Streaming
         * @description Stream LLM analysis progress for a batch via Server-Sent Events (NEM-1665).
         *
         *     This endpoint provides progressive LLM response updates during long inference
         *     times, allowing the frontend to display partial results and show typing
         *     indicators while the analysis is in progress.
         *
         *     Event Types:
         *     - progress: Partial LLM response chunk with accumulated_text
         *     - complete: Final event with risk assessment and event_id
         *     - error: Error information with error_code and recoverable flag
         *
         *     Args:
         *         batch_id: Batch identifier to analyze
         *         camera_id: Optional camera ID (uses Redis lookup if not provided)
         *         detection_ids: Optional comma-separated detection IDs
         *         analyzer: NemotronAnalyzer injected via Depends()
         *
         *     Returns:
         *         StreamingResponse with SSE event stream (text/event-stream)
         *
         *     Example SSE output:
         *         data: {"event_type": "progress", "content": "Based on", "accumulated_text": "Based on"}
         *
         *         data: {"event_type": "progress", "content": " the", "accumulated_text": "Based on the"}
         *
         *         data: {"event_type": "complete", "event_id": 123, "risk_score": 75, ...}
         */
        get: operations["events_analyze_batch_streaming"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/bulk": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Bulk create events
         * @description Create multiple events in a single request.
         *
         *     Supports partial success - some events may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk create request with up to 100 events
         *         db: Database session
         *
         *     Returns:
         *         EventBulkCreateResponse with per-item results
         */
        post: operations["events_bulk_create_events"];
        /**
         * Bulk delete events
         * @description Delete multiple events in a single request.
         *
         *     Supports partial success - some deletions may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     By default uses soft delete (sets deleted_at timestamp) with cascade to
         *     related detections. Use soft_delete=false for permanent deletion.
         *     Use cascade=false to only delete the event without affecting detections.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk delete request with up to 100 event IDs
         *         db: Database session
         *         cache: Cache service for invalidation
         *
         *     Returns:
         *         BulkOperationResponse with per-item results
         */
        delete: operations["events_bulk_delete_events"];
        options?: never;
        head?: never;
        /**
         * Bulk update events
         * @description Update multiple events in a single request.
         *
         *     Supports partial success - some updates may succeed while others fail.
         *     Returns HTTP 207 Multi-Status with per-item results.
         *
         *     Rate limiting: Limited to 10 requests/minute with burst of 2 (NEM-2600).
         *
         *     Args:
         *         request: Bulk update request with up to 100 event updates
         *         db: Database session
         *
         *     Returns:
         *         BulkOperationResponse with per-item results
         */
        patch: operations["events_bulk_update_events"];
        trace?: never;
    };
    "/api/events/clusters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Clusters
         * @description Cluster events by temporal proximity (NEM-3620).
         *
         *     Groups events that occur within a specified time window into clusters.
         *     Events from the same camera within `time_window_minutes` are grouped together.
         *     Events from different cameras within 2 minutes are also grouped (cross-camera clusters).
         *
         *     Clustering algorithm:
         *     1. Sort all events by timestamp
         *     2. For each event, check if it fits in an existing cluster:
         *        - Same camera: within time_window_minutes of cluster end
         *        - Different camera: within 2 minutes of cluster end (correlating activity)
         *     3. If no matching cluster, start a new potential cluster
         *     4. Only return clusters with >= min_cluster_size events
         *
         *     Uses read replica for linear scalability (NEM-3392).
         *
         *     Args:
         *         start_date: Start of time range to analyze (required)
         *         end_date: End of time range to analyze (required)
         *         camera_id: Optional filter to only cluster events from specific camera
         *         time_window_minutes: Time window for same-camera clustering (1-60, default 5)
         *         min_cluster_size: Minimum events to form a cluster (2-100, default 2)
         *         db: Database session (read replica)
         *
         *     Returns:
         *         EventClustersResponse with clusters and unclustered event count
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["events_get_event_clusters"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all soft-deleted events
         * @description List all soft-deleted events for trash view.
         *
         *     Returns events that have been soft-deleted (deleted_at is not null),
         *     ordered by deleted_at descending (most recently deleted first).
         *
         *     This endpoint enables a "trash" view where users can see deleted events
         *     and optionally restore them.
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         DeletedEventsListResponse containing list of deleted events and count
         */
        get: operations["events_list_deleted_events"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export Events
         * @description Export events as CSV, JSON, or Excel file for external analysis or record-keeping.
         *
         *     Supports content negotiation via HTTP Accept header:
         *     - `Accept: text/csv` or `Accept: application/csv` - CSV format (default)
         *     - `Accept: application/json` - JSON format
         *     - `Accept: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet` - Excel (XLSX)
         *     - `Accept: application/vnd.ms-excel` or `Accept: application/xlsx` - Excel (XLSX)
         *
         *     This endpoint is rate-limited to 10 requests per minute per client IP
         *     to prevent abuse and protect against data exfiltration attacks.
         *
         *     Exports events with the following fields:
         *     - Event ID, camera name, timestamps
         *     - Risk score, risk level, summary
         *     - Detection count, reviewed status
         *
         *     Args:
         *         request: FastAPI request object (includes Accept header for format selection)
         *         camera_id: Optional camera ID to filter by
         *         risk_level: Optional risk level to filter by (low, medium, high, critical)
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         reviewed: Optional filter by reviewed status
         *         db: Database session
         *         _rate_limit: Rate limiter dependency (10 req/min, no burst)
         *
         *     Returns:
         *         StreamingResponse with CSV, JSON Response, or Excel Response
         *
         *     Raises:
         *         HTTPException: 429 if rate limit exceeded
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["events_export_events"];
        put?: never;
        /**
         * Start export job
         * @description Start a background export job for events. Returns a job ID that can be used to track progress via GET /api/jobs/{job_id}.
         */
        post: operations["jobs_start_export_job"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Events Endpoint
         * @description Search events using full-text search.
         *
         *     Uses read replica for linear scalability (NEM-3392).
         *
         *     This endpoint provides PostgreSQL full-text search across event summaries,
         *     reasoning, object types, and camera names.
         *
         *     Search Query Syntax:
         *     - Basic words: "person vehicle" (implicit AND)
         *     - Phrase search: '"suspicious person"' (exact phrase)
         *     - Boolean OR: "person OR animal"
         *     - Boolean NOT: "person NOT cat"
         *     - Boolean AND: "person AND vehicle" (explicit)
         *
         *     Args:
         *         q: Search query string (required)
         *         camera_id: Optional comma-separated camera IDs to filter by
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         severity: Optional comma-separated risk levels (low, medium, high, critical)
         *         risk_level: Alias for severity - accepts same format
         *         object_type: Optional comma-separated object types (person, vehicle, animal)
         *         reviewed: Optional filter by reviewed status
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         db: Database session
         *
         *     Returns:
         *         SearchResponse with ranked results and pagination info
         *
         *     Raises:
         *         HTTPException: 400 if any severity value is invalid
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["events_search_events_endpoint"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Stats
         * @description Get aggregated event statistics.
         *
         *     Returns statistics about events including:
         *     - Total event count
         *     - Events grouped by risk level (critical, high, medium, low)
         *     - Events grouped by camera with camera names
         *
         *     Uses Redis cache with cache-aside pattern to improve performance
         *     and generate cache hit metrics.
         *
         *     Args:
         *         start_date: Optional start date for date range filter
         *         end_date: Optional end date for date range filter
         *         camera_id: Optional camera ID filter (for camera-specific stats)
         *         db: Database session
         *         cache: Cache service injected via FastAPI DI
         *
         *     Returns:
         *         EventStatsResponse with aggregated statistics
         *
         *     Raises:
         *         HTTPException: 400 if start_date is after end_date
         */
        get: operations["events_get_event_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/timeline-summary": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Timeline Summary
         * @description Get timeline summary data for the timeline scrubber visualization (NEM-2932).
         *
         *     Returns event data bucketed by time periods for visualization.
         *     Each bucket includes:
         *     - Timestamp (start of the bucket)
         *     - Event count
         *     - Maximum risk score in that bucket
         *
         *     Bucket sizes based on zoom level:
         *     - hour: 5-minute buckets (12 buckets per hour)
         *     - day: 1-hour buckets (24 buckets per day)
         *     - week: 1-day buckets (7 buckets per week)
         *
         *     Args:
         *         start_date: Start of timeline range (defaults based on bucket_size)
         *         end_date: End of timeline range (defaults to now)
         *         bucket_size: Zoom level - "hour", "day", or "week"
         *         camera_id: Optional camera filter
         *         db: Database session
         *         cache: Cache service
         *
         *     Returns:
         *         TimelineSummaryResponse with bucketed event data
         */
        get: operations["events_get_timeline_summary"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event
         * @description Get a specific event by ID with HATEOAS links.
         *
         *     Args:
         *         event_id: Event ID
         *         request: FastAPI request object for building HATEOAS links
         *         db: Database session
         *
         *     Returns:
         *         Event object with detection count and HATEOAS links
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["events_get_event"];
        put?: never;
        post?: never;
        /**
         * Soft delete a single event
         * @description Soft delete a single event with optional cascade to related detections.
         *
         *     By default, cascade=True soft deletes all related detections using the same
         *     timestamp as the event. This enables cascade restore by matching timestamps.
         *
         *     Args:
         *         event_id: ID of the event to delete
         *         cascade: If True, cascade soft delete to related detections
         *         db: Database session
         *         cache: Cache service for invalidation
         *
         *     Raises:
         *         HTTPException: 404 if event not found, 409 if already deleted
         */
        delete: operations["events_delete_event"];
        options?: never;
        head?: never;
        /**
         * Update Event
         * @description Update an event (mark as reviewed).
         *
         *     Supports optimistic locking (NEM-3625): Include the `version` field from the
         *     event response to prevent concurrent modification conflicts. If the version
         *     doesn't match, returns HTTP 409 Conflict with the current version.
         *
         *     Args:
         *         event_id: Event ID
         *         update_data: Update data (reviewed, notes, snooze_until, version)
         *         request: FastAPI request for audit logging
         *         db: Database session
         *         cache: Cache service for cache invalidation (NEM-1938)
         *
         *     Returns:
         *         Updated event object with new version
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         *         HTTPException: 409 if version mismatch (concurrent modification)
         */
        patch: operations["events_update_event"];
        trace?: never;
    };
    "/api/events/{event_id}/clip": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Clip
         * @description Get clip information for a specific event.
         *
         *     Returns information about whether a video clip is available for the event,
         *     and if so, provides the URL to access it along with metadata.
         *
         *     Args:
         *         event_id: Event ID
         *         db: Database session
         *
         *     Returns:
         *         ClipInfoResponse with clip availability and metadata
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["events_get_event_clip"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/clip/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Event Clip
         * @description Trigger video clip generation for an event.
         *
         *     If a clip already exists and force=False, returns the existing clip info.
         *     If force=True, regenerates the clip even if one exists.
         *
         *     Clip generation uses detection images to create a video sequence, or
         *     extracts from existing video if available.
         *
         *     Args:
         *         event_id: Event ID
         *         request: Clip generation parameters
         *         db: Database session
         *         clip_generator: ClipGenerator injected via Depends()
         *
         *     Returns:
         *         ClipGenerateResponse with generation status and clip info
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         *         HTTPException: 400 if event has no detections to generate clip from
         */
        post: operations["events_generate_event_clip"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/detections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Detections
         * @description Get detections for a specific event.
         *
         *     NEM-3629: Supports ordering by EventDetection.created_at to show detection
         *     order within the event (first, second, etc.). When using order_detections_by=created_at,
         *     the association_created_at field will be populated in each detection response.
         *
         *     Args:
         *         event_id: Event ID
         *         limit: Maximum number of results to return (1-1000, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *         order_detections_by: Order by 'detected_at' (default) or 'created_at'
         *         db: Database session
         *
         *     Returns:
         *         DetectionListResponse containing detections for the event
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         *         HTTPException: 400 if invalid order_detections_by value
         */
        get: operations["events_get_event_detections"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/enrichments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event Enrichments
         * @description Get enrichment data for detections in an event with pagination.
         *
         *     Returns structured vision model results from the enrichment pipeline for
         *     each detection in the event. Results include:
         *     - License plate detection and OCR
         *     - Face detection
         *     - Vehicle classification and damage detection
         *     - Clothing analysis (FashionCLIP and SegFormer)
         *     - Violence detection
         *     - Image quality assessment
         *     - Pet classification
         *
         *     Args:
         *         event_id: Event ID
         *         limit: Maximum number of enrichments to return (1-200, default 50)
         *         offset: Number of enrichments to skip (default 0)
         *         db: Database session
         *
         *     Returns:
         *         EventEnrichmentsResponse with enrichment data for each detection and pagination metadata
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         */
        get: operations["events_get_event_enrichments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/events/{event_id}/restore": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restore a soft-deleted event
         * @description Restore a soft-deleted event with optional cascade to related detections.
         *
         *     When cascade=True, this restores detections that were deleted at the same
         *     timestamp as the event, indicating they were cascade-deleted together.
         *
         *     Args:
         *         event_id: ID of the event to restore
         *         cascade: If True, cascade restore to related detections
         *         db: Database session
         *         cache: Cache service for invalidation
         *
         *     Returns:
         *         The restored event as EventResponse
         *
         *     Raises:
         *         HTTPException: 404 if event not found, 409 if not deleted
         */
        post: operations["events_restore_event"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/exports": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List export jobs
         * @description List recent export jobs with optional filtering by status.
         */
        get: operations["exports_list_exports"];
        put?: never;
        /**
         * Start export job
         * @description Start a new background export job. Returns a job ID that can be used to track progress via GET /api/exports/{job_id}.
         */
        post: operations["exports_start_export"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/exports/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get export status
         * @description Get the current status and progress of an export job.
         */
        get: operations["exports_get_export_status"];
        put?: never;
        post?: never;
        /**
         * Cancel export job
         * @description Cancel a pending or running export job. Completed or failed jobs cannot be cancelled.
         */
        delete: operations["exports_cancel_export"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/exports/{job_id}/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download export file
         * @description Download the completed export file.
         */
        get: operations["exports_download_export"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/exports/{job_id}/download/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get download info
         * @description Get metadata about the export file for download.
         */
        get: operations["exports_get_download_info"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/face-events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Face Events
         * @description List face detection events with optional filters.
         *
         *     Args:
         *         camera_id: Filter by camera ID (optional)
         *         start_time: Filter events after this time (optional)
         *         end_time: Filter events before this time (optional)
         *         unknown_only: If True, only return unknown faces
         *         limit: Maximum events to return (default: 100, max: 1000)
         *         offset: Number of events to skip for pagination
         *         session: Database session
         *
         *     Returns:
         *         FaceDetectionEventListResponse with events and total count
         */
        get: operations["face-recognition_list_face_events"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/face-events/match": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Match Face
         * @description Match a face embedding against known persons.
         *
         *     Compares the provided 512-dimensional embedding against all stored
         *     embeddings and returns the best match if above the threshold.
         *
         *     Args:
         *         data: Match request with embedding and optional threshold
         *         session: Database session
         *
         *     Returns:
         *         FaceMatchResponse with match results
         *
         *     Raises:
         *         HTTPException: 400 if embedding is invalid
         */
        post: operations["face-recognition_match_face"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/face-events/unknown": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Unknown Strangers
         * @description Get unknown stranger alerts.
         *
         *     Returns face detection events where no known person was matched.
         *     Only includes faces with quality score above the threshold.
         *
         *     Args:
         *         start_time: Filter events after this time (optional)
         *         end_time: Filter events before this time (optional)
         *         min_quality: Minimum quality score for reliable detections
         *         limit: Maximum events to return
         *         session: Database session
         *
         *     Returns:
         *         UnknownStrangerListResponse with unknown face detections
         */
        get: operations["face-recognition_get_unknown_strangers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/feedback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Submit event feedback
         * @description Submit feedback for an event.
         *
         *     Allows users to mark events as false positives, missed detections,
         *     wrong severity, or correctly classified. Only one feedback per event
         *     is allowed (enforced by unique constraint).
         *
         *     This feedback is used to calibrate personalized risk thresholds
         *     and improve the AI model's accuracy over time.
         *
         *     Args:
         *         feedback_data: Feedback details including event_id and feedback_type
         *         db: Database session
         *
         *     Returns:
         *         The created feedback record
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         *         HTTPException: 409 if feedback already exists for this event
         */
        post: operations["feedback_create_feedback"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/feedback/event/{event_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get feedback for an event
         * @description Get feedback for a specific event.
         *
         *     Args:
         *         event_id: The event ID to get feedback for
         *         db: Database session
         *
         *     Returns:
         *         The feedback record for the event
         *
         *     Raises:
         *         HTTPException: 404 if no feedback exists for the event
         */
        get: operations["feedback_get_event_feedback"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/feedback/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get feedback statistics
         * @description Get aggregate feedback statistics.
         *
         *     Returns counts of feedback grouped by:
         *     - Feedback type (false_positive, missed_detection, wrong_severity, correct)
         *     - Camera ID
         *
         *     This data is useful for:
         *     - Identifying cameras with high false positive rates
         *     - Calibrating risk thresholds per camera
         *     - Tracking model accuracy over time
         *
         *     Args:
         *         db: Database session
         *
         *     Returns:
         *         Aggregate statistics including total count and breakdowns
         */
        get: operations["feedback_get_feedback_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/health/ai-services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Unified AI Services Health Status
         * @description Get a unified view of all AI service health including circuit breaker states,
         *     error rates, latency metrics, and queue depths.
         *
         *     The response includes:
         *     - **overall_status**: healthy/degraded/critical based on service availability
         *     - **services**: Individual health status for each AI service (yolo26, nemotron, florence, clip, enrichment)
         *     - **queues**: Current depth of detection and analysis queues with DLQ counts
         *
         *     HTTP Status Codes:
         *     - **200**: All services operational or system is degraded but functional
         *     - **503**: Critical services (yolo26, nemotron) are unhealthy
         */
        get: operations["health_get_ai_services_health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/heatmaps/camera/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Current Heatmap
         * @description Get the current heatmap image for a camera.
         *
         *     Returns a heatmap visualization based on the current in-memory accumulator
         *     for the specified camera. If no accumulator exists, returns an empty heatmap.
         *
         *     Args:
         *         camera_id: ID of the camera.
         *         resolution: Requested resolution (for metadata).
         *         output_width: Width of the output image in pixels.
         *         output_height: Height of the output image in pixels.
         *         colormap: Matplotlib colormap name.
         *         db: Database session.
         *
         *     Returns:
         *         HeatmapResponse with base64-encoded image and metadata.
         *
         *     Raises:
         *         HTTPException: 404 if camera not found.
         */
        get: operations["heatmaps_get_current_heatmap"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/heatmaps/camera/{camera_id}/accumulator": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Reset Heatmap Accumulator
         * @description Reset the heatmap accumulator for a camera.
         *
         *     Clears all accumulated detection data from memory. This does not
         *     affect saved heatmap records in the database.
         *
         *     Args:
         *         camera_id: ID of the camera.
         *         db: Database session.
         *
         *     Returns:
         *         Dictionary with reset status.
         *
         *     Raises:
         *         HTTPException: 404 if camera not found.
         */
        delete: operations["heatmaps_reset_heatmap_accumulator"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/heatmaps/camera/{camera_id}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Heatmap History
         * @description Get historical heatmap metadata for a camera.
         *
         *     Returns a list of heatmap metadata records for the specified time range.
         *     Does not include the full heatmap images - use the individual heatmap
         *     endpoint to retrieve specific images.
         *
         *     Args:
         *         camera_id: ID of the camera.
         *         start_time: Start of the time range.
         *         end_time: End of the time range.
         *         resolution: Optional filter by resolution level.
         *         limit: Maximum number of records to return.
         *         offset: Number of records to skip.
         *         db: Database session.
         *
         *     Returns:
         *         HeatmapListResponse with metadata records and total count.
         *
         *     Raises:
         *         HTTPException: 400 if start_time is after end_time.
         *         HTTPException: 404 if camera not found.
         */
        get: operations["heatmaps_get_heatmap_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/heatmaps/camera/{camera_id}/merged": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Merged Heatmap
         * @description Get a merged heatmap from multiple records in a time range.
         *
         *     Combines all heatmap data in the specified time range into a single
         *     visualization, showing activity patterns across the entire period.
         *
         *     Args:
         *         camera_id: ID of the camera.
         *         start_time: Start of the time range.
         *         end_time: End of the time range.
         *         resolution: Optional filter by resolution level.
         *         db: Database session.
         *
         *     Returns:
         *         HeatmapResponse with merged heatmap image.
         *
         *     Raises:
         *         HTTPException: 400 if start_time is after end_time.
         *         HTTPException: 404 if camera not found or no data in range.
         */
        get: operations["heatmaps_get_merged_heatmap"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/heatmaps/camera/{camera_id}/snapshot": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Save Heatmap Snapshot
         * @description Force save the current heatmap accumulator to the database.
         *
         *     Manually triggers a snapshot of the current in-memory heatmap data
         *     for the specified camera. Useful for debugging or manual data capture.
         *
         *     Args:
         *         camera_id: ID of the camera.
         *         request: Snapshot request with resolution.
         *         db: Database session.
         *
         *     Returns:
         *         HeatmapSnapshotResponse with save status.
         *
         *     Raises:
         *         HTTPException: 404 if camera not found.
         */
        post: operations["heatmaps_save_heatmap_snapshot"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/heatmaps/camera/{camera_id}/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Heatmap Stats
         * @description Get statistics about the current heatmap accumulator for a camera.
         *
         *     Returns information about the in-memory accumulator including total
         *     detections, dimensions, and intensity statistics.
         *
         *     Args:
         *         camera_id: ID of the camera.
         *         db: Database session.
         *
         *     Returns:
         *         Dictionary with accumulator statistics.
         *
         *     Raises:
         *         HTTPException: 404 if camera not found.
         */
        get: operations["heatmaps_get_heatmap_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/household/members": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Members
         * @description List all household members.
         *
         *     Returns all registered household members ordered by name.
         *
         *     Args:
         *         session: Database session
         *
         *     Returns:
         *         List of HouseholdMember objects
         */
        get: operations["household_list_members"];
        put?: never;
        /**
         * Create Member
         * @description Create a new household member.
         *
         *     Args:
         *         member: Member creation data
         *         session: Database session
         *
         *     Returns:
         *         Created HouseholdMember object
         */
        post: operations["household_create_member"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/household/members/{member_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Member
         * @description Get a specific household member by ID.
         *
         *     Args:
         *         member_id: ID of the member to retrieve
         *         session: Database session
         *
         *     Returns:
         *         HouseholdMember object
         *
         *     Raises:
         *         HTTPException: 404 if member not found
         */
        get: operations["household_get_member"];
        put?: never;
        post?: never;
        /**
         * Delete Member
         * @description Delete a household member.
         *
         *     This will also delete all associated person embeddings (cascade).
         *
         *     Args:
         *         member_id: ID of the member to delete
         *         session: Database session
         *
         *     Raises:
         *         HTTPException: 404 if member not found
         */
        delete: operations["household_delete_member"];
        options?: never;
        head?: never;
        /**
         * Update Member
         * @description Update an existing household member.
         *
         *     Args:
         *         member_id: ID of the member to update
         *         updates: Member update data (all fields optional)
         *         session: Database session
         *
         *     Returns:
         *         Updated HouseholdMember object
         *
         *     Raises:
         *         HTTPException: 404 if member not found
         */
        patch: operations["household_update_member"];
        trace?: never;
    };
    "/api/household/members/{member_id}/embeddings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add Embedding From Event
         * @description Add a person embedding from an event to a household member.
         *
         *     This endpoint allows linking a person detection embedding from an event
         *     to a household member for future re-identification. The embedding data
         *     is extracted from the event's detection.
         *
         *     Args:
         *         member_id: ID of the household member
         *         request: Request containing event_id and confidence
         *         session: Database session
         *
         *     Returns:
         *         Created PersonEmbedding object
         *
         *     Raises:
         *         HTTPException: 404 if member not found
         *         HTTPException: 404 if event not found
         *         HTTPException: 400 if event has no embedding data
         */
        post: operations["household_add_embedding_from_event"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/household/vehicles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Vehicles
         * @description List all registered vehicles.
         *
         *     Returns all registered vehicles ordered by description.
         *
         *     Args:
         *         session: Database session
         *
         *     Returns:
         *         List of RegisteredVehicle objects
         */
        get: operations["household_list_vehicles"];
        put?: never;
        /**
         * Create Vehicle
         * @description Create a new registered vehicle.
         *
         *     Args:
         *         vehicle: Vehicle creation data
         *         session: Database session
         *
         *     Returns:
         *         Created RegisteredVehicle object
         *
         *     Raises:
         *         HTTPException: 404 if owner_id is specified but owner doesn't exist
         */
        post: operations["household_create_vehicle"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/household/vehicles/{vehicle_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Vehicle
         * @description Get a specific registered vehicle by ID.
         *
         *     Args:
         *         vehicle_id: ID of the vehicle to retrieve
         *         session: Database session
         *
         *     Returns:
         *         RegisteredVehicle object
         *
         *     Raises:
         *         HTTPException: 404 if vehicle not found
         */
        get: operations["household_get_vehicle"];
        put?: never;
        post?: never;
        /**
         * Delete Vehicle
         * @description Delete a registered vehicle.
         *
         *     Args:
         *         vehicle_id: ID of the vehicle to delete
         *         session: Database session
         *
         *     Raises:
         *         HTTPException: 404 if vehicle not found
         */
        delete: operations["household_delete_vehicle"];
        options?: never;
        head?: never;
        /**
         * Update Vehicle
         * @description Update an existing registered vehicle.
         *
         *     Args:
         *         vehicle_id: ID of the vehicle to update
         *         updates: Vehicle update data (all fields optional)
         *         session: Database session
         *
         *     Returns:
         *         Updated RegisteredVehicle object
         *
         *     Raises:
         *         HTTPException: 404 if vehicle not found
         *         HTTPException: 404 if owner_id is specified but owner doesn't exist
         */
        patch: operations["household_update_vehicle"];
        trace?: never;
    };
    "/api/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all jobs
         * @description List all background jobs with optional filtering by type and status.
         */
        get: operations["jobs_list_jobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/bulk-cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Bulk cancel jobs
         * @description Cancel multiple jobs at once. Returns counts of successful and failed cancellations.
         */
        post: operations["jobs_bulk_cancel_jobs"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search and filter jobs
         * @description Search and filter jobs with advanced query capabilities. Supports free text search, filtering by status/type/timestamps/duration, and returns aggregation data for faceted filtering. NEM-2392: Advanced job search endpoint.
         */
        get: operations["jobs_search_jobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get job statistics
         * @description Get aggregate statistics about jobs including counts by status, counts by type, and timing information.
         */
        get: operations["jobs_get_job_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List available job types
         * @description List all available job types that can be created.
         */
        get: operations["jobs_list_job_types"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get job status
         * @description Get the current status and progress of a background job.
         */
        get: operations["jobs_get_job_status"];
        put?: never;
        post?: never;
        /**
         * Cancel or abort a job
         * @description Cancel or abort a job based on its current state. Queued jobs will be cancelled, running jobs will be aborted.
         */
        delete: operations["jobs_delete_job"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/abort": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Abort a running job
         * @description Abort a running background job by sending a signal to the worker. Only jobs with status 'running' can be aborted. Queued jobs should use the /cancel endpoint instead.
         */
        post: operations["jobs_abort_job"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel a job
         * @description Request cancellation of a background job. Jobs that are already completed or failed cannot be cancelled.
         */
        post: operations["jobs_cancel_job"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/detail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get detailed job information
         * @description Get detailed information about a specific job including full progress history, timing information, retry details, and execution metadata. NEM-2390: Provides comprehensive job status for monitoring and debugging.
         */
        get: operations["jobs_get_job_detail"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get job history
         * @description Retrieve complete job execution history including state transitions, retry attempts, and execution timeline. Provides audit trail for debugging and compliance purposes. NEM-2396.
         */
        get: operations["jobs_get_job_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/{job_id}/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get job logs
         * @description Retrieve execution logs for a job with optional filtering by level and time range. Useful for debugging and monitoring job execution. NEM-2396.
         */
        get: operations["jobs_get_job_logs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/known-persons": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Known Persons
         * @description List all known persons.
         *
         *     Returns all registered known persons with their embedding counts.
         *     Optionally filter to only household members.
         *
         *     Args:
         *         household_only: If True, only return household members
         *         session: Database session
         *
         *     Returns:
         *         KnownPersonListResponse with list of persons and total count
         */
        get: operations["face-recognition_list_known_persons"];
        put?: never;
        /**
         * Create Known Person
         * @description Create a new known person.
         *
         *     Args:
         *         data: Person creation data
         *         session: Database session
         *
         *     Returns:
         *         Created KnownPersonResponse
         */
        post: operations["face-recognition_create_known_person"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/known-persons/{person_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Known Person
         * @description Get a known person by ID.
         *
         *     Args:
         *         person_id: ID of the person
         *         session: Database session
         *
         *     Returns:
         *         KnownPersonResponse
         *
         *     Raises:
         *         HTTPException: 404 if person not found
         */
        get: operations["face-recognition_get_known_person"];
        put?: never;
        post?: never;
        /**
         * Delete Known Person
         * @description Delete a known person and all associated embeddings.
         *
         *     Args:
         *         person_id: ID of the person to delete
         *         session: Database session
         *
         *     Raises:
         *         HTTPException: 404 if person not found
         */
        delete: operations["face-recognition_delete_known_person"];
        options?: never;
        head?: never;
        /**
         * Update Known Person
         * @description Update a known person.
         *
         *     Args:
         *         person_id: ID of the person to update
         *         data: Update data (all fields optional)
         *         session: Database session
         *
         *     Returns:
         *         Updated KnownPersonResponse
         *
         *     Raises:
         *         HTTPException: 404 if person not found
         */
        patch: operations["face-recognition_update_known_person"];
        trace?: never;
    };
    "/api/known-persons/{person_id}/embeddings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Person Embeddings
         * @description List all face embeddings for a person.
         *
         *     Args:
         *         person_id: ID of the person
         *         session: Database session
         *
         *     Returns:
         *         List of FaceEmbeddingResponse
         *
         *     Raises:
         *         HTTPException: 404 if person not found
         */
        get: operations["face-recognition_list_person_embeddings"];
        put?: never;
        /**
         * Add Face Embedding
         * @description Add a face embedding for a known person.
         *
         *     The embedding should be a 512-dimensional ArcFace embedding vector.
         *
         *     Args:
         *         person_id: ID of the person
         *         data: Embedding data with 512-dim vector
         *         session: Database session
         *
         *     Returns:
         *         Created FaceEmbeddingResponse
         *
         *     Raises:
         *         HTTPException: 404 if person not found
         *         HTTPException: 400 if embedding is invalid
         */
        post: operations["face-recognition_add_face_embedding"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/known-persons/{person_id}/embeddings/{embedding_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Face Embedding
         * @description Delete a face embedding.
         *
         *     Args:
         *         person_id: ID of the person (for URL consistency)
         *         embedding_id: ID of the embedding to delete
         *         session: Database session
         *
         *     Raises:
         *         HTTPException: 404 if embedding not found
         */
        delete: operations["face-recognition_delete_face_embedding"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List logs with optional filtering
         * @description Query logs with optional filtering by level, component, source, and date range.
         */
        get: operations["logs_list_logs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/frontend": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ingest single frontend log
         * @description Receive a single log entry from the frontend for structured logging.
         */
        post: operations["logs_ingest_frontend_log"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/frontend/batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ingest batch of frontend logs
         * @description Receive a batch of log entries from the frontend for structured logging.
         */
        post: operations["logs_ingest_frontend_logs_batch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/logs/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get log statistics
         * @description Get aggregated log statistics for the dashboard.
         */
        get: operations["logs_get_log_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/cameras/{camera_id}/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Camera File
         * @description Serve camera images or videos from Foscam storage.
         *
         *     Args:
         *         camera_id: The camera identifier (directory name)
         *         filename: The file to serve (can include subdirectories)
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["media_serve_camera_file"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/clips/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Clip
         * @description Serve event video clips.
         *
         *     Clips are generated by the ClipGenerator service and stored in the
         *     configured clips directory.
         *
         *     Args:
         *         filename: The clip filename (e.g., "123_clip.mp4")
         *         clip_generator: ClipGenerator injected via Depends()
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["media_serve_clip"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/thumbnails/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Thumbnail
         * @description Serve detection thumbnail images.
         *
         *     Args:
         *         filename: The thumbnail filename
         *
         *     Returns:
         *         FileResponse with appropriate content-type header
         *
         *     Raises:
         *         HTTPException: 403 for invalid paths, 404 for missing files
         */
        get: operations["media_serve_thumbnail"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/media/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Serve Media Compat
         * @description Compatibility route: serve media via design-spec-style /api/media/{path}.
         *
         *     This preserves the stricter behavior of the new routes:
         *     - Path traversal protection
         *     - Allowed file type allowlist
         *     - Must remain under configured base directories
         *
         *     Mapping rules:
         *     - `cameras/<camera_id>/<filename...>` -> camera media
         *     - `thumbnails/<filename>` -> thumbnails
         *     - `detections/<id>` -> detection images
         */
        get: operations["media_serve_media_compat"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Metrics
         * @description Return Prometheus metrics in exposition format.
         *
         *     This endpoint returns all registered metrics in the standard
         *     Prometheus exposition format for scraping.
         *
         *     Returns:
         *         Response with text/plain content type containing metrics
         */
        get: operations["metrics_metrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Notification Preferences
         * @description Get global notification preferences.
         *
         *     Returns the global notification settings including:
         *     - Whether notifications are enabled
         *     - Notification sound selection
         *     - Risk level filters (which risk levels trigger notifications)
         *
         *     Returns:
         *         NotificationPreferencesResponse with current preferences
         */
        get: operations["notification-preferences_get_notification_preferences"];
        /**
         * Update Notification Preferences
         * @description Update global notification preferences.
         *
         *     Args:
         *         update: Preferences update data
         *
         *     Returns:
         *         NotificationPreferencesResponse with updated preferences
         *
         *     Raises:
         *         HTTPException: 400 if sound value is invalid
         */
        put: operations["notification-preferences_update_notification_preferences"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Camera Settings
         * @description Get all camera notification settings.
         *
         *     Returns:
         *         CameraNotificationSettingsListResponse with all camera settings
         */
        get: operations["notification-preferences_get_all_camera_settings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/cameras/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Camera Setting
         * @description Get notification setting for a specific camera.
         *
         *     Args:
         *         camera_id: Camera ID
         *
         *     Returns:
         *         CameraNotificationSettingResponse for the camera
         *
         *     Raises:
         *         HTTPException: 404 if setting not found
         */
        get: operations["notification-preferences_get_camera_setting"];
        /**
         * Update Camera Setting
         * @description Update or create notification setting for a camera.
         *
         *     Args:
         *         camera_id: Camera ID
         *         update: Setting update data
         *
         *     Returns:
         *         CameraNotificationSettingResponse with updated setting
         *
         *     Raises:
         *         HTTPException: 404 if camera doesn't exist
         */
        put: operations["notification-preferences_update_camera_setting"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/quiet-hours": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Quiet Hours
         * @description Get all quiet hours periods.
         *
         *     Returns:
         *         QuietHoursPeriodsListResponse with all quiet periods
         */
        get: operations["notification-preferences_get_quiet_hours"];
        put?: never;
        /**
         * Create Quiet Hours Period
         * @description Create a new quiet hours period.
         *
         *     Args:
         *         period: Quiet hours period data
         *
         *     Returns:
         *         QuietHoursPeriodResponse with created period
         *
         *     Raises:
         *         HTTPException: 400 if start_time equals end_time (zero-length period)
         *
         *     Note:
         *         Periods can span midnight (e.g., 22:00 to 06:00).
         *         If start_time > end_time, the period wraps to the next day.
         */
        post: operations["notification-preferences_create_quiet_hours_period"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification-preferences/quiet-hours/{period_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Quiet Hours Period
         * @description Delete a quiet hours period.
         *
         *     Args:
         *         period_id: Period UUID
         *
         *     Raises:
         *         HTTPException: 404 if period not found
         */
        delete: operations["notification-preferences_delete_quiet_hours_period"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Notification Config
         * @description Get notification configuration status.
         *
         *     Returns the current notification configuration including:
         *     - Whether notifications are enabled
         *     - Which channels are configured (email, webhook, push)
         *     - SMTP host and port (if configured)
         *     - Default webhook URL (if configured)
         *     - Default email recipients
         *
         *     Note: Sensitive fields like SMTP password are NOT returned.
         *
         *     Returns:
         *         NotificationConfigResponse with current notification settings
         */
        get: operations["notification_get_notification_config"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Notification Config
         * @description Update notification configuration.
         *
         *     Allows enabling/disabling SMTP and webhook channels, and updating their settings.
         *     Only specified fields will be updated; others remain unchanged.
         *
         *     Args:
         *         config_update: Partial configuration update with optional fields
         *
         *     Returns:
         *         NotificationConfigUpdateResponse with the updated configuration
         */
        patch: operations["notification_update_notification_config"];
        trace?: never;
    };
    "/api/notification/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Notification History
         * @description Get notification delivery history with optional filters.
         *
         *     Returns paginated notification delivery records with optional filtering
         *     by alert ID, channel type, and success status.
         *
         *     Note: This endpoint returns the structure for notification history.
         *     A future enhancement will persist delivery records to the database
         *     and return actual history data.
         *
         *     Args:
         *         alert_id: Optional alert ID to filter by
         *         channel: Optional notification channel to filter by
         *         success: Optional success status to filter by
         *         limit: Maximum number of results to return (1-100, default 50)
         *         offset: Number of results to skip for pagination (default 0)
         *
         *     Returns:
         *         NotificationHistoryResponse with delivery history entries
         */
        get: operations["notification_get_notification_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/notification/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Notification
         * @description Test notification delivery for a specific channel.
         *
         *     Sends a test notification to verify the configuration is working.
         *     For email, sends a test email to the specified recipients or default recipients.
         *     For webhook, sends a test payload to the specified URL or default URL.
         *
         *     Args:
         *         test_request: Test notification request with channel and optional overrides
         *
         *     Returns:
         *         TestNotificationResponse with test result
         */
        post: operations["notification_test_notification"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/outbound-webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List webhooks
         * @description List all outbound webhook configurations with optional filtering.
         */
        get: operations["outbound-webhooks_list_webhooks"];
        put?: never;
        /**
         * Create webhook
         * @description Create a new outbound webhook configuration. The webhook will be triggered when subscribed events occur in the system.
         */
        post: operations["outbound-webhooks_create_webhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/outbound-webhooks/deliveries/{delivery_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get delivery details
         * @description Get detailed information about a specific webhook delivery attempt.
         */
        get: operations["outbound-webhooks_get_delivery"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/outbound-webhooks/deliveries/{delivery_id}/retry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Retry failed delivery
         * @description Manually retry a failed webhook delivery. Creates a new delivery attempt for the same event and webhook configuration.
         */
        post: operations["outbound-webhooks_retry_delivery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/outbound-webhooks/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get webhook health summary
         * @description Get aggregated health metrics for all outbound webhooks, including success rates and delivery statistics over the last 24 hours.
         */
        get: operations["outbound-webhooks_get_webhook_health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/outbound-webhooks/{webhook_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get webhook
         * @description Get a specific outbound webhook configuration by ID.
         */
        get: operations["outbound-webhooks_get_webhook"];
        put?: never;
        post?: never;
        /**
         * Delete webhook
         * @description Delete an outbound webhook configuration. This will also delete all associated delivery history.
         */
        delete: operations["outbound-webhooks_delete_webhook"];
        options?: never;
        head?: never;
        /**
         * Update webhook
         * @description Update an existing outbound webhook configuration.
         */
        patch: operations["outbound-webhooks_update_webhook"];
        trace?: never;
    };
    "/api/outbound-webhooks/{webhook_id}/deliveries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List deliveries
         * @description List delivery history for a specific webhook with pagination.
         */
        get: operations["outbound-webhooks_list_deliveries"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/outbound-webhooks/{webhook_id}/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Disable webhook
         * @description Disable a webhook so it will stop receiving events.
         */
        post: operations["outbound-webhooks_disable_webhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/outbound-webhooks/{webhook_id}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable webhook
         * @description Enable a disabled webhook so it will receive events.
         */
        post: operations["outbound-webhooks_enable_webhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/outbound-webhooks/{webhook_id}/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test webhook
         * @description Test a webhook by sending a sample payload. This does not create a delivery record and is useful for validating webhook configuration.
         */
        post: operations["outbound-webhooks_test_webhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/plate-reads": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Plate Reads
         * @description List plate reads with optional filters.
         *
         *     Returns a paginated list of plate recognition results with optional
         *     filtering by camera, time range, and confidence threshold.
         *
         *     Args:
         *         db: Database session.
         *         camera_id: Optional filter by camera ID.
         *         start_time: Optional start time filter (ISO format).
         *         end_time: Optional end time filter (ISO format).
         *         min_confidence: Optional minimum OCR confidence filter (0-1).
         *         page: Page number (1-indexed, default 1).
         *         page_size: Number of items per page (1-100, default 50).
         *
         *     Returns:
         *         PlateReadListResponse with paginated plate reads.
         *
         *     Example:
         *         GET /api/plate-reads?camera_id=driveway&page=1&page_size=25
         */
        get: operations["plate-reads_list_plate_reads"];
        put?: never;
        /**
         * Create Plate Read
         * @description Create a new plate read record.
         *
         *     Used for manual entry or importing plate reads from external ALPR
         *     systems. For automatic recognition from images, use POST /recognize.
         *
         *     Args:
         *         data: PlateReadCreate schema with plate data.
         *         db: Database session.
         *
         *     Returns:
         *         PlateReadResponse with the created record.
         *
         *     Example:
         *         POST /api/plate-reads
         *         {
         *             "camera_id": "driveway",
         *             "timestamp": "2026-01-26T14:30:00Z",
         *             "plate_text": "ABC1234",
         *             "raw_text": "ABC-1234",
         *             "detection_confidence": 0.95,
         *             "ocr_confidence": 0.92,
         *             "bbox": [100.0, 200.0, 250.0, 240.0],
         *             "image_quality_score": 0.85,
         *             "is_enhanced": false,
         *             "is_blurry": false
         *         }
         */
        post: operations["plate-reads_create_plate_read"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/plate-reads/camera/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Reads By Camera
         * @description Get plate reads for a specific camera.
         *
         *     Returns a paginated list of plate reads from the specified camera
         *     with optional time range filtering.
         *
         *     Args:
         *         camera_id: ID of the camera to get reads for.
         *         db: Database session.
         *         start_time: Optional start time filter (ISO format).
         *         end_time: Optional end time filter (ISO format).
         *         page: Page number (1-indexed, default 1).
         *         page_size: Number of items per page (1-100, default 50).
         *
         *     Returns:
         *         PlateReadListResponse with camera's plate reads.
         *
         *     Example:
         *         GET /api/plate-reads/camera/driveway?page=1&page_size=25
         */
        get: operations["plate-reads_get_reads_by_camera"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/plate-reads/recognize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Recognize Plate
         * @description Recognize plate text from an uploaded image.
         *
         *     Processes the image through PaddleOCR to extract plate text.
         *     Optionally stores the result in the database.
         *
         *     The image should be base64-encoded JPEG or PNG data, optionally
         *     prefixed with a data URL scheme (e.g., "data:image/jpeg;base64,").
         *
         *     Args:
         *         request: PlateRecognizeRequest with image data.
         *         db: Database session.
         *         store: Whether to store the result (default true).
         *
         *     Returns:
         *         PlateRecognizeResponse with recognition results.
         *
         *     Raises:
         *         HTTPException: 400 if image decoding fails.
         *         HTTPException: 500 if OCR processing fails.
         *
         *     Example:
         *         POST /api/plate-reads/recognize?store=true
         *         {
         *             "camera_id": "driveway",
         *             "image_base64": "data:image/jpeg;base64,/9j/4AAQSkZ...",
         *             "detection_bbox": [100.0, 200.0, 250.0, 240.0],
         *             "detection_confidence": 0.95
         *         }
         */
        post: operations["plate-reads_recognize_plate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/plate-reads/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search By Plate Text
         * @description Search plate reads by plate text.
         *
         *     Searches for plate reads matching the given text. By default performs
         *     a partial match (LIKE %text%). Set exact=true for exact matches only.
         *
         *     Args:
         *         db: Database session.
         *         text: Plate text to search for (required).
         *         exact: If true, match exactly; if false, partial match (default).
         *         page: Page number (1-indexed, default 1).
         *         page_size: Number of items per page (1-100, default 50).
         *
         *     Returns:
         *         PlateReadListResponse with matching plate reads.
         *
         *     Example:
         *         GET /api/plate-reads/search?text=ABC&exact=false
         *         GET /api/plate-reads/search?text=ABC1234&exact=true
         */
        get: operations["plate-reads_search_by_plate_text"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/plate-reads/statistics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Statistics
         * @description Get plate recognition statistics.
         *
         *     Returns aggregate statistics for ALPR system health monitoring,
         *     including total reads, average confidence, and recent activity.
         *
         *     Args:
         *         db: Database session.
         *
         *     Returns:
         *         PlateStatisticsResponse with recognition metrics.
         *
         *     Example:
         *         GET /api/plate-reads/statistics
         */
        get: operations["plate-reads_get_statistics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/plate-reads/{plate_read_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Plate Read
         * @description Get a single plate read by ID.
         *
         *     Retrieves full details of a specific plate read record.
         *
         *     Args:
         *         plate_read_id: Database ID of the plate read.
         *         db: Database session.
         *
         *     Returns:
         *         PlateReadResponse with the plate read details.
         *
         *     Raises:
         *         HTTPException: 404 if plate read not found.
         *
         *     Example:
         *         GET /api/plate-reads/123
         */
        get: operations["plate-reads_get_plate_read"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/prompts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Prompts
         * @description Fetch current prompt configurations for all AI models.
         *
         *     Returns the active prompt/configuration for each supported model:
         *     - nemotron: System prompt for risk analysis
         *     - florence2: Scene analysis queries
         *     - yolo_world: Custom object classes and confidence threshold
         *     - xclip: Action recognition classes
         *     - fashion_clip: Clothing categories
         */
        get: operations["prompts_get_all_prompts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/prompts/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export Prompts
         * @description Export all prompt configurations as JSON.
         *
         *     Returns a complete export of all model configurations suitable for
         *     backup, sharing, or importing into another instance.
         */
        get: operations["prompts_export_prompts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/prompts/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Prompt History
         * @description Get version history for prompt configurations.
         *
         *     Returns a list of all prompt versions, optionally filtered by model.
         */
        get: operations["prompts_get_prompt_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/prompts/history/{version_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restore Prompt Version
         * @description Restore a specific prompt version.
         *
         *     Creates a new version with the configuration from the specified version,
         *     making it the active configuration.
         */
        post: operations["prompts_restore_prompt_version"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/prompts/import": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import Prompts
         * @description Import prompt configurations from JSON.
         *
         *     Validates and imports configurations for each model, creating new
         *     versions for each imported configuration.
         */
        post: operations["prompts_import_prompts"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/prompts/import/preview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Preview Import Prompts
         * @description Preview import changes without applying them.
         *
         *     Validates the import data and computes diffs against current configurations.
         */
        post: operations["prompts_preview_import_prompts"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/prompts/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Prompt
         * @description Test a modified prompt configuration against an event or image.
         *
         *     Runs inference with the modified configuration and compares results
         *     with the original configuration.
         *
         *     Rate Limited:
         *         This endpoint is rate limited to 10 requests per minute per client
         *         with a burst allowance of 3. This protects the AI services from abuse
         *         since prompt testing runs LLM inference which is computationally expensive.
         *
         *     Returns 429 Too Many Requests if rate limit is exceeded.
         */
        post: operations["prompts_test_prompt"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/prompts/test-prompt": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Custom Prompt
         * @description Test a custom prompt against an existing event for A/B testing.
         *
         *     This endpoint allows testing a custom prompt without persisting results.
         *     It's designed for the Prompt Playground A/B testing feature where users
         *     can experiment with different prompts and compare results.
         *
         *     The endpoint:
         *     1. Fetches the event with its detections
         *     2. Builds context from the event data
         *     3. Calls the AI model with the custom prompt (or mocks if service unavailable)
         *     4. Returns results WITHOUT saving to database
         *
         *     Rate Limited:
         *         This endpoint is rate limited to 10 requests per minute per client
         *         with a burst allowance of 3. This protects the AI services from abuse
         *         since prompt testing runs LLM inference which is computationally expensive.
         *
         *     Args:
         *         request: Test request containing event_id, custom_prompt, and optional
         *                  parameters (temperature, max_tokens, model)
         *         db: Database session
         *
         *     Returns:
         *         CustomTestPromptResponse with risk analysis results
         *
         *     Raises:
         *         HTTPException: 404 if event not found
         *         HTTPException: 400 if prompt is invalid (empty or too long)
         *         HTTPException: 429 if rate limit is exceeded
         *         HTTPException: 503 if AI service is unavailable
         *         HTTPException: 408 if request times out (>60s)
         */
        post: operations["prompts_test_custom_prompt"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/prompts/{model}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Prompt For Model
         * @description Fetch prompt configuration for a specific AI model.
         */
        get: operations["prompts_get_prompt_for_model"];
        /**
         * Update Prompt For Model
         * @description Update prompt configuration for a specific AI model.
         *
         *     Creates a new version of the configuration while preserving history.
         *     Validates the configuration structure before saving.
         *
         *     Supports optimistic locking via expected_version in the request body.
         *     If expected_version is provided and doesn't match the current version,
         *     returns 409 Conflict to indicate concurrent modification.
         */
        put: operations["prompts_update_prompt_for_model"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/queues/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get queue status
         * @description Get the status of all job queues including depth, processing rate, and health.
         *
         *     **Queues Monitored:**
         *     - `detection`: Object detection jobs from camera uploads
         *     - `ai_analysis`: LLM risk analysis jobs for batched detections
         *     - `dlq`: Dead-letter queue for failed jobs
         *
         *     **Health Status:**
         *     - `healthy`: Queue depth below warning threshold, wait times acceptable
         *     - `warning`: Queue depth approaching limits or wait times elevated
         *     - `critical`: Queue depth exceeds limits or oldest job waiting too long
         *
         *     **Thresholds:**
         *     Each queue has configurable thresholds:
         *     - `depth_warning`: Queue depth that triggers warning status
         *     - `depth_critical`: Queue depth that triggers critical status
         *     - `max_wait_seconds`: Maximum acceptable wait time for oldest job
         */
        get: operations["queues_get_queues_status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rum": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ingest RUM metrics
         * @description Receive Core Web Vitals metrics from the frontend for Real User Monitoring.
         */
        post: operations["rum_ingest_rum_metrics"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/scheduled-reports": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all scheduled reports
         * @description Get a list of all scheduled reports with their configurations.
         */
        get: operations["scheduled-reports_list_scheduled_reports"];
        put?: never;
        /**
         * Create a scheduled report
         * @description Create a new scheduled report with the specified configuration. Reports can be daily, weekly, or monthly, and can be delivered via email.
         */
        post: operations["scheduled-reports_create_scheduled_report"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/scheduled-reports/{report_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a scheduled report
         * @description Get details of a specific scheduled report by ID.
         */
        get: operations["scheduled-reports_get_scheduled_report"];
        /**
         * Update a scheduled report
         * @description Update an existing scheduled report configuration. All fields are optional - only provided fields will be updated.
         */
        put: operations["scheduled-reports_update_scheduled_report"];
        post?: never;
        /**
         * Delete a scheduled report
         * @description Delete a scheduled report by ID.
         */
        delete: operations["scheduled-reports_delete_scheduled_report"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/scheduled-reports/{report_id}/run": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Manually trigger a report
         * @description Manually trigger a scheduled report to run immediately, regardless of its schedule.
         */
        post: operations["scheduled-reports_run_scheduled_report"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/summaries/daily": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Daily Summary
         * @description Get the latest daily summary.
         *
         *     Returns the most recent daily summary, which covers high/critical events
         *     since midnight today. Returns null if no daily summary exists.
         *
         *     This endpoint is useful when you only need the daily summary without
         *     the overhead of fetching the hourly summary as well.
         *
         *     Returns:
         *         SummaryResponse with daily summary, or null if none exists
         */
        get: operations["summaries_get_daily_summary"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/summaries/hourly": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Hourly Summary
         * @description Get the latest hourly summary.
         *
         *     Returns the most recent hourly summary, which covers high/critical events
         *     from the past 60 minutes. Returns null if no hourly summary exists.
         *
         *     This endpoint is useful when you only need the hourly summary without
         *     the overhead of fetching the daily summary as well.
         *
         *     Returns:
         *         SummaryResponse with hourly summary, or null if none exists
         */
        get: operations["summaries_get_hourly_summary"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/summaries/latest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Latest Summaries
         * @description Get the latest hourly and daily summaries.
         *
         *     Returns both the most recent hourly summary (covering the past 60 minutes)
         *     and the most recent daily summary (covering since midnight today).
         *
         *     Either `hourly` or `daily` can be null if no summary exists yet for that
         *     time period. This can happen when:
         *     - The system was just started
         *     - No high/critical events have occurred
         *
         *     Response is cached in Redis with a 5-minute TTL to match the summary
         *     generation frequency. Cache is invalidated when new summaries are generated.
         *
         *     Returns:
         *         LatestSummariesResponse with hourly and daily summaries (or nulls)
         */
        get: operations["summaries_get_latest_summaries"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/ai-services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List available AI services
         * @description Returns all AI services with their VRAM requirements.
         */
        get: operations["gpu-config_list_ai_services"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/anomaly-config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Anomaly Config
         * @description Get current anomaly detection configuration.
         *
         *     Returns the current settings for the baseline service including:
         *     - threshold_stdev: Number of standard deviations for anomaly detection
         *     - min_samples: Minimum samples required before anomaly detection is reliable
         *     - decay_factor: Exponential decay factor for EWMA (weights recent observations)
         *     - window_days: Rolling window size in days for baseline calculations
         *
         *     Args:
         *         service: BaselineService injected via Depends()
         *
         *     Returns:
         *         AnomalyConfig with current anomaly detection settings
         */
        get: operations["system_get_anomaly_config"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Anomaly Config
         * @description Update anomaly detection configuration.
         *
         *     Allows updating the anomaly detection thresholds:
         *     - threshold_stdev: Number of standard deviations for anomaly detection
         *     - min_samples: Minimum samples required before anomaly detection is reliable
         *
         *     Note: decay_factor and window_days are not configurable at runtime
         *     as they affect historical data calculations.
         *
         *     Requires API key authentication.
         *
         *     Args:
         *         config_update: Configuration values to update (only provided values are changed)
         *         request: HTTP request for audit logging
         *         db: Database session
         *         service: BaselineService injected via Depends()
         *
         *     Returns:
         *         AnomalyConfig with updated settings
         */
        patch: operations["system_update_anomaly_config"];
        trace?: never;
    };
    "/api/system/circuit-breakers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Circuit Breakers
         * @description Get status of all circuit breakers in the system.
         *
         *     Returns the current state and metrics for each circuit breaker,
         *     which protect external services from cascading failures.
         *
         *     Circuit breakers can be in one of three states:
         *     - CLOSED: Normal operation, calls pass through
         *     - OPEN: Service failing, calls rejected immediately
         *     - HALF_OPEN: Testing recovery, limited calls allowed
         *
         *     Returns:
         *         CircuitBreakersResponse with status of all circuit breakers
         */
        get: operations["system_get_circuit_breakers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/circuit-breakers/{name}/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset Circuit Breaker
         * @description Reset a specific circuit breaker to CLOSED state.
         *
         *     This manually resets a circuit breaker, clearing failure counts
         *     and returning it to normal operation. Use this to recover from
         *     transient failures or after fixing an underlying issue.
         *
         *     Requires API key authentication when api_key_enabled is True.
         *
         *     Args:
         *         name: Name of the circuit breaker to reset
         *
         *     Returns:
         *         CircuitBreakerResetResponse with reset confirmation
         *
         *     Raises:
         *         HTTPException 400: If name is invalid (empty, too long, or contains invalid characters)
         *         HTTPException 404: If circuit breaker not found
         */
        post: operations["system_reset_circuit_breaker"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/cleanup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Cleanup
         * @description Trigger manual data cleanup based on retention settings.
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     This endpoint runs the CleanupService to delete old data according to
         *     the configured retention period. It deletes:
         *     - Events older than retention period
         *     - Detections older than retention period
         *     - GPU stats older than retention period
         *     - Logs older than log retention period
         *     - Associated thumbnail files
         *     - Optionally original image files (if delete_images is enabled)
         *
         *     The cleanup respects the current retention_days setting from the system
         *     configuration. To change the retention period before running cleanup,
         *     use PATCH /api/system/config first.
         *
         *     Args:
         *         dry_run: If True, calculate and return what would be deleted without
         *                  actually performing the deletion. Useful for verification
         *                  before destructive operations.
         *
         *     Returns:
         *         CleanupResponse with statistics about the cleanup operation.
         *         When dry_run=True, the counts represent what would be deleted.
         */
        post: operations["system_trigger_cleanup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/cleanup/orphaned-files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Run Orphaned File Cleanup
         * @description Find and clean up orphaned files (files on disk not referenced in database).
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     This endpoint scans storage directories for files that are not referenced
         *     in the database and optionally deletes them to reclaim disk space.
         *
         *     Storage directories scanned:
         *     - Thumbnails directory (video_thumbnails_dir setting)
         *     - Clips directory (clips_directory setting)
         *
         *     Database tables checked for file references:
         *     - Detection.file_path (source images)
         *     - Detection.thumbnail_path (thumbnails)
         *     - Event.clip_path (generated clips)
         *
         *     **Safety Features:**
         *     - dry_run=True by default to prevent accidental deletion
         *     - Progress tracking via job system
         *     - Detailed reporting of orphaned files
         *
         *     Args:
         *         dry_run: If True, calculate and return what would be deleted without
         *                  actually performing the deletion. Default is True for safety.
         *                  Set to False to actually delete orphaned files.
         *
         *     Returns:
         *         OrphanedFileCleanupResponse with statistics about orphaned files.
         *         When dry_run=True, shows what would be deleted.
         *         When dry_run=False, shows what was deleted.
         */
        post: operations["system_run_orphaned_file_cleanup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/cleanup/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Cleanup Status
         * @description Get current status of the cleanup service.
         *
         *     Returns information about the automated cleanup service including:
         *     - Whether the service is running
         *     - Current retention settings
         *     - Next scheduled cleanup time
         *
         *     Returns:
         *         CleanupStatusResponse with cleanup service status
         */
        get: operations["system_get_cleanup_status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Config
         * @description Get public configuration settings.
         *
         *     Returns non-sensitive application configuration values.
         *     Does NOT expose database URLs, API keys, or other secrets.
         *
         *     Note: The detection_confidence_threshold field is deprecated.
         *     Use /api/v1/settings detection.confidence_threshold instead.
         *
         *     Returns:
         *         ConfigResponse with public configuration settings
         */
        get: operations["system_get_config"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Patch Config
         * @description Patch processing-related configuration and persist runtime overrides.
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     Note: The detection_confidence_threshold field is deprecated.
         *     Use PATCH /api/v1/settings with detection.confidence_threshold instead.
         *
         *     Notes:
         *     - This updates a runtime override env file (see `HSI_RUNTIME_ENV_PATH`) and clears the
         *       settings cache so subsequent `get_settings()` calls observe the new values.
         */
        patch: operations["system_patch_config"];
        trace?: never;
    };
    "/api/system/gpu": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Gpu Stats
         * @description Get current GPU statistics.
         *
         *     Returns the most recent GPU statistics including:
         *     - GPU name
         *     - GPU utilization percentage
         *     - Memory usage (used/total)
         *     - Temperature
         *     - Power usage
         *     - Inference FPS
         *
         *     Results are cached for HEALTH_CACHE_TTL_SECONDS (default 5 seconds) to reduce
         *     database load from frequent polling. GPU stats only update every 5 seconds anyway.
         *
         *     Returns:
         *         GPUStatsResponse with GPU statistics (null values if unavailable)
         */
        get: operations["system_get_gpu_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu-config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get GPU configuration
         * @description Returns current GPU assignment strategy and service-to-GPU mappings.
         */
        get: operations["gpu-config_get_gpu_config"];
        /**
         * Update GPU configuration
         * @description Updates GPU assignments. Does not apply changes - use /apply endpoint.
         */
        put: operations["gpu-config_update_gpu_config"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu-config/apply": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Apply GPU configuration
         * @description Applies current config and restarts affected services.
         */
        post: operations["gpu-config_apply_gpu_config"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu-config/detect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Re-detect GPUs
         * @description Triggers a fresh GPU scan and updates the database.
         */
        post: operations["gpu-config_detect_gpus"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu-config/preview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Preview auto-assignment
         * @description Preview what assignments would result from a given strategy.
         */
        get: operations["gpu-config_preview_gpu_config"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu-config/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get AI service health status
         * @description Returns health status of all AI services including GPU assignments.
         */
        get: operations["gpu-config_get_service_health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu-config/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get apply operation status
         * @description Returns current status of GPU configuration apply operation.
         */
        get: operations["gpu-config_get_gpu_config_status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpu/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Gpu Stats History
         * @description Get recent GPU stats samples as a time-series.
         *
         *     Returns GPU stats in standard pagination envelope format (NEM-2178):
         *     - items: GPU stats samples (renamed from 'samples')
         *     - pagination: Standard pagination metadata
         *
         *     Args:
         *         since: Optional lower bound for recorded_at (ISO datetime)
         *         limit: Maximum number of samples to return (default 300, max 5000)
         *         db: Database session
         */
        get: operations["system_get_gpu_stats_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/gpus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List detected GPUs
         * @description Returns all GPUs detected on the system with hardware specs and utilization.
         */
        get: operations["gpu-config_list_gpus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Health
         * @description Get detailed system health check.
         *
         *     Checks the health of all system components:
         *     - Database connectivity
         *     - Redis connectivity
         *     - AI services status
         *
         *     Health checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).
         *     If a health check times out, the service is marked as unhealthy.
         *
         *     Results are cached for HEALTH_CACHE_TTL_SECONDS (default 5 seconds) to reduce
         *     load from frequent health probes. Cached responses are returned immediately
         *     without re-checking services.
         *
         *     Returns:
         *         HealthResponse with overall status and individual service statuses.
         *         HTTP 200 if healthy, 503 if degraded or unhealthy.
         */
        get: operations["system_get_health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/full": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Full System Health Status
         * @description Get comprehensive health status for all system components.
         */
        get: operations["system_get_full_health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Readiness
         * @description Kubernetes-style readiness probe endpoint with detailed information.
         *
         *     This endpoint indicates whether the application is ready to receive
         *     traffic and process uploads. It checks all critical dependencies:
         *     - Database connectivity (critical)
         *     - Redis connectivity (required for queue processing)
         *     - AI services availability
         *     - Background worker status
         *
         *     Note: The canonical readiness probe is GET /ready at the root level.
         *     This endpoint provides the same readiness check but with detailed
         *     service and worker status information.
         *
         *     Used by Kubernetes/Docker to determine if traffic should be routed to this instance.
         *     If this endpoint returns not_ready, the instance should not receive new requests.
         *
         *     Health checks have a timeout of HEALTH_CHECK_TIMEOUT_SECONDS (default 5 seconds).
         *     If a health check times out, the service is marked as unhealthy.
         *
         *     Results are cached for HEALTH_CACHE_TTL_SECONDS (default 5 seconds) to reduce
         *     load from frequent readiness probes.
         *
         *     Returns:
         *         ReadinessResponse with overall readiness status and detailed checks.
         *         HTTP 200 if ready, 503 if degraded or not ready.
         */
        get: operations["system_get_readiness"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/health/websocket": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Websocket Health
         * @description Get health status of WebSocket broadcasters and their circuit breakers.
         *
         *     Returns the current state of circuit breakers for:
         *     - Event broadcaster: Handles real-time security event distribution
         *     - System broadcaster: Handles system status updates (GPU, cameras, queues)
         *
         *     Circuit breakers protect the system from cascading failures by:
         *     - Opening after repeated connection failures
         *     - Blocking recovery attempts while open to allow stabilization
         *     - Gradually testing recovery in half-open state
         *
         *     Circuit breaker states:
         *     - closed: Normal operation, WebSocket events flowing normally
         *     - open: Failures detected, events may be delayed or unavailable
         *     - half_open: Testing recovery, limited operations allowed
         *
         *     Returns:
         *         WebSocketHealthResponse with circuit breaker status for both broadcasters
         */
        get: operations["system_get_websocket_health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/model-zoo/latency/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Zoo Latency History
         * @description Get latency history for a specific Model Zoo model.
         *
         *     Returns time-series latency data for the dropdown-controlled chart.
         *     Each bucket contains aggregated statistics (avg, p50, p95).
         *
         *     Args:
         *         model: Model name to get history for
         *         since: Number of minutes of history to return (default 60)
         *         bucket_seconds: Size of each time bucket in seconds (default 60)
         *
         *     Returns:
         *         ModelLatencyHistoryResponse with chronologically ordered snapshots
         *
         *     Raises:
         *         HTTPException: 404 if model not found in registry
         */
        get: operations["system_get_model_zoo_latency_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/model-zoo/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Zoo Status
         * @description Get status information for all Model Zoo models.
         *
         *     Returns status information for all 18 Model Zoo models, including:
         *     - Current status (loaded, unloaded, disabled)
         *     - VRAM usage when loaded
         *     - Last usage timestamp (derived from EventAudit records, None if DB unavailable)
         *     - Category grouping for UI display
         *
         *     This endpoint is optimized for the compact status card display
         *     in the AI Performance page.
         *
         *     Args:
         *         db: Optional database session for querying EventAudit last used timestamps
         *
         *     Returns:
         *         ModelZooStatusResponse with all model statuses
         */
        get: operations["system_get_model_zoo_status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/models": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Zoo Registry
         * @description Get the current status of all models in the Model Zoo.
         *
         *     Returns comprehensive information about all AI models available in the system,
         *     including their VRAM requirements, loading status, and configuration.
         *
         *     **VRAM Budget**: The Model Zoo has a dedicated VRAM budget of 1650 MB,
         *     separate from the YOLO26v2 detector and Nemotron LLM allocations.
         *
         *     **Loading Strategy**: Models are loaded sequentially (one at a time) to
         *     prevent VRAM fragmentation and ensure stable operation.
         *
         *     **Model Categories**:
         *     - detection: Object detection models (YOLO variants)
         *     - recognition: Face and license plate recognition
         *     - ocr: Optical character recognition
         *     - embedding: Visual embedding models (CLIP)
         *     - depth-estimation: Depth estimation models
         *     - pose: Human pose estimation
         *
         *     Returns:
         *         ModelRegistryResponse with VRAM stats and all model statuses
         */
        get: operations["system_get_models"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/models/{model_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Model Status
         * @description Get detailed status information for a specific model.
         *
         *     Args:
         *         model_name: Unique identifier of the model (e.g., 'yolo11-license-plate')
         *
         *     Returns:
         *         ModelStatusResponse with detailed model information
         *
         *     Raises:
         *         HTTPException: 404 if model not found in registry
         */
        get: operations["system_get_model"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/monitoring/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Monitoring Health
         * @description Get comprehensive monitoring stack health status.
         *
         *     Checks the health of the monitoring infrastructure including:
         *     - Prometheus server reachability
         *     - Scrape target status (UP/DOWN counts by job)
         *     - Exporter status (redis-exporter, json-exporter, blackbox-exporter)
         *     - Metrics collection status
         *
         *     This endpoint provides operators with a quick view of monitoring
         *     stack health without needing to access the Prometheus UI directly.
         *
         *     Returns:
         *         MonitoringHealthResponse with full monitoring stack status.
         *         The 'healthy' field is True if Prometheus is reachable and
         *         the majority of critical targets are up.
         */
        get: operations["system_get_monitoring_health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/monitoring/targets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Monitoring Targets
         * @description Get detailed status of all Prometheus scrape targets.
         *
         *     Returns complete information about every target Prometheus is
         *     configured to scrape, including:
         *     - Job and instance identifiers
         *     - Health status (up/down)
         *     - All labels associated with the target
         *     - Last scrape timestamp and duration
         *     - Any scrape errors
         *
         *     This endpoint is useful for debugging specific target issues
         *     or getting a comprehensive view of all monitored endpoints.
         *
         *     Returns:
         *         MonitoringTargetsResponse with detailed target information.
         *
         *     Raises:
         *         HTTPException: 503 if Prometheus is unreachable
         */
        get: operations["system_get_monitoring_targets"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/performance": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Performance Metrics
         * @description Get current system performance metrics.
         *
         *     Collects and returns real-time metrics from all system components:
         *     - GPU: Utilization, VRAM usage, temperature, power consumption
         *     - AI Models: YOLO26v2 and Nemotron status and resource usage
         *     - Inference: Latency percentiles and throughput metrics
         *     - Databases: PostgreSQL and Redis connection status and performance
         *     - Host: CPU, RAM, and disk usage
         *     - Containers: Health status of all running containers
         *     - Alerts: Active performance alerts when thresholds are exceeded
         *
         *     This endpoint powers the System Performance Dashboard and provides
         *     a comprehensive snapshot of system health at the time of the request.
         *
         *     Returns:
         *         PerformanceUpdate with all available metrics. Fields may be None
         *         if a particular metric source is unavailable.
         *
         *     Raises:
         *         HTTPException: 503 if performance collector is not initialized
         *         HTTPException: 500 if metric collection fails
         */
        get: operations["system_get_performance_metrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/performance/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Performance History
         * @description Get historical system performance metrics.
         *
         *     Returns historical performance snapshots for time-series visualization.
         *     The data is sampled based on the requested time range to provide
         *     approximately 60 data points for each range:
         *
         *     - 5m: All snapshots from the last 5 minutes (every 5s = 60 points max)
         *     - 15m: Sampled snapshots from last 15 minutes (every 15s = 60 points max)
         *     - 60m: Sampled snapshots from last 60 minutes (every 60s = 60 points max)
         *
         *     This endpoint enables the System Performance Dashboard to display
         *     historical trends and patterns in system metrics.
         *
         *     Args:
         *         time_range: Time range for history (5m, 15m, or 60m). Defaults to 5m.
         *
         *     Returns:
         *         PerformanceHistoryResponse containing:
         *         - snapshots: List of PerformanceUpdate objects in chronological order
         *         - time_range: The requested time range
         *         - count: Number of snapshots returned
         */
        get: operations["system_get_performance_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Status
         * @description Get combined status of all pipeline operations.
         *
         *     Returns real-time visibility into the AI processing pipeline:
         *
         *     **FileWatcher**: Monitors camera directories for new uploads
         *     - running: Whether the watcher is active
         *     - camera_root: Directory being watched
         *     - pending_tasks: Files waiting for debounce completion
         *     - observer_type: Filesystem observer type (native/polling)
         *
         *     **BatchAggregator**: Groups detections into time-based batches
         *     - active_batches: Number of batches being aggregated
         *     - batches: Details of each active batch
         *     - batch_window_seconds: Configured window timeout
         *     - idle_timeout_seconds: Configured idle timeout
         *
         *     **DegradationManager**: Handles graceful degradation
         *     - mode: Current degradation mode (normal/degraded/minimal/offline)
         *     - is_degraded: Whether system is in any degraded state
         *     - services: Health status of registered services
         *     - available_features: Features available in current mode
         *
         *     Returns:
         *         PipelineStatusResponse with status of all pipeline services
         */
        get: operations["system_get_pipeline_status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline-latency": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Latency
         * @description Get pipeline latency metrics with percentiles.
         *
         *     Returns latency statistics for each stage transition in the AI pipeline:
         *     - watch_to_detect: Time from file watcher detecting image to YOLO26 processing start
         *     - detect_to_batch: Time from detection completion to batch aggregation
         *     - batch_to_analyze: Time from batch completion to Nemotron analysis start
         *     - total_pipeline: Total end-to-end processing time
         *
         *     Each stage includes:
         *     - avg_ms: Average latency in milliseconds
         *     - min_ms: Minimum latency
         *     - max_ms: Maximum latency
         *     - p50_ms: 50th percentile (median)
         *     - p95_ms: 95th percentile
         *     - p99_ms: 99th percentile
         *     - sample_count: Number of samples used
         *
         *     Args:
         *         window_minutes: Time window for statistics calculation (default 60 minutes)
         *
         *     Returns:
         *         PipelineLatencyResponse with latency statistics for each stage
         */
        get: operations["system_get_pipeline_latency"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/pipeline-latency/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pipeline Latency History
         * @description Get pipeline latency history for time-series visualization.
         *
         *     Returns latency data grouped into time buckets for charting.
         *     Each bucket contains aggregated statistics for all pipeline stages.
         *
         *     Args:
         *         since: Number of minutes of history to return (1-1440, default 60)
         *         bucket_seconds: Size of each time bucket in seconds (10-3600, default 60)
         *
         *     Returns:
         *         PipelineLatencyHistoryResponse with chronologically ordered snapshots
         */
        get: operations["system_get_pipeline_latency_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Services
         * @description Get status of all managed services.
         *
         *     Args:
         *         category: Optional filter by category (infrastructure, ai, monitoring)
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         List of services with status and category summaries.
         */
        get: operations["services_list_services"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services/{name}/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Disable Service
         * @description Manually disable a service.
         *
         *     Prevents self-healing restarts.
         *
         *     Args:
         *         name: Service name to disable
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         Action result with updated service information
         *
         *     Raises:
         *         HTTPException: 404 if service not found
         */
        post: operations["services_disable_service"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services/{name}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable Service
         * @description Re-enable a disabled service.
         *
         *     Resets failure count and allows self-healing to resume.
         *
         *     Args:
         *         name: Service name to enable
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         Action result with updated service information
         *
         *     Raises:
         *         HTTPException: 404 if service not found
         */
        post: operations["services_enable_service"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services/{name}/restart": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restart Service
         * @description Manually restart a service.
         *
         *     Resets failure count (manual restart is intentional).
         *
         *     Args:
         *         name: Service name to restart
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         Action result with updated service information
         *
         *     Raises:
         *         HTTPException: 404 if service not found, 400 if service is disabled
         */
        post: operations["services_restart_service"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/services/{name}/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Service
         * @description Start a stopped service container.
         *
         *     Args:
         *         name: Service name to start
         *         orchestrator: Container orchestrator instance (injected)
         *
         *     Returns:
         *         Action result with updated service information
         *
         *     Raises:
         *         HTTPException: 404 if service not found,
         *                        400 if service is already running or disabled
         */
        post: operations["services_start_service"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/severity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Severity Metadata
         * @description Get severity level definitions and thresholds.
         *
         *     Returns complete information about the severity taxonomy including:
         *     - All severity level definitions (LOW, MEDIUM, HIGH, CRITICAL)
         *     - Risk score thresholds for each level
         *     - Color codes for UI display
         *     - Human-readable labels and descriptions
         *
         *     This endpoint is useful for frontends to:
         *     - Display severity information consistently
         *     - Show severity legends in the UI
         *     - Validate severity-related user inputs
         *     - Map risk scores to severity levels client-side
         *
         *     Returns:
         *         SeverityMetadataResponse with all severity definitions and current thresholds
         */
        get: operations["system_get_severity_metadata"];
        /**
         * Update Severity Thresholds
         * @description Update severity threshold configuration.
         *
         *     Updates the risk score thresholds for severity levels. The thresholds
         *     define how risk scores (0-100) are mapped to severity levels:
         *     - LOW: 0 to low_max
         *     - MEDIUM: low_max+1 to medium_max
         *     - HIGH: medium_max+1 to high_max
         *     - CRITICAL: high_max+1 to 100
         *
         *     Requires API key authentication when api_key_enabled is True in settings.
         *     Provide the API key via X-API-Key header.
         *
         *     Validation:
         *     - Thresholds must be strictly ordered: low_max < medium_max < high_max
         *     - All thresholds must be between 1 and 99
         *     - This ensures contiguous, non-overlapping ranges covering 0-100
         *
         *     Note: Changes only affect new events. Existing events retain their
         *     original severity assignment.
         *
         *     Args:
         *         update: New threshold values
         *
         *     Returns:
         *         SeverityMetadataResponse with updated definitions and thresholds
         *
         *     Raises:
         *         HTTPException 400: If thresholds are not strictly ordered
         */
        put: operations["system_update_severity_thresholds"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Stats
         * @description Get system statistics.
         *
         *     Returns aggregate statistics about the system:
         *     - Total number of cameras
         *     - Total number of events
         *     - Total number of detections
         *     - Application uptime
         *
         *     Results are cached for HEALTH_CACHE_TTL_SECONDS (default 5 seconds) to reduce
         *     database load from three sequential COUNT queries.
         *
         *     Returns:
         *         SystemStatsResponse with system statistics
         */
        get: operations["system_get_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/storage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Storage Stats
         * @description Get storage statistics and disk usage metrics.
         *
         *     Returns detailed storage usage information including:
         *     - Overall disk usage (used/total/free)
         *     - Storage breakdown by category (thumbnails, images, clips)
         *     - Database record counts (events, detections, GPU stats, logs)
         *
         *     This endpoint helps operators:
         *     - Monitor available storage space
         *     - Understand storage distribution across data types
         *     - Plan cleanup operations
         *     - Track database growth
         *
         *     Returns:
         *         StorageStatsResponse with comprehensive storage metrics
         */
        get: operations["system_get_storage_stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/supervisor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Supervisor Status
         * @description Get status of the Worker Supervisor and all supervised workers.
         *
         *     The Worker Supervisor monitors pipeline worker tasks and automatically
         *     restarts them with exponential backoff when they crash.
         *
         *     Returns:
         *         WorkerSupervisorStatusResponse with:
         *         - running: Whether the supervisor is active
         *         - worker_count: Number of registered workers
         *         - workers: Detailed status of each supervised worker including:
         *           - status: running/stopped/crashed/restarting/failed
         *           - restart_count: Number of restart attempts
         *           - last_started_at/last_crashed_at: Timestamps
         *           - error: Last error message if crashed
         *
         *     Use this endpoint to monitor worker health and identify workers that
         *     are repeatedly crashing or have exceeded their restart limit.
         */
        get: operations["system_get_supervisor_status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/supervisor/reset/{worker_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset Worker
         * @description Reset a failed worker's restart count to allow new restart attempts.
         *
         *     When a worker exceeds its max restart limit, it enters FAILED status
         *     and won't be restarted. Use this endpoint to reset the worker's
         *     restart count and transition it back to STOPPED status, allowing
         *     the supervisor to attempt restarts again.
         *
         *     Args:
         *         worker_name: Name of the worker to reset
         *
         *     Returns:
         *         Dictionary with success status and message
         *
         *     Raises:
         *         HTTPException 404: Worker not found
         *         HTTPException 503: Supervisor not initialized
         */
        post: operations["system_reset_worker"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/supervisor/restart-history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Restart History
         * @description Get paginated history of worker restart events.
         *
         *     Returns a list of restart events including both automatic restarts
         *     (triggered by crashes) and manual restarts.
         *
         *     Args:
         *         worker_name: Optional filter by worker name
         *         limit: Maximum number of events to return (default 50, max 100)
         *         offset: Number of events to skip for pagination
         *
         *     Returns:
         *         RestartHistoryResponse with events and pagination metadata
         */
        get: operations["system_get_restart_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/supervisor/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Supervisor Full Status
         * @description Get full status of the Worker Supervisor and all supervised workers.
         *
         *     This endpoint is an alias for GET /supervisor but with a clearer path
         *     that matches the API convention for status endpoints.
         *
         *     Returns:
         *         WorkerSupervisorStatusResponse with:
         *         - running: Whether the supervisor is active
         *         - worker_count: Number of registered workers
         *         - workers: Detailed status of each supervised worker
         *         - timestamp: When the status was queried
         */
        get: operations["system_get_supervisor_full_status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/supervisor/workers/{worker_name}/restart": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restart Supervisor Worker
         * @description Manually restart a supervised worker.
         *
         *     This stops the worker if running and starts it again with reset state.
         *
         *     Args:
         *         worker_name: Name of the worker to restart (e.g., file_watcher, detector)
         *
         *     Returns:
         *         WorkerControlResponse with success status and message
         *
         *     Raises:
         *         HTTPException 400: Invalid worker name format
         *         HTTPException 404: Worker not found
         *         HTTPException 503: Supervisor not initialized
         */
        post: operations["system_restart_supervisor_worker"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/supervisor/workers/{worker_name}/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Supervisor Worker
         * @description Manually start a stopped supervised worker.
         *
         *     This starts a worker that was previously stopped. If the worker
         *     is already running, this is a no-op and returns success.
         *
         *     Args:
         *         worker_name: Name of the worker to start
         *
         *     Returns:
         *         WorkerControlResponse with success status and message
         *
         *     Raises:
         *         HTTPException 400: Invalid worker name format
         *         HTTPException 404: Worker not found
         *         HTTPException 503: Supervisor not initialized
         */
        post: operations["system_start_supervisor_worker"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/supervisor/workers/{worker_name}/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stop Supervisor Worker
         * @description Manually stop a supervised worker.
         *
         *     This stops the worker's task. The worker will remain registered
         *     but will not be automatically restarted by the supervisor.
         *
         *     Args:
         *         worker_name: Name of the worker to stop
         *
         *     Returns:
         *         WorkerControlResponse with success status and message
         *
         *     Raises:
         *         HTTPException 400: Invalid worker name format
         *         HTTPException 404: Worker not found
         *         HTTPException 503: Supervisor not initialized
         */
        post: operations["system_stop_supervisor_worker"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/telemetry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Telemetry
         * @description Get pipeline telemetry data.
         *
         *     Returns real-time metrics about the AI processing pipeline:
         *     - Queue depths: Items waiting in detection and analysis queues
         *     - Stage latencies: Processing time statistics for each pipeline stage
         *
         *     This endpoint helps operators:
         *     - Monitor pipeline health and throughput
         *     - Identify bottlenecks and backlogs
         *     - Debug pipeline stalls
         *     - Track performance trends
         *
         *     Returns:
         *         TelemetryResponse with queue depths and latency statistics
         */
        get: operations["system_get_telemetry"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/system/websocket/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Websocket Event Types
         * @description List all available WebSocket event types with schemas.
         *
         *     Returns the complete registry of WebSocket event types supported by the system,
         *     including their descriptions, payload schemas, and example payloads. This
         *     endpoint enables frontend developers and API consumers to discover and
         *     understand all available real-time event types.
         *
         *     Event types follow a hierarchical naming convention: {domain}.{action}
         *     For example: detection.new, event.created, camera.status_changed
         *
         *     Channels group related events:
         *     - detections: AI detection pipeline events
         *     - events: Security event lifecycle events
         *     - alerts: Alert notifications and state changes
         *     - cameras: Camera status and configuration changes
         *     - jobs: Background job lifecycle events
         *     - system: System health and status events
         *
         *     Note: Some event types are marked as deprecated with suggested replacements.
         *     These remain available for backward compatibility but should be avoided in
         *     new implementations.
         *
         *     Returns:
         *         EventRegistryResponse containing:
         *         - event_types: List of all event types with schemas and examples
         *         - channels: List of available WebSocket channels
         *         - total_count: Total number of event types
         *         - deprecated_count: Number of deprecated event types
         */
        get: operations["system_list_websocket_event_types"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/tracks/camera/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Tracks By Camera
         * @description Get paginated list of tracks for a camera.
         *
         *     Returns a list of tracks observed on a specific camera with optional
         *     filtering by time range and object class. Results are ordered by
         *     first_seen timestamp (newest first).
         *
         *     Args:
         *         camera_id: ID of the camera to query tracks for.
         *         db: Database session.
         *         start_time: Optional start time filter (inclusive, ISO format).
         *         end_time: Optional end time filter (inclusive, ISO format).
         *         object_class: Optional filter by object class (e.g., 'person', 'car').
         *         page: Page number (1-indexed, default 1).
         *         page_size: Number of items per page (1-100, default 50).
         *
         *     Returns:
         *         TrackListResponse with paginated tracks and total count.
         *
         *     Example:
         *         GET /api/tracks/camera/front_door?object_class=person&page=1&page_size=25
         *         Returns first 25 person tracks from front_door camera.
         */
        get: operations["tracks_get_tracks_by_camera"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/tracks/{camera_id}/{track_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Track History
         * @description Get full track history with trajectory and metrics.
         *
         *     Returns the complete trajectory data and computed movement metrics
         *     for a specific track, suitable for visualization and analysis.
         *
         *     Args:
         *         camera_id: ID of the camera where the track was observed.
         *         track_id: Tracker-assigned track ID (unique per camera session).
         *         db: Database session.
         *
         *     Returns:
         *         TrackHistoryResponse with full trajectory and movement metrics.
         *
         *     Raises:
         *         HTTPException: 404 if track not found.
         *
         *     Example:
         *         GET /api/tracks/front_door/42
         *         Returns trajectory points and metrics for track 42 on front_door camera.
         */
        get: operations["tracks_get_track_history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/tracks/{camera_id}/{track_id}/trajectory": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Track Trajectory
         * @description Get just the trajectory points for a track.
         *
         *     Returns only the position data (x, y, timestamp) for efficient
         *     trajectory plotting without full track metadata.
         *
         *     Args:
         *         camera_id: ID of the camera where the track was observed.
         *         track_id: Tracker-assigned track ID (unique per camera session).
         *         db: Database session.
         *         limit: Maximum number of trajectory points to return (default 100, max 1000).
         *             Returns the most recent points if trajectory exceeds limit.
         *
         *     Returns:
         *         List of TrajectoryPoint objects ordered by timestamp.
         *
         *     Raises:
         *         HTTPException: 404 if track not found.
         *
         *     Example:
         *         GET /api/tracks/front_door/42/trajectory?limit=50
         *         Returns up to 50 most recent trajectory points.
         */
        get: operations["tracks_get_track_trajectory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/alertmanager/webhook": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Receive Alertmanager Webhook
         * @description Receive webhook notifications from Alertmanager.
         *
         *     This endpoint receives alerts from Prometheus Alertmanager and:
         *     1. Stores each alert in the database for history tracking
         *     2. Broadcasts each alert via WebSocket for real-time frontend updates
         *     3. Returns acknowledgment to Alertmanager
         *
         *     The alerts are infrastructure alerts (GPU memory, pipeline health, etc.)
         *     which are stored for history and displayed alongside security alerts.
         *
         *     Args:
         *         payload: Alertmanager webhook payload containing alert details
         *         db: Database session (injected)
         *         redis_client: Redis client for WebSocket broadcasting (optional)
         *
         *     Returns:
         *         AlertmanagerWebhookResponse with processing status
         */
        post: operations["alertmanager_receive_alertmanager_webhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/areas/{area_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Area
         * @description Get a specific area by ID.
         *
         *     Args:
         *         area_id: ID of the area to retrieve
         *         session: Database session
         *
         *     Returns:
         *         Area object
         *
         *     Raises:
         *         HTTPException: 404 if area not found
         */
        get: operations["areas_get_area"];
        put?: never;
        post?: never;
        /**
         * Delete Area
         * @description Delete an area.
         *
         *     This will unlink all cameras associated with this area (cameras themselves
         *     are not deleted, only the association).
         *
         *     Args:
         *         area_id: ID of the area to delete
         *         session: Database session
         *
         *     Raises:
         *         HTTPException: 404 if area not found
         */
        delete: operations["areas_delete_area"];
        options?: never;
        head?: never;
        /**
         * Update Area
         * @description Update an existing area.
         *
         *     Args:
         *         area_id: ID of the area to update
         *         updates: Area update data (all fields optional)
         *         session: Database session
         *
         *     Returns:
         *         Updated Area object
         *
         *     Raises:
         *         HTTPException: 404 if area not found
         *         HTTPException: 409 if new name conflicts with existing area in same property
         */
        patch: operations["areas_update_area"];
        trace?: never;
    };
    "/api/v1/areas/{area_id}/cameras": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Area Cameras
         * @description List all cameras linked to an area.
         *
         *     Args:
         *         area_id: ID of the area
         *         session: Database session
         *
         *     Returns:
         *         AreaCamerasResponse with list of cameras and count
         *
         *     Raises:
         *         HTTPException: 404 if area not found
         */
        get: operations["areas_list_area_cameras"];
        put?: never;
        /**
         * Link Camera To Area
         * @description Link a camera to an area.
         *
         *     Creates a many-to-many relationship between the area and camera.
         *     A camera can be linked to multiple areas, and an area can have multiple cameras.
         *
         *     Args:
         *         area_id: ID of the area
         *         link_request: Contains the camera_id to link
         *         session: Database session
         *
         *     Returns:
         *         CameraLinkResponse confirming the link
         *
         *     Raises:
         *         HTTPException: 404 if area or camera not found
         *         HTTPException: 409 if camera is already linked to this area
         */
        post: operations["areas_link_camera_to_area"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/areas/{area_id}/cameras/{camera_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Unlink Camera From Area
         * @description Unlink a camera from an area.
         *
         *     Removes the many-to-many relationship between the area and camera.
         *     Neither the area nor the camera is deleted.
         *
         *     Args:
         *         area_id: ID of the area
         *         camera_id: ID of the camera to unlink
         *         session: Database session
         *
         *     Returns:
         *         CameraLinkResponse confirming the unlink
         *
         *     Raises:
         *         HTTPException: 404 if area or camera not found
         *         HTTPException: 404 if camera is not linked to this area
         */
        delete: operations["areas_unlink_camera_from_area"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/households": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Households
         * @description List all households.
         *
         *     Returns all households in the system ordered by name.
         *
         *     Args:
         *         session: Database session
         *
         *     Returns:
         *         HouseholdListResponse with list of households and total count
         */
        get: operations["households_list_households"];
        put?: never;
        /**
         * Create Household
         * @description Create a new household.
         *
         *     Args:
         *         household_data: Household creation data
         *         session: Database session
         *
         *     Returns:
         *         Created Household object
         *
         *     Raises:
         *         HTTPException: 409 if household with same name already exists
         */
        post: operations["households_create_household"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/households/{household_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Household
         * @description Get a specific household by ID.
         *
         *     Args:
         *         household_id: ID of the household to retrieve
         *         session: Database session
         *
         *     Returns:
         *         Household object
         *
         *     Raises:
         *         HTTPException: 404 if household not found
         */
        get: operations["households_get_household"];
        put?: never;
        post?: never;
        /**
         * Delete Household
         * @description Delete a household.
         *
         *     This will cascade delete all related properties, areas, and unlink
         *     associated members and vehicles.
         *
         *     Args:
         *         household_id: ID of the household to delete
         *         session: Database session
         *
         *     Raises:
         *         HTTPException: 404 if household not found
         */
        delete: operations["households_delete_household"];
        options?: never;
        head?: never;
        /**
         * Update Household
         * @description Update an existing household.
         *
         *     Args:
         *         household_id: ID of the household to update
         *         updates: Household update data (all fields optional)
         *         session: Database session
         *
         *     Returns:
         *         Updated Household object
         *
         *     Raises:
         *         HTTPException: 404 if household not found
         *         HTTPException: 409 if new name conflicts with existing household
         */
        patch: operations["households_update_household"];
        trace?: never;
    };
    "/api/v1/households/{household_id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Household Properties
         * @description List all properties for a household.
         *
         *     Args:
         *         household_id: ID of the household
         *         session: Database session
         *
         *     Returns:
         *         PropertyListResponse with list of properties and total count
         *
         *     Raises:
         *         HTTPException: 404 if household not found
         */
        get: operations["households_list_household_properties"];
        put?: never;
        /**
         * Create Property
         * @description Create a new property under a household.
         *
         *     Args:
         *         household_id: ID of the household that owns this property
         *         property_data: Property creation data
         *         session: Database session
         *
         *     Returns:
         *         Created Property object
         *
         *     Raises:
         *         HTTPException: 404 if household not found
         *         HTTPException: 409 if property with same name already exists for this household
         */
        post: operations["households_create_property"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/properties/{property_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Property
         * @description Get a specific property by ID.
         *
         *     Args:
         *         property_id: ID of the property to retrieve
         *         session: Database session
         *
         *     Returns:
         *         Property object
         *
         *     Raises:
         *         HTTPException: 404 if property not found
         */
        get: operations["properties_get_property"];
        put?: never;
        post?: never;
        /**
         * Delete Property
         * @description Delete a property.
         *
         *     This will cascade delete all related areas and unlink associated cameras.
         *
         *     Args:
         *         property_id: ID of the property to delete
         *         session: Database session
         *
         *     Raises:
         *         HTTPException: 404 if property not found
         */
        delete: operations["properties_delete_property"];
        options?: never;
        head?: never;
        /**
         * Update Property
         * @description Update an existing property.
         *
         *     Args:
         *         property_id: ID of the property to update
         *         updates: Property update data (all fields optional)
         *         session: Database session
         *
         *     Returns:
         *         Updated Property object
         *
         *     Raises:
         *         HTTPException: 404 if property not found
         *         HTTPException: 409 if new name conflicts with existing property in same household
         */
        patch: operations["properties_update_property"];
        trace?: never;
    };
    "/api/v1/properties/{property_id}/areas": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Property Areas
         * @description List all areas for a property.
         *
         *     Args:
         *         property_id: ID of the property
         *         session: Database session
         *
         *     Returns:
         *         AreaListResponse with list of areas and total count
         *
         *     Raises:
         *         HTTPException: 404 if property not found
         */
        get: operations["properties_list_property_areas"];
        put?: never;
        /**
         * Create Area
         * @description Create a new area under a property.
         *
         *     Args:
         *         property_id: ID of the property that owns this area
         *         area_data: Area creation data
         *         session: Database session
         *
         *     Returns:
         *         Created Area object
         *
         *     Raises:
         *         HTTPException: 404 if property not found
         *         HTTPException: 409 if area with same name already exists for this property
         */
        post: operations["properties_create_area"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get current system settings
         * @description Returns user-configurable settings grouped by category. These settings control detection thresholds, batch processing, severity levels, feature toggles, rate limiting, queue management, and data retention policies.
         */
        get: operations["settings_get_user_settings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update runtime settings
         * @description Update system settings at runtime without server restart. Changes are written to data/runtime.env and take effect immediately. All fields are optional - only provided fields will be updated.
         */
        patch: operations["settings_update_settings"];
        trace?: never;
    };
    "/api/v1/system-settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List System Settings
         * @description List all system settings.
         *
         *     Returns all key-value pairs from the SystemSetting table, ordered by key.
         *
         *     Returns:
         *         SystemSettingListResponse with all settings
         */
        get: operations["system-settings_list_system_settings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/system-settings/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get System Setting
         * @description Get a specific system setting by key.
         *
         *     Args:
         *         key: Setting key to retrieve
         *         db: Database session
         *
         *     Returns:
         *         SystemSettingResponse with the setting value
         *
         *     Raises:
         *         HTTPException: 404 if setting not found
         */
        get: operations["system-settings_get_system_setting"];
        put?: never;
        post?: never;
        /**
         * Delete System Setting
         * @description Delete a system setting.
         *
         *     Args:
         *         key: Setting key to delete
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if setting not found
         */
        delete: operations["system-settings_delete_system_setting"];
        options?: never;
        head?: never;
        /**
         * Update System Setting
         * @description Update or create a system setting.
         *
         *     If the setting exists, updates its value. If it doesn't exist, creates it.
         *     This is an upsert operation.
         *
         *     Args:
         *         key: Setting key to update or create
         *         update: New value for the setting
         *         db: Database session
         *
         *     Returns:
         *         SystemSettingResponse with the updated setting
         *
         *     Raises:
         *         HTTPException: 400 if key format is invalid
         */
        patch: operations["system-settings_update_system_setting"];
        trace?: never;
    };
    "/api/webhooks/alerts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Receive Alertmanager Webhook
         * @description Receive webhook notifications from Alertmanager.
         *
         *     This endpoint receives alerts from Prometheus Alertmanager and:
         *     1. Logs the alert for observability
         *     2. Broadcasts to WebSocket clients for real-time frontend updates
         *     3. Returns acknowledgment to Alertmanager
         *
         *     The alerts are infrastructure alerts (GPU memory, pipeline health, etc.)
         *     which are separate from AI-generated security alerts.
         *
         *     Args:
         *         payload: Alertmanager webhook payload containing alert details
         *         background_tasks: FastAPI background tasks for async processing
         *
         *     Returns:
         *         WebhookResponse with processing status
         */
        post: operations["webhooks_receive_alertmanager_webhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/zones/anomalies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List All Anomalies
         * @description List all zone anomalies across all zones.
         *
         *     Returns a paginated list of anomalies with optional filtering by severity,
         *     acknowledgment status, and time range.
         *
         *     Args:
         *         severity: Filter by one or more severity levels (info, warning, critical)
         *         unacknowledged_only: If True, only return unacknowledged anomalies
         *         since: Start time for the query (defaults to 24 hours ago)
         *         until: End time for the query (defaults to now)
         *         limit: Maximum number of results to return
         *         offset: Number of results to skip for pagination
         *         db: Database session
         *
         *     Returns:
         *         ZoneAnomalyListResponse with list of anomalies and pagination info
         */
        get: operations["zone-anomalies_list_all_anomalies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/zones/anomalies/{anomaly_id}/acknowledge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Acknowledge Anomaly
         * @description Acknowledge a zone anomaly.
         *
         *     Marks the specified anomaly as acknowledged, indicating that a user
         *     has reviewed and acknowledged the alert.
         *
         *     Args:
         *         anomaly_id: The anomaly ID to acknowledge
         *         db: Database session
         *
         *     Returns:
         *         ZoneAnomalyAcknowledgeResponse with updated acknowledgment status
         *
         *     Raises:
         *         HTTPException: 404 if anomaly not found
         */
        post: operations["zone-anomalies_acknowledge_anomaly"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/zones/member/{member_id}/zones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Member Zones
         * @description Get all zones where a household member has trust.
         *
         *     Returns zones where the member is:
         *     - The owner (full trust)
         *     - In the allowed members list (partial trust)
         *     - In any access schedule (potential monitor trust)
         *
         *     Args:
         *         member_id: ID of the household member
         *         db: Database session
         *
         *     Returns:
         *         List of zones with trust information
         */
        get: operations["zone-household_get_member_zones"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/zones/vehicle/{vehicle_id}/zones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Vehicle Zones
         * @description Get all zones where a vehicle has trust.
         *
         *     Returns zones where the vehicle is in the allowed vehicles list.
         *
         *     Args:
         *         vehicle_id: ID of the registered vehicle
         *         db: Database session
         *
         *     Returns:
         *         List of zones with trust information
         */
        get: operations["zone-household_get_vehicle_zones"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/zones/{zone_id}/anomalies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Zone Anomalies
         * @description List anomalies for a specific zone.
         *
         *     Returns a paginated list of anomalies for the specified zone with optional
         *     filtering by severity, acknowledgment status, and time range.
         *
         *     Args:
         *         zone_id: The zone ID to fetch anomalies for
         *         severity: Filter by one or more severity levels (info, warning, critical)
         *         unacknowledged_only: If True, only return unacknowledged anomalies
         *         since: Start time for the query (defaults to 24 hours ago)
         *         until: End time for the query (defaults to now)
         *         limit: Maximum number of results to return
         *         offset: Number of results to skip for pagination
         *         db: Database session
         *
         *     Returns:
         *         ZoneAnomalyListResponse with list of anomalies and pagination info
         */
        get: operations["zone-anomalies_list_zone_anomalies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/zones/{zone_id}/household": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Zone Household Config
         * @description Get the household configuration for a zone.
         *
         *     Returns the household configuration if one exists, or null if the zone
         *     has no household linkage configured.
         *
         *     Args:
         *         zone_id: ID of the zone
         *         db: Database session
         *
         *     Returns:
         *         ZoneHouseholdConfigResponse if config exists, None otherwise
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        get: operations["zone-household_get_zone_household_config"];
        /**
         * Upsert Zone Household Config
         * @description Create or update the household configuration for a zone.
         *
         *     If a configuration already exists for this zone, it will be updated.
         *     Otherwise, a new configuration will be created.
         *
         *     Args:
         *         zone_id: ID of the zone
         *         config_data: Household configuration data
         *         db: Database session
         *
         *     Returns:
         *         Created or updated ZoneHouseholdConfigResponse
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         *         HTTPException: 404 if owner_id references non-existent member
         */
        put: operations["zone-household_upsert_zone_household_config"];
        post?: never;
        /**
         * Delete Zone Household Config
         * @description Delete the household configuration for a zone.
         *
         *     Removes all household linkage for this zone, including owner,
         *     allowed members, allowed vehicles, and access schedules.
         *
         *     Args:
         *         zone_id: ID of the zone
         *         db: Database session
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         *         HTTPException: 404 if config not found
         */
        delete: operations["zone-household_delete_zone_household_config"];
        options?: never;
        head?: never;
        /**
         * Patch Zone Household Config
         * @description Partially update the household configuration for a zone.
         *
         *     Only updates the fields that are provided in the request body.
         *     Unlike PUT, this endpoint requires an existing configuration.
         *
         *     Args:
         *         zone_id: ID of the zone
         *         config_data: Household configuration update data
         *         db: Database session
         *
         *     Returns:
         *         Updated ZoneHouseholdConfigResponse
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         *         HTTPException: 404 if config not found
         *         HTTPException: 404 if owner_id references non-existent member
         */
        patch: operations["zone-household_patch_zone_household_config"];
        trace?: never;
    };
    "/api/zones/{zone_id}/household/trust/{entity_type}/{entity_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check Entity Trust
         * @description Check the trust level of an entity in a zone.
         *
         *     Evaluates the trust level based on:
         *     1. Zone ownership (full trust)
         *     2. Allowed members/vehicles list (partial trust)
         *     3. Time-based access schedules (monitor trust)
         *     4. No configuration (none)
         *
         *     Args:
         *         zone_id: ID of the zone
         *         entity_type: Type of entity ("member" or "vehicle")
         *         entity_id: ID of the entity to check
         *         at_time: Optional time for schedule checking (defaults to now)
         *         db: Database session
         *
         *     Returns:
         *         TrustCheckResponse with trust level and reason
         *
         *     Raises:
         *         HTTPException: 404 if zone not found
         */
        get: operations["zone-household_check_entity_trust"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health
         * @description Simple liveness health check endpoint (canonical liveness probe).
         *
         *     This endpoint indicates whether the process is running and able to
         *     respond to HTTP requests. It always returns 200 with status "alive"
         *     if the process is up.
         *
         *     This is the canonical liveness probe endpoint. Use this for:
         *     - Docker HEALTHCHECK liveness checks
         *     - Kubernetes liveness probes
         *     - Simple "is the server up?" monitoring
         *
         *     For detailed health information, use:
         *     - GET /api/system/health - Detailed health check with service status
         *     - GET /ready - Readiness probe (checks dependencies)
         *
         *     Returns:
         *         LivenessResponse with status "alive".
         */
        get: operations["health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Ready
         * @description Simple readiness health check endpoint (canonical readiness probe).
         *
         *     This endpoint indicates whether the application is ready to receive
         *     traffic and process requests. It checks critical dependencies:
         *     - Database connectivity
         *     - Redis connectivity
         *     - Critical pipeline workers
         *
         *     This is the canonical readiness probe endpoint. Use this for:
         *     - Docker HEALTHCHECK readiness checks
         *     - Kubernetes readiness probes
         *     - Load balancer health checks
         *
         *     For detailed readiness information with service breakdown, use:
         *     - GET /api/system/health/ready - Full readiness response with details
         *
         *     Returns:
         *         SimpleReadinessResponse with ready bool and status. HTTP 200 if ready, 503 if not.
         */
        get: operations["ready"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AIModelEnum
         * @description Supported AI models for prompt configuration.
         * @enum {string}
         */
        AIModelEnum: "nemotron" | "florence2" | "yolo_world" | "xclip" | "fashion_clip";
        /**
         * AIServiceCircuitState
         * @description Circuit breaker state for an AI service.
         *
         *     States:
         *     - closed: Normal operation, requests pass through
         *     - open: Service failing, requests fail immediately
         *     - half_open: Testing recovery, limited requests allowed
         * @enum {string}
         */
        AIServiceCircuitState: "closed" | "open" | "half_open";
        /**
         * AIServiceHealthDetail
         * @description Detailed health information for a single AI service.
         *
         *     Provides comprehensive status including circuit breaker state,
         *     error rates, and latency metrics for monitoring and alerting.
         * @example {
         *       "circuit_state": "closed",
         *       "error_rate_1h": 0.02,
         *       "last_health_check": "2026-01-20T12:00:00Z",
         *       "latency_p99_ms": 450,
         *       "status": "healthy",
         *       "url": "http://ai-detector:8090"
         *     }
         */
        AIServiceHealthDetail: {
            /**
             * @description Circuit breaker state for this service
             * @default closed
             */
            circuit_state: components["schemas"]["AIServiceCircuitState"];
            /**
             * Error
             * @description Error message if service is unhealthy
             */
            error?: string | null;
            /**
             * Error Rate 1H
             * @description Error rate over the last hour (0.0 to 1.0)
             */
            error_rate_1h?: number | null;
            /**
             * Last Health Check
             * @description Timestamp of the last successful health check
             */
            last_health_check?: string | null;
            /**
             * Latency P99 Ms
             * @description 99th percentile latency in milliseconds
             */
            latency_p99_ms?: number | null;
            /** @description Current health status of the service */
            status: components["schemas"]["AIServiceStatus"];
            /**
             * Url
             * @description Service URL if configured
             */
            url?: string | null;
        };
        /**
         * AIServiceHealthStatus
         * @description Health status for an AI service.
         *
         *     Includes service identification, health state, circuit breaker state,
         *     and response time metrics.
         * @example {
         *       "circuit_state": "closed",
         *       "display_name": "YOLO26v2 Object Detection",
         *       "last_check": "2026-01-08T10:30:00Z",
         *       "name": "yolo26",
         *       "response_time_ms": 45.2,
         *       "status": "healthy",
         *       "url": "http://ai-detector:8090"
         *     }
         */
        AIServiceHealthStatus: {
            /**
             * @description Circuit breaker state
             * @default closed
             */
            circuit_state: components["schemas"]["CircuitState"];
            /**
             * Display Name
             * @description Human-readable service name
             */
            display_name: string;
            /**
             * Error
             * @description Error message if unhealthy
             */
            error?: string | null;
            /**
             * Last Check
             * @description Timestamp of last health check
             */
            last_check?: string | null;
            /**
             * Name
             * @description Service identifier (e.g., 'yolo26', 'nemotron')
             */
            name: string;
            /**
             * Response Time Ms
             * @description Health check response time in milliseconds
             */
            response_time_ms?: number | null;
            /** @description Current health state */
            status: components["schemas"]["ServiceHealthState"];
            /**
             * Url
             * @description Service URL if configured
             */
            url?: string | null;
        };
        /**
         * AIServiceOverallStatus
         * @description Overall status for the AI services subsystem.
         *
         *     Statuses:
         *     - healthy: All services are operational
         *     - degraded: Some services are unhealthy but system is functional
         *     - critical: Critical services are down, system cannot process requests
         * @enum {string}
         */
        AIServiceOverallStatus: "healthy" | "degraded" | "critical";
        /**
         * AIServiceStatus
         * @description Health status for an individual AI service.
         *
         *     Statuses:
         *     - healthy: Service is fully operational
         *     - unhealthy: Service is down or experiencing critical issues
         *     - degraded: Service is partially operational
         *     - unknown: Service status cannot be determined
         * @enum {string}
         */
        AIServiceStatus: "healthy" | "unhealthy" | "degraded" | "unknown";
        /**
         * AIServicesHealthResponse
         * @description Response schema for GET /api/health/ai-services endpoint.
         *
         *     Provides a unified view of all AI service health including:
         *     - Overall system status (healthy/degraded/critical)
         *     - Individual service health with circuit breaker states
         *     - Queue depths for detection and analysis pipelines
         *
         *     HTTP Status Codes:
         *     - 200: System is healthy or degraded (can still serve traffic)
         *     - 503: Critical services are unhealthy (should not receive traffic)
         * @example {
         *       "overall_status": "healthy",
         *       "queues": {
         *         "analysis_queue": {
         *           "depth": 2,
         *           "dlq_depth": 0
         *         },
         *         "detection_queue": {
         *           "depth": 5,
         *           "dlq_depth": 0
         *         }
         *       },
         *       "services": {
         *         "clip": {
         *           "circuit_state": "closed",
         *           "error_rate_1h": 0,
         *           "last_health_check": "2026-01-20T12:00:00Z",
         *           "latency_p99_ms": 200,
         *           "status": "healthy",
         *           "url": "http://clip-service:8092"
         *         },
         *         "enrichment": {
         *           "circuit_state": "half_open",
         *           "error": "Intermittent connection issues",
         *           "error_rate_1h": 0.15,
         *           "last_health_check": "2026-01-20T11:55:00Z",
         *           "latency_p99_ms": 1200,
         *           "status": "degraded",
         *           "url": "http://enrichment-service:8093"
         *         },
         *         "florence": {
         *           "circuit_state": "closed",
         *           "error_rate_1h": 0,
         *           "last_health_check": "2026-01-20T12:00:00Z",
         *           "latency_p99_ms": 350,
         *           "status": "healthy",
         *           "url": "http://florence-service:8091"
         *         },
         *         "nemotron": {
         *           "circuit_state": "closed",
         *           "error_rate_1h": 0.01,
         *           "last_health_check": "2026-01-20T12:00:00Z",
         *           "latency_p99_ms": 2500,
         *           "status": "healthy",
         *           "url": "http://llm-analyzer:8080"
         *         },
         *         "yolo26": {
         *           "circuit_state": "closed",
         *           "error_rate_1h": 0.02,
         *           "last_health_check": "2026-01-20T12:00:00Z",
         *           "latency_p99_ms": 450,
         *           "status": "healthy",
         *           "url": "http://ai-detector:8090"
         *         }
         *       },
         *       "timestamp": "2026-01-20T12:00:00Z"
         *     }
         */
        AIServicesHealthResponse: {
            /** @description Overall health status of the AI services subsystem */
            overall_status: components["schemas"]["AIServiceOverallStatus"];
            /**
             * Queues
             * @description Queue depth information for processing queues
             */
            queues: {
                [key: string]: components["schemas"]["QueueDepthInfo"];
            };
            /**
             * Services
             * @description Health details for each AI service keyed by service name
             */
            services: {
                [key: string]: components["schemas"]["AIServiceHealthDetail"];
            };
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp when this health check was performed
             */
            timestamp: string;
        };
        /**
         * AccessSchedule
         * @description Schema for time-based access schedule configuration.
         *
         *     Allows defining when specific members have access to a zone using
         *     cron-style expressions for flexible scheduling.
         *
         *     Example:
         *         {
         *             "member_ids": [1, 2, 3],
         *             "cron_expression": "0 9-17 * * 1-5",  # Weekdays 9am-5pm
         *             "description": "Service workers during business hours"
         *         }
         * @example {
         *       "cron_expression": "0 9-17 * * 1-5",
         *       "description": "Business hours access",
         *       "member_ids": [
         *         1,
         *         2
         *       ]
         *     }
         */
        AccessSchedule: {
            /**
             * Cron Expression
             * @description Cron expression defining when access is granted (minute hour day month weekday)
             */
            cron_expression: string;
            /**
             * Description
             * @description Optional human-readable description of the schedule
             */
            description?: string | null;
            /**
             * Member Ids
             * @description List of household member IDs this schedule applies to
             */
            member_ids: number[];
        };
        /**
         * ActionAnalyzeRequest
         * @description Schema for action analysis request.
         *
         *     Used to trigger action recognition on a set of frames.
         * @example {
         *       "camera_id": "front_door",
         *       "confidence_threshold": 0.5,
         *       "frame_paths": [
         *         "/export/foscam/front_door/frame_001.jpg",
         *         "/export/foscam/front_door/frame_002.jpg",
         *         "/export/foscam/front_door/frame_003.jpg",
         *         "/export/foscam/front_door/frame_004.jpg",
         *         "/export/foscam/front_door/frame_005.jpg",
         *         "/export/foscam/front_door/frame_006.jpg",
         *         "/export/foscam/front_door/frame_007.jpg",
         *         "/export/foscam/front_door/frame_008.jpg"
         *       ],
         *       "track_id": 42
         *     }
         */
        ActionAnalyzeRequest: {
            /**
             * Camera Id
             * @description Camera ID for the frames
             */
            camera_id: string;
            /**
             * Confidence Threshold
             * @description Minimum confidence threshold for creating an action event
             * @default 0.5
             */
            confidence_threshold: number;
            /**
             * Frame Paths
             * @description List of frame file paths to analyze (1-32 frames)
             */
            frame_paths: string[];
            /**
             * Save Event
             * @description Whether to save the action event to the database
             * @default true
             */
            save_event: boolean;
            /**
             * Track Id
             * @description Optional track ID to associate with the action
             */
            track_id?: number | null;
        };
        /**
         * ActionAnalyzeResponse
         * @description Schema for action analysis response.
         *
         *     Returns the detected action along with all scores and optional saved event.
         * @example {
         *       "action": "walking normally",
         *       "all_scores": {
         *         "climbing": 0.02,
         *         "loitering": 0.04,
         *         "running": 0.05,
         *         "walking normally": 0.89
         *       },
         *       "confidence": 0.89,
         *       "event_id": 1,
         *       "frame_count": 8,
         *       "is_suspicious": false,
         *       "saved": true
         *     }
         */
        ActionAnalyzeResponse: {
            /**
             * Action
             * @description Detected action label
             */
            action: string;
            /**
             * All Scores
             * @description All action scores
             */
            all_scores: {
                [key: string]: number;
            };
            /**
             * Confidence
             * @description Action classification confidence
             */
            confidence: number;
            /**
             * Event Id
             * @description Saved action event ID (if save_event=True)
             */
            event_id?: number | null;
            /**
             * Frame Count
             * @description Number of frames analyzed
             */
            frame_count: number;
            /**
             * Is Suspicious
             * @description Whether the action is security-relevant
             */
            is_suspicious: boolean;
            /**
             * Saved
             * @description Whether the event was saved to the database
             */
            saved: boolean;
        };
        /**
         * ActionEventCreate
         * @description Schema for creating a new action event.
         *
         *     Inherits all fields from ActionEventBase. The timestamp will be
         *     auto-generated if not provided.
         * @example {
         *       "action": "walking normally",
         *       "all_scores": {
         *         "climbing": 0.02,
         *         "loitering": 0.04,
         *         "running": 0.05,
         *         "walking normally": 0.89
         *       },
         *       "camera_id": "front_door",
         *       "confidence": 0.89,
         *       "frame_count": 8,
         *       "is_suspicious": false,
         *       "track_id": 42
         *     }
         */
        ActionEventCreate: {
            /**
             * Action
             * @description Detected action label (e.g., 'walking normally', 'climbing')
             */
            action: string;
            /**
             * All Scores
             * @description Dictionary mapping all action classes to their confidence scores
             */
            all_scores?: {
                [key: string]: number;
            } | null;
            /**
             * Camera Id
             * @description Camera ID where the action was detected
             */
            camera_id: string;
            /**
             * Confidence
             * @description Action classification confidence (0.0 to 1.0)
             */
            confidence: number;
            /**
             * Frame Count
             * @description Number of frames analyzed for this action
             * @default 8
             */
            frame_count: number;
            /**
             * Is Suspicious
             * @description Whether the action is flagged as security-relevant
             * @default false
             */
            is_suspicious: boolean;
            /**
             * Timestamp
             * @description When the action was detected (auto-generated if not provided)
             */
            timestamp?: string | null;
            /**
             * Track Id
             * @description Optional track ID for the detected person
             */
            track_id?: number | null;
        };
        /**
         * ActionEventListResponse
         * @description Schema for action event list response with pagination.
         *
         *     Uses the standard pagination envelope pattern.
         * @example {
         *       "items": [
         *         {
         *           "action": "walking normally",
         *           "camera_id": "front_door",
         *           "confidence": 0.89,
         *           "created_at": "2026-01-26T12:00:00Z",
         *           "frame_count": 8,
         *           "id": 1,
         *           "is_suspicious": false,
         *           "timestamp": "2026-01-26T12:00:00Z",
         *           "track_id": 42
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        ActionEventListResponse: {
            /**
             * Items
             * @description List of action events
             */
            items: components["schemas"]["ActionEventResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * ActionEventResponse
         * @description Schema for action event response.
         *
         *     Includes all base fields plus server-generated fields like id and timestamps.
         * @example {
         *       "action": "walking normally",
         *       "all_scores": {
         *         "climbing": 0.02,
         *         "loitering": 0.04,
         *         "running": 0.05,
         *         "walking normally": 0.89
         *       },
         *       "camera_id": "front_door",
         *       "confidence": 0.89,
         *       "created_at": "2026-01-26T12:00:00Z",
         *       "frame_count": 8,
         *       "id": 1,
         *       "is_suspicious": false,
         *       "timestamp": "2026-01-26T12:00:00Z",
         *       "track_id": 42
         *     }
         */
        ActionEventResponse: {
            /**
             * Action
             * @description Detected action label (e.g., 'walking normally', 'climbing')
             */
            action: string;
            /**
             * All Scores
             * @description Dictionary mapping all action classes to their confidence scores
             */
            all_scores?: {
                [key: string]: number;
            } | null;
            /**
             * Camera Id
             * @description Camera ID where the action was detected
             */
            camera_id: string;
            /**
             * Confidence
             * @description Action classification confidence (0.0 to 1.0)
             */
            confidence: number;
            /**
             * Created At
             * Format: date-time
             * @description Record creation timestamp
             */
            created_at: string;
            /**
             * Frame Count
             * @description Number of frames analyzed for this action
             * @default 8
             */
            frame_count: number;
            /**
             * Id
             * @description Action event ID
             */
            id: number;
            /**
             * Is Suspicious
             * @description Whether the action is flagged as security-relevant
             * @default false
             */
            is_suspicious: boolean;
            /**
             * Timestamp
             * Format: date-time
             * @description When the action was detected
             */
            timestamp: string;
            /**
             * Track Id
             * @description Optional track ID for the detected person
             */
            track_id?: number | null;
        };
        /**
         * ActiveDwellerResponse
         * @description Response for an object currently dwelling in a zone.
         *
         *     Includes real-time dwell time calculation.
         * @example {
         *       "camera_id": "front_door",
         *       "current_dwell_seconds": 150.3,
         *       "entry_time": "2026-01-26T12:00:00Z",
         *       "object_class": "person",
         *       "record_id": 1,
         *       "track_id": 42
         *     }
         */
        ActiveDwellerResponse: {
            /**
             * Camera Id
             * @description ID of the camera
             */
            camera_id: string;
            /**
             * Current Dwell Seconds
             * @description Current dwell time in seconds (calculated at request time)
             */
            current_dwell_seconds: number;
            /**
             * Entry Time
             * Format: date-time
             * @description When the object entered the zone
             */
            entry_time: string;
            /**
             * Object Class
             * @description Classification of the object
             */
            object_class: string;
            /**
             * Record Id
             * @description ID of the dwell time record
             */
            record_id: number;
            /**
             * Track Id
             * @description Tracking ID of the object
             */
            track_id: number;
        };
        /**
         * ActiveDwellersListResponse
         * @description List of objects currently dwelling in a zone.
         * @example {
         *       "dwellers": [
         *         {
         *           "camera_id": "front_door",
         *           "current_dwell_seconds": 150.3,
         *           "entry_time": "2026-01-26T12:00:00Z",
         *           "object_class": "person",
         *           "record_id": 1,
         *           "track_id": 42
         *         }
         *       ],
         *       "total": 1,
         *       "zone_id": 1
         *     }
         */
        ActiveDwellersListResponse: {
            /**
             * Dwellers
             * @description List of objects currently in the zone
             */
            dwellers: components["schemas"]["ActiveDwellerResponse"][];
            /**
             * Total
             * @description Total number of active dwellers
             */
            total: number;
            /**
             * Zone Id
             * @description ID of the polygon zone
             */
            zone_id: number;
        };
        /**
         * ActivityBaselineEntry
         * @description A single activity baseline entry for a specific hour and day combination.
         *
         *     This represents one cell in the 24x7 activity heatmap (168 total entries).
         * @example {
         *       "avg_count": 5.2,
         *       "day_of_week": 0,
         *       "hour": 17,
         *       "is_peak": true,
         *       "sample_count": 30
         *     }
         */
        ActivityBaselineEntry: {
            /**
             * Avg Count
             * @description Average activity count for this time slot
             */
            avg_count: number;
            /**
             * Day Of Week
             * @description Day of week (0=Monday, 6=Sunday)
             */
            day_of_week: number;
            /**
             * Hour
             * @description Hour of day (0-23)
             */
            hour: number;
            /**
             * Is Peak
             * @description Whether this time slot has above-average activity
             * @default false
             */
            is_peak: boolean;
            /**
             * Sample Count
             * @description Number of samples used to calculate this average
             */
            sample_count: number;
        };
        /**
         * ActivityBaselineResponse
         * @description Response for camera activity baseline endpoint.
         *
         *     Contains 168 entries (24 hours x 7 days) representing the full weekly
         *     activity heatmap for a camera.
         * @example {
         *       "camera_id": "front_door",
         *       "entries": [
         *         {
         *           "avg_count": 0.5,
         *           "day_of_week": 0,
         *           "hour": 0,
         *           "is_peak": false,
         *           "sample_count": 30
         *         },
         *         {
         *           "avg_count": 5.2,
         *           "day_of_week": 4,
         *           "hour": 17,
         *           "is_peak": true,
         *           "sample_count": 30
         *         }
         *       ],
         *       "learning_complete": true,
         *       "min_samples_required": 10,
         *       "peak_day": 4,
         *       "peak_hour": 17,
         *       "total_samples": 720
         *     }
         */
        ActivityBaselineResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Entries
             * @description Activity baseline entries (up to 168 = 24h x 7 days)
             */
            entries?: components["schemas"]["ActivityBaselineEntry"][];
            /**
             * Learning Complete
             * @description Whether baseline has sufficient samples for reliable anomaly detection
             * @default false
             */
            learning_complete: boolean;
            /**
             * Min Samples Required
             * @description Minimum samples required per time slot for learning completion
             * @default 10
             */
            min_samples_required: number;
            /**
             * Peak Day
             * @description Day with highest average activity (0=Monday, 6=Sunday)
             */
            peak_day?: number | null;
            /**
             * Peak Hour
             * @description Hour with highest average activity (0-23)
             */
            peak_hour?: number | null;
            /**
             * Total Samples
             * @description Total number of samples across all entries
             */
            total_samples: number;
        };
        /**
         * ActualThreatLevel
         * @description User's assessment of the actual threat level.
         *
         *     Values:
         *         NO_THREAT: No threat at all (e.g., household member, pet)
         *         MINOR_CONCERN: Worth noting but not alarming
         *         GENUINE_THREAT: Real security concern
         * @enum {string}
         */
        ActualThreatLevel: "no_threat" | "minor_concern" | "genuine_threat";
        /**
         * AddEmbeddingRequest
         * @description Schema for adding a person embedding from an event.
         * @example {
         *       "confidence": 0.95,
         *       "event_id": 100
         *     }
         */
        AddEmbeddingRequest: {
            /**
             * Confidence
             * @description Reliability score for this embedding (0-1)
             * @default 1
             */
            confidence: number;
            /**
             * Event Id
             * @description ID of the event to extract embedding from
             */
            event_id: number;
        };
        /**
         * AiModelMetrics
         * @description Metrics for YOLO26v2 model.
         * @example {
         *       "device": "cuda:0",
         *       "model": "yolo26_r50vd_coco_o365",
         *       "status": "healthy",
         *       "vram_gb": 0.17
         *     }
         */
        AiModelMetrics: {
            /**
             * Device
             * @description Device (e.g., 'cuda:0')
             */
            device: string;
            /**
             * Model
             * @description Model name
             */
            model: string;
            /**
             * Status
             * @description Health status: healthy, unhealthy, unreachable
             */
            status: string;
            /**
             * Vram Gb
             * @description VRAM used by the model in GB
             */
            vram_gb: number;
        };
        /**
         * AiServiceInfo
         * @description Information about an AI service for GPU assignment.
         *
         *     Provides service metadata including VRAM requirements, enabling
         *     the frontend to dynamically build the assignment UI.
         * @example {
         *       "description": "Nemotron LLM for risk analysis and enrichment",
         *       "display_name": "LLM (Nemotron)",
         *       "name": "ai-llm",
         *       "vram_required_gb": 8,
         *       "vram_required_mb": 8192
         *     }
         */
        AiServiceInfo: {
            /**
             * Description
             * @description Service description
             */
            description?: string | null;
            /**
             * Display Name
             * @description Human-readable display name
             */
            display_name: string;
            /**
             * Name
             * @description Service name (e.g., 'ai-llm')
             */
            name: string;
            /**
             * Vram Required Gb
             * @description VRAM requirement in gigabytes
             */
            vram_required_gb: number;
            /**
             * Vram Required Mb
             * @description VRAM requirement in megabytes
             */
            vram_required_mb: number;
        };
        /**
         * AiServicesResponse
         * @description Response schema for listing available AI services.
         *
         *     Returns all AI services with their VRAM requirements for GPU assignment.
         * @example {
         *       "services": [
         *         {
         *           "description": "Nemotron LLM for risk analysis and enrichment",
         *           "display_name": "LLM (Nemotron)",
         *           "name": "ai-llm",
         *           "vram_required_gb": 8,
         *           "vram_required_mb": 8192
         *         },
         *         {
         *           "description": "YOLO26 real-time object detection",
         *           "display_name": "Object Detector",
         *           "name": "ai-detector",
         *           "vram_required_gb": 2,
         *           "vram_required_mb": 2048
         *         }
         *       ]
         *     }
         */
        AiServicesResponse: {
            /**
             * Services
             * @description List of available AI services
             */
            services: components["schemas"]["AiServiceInfo"][];
        };
        /**
         * AlertResponse
         * @description Schema for alert response.
         * @example {
         *       "channels": [
         *         "pushover"
         *       ],
         *       "created_at": "2025-12-28T12:00:00Z",
         *       "dedup_key": "front_door:person:entry_zone",
         *       "delivered_at": "2025-12-28T12:00:30Z",
         *       "event_id": 123,
         *       "id": "550e8400-e29b-41d4-a716-446655440001",
         *       "metadata": {
         *         "camera_name": "Front Door"
         *       },
         *       "rule_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "severity": "high",
         *       "status": "delivered",
         *       "updated_at": "2025-12-28T12:01:00Z"
         *     }
         */
        AlertResponse: {
            /**
             * Channels
             * @description Notification channels
             */
            channels?: string[];
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp
             */
            created_at: string;
            /**
             * Dedup Key
             * @description Deduplication key
             */
            dedup_key: string;
            /**
             * Delivered At
             * @description Delivery timestamp
             */
            delivered_at?: string | null;
            /**
             * Event Id
             * @description Event ID that triggered this alert
             */
            event_id: number;
            /**
             * Id
             * @description Alert UUID
             */
            id: string;
            /**
             * Metadata
             * @description Additional context
             */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /**
             * Rule Id
             * @description Alert rule UUID that matched
             */
            rule_id?: string | null;
            /** @description Alert severity level */
            severity: components["schemas"]["AlertSeverity"];
            /** @description Alert status */
            status: components["schemas"]["AlertStatus"];
            /**
             * Updated At
             * Format: date-time
             * @description Last update timestamp
             */
            updated_at: string;
        };
        /**
         * AlertRuleConditions
         * @description Schema for legacy alert rule conditions (backward compatibility).
         *
         *     New rules should use explicit fields on AlertRuleCreate/AlertRuleUpdate.
         *     This schema is kept for backward compatibility with existing rules.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "object_types": [
         *         "person",
         *         "vehicle"
         *       ],
         *       "risk_threshold": 70,
         *       "time_ranges": [
         *         {
         *           "end": "06:00",
         *           "start": "22:00"
         *         }
         *       ]
         *     }
         */
        AlertRuleConditions: {
            /**
             * Camera Ids
             * @description Specific camera IDs that trigger alerts
             */
            camera_ids?: string[] | null;
            /**
             * Object Types
             * @description Object types that trigger alerts (e.g., person, vehicle)
             */
            object_types?: string[] | null;
            /**
             * Risk Threshold
             * @description Minimum risk score to trigger alert
             */
            risk_threshold?: number | null;
            /**
             * Time Ranges
             * @description Time ranges when alerts are active (start/end in HH:MM format)
             */
            time_ranges?: {
                [key: string]: unknown;
            }[] | null;
        };
        /**
         * AlertRuleCreate
         * @description Schema for creating an alert rule.
         *
         *     All conditions use AND logic - all specified conditions must match for the rule to trigger.
         *     Leave a condition as null/empty to not filter on that criterion.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "channels": [
         *         "pushover",
         *         "webhook"
         *       ],
         *       "cooldown_seconds": 300,
         *       "dedup_key_template": "{camera_id}:{rule_id}",
         *       "description": "High-priority alert for person detection at night",
         *       "enabled": true,
         *       "min_confidence": 0.8,
         *       "name": "Night Intruder Alert",
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_threshold": 70,
         *       "schedule": {
         *         "days": [
         *           "monday",
         *           "tuesday",
         *           "wednesday",
         *           "thursday",
         *           "friday"
         *         ],
         *         "end_time": "06:00",
         *         "start_time": "22:00",
         *         "timezone": "America/New_York"
         *       },
         *       "severity": "critical"
         *     }
         */
        AlertRuleCreate: {
            /**
             * Camera Ids
             * @description Camera IDs to apply rule to (empty = all cameras)
             */
            camera_ids?: string[] | null;
            /**
             * Channels
             * @description Notification channels for this rule
             */
            channels?: string[];
            /** @description Legacy conditions (use explicit fields instead) */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             * @default 300
             */
            cooldown_seconds: number;
            /**
             * Dedup Key Template
             * @description Template for dedup key. Variables: {camera_id}, {rule_id}, {object_type}
             * @default {camera_id}:{rule_id}
             */
            dedup_key_template: string;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             * @default true
             */
            enabled: boolean;
            /**
             * Min Confidence
             * @description Minimum detection confidence (0.0-1.0)
             */
            min_confidence?: number | null;
            /**
             * Name
             * @description Rule name
             */
            name: string;
            /**
             * Object Types
             * @description Object types to match (e.g., ['person', 'vehicle'])
             */
            object_types?: string[] | null;
            /**
             * Risk Threshold
             * @description Alert when risk_score >= threshold
             */
            risk_threshold?: number | null;
            /** @description Time-based conditions (null = always active) */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /**
             * @description Severity level for triggered alerts
             * @default medium
             */
            severity: components["schemas"]["AlertSeverity"];
            /**
             * Zone Ids
             * @description Zone IDs to match (empty = any zone)
             */
            zone_ids?: string[] | null;
        };
        /**
         * AlertRuleListResponse
         * @description Schema for alert rule list response with pagination.
         * @example {
         *       "items": [
         *         {
         *           "channels": [
         *             "pushover"
         *           ],
         *           "conditions": {
         *             "risk_threshold": 70
         *           },
         *           "cooldown_seconds": 300,
         *           "created_at": "2025-12-28T12:00:00Z",
         *           "enabled": true,
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "name": "High Risk Alert",
         *           "updated_at": "2025-12-28T12:00:00Z"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        AlertRuleListResponse: {
            /**
             * Items
             * @description List of alert rules
             */
            items: components["schemas"]["AlertRuleResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * AlertRuleResponse
         * @description Schema for alert rule response.
         * @example {
         *       "camera_ids": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "channels": [
         *         "pushover",
         *         "webhook"
         *       ],
         *       "cooldown_seconds": 300,
         *       "created_at": "2025-12-28T12:00:00Z",
         *       "dedup_key_template": "{camera_id}:{rule_id}",
         *       "description": "High-priority alert for person detection at night",
         *       "enabled": true,
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "min_confidence": 0.8,
         *       "name": "Night Intruder Alert",
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_threshold": 70,
         *       "schedule": {
         *         "days": [
         *           "monday",
         *           "tuesday",
         *           "wednesday",
         *           "thursday",
         *           "friday"
         *         ],
         *         "end_time": "06:00",
         *         "start_time": "22:00",
         *         "timezone": "America/New_York"
         *       },
         *       "severity": "critical",
         *       "updated_at": "2025-12-28T12:00:00Z"
         *     }
         */
        AlertRuleResponse: {
            /**
             * Camera Ids
             * @description Camera IDs to apply to
             */
            camera_ids?: string[] | null;
            /**
             * Channels
             * @description Notification channels
             */
            channels?: string[];
            /** @description Legacy conditions */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             */
            cooldown_seconds: number;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp
             */
            created_at: string;
            /**
             * Dedup Key Template
             * @description Template for dedup key
             */
            dedup_key_template: string;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             */
            enabled: boolean;
            /**
             * Id
             * @description Alert rule UUID
             */
            id: string;
            /**
             * Min Confidence
             * @description Minimum confidence
             */
            min_confidence?: number | null;
            /**
             * Name
             * @description Rule name
             */
            name: string;
            /**
             * Object Types
             * @description Object types to match
             */
            object_types?: string[] | null;
            /**
             * Risk Threshold
             * @description Risk score threshold
             */
            risk_threshold?: number | null;
            /** @description Time-based conditions */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /** @description Severity level */
            severity: components["schemas"]["AlertSeverity"];
            /**
             * Updated At
             * Format: date-time
             * @description Last update timestamp
             */
            updated_at: string;
            /**
             * Zone Ids
             * @description Zone IDs to match
             */
            zone_ids?: string[] | null;
        };
        /**
         * AlertRuleSchedule
         * @description Schema for alert rule schedule (time-based conditions).
         *
         *     If start_time > end_time, the schedule spans midnight (e.g., 22:00-06:00).
         *     Empty days array means all days. No schedule = always active (vacation mode).
         *
         *     Validation:
         *     - Days must be valid day names (monday-sunday)
         *     - Times must be valid HH:MM format with hours 00-23, minutes 00-59
         *     - Start and end times are validated but can span midnight
         * @example {
         *       "days": [
         *         "monday",
         *         "tuesday",
         *         "wednesday",
         *         "thursday",
         *         "friday"
         *       ],
         *       "end_time": "06:00",
         *       "start_time": "22:00",
         *       "timezone": "America/New_York"
         *     }
         */
        AlertRuleSchedule: {
            /**
             * Days
             * @description Days of week when rule is active (empty = all days). Values: monday, tuesday, wednesday, thursday, friday, saturday, sunday
             */
            days?: string[] | null;
            /**
             * End Time
             * @description End time in HH:MM format (00:00-23:59)
             */
            end_time?: string | null;
            /**
             * Start Time
             * @description Start time in HH:MM format (00:00-23:59)
             */
            start_time?: string | null;
            /**
             * Timezone
             * @description Timezone for time evaluation
             * @default UTC
             */
            timezone: string;
        };
        /**
         * AlertRuleUpdate
         * @description Schema for updating an alert rule (PATCH).
         *
         *     Only provided fields will be updated. Null values clear the field.
         * @example {
         *       "cooldown_seconds": 600,
         *       "enabled": false,
         *       "risk_threshold": 80
         *     }
         */
        AlertRuleUpdate: {
            /**
             * Camera Ids
             * @description Camera IDs to apply rule to
             */
            camera_ids?: string[] | null;
            /**
             * Channels
             * @description Notification channels for this rule
             */
            channels?: string[] | null;
            /** @description Legacy conditions */
            conditions?: components["schemas"]["AlertRuleConditions"] | null;
            /**
             * Cooldown Seconds
             * @description Minimum seconds between duplicate alerts
             */
            cooldown_seconds?: number | null;
            /**
             * Dedup Key Template
             * @description Template for dedup key
             */
            dedup_key_template?: string | null;
            /**
             * Description
             * @description Rule description
             */
            description?: string | null;
            /**
             * Enabled
             * @description Whether the rule is active
             */
            enabled?: boolean | null;
            /**
             * Min Confidence
             * @description Minimum detection confidence
             */
            min_confidence?: number | null;
            /**
             * Name
             * @description Rule name
             */
            name?: string | null;
            /**
             * Object Types
             * @description Object types to match
             */
            object_types?: string[] | null;
            /**
             * Risk Threshold
             * @description Alert when risk_score >= threshold
             */
            risk_threshold?: number | null;
            /** @description Time-based conditions */
            schedule?: components["schemas"]["AlertRuleSchedule"] | null;
            /** @description Severity level */
            severity?: components["schemas"]["AlertSeverity"] | null;
            /**
             * Zone Ids
             * @description Zone IDs to match
             */
            zone_ids?: string[] | null;
        };
        /**
         * AlertSeverity
         * @description Alert severity levels.
         * @enum {string}
         */
        AlertSeverity: "low" | "medium" | "high" | "critical";
        /**
         * AlertStatus
         * @description Alert status values.
         * @enum {string}
         */
        AlertStatus: "pending" | "delivered" | "acknowledged" | "dismissed";
        /**
         * AlertmanagerAlert
         * @description Schema for a single alert in Alertmanager webhook payload.
         *
         *     Represents one alert instance with its labels, annotations, and timing.
         *     This schema matches the Alertmanager webhook format.
         * @example {
         *       "annotations": {
         *         "description": "CPU usage is above 80% for 5 minutes",
         *         "summary": "CPU usage is high"
         *       },
         *       "endsAt": "0001-01-01T00:00:00Z",
         *       "fingerprint": "abc123def456",
         *       "generatorURL": "http://prometheus:9090/graph?...",
         *       "labels": {
         *         "alertname": "HighCPU",
         *         "instance": "localhost:9090",
         *         "severity": "warning"
         *       },
         *       "startsAt": "2026-01-20T12:00:00Z",
         *       "status": "firing"
         *     }
         */
        AlertmanagerAlert: {
            /**
             * Annotations
             * @description Alert annotations (summary, description)
             */
            annotations?: {
                [key: string]: string;
            };
            /**
             * Endsat
             * @description When the alert was resolved
             */
            endsAt?: string | null;
            /**
             * Fingerprint
             * @description Unique identifier for alert deduplication
             */
            fingerprint: string;
            /**
             * Generatorurl
             * @description URL to the Prometheus graph
             */
            generatorURL?: string | null;
            /**
             * Labels
             * @description Alert labels (alertname, severity, etc.)
             */
            labels?: {
                [key: string]: string;
            };
            /**
             * Startsat
             * Format: date-time
             * @description When the alert started firing
             */
            startsAt: string;
            /** @description Alert status (firing or resolved) */
            status: components["schemas"]["PrometheusAlertStatus"];
        };
        /**
         * AlertmanagerStatus
         * @description Alertmanager alert status values.
         * @enum {string}
         */
        AlertmanagerStatus: "firing" | "resolved";
        /**
         * AlertmanagerWebhook
         * @description Schema for Alertmanager webhook payload.
         *
         *     This is the format Alertmanager sends when configured with a webhook receiver.
         *     See: https://prometheus.io/docs/alerting/latest/configuration/#webhook_config
         * @example {
         *       "alerts": [
         *         {
         *           "annotations": {
         *             "description": "CPU at 85%"
         *           },
         *           "endsAt": "0001-01-01T00:00:00Z",
         *           "fingerprint": "abc123",
         *           "labels": {
         *             "alertname": "HighCPU",
         *             "severity": "warning"
         *           },
         *           "startsAt": "2026-01-20T12:00:00Z",
         *           "status": "firing"
         *         }
         *       ],
         *       "commonAnnotations": {
         *         "summary": "CPU usage is high"
         *       },
         *       "commonLabels": {
         *         "alertname": "HighCPU",
         *         "severity": "warning"
         *       },
         *       "externalURL": "http://alertmanager:9093",
         *       "groupKey": "{}:{alertname=\"HighCPU\"}",
         *       "groupLabels": {
         *         "alertname": "HighCPU"
         *       },
         *       "receiver": "webhook-receiver",
         *       "status": "firing",
         *       "truncatedAlerts": 0,
         *       "version": "4"
         *     }
         */
        AlertmanagerWebhook: {
            /**
             * Alerts
             * @description List of alerts in this group
             */
            alerts: components["schemas"]["AlertmanagerAlert"][];
            /**
             * Commonannotations
             * @description Annotations common to all alerts
             */
            commonAnnotations?: {
                [key: string]: string;
            };
            /**
             * Commonlabels
             * @description Labels common to all alerts
             */
            commonLabels?: {
                [key: string]: string;
            };
            /**
             * Externalurl
             * @description Alertmanager external URL
             */
            externalURL?: string | null;
            /**
             * Groupkey
             * @description Key identifying the alert group
             */
            groupKey: string;
            /**
             * Grouplabels
             * @description Labels used for grouping
             */
            groupLabels?: {
                [key: string]: string;
            };
            /**
             * Receiver
             * @description Name of the receiver that matched
             */
            receiver: string;
            /** @description Overall group status */
            status: components["schemas"]["PrometheusAlertStatus"];
            /**
             * Truncatedalerts
             * @description Number of truncated alerts
             * @default 0
             */
            truncatedAlerts: number;
            /**
             * Version
             * @description Alertmanager webhook version
             * @default 4
             */
            version: string;
        };
        /**
         * AlertmanagerWebhookPayload
         * @description Schema for Alertmanager webhook payload.
         *
         *     This is the format Alertmanager sends when configured with a webhook receiver.
         *     See: https://prometheus.io/docs/alerting/latest/configuration/#webhook_config
         * @example {
         *       "alerts": [
         *         {
         *           "annotations": {
         *             "description": "GPU memory at 96%"
         *           },
         *           "endsAt": "0001-01-01T00:00:00Z",
         *           "fingerprint": "abc123",
         *           "labels": {
         *             "alertname": "HSIGPUMemoryHigh",
         *             "severity": "warning"
         *           },
         *           "startsAt": "2026-01-17T12:22:56.068Z",
         *           "status": "firing"
         *         }
         *       ],
         *       "commonAnnotations": {
         *         "summary": "GPU memory usage is high"
         *       },
         *       "commonLabels": {
         *         "alertname": "HSIGPUMemoryHigh",
         *         "severity": "warning"
         *       },
         *       "externalURL": "http://alertmanager:9093",
         *       "groupKey": "{}:{alertname=\"HSIGPUMemoryHigh\"}",
         *       "groupLabels": {
         *         "alertname": "HSIGPUMemoryHigh"
         *       },
         *       "receiver": "critical-receiver",
         *       "status": "firing",
         *       "truncatedAlerts": 0,
         *       "version": "4"
         *     }
         */
        AlertmanagerWebhookPayload: {
            /**
             * Alerts
             * @description List of alerts in this group
             */
            alerts: components["schemas"]["WebhookAlert"][];
            /**
             * Commonannotations
             * @description Annotations common to all alerts
             */
            commonAnnotations?: {
                [key: string]: string;
            };
            /**
             * Commonlabels
             * @description Labels common to all alerts
             */
            commonLabels?: {
                [key: string]: string;
            };
            /**
             * Externalurl
             * @description Alertmanager external URL
             */
            externalURL?: string | null;
            /**
             * Groupkey
             * @description Key identifying the alert group
             */
            groupKey: string;
            /**
             * Grouplabels
             * @description Labels used for grouping
             */
            groupLabels?: {
                [key: string]: string;
            };
            /**
             * Receiver
             * @description Name of the receiver that matched
             */
            receiver: string;
            /** @description Overall group status */
            status: components["schemas"]["AlertmanagerStatus"];
            /**
             * Truncatedalerts
             * @description Number of truncated alerts
             * @default 0
             */
            truncatedAlerts: number;
            /**
             * Version
             * @description Alertmanager webhook version
             * @default 4
             */
            version: string;
        };
        /**
         * AlertmanagerWebhookResponse
         * @description Response schema for the alertmanager webhook endpoint.
         * @example {
         *       "broadcast": 2,
         *       "message": "Processed 2 alert(s)",
         *       "received": 2,
         *       "status": "ok",
         *       "stored": 2
         *     }
         */
        AlertmanagerWebhookResponse: {
            /**
             * Broadcast
             * @description Number of alerts broadcast via WebSocket
             */
            broadcast: number;
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Received
             * @description Number of alerts received
             */
            received: number;
            /**
             * Status
             * @description Processing status (ok or error)
             */
            status: string;
            /**
             * Stored
             * @description Number of alerts stored in database
             */
            stored: number;
        };
        /**
         * AllPromptsResponse
         * @description Response containing prompts for all configurable models.
         * @example {
         *       "exported_at": "2026-01-03T10:30:00Z",
         *       "prompts": {
         *         "florence2": {
         *           "vqa_queries": [
         *             "What is this person wearing?",
         *             "Is this person carrying anything?"
         *           ]
         *         },
         *         "nemotron": {
         *           "max_tokens": 2048,
         *           "system_prompt": "You are a home security AI assistant...",
         *           "temperature": 0.7
         *         }
         *       },
         *       "version": "1.0"
         *     }
         */
        AllPromptsResponse: {
            /**
             * Exported At
             * Format: date-time
             * @description Export timestamp
             */
            exported_at: string;
            /**
             * Prompts
             * @description Configuration for each model
             */
            prompts: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
            /**
             * Version
             * @description Export format version
             * @default 1.0
             */
            version: string;
        };
        /**
         * AnomalyConfig
         * @description Current anomaly detection configuration.
         * @example {
         *       "decay_factor": 0.1,
         *       "min_samples": 10,
         *       "threshold_stdev": 2,
         *       "window_days": 30
         *     }
         */
        AnomalyConfig: {
            /**
             * Decay Factor
             * @description Exponential decay factor for EWMA (0 < factor <= 1)
             */
            decay_factor: number;
            /**
             * Min Samples
             * @description Minimum samples required before anomaly detection is reliable
             */
            min_samples: number;
            /**
             * Threshold Stdev
             * @description Number of standard deviations from mean for anomaly detection
             */
            threshold_stdev: number;
            /**
             * Window Days
             * @description Rolling window size in days for baseline calculations
             */
            window_days: number;
        };
        /**
         * AnomalyConfigUpdate
         * @description Request to update anomaly detection configuration.
         * @example {
         *       "min_samples": 15,
         *       "threshold_stdev": 2.5
         *     }
         */
        AnomalyConfigUpdate: {
            /**
             * Min Samples
             * @description Minimum samples required before anomaly detection is reliable
             */
            min_samples?: number | null;
            /**
             * Threshold Stdev
             * @description Number of standard deviations from mean for anomaly detection
             */
            threshold_stdev?: number | null;
        };
        /**
         * AnomalyEvent
         * @description A single anomaly event detected for a camera.
         * @example {
         *       "anomaly_score": 0.95,
         *       "detection_class": "vehicle",
         *       "expected_frequency": 0.1,
         *       "observed_frequency": 5,
         *       "reason": "Vehicle detected at 2:30 AM when rarely seen at this hour",
         *       "timestamp": "2026-01-03T02:30:00Z"
         *     }
         */
        AnomalyEvent: {
            /**
             * Anomaly Score
             * @description Anomaly score (0.0-1.0, higher is more anomalous)
             */
            anomaly_score: number;
            /**
             * Detection Class
             * @description Object class that triggered the anomaly
             */
            detection_class: string;
            /**
             * Expected Frequency
             * @description Expected frequency for this class at this time
             */
            expected_frequency: number;
            /**
             * Observed Frequency
             * @description Observed frequency that triggered the anomaly
             */
            observed_frequency: number;
            /**
             * Reason
             * @description Human-readable explanation of why this is anomalous
             */
            reason: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the anomaly was detected
             */
            timestamp: string;
        };
        /**
         * AnomalyListResponse
         * @description Response schema for camera anomaly list endpoint.
         * @example {
         *       "anomalies": [
         *         {
         *           "anomaly_score": 0.95,
         *           "detection_class": "vehicle",
         *           "expected_frequency": 0.1,
         *           "observed_frequency": 5,
         *           "reason": "Vehicle detected at 2:30 AM when rarely seen",
         *           "timestamp": "2026-01-03T02:30:00Z"
         *         }
         *       ],
         *       "camera_id": "front_door",
         *       "count": 1,
         *       "period_days": 7
         *     }
         */
        AnomalyListResponse: {
            /**
             * Anomalies
             * @description List of recent anomaly events
             */
            anomalies?: components["schemas"]["AnomalyEvent"][];
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Count
             * @description Total number of anomalies returned
             */
            count: number;
            /**
             * Period Days
             * @description Number of days covered by this query
             */
            period_days: number;
        };
        /**
         * AreaBasic
         * @description Minimal area schema for embedding in CameraResponse.
         *
         *     NEM-3597: Basic area information for API responses that include
         *     camera-area relationships without full area details.
         * @example {
         *       "id": 1,
         *       "name": "Front Yard"
         *     }
         */
        AreaBasic: {
            /**
             * Id
             * @description Unique area identifier
             */
            id: number;
            /**
             * Name
             * @description Area name
             */
            name: string;
        };
        /**
         * AreaCameraResponse
         * @description Schema for camera info in area context (minimal camera info).
         * @example {
         *       "id": "front_door",
         *       "name": "Front Door Camera",
         *       "status": "online"
         *     }
         */
        AreaCameraResponse: {
            /**
             * Id
             * @description Camera ID
             */
            id: string;
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * Status
             * @description Camera status (online, offline, error, unknown)
             */
            status: string;
        };
        /**
         * AreaCamerasResponse
         * @description Schema for listing cameras in an area.
         * @example {
         *       "area_id": 1,
         *       "area_name": "Front Yard",
         *       "cameras": [
         *         {
         *           "id": "front_door",
         *           "name": "Front Door Camera",
         *           "status": "online"
         *         }
         *       ],
         *       "count": 1
         *     }
         */
        AreaCamerasResponse: {
            /**
             * Area Id
             * @description ID of the area
             */
            area_id: number;
            /**
             * Area Name
             * @description Name of the area
             */
            area_name: string;
            /**
             * Cameras
             * @description List of cameras in this area
             */
            cameras: components["schemas"]["AreaCameraResponse"][];
            /**
             * Count
             * @description Number of cameras in this area
             */
            count: number;
        };
        /**
         * AreaCreate
         * @description Schema for creating a new area.
         *
         *     An area represents a logical zone within a property
         *     (e.g., front yard, garage, pool area).
         * @example {
         *       "color": "#10B981",
         *       "description": "Main entrance and lawn area",
         *       "name": "Front Yard"
         *     }
         */
        AreaCreate: {
            /**
             * Color
             * @description Hex color code for UI display
             * @default #76B900
             */
            color: string;
            /**
             * Description
             * @description Optional longer description
             */
            description?: string | null;
            /**
             * Name
             * @description Area name (e.g., 'Front Yard')
             */
            name: string;
        };
        /**
         * AreaListResponse
         * @description Schema for listing areas.
         * @example {
         *       "items": [
         *         {
         *           "color": "#10B981",
         *           "created_at": "2026-01-20T10:00:00Z",
         *           "description": "Main entrance",
         *           "id": 1,
         *           "name": "Front Yard",
         *           "property_id": 1
         *         }
         *       ],
         *       "total": 1
         *     }
         */
        AreaListResponse: {
            /**
             * Items
             * @description List of areas
             */
            items: components["schemas"]["AreaResponse"][];
            /**
             * Total
             * @description Total number of areas
             */
            total: number;
        };
        /**
         * AreaResponse
         * @description Schema for area response.
         * @example {
         *       "color": "#10B981",
         *       "created_at": "2026-01-20T10:00:00Z",
         *       "description": "Main entrance and lawn area",
         *       "id": 1,
         *       "name": "Front Yard",
         *       "property_id": 1
         *     }
         */
        AreaResponse: {
            /**
             * Color
             * @description Hex color code for UI
             */
            color: string;
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when area was created
             */
            created_at: string;
            /**
             * Description
             * @description Description
             */
            description?: string | null;
            /**
             * Id
             * @description Unique area identifier
             */
            id: number;
            /**
             * Name
             * @description Area name
             */
            name: string;
            /**
             * Property Id
             * @description ID of the parent property
             */
            property_id: number;
        };
        /**
         * AreaUpdate
         * @description Schema for updating an existing area.
         *
         *     All fields are optional; only provided fields will be updated.
         * @example {
         *       "color": "#3B82F6",
         *       "name": "Main Entrance"
         *     }
         */
        AreaUpdate: {
            /**
             * Color
             * @description Hex color code
             */
            color?: string | null;
            /**
             * Description
             * @description Description
             */
            description?: string | null;
            /**
             * Name
             * @description Area name
             */
            name?: string | null;
        };
        /**
         * AuditLogListResponse
         * @description Schema for paginated audit log response.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Cursor-based pagination offers better performance for large datasets.
         * @example {
         *       "items": [
         *         {
         *           "action": "acknowledge",
         *           "actor": "admin@example.com",
         *           "id": 1,
         *           "ip_address": "192.168.1.100",
         *           "resource_id": "123",
         *           "resource_type": "event",
         *           "status": "success",
         *           "timestamp": "2026-01-03T10:30:00Z"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjYtMDEtMDNUMTA6MzA6MDBaIn0=", // pragma: allowlist secret
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        AuditLogListResponse: {
            /**
             * Deprecation Warning
             * @description Warning when using deprecated offset pagination
             */
            deprecation_warning?: string | null;
            /**
             * Items
             * @description List of audit log entries
             */
            items: components["schemas"]["AuditLogResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * AuditLogResponse
         * @description Schema for a single audit log entry.
         * @example {
         *       "action": "acknowledge",
         *       "actor": "admin@example.com",
         *       "details": {
         *         "new_status": "acknowledged",
         *         "previous_status": "unacknowledged"
         *       },
         *       "id": 1,
         *       "ip_address": "192.168.1.100",
         *       "resource_id": "123",
         *       "resource_type": "event",
         *       "status": "success",
         *       "timestamp": "2026-01-03T10:30:00Z",
         *       "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0"
         *     }
         */
        AuditLogResponse: {
            /**
             * Action
             * @description The action performed (e.g., 'create', 'update', 'delete', 'acknowledge')
             */
            action: string;
            /**
             * Actor
             * @description User or system that performed the action
             */
            actor: string;
            /**
             * Details
             * @description Action-specific details (JSON-serializable)
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * Id
             * @description Audit log entry ID
             */
            id: number;
            /**
             * Ip Address
             * @description IP address of the client (IPv4 or IPv6)
             */
            ip_address?: string | null;
            /**
             * Resource Id
             * @description ID of the specific resource
             */
            resource_id?: string | null;
            /**
             * Resource Type
             * @description Type of resource (event, alert, rule, camera, settings)
             */
            resource_type: string;
            /**
             * Status
             * @description Status of the action (success/failure)
             */
            status: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the action occurred (UTC)
             */
            timestamp: string;
            /**
             * User Agent
             * @description User agent string of the client
             */
            user_agent?: string | null;
        };
        /**
         * AuditLogStats
         * @description Schema for audit log statistics.
         * @example {
         *       "by_action": {
         *         "acknowledge": 50,
         *         "create": 30,
         *         "delete": 25,
         *         "update": 45
         *       },
         *       "by_resource_type": {
         *         "alert": 40,
         *         "camera": 20,
         *         "event": 80,
         *         "settings": 10
         *       },
         *       "by_status": {
         *         "failure": 5,
         *         "success": 145
         *       },
         *       "logs_today": 150,
         *       "recent_actors": [
         *         "admin@example.com",
         *         "system",
         *         "scheduler"
         *       ],
         *       "total_logs": 5000
         *     }
         */
        AuditLogStats: {
            /**
             * By Action
             * @description Counts by action type
             */
            by_action: {
                [key: string]: number;
            };
            /**
             * By Resource Type
             * @description Counts by resource type
             */
            by_resource_type: {
                [key: string]: number;
            };
            /**
             * By Status
             * @description Counts by status
             */
            by_status: {
                [key: string]: number;
            };
            /**
             * Logs Today
             * @description Number of logs today
             */
            logs_today: number;
            /**
             * Recent Actors
             * @description Recently active actors
             */
            recent_actors: string[];
            /**
             * Total Logs
             * @description Total number of audit logs
             */
            total_logs: number;
        };
        /**
         * AuditStatsResponse
         * @description Aggregate audit statistics.
         * @example {
         *       "audited_events": 1100,
         *       "audits_by_day": [
         *         {
         *           "avg_enrichment_utilization": 0.78,
         *           "avg_quality_score": 4.2,
         *           "count": 45,
         *           "date": "2026-01-01",
         *           "day_of_week": "Wednesday",
         *           "model_contributions": {
         *             "florence": 38,
         *             "yolo26": 45
         *           }
         *         },
         *         {
         *           "avg_enrichment_utilization": 0.8,
         *           "avg_quality_score": 4,
         *           "count": 52,
         *           "date": "2026-01-02",
         *           "day_of_week": "Thursday",
         *           "model_contributions": {
         *             "florence": 45,
         *             "yolo26": 52
         *           }
         *         },
         *         {
         *           "avg_enrichment_utilization": 0.75,
         *           "avg_quality_score": 4.3,
         *           "count": 38,
         *           "date": "2026-01-03",
         *           "day_of_week": "Friday",
         *           "model_contributions": {
         *             "florence": 30,
         *             "yolo26": 38
         *           }
         *         }
         *       ],
         *       "avg_consistency_rate": 0.92,
         *       "avg_enrichment_utilization": 0.78,
         *       "avg_quality_score": 4.1,
         *       "fully_evaluated_events": 950,
         *       "model_contribution_rates": {
         *         "clothing": 0.72,
         *         "florence": 0.85,
         *         "weather": 0.95,
         *         "yolo26": 0.98
         *       },
         *       "total_events": 1250
         *     }
         */
        AuditStatsResponse: {
            /** Audited Events */
            audited_events: number;
            /** Audits By Day */
            audits_by_day: components["schemas"]["DailyAuditStats"][];
            /** Avg Consistency Rate */
            avg_consistency_rate: number | null;
            /** Avg Enrichment Utilization */
            avg_enrichment_utilization: number | null;
            /** Avg Quality Score */
            avg_quality_score: number | null;
            /** Fully Evaluated Events */
            fully_evaluated_events: number;
            /** Model Contribution Rates */
            model_contribution_rates: {
                [key: string]: number;
            };
            /** Total Events */
            total_events: number;
        };
        /**
         * BaselineSummaryResponse
         * @description Response schema for camera baseline summary endpoint.
         *
         *     Provides comprehensive baseline data for a camera including:
         *     - Hourly activity patterns (0-23 hours)
         *     - Daily patterns (by day of week)
         *     - Object-specific baselines
         *     - Current deviation from baseline
         * @example {
         *       "baseline_established": "2026-01-01T00:00:00Z",
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "current_deviation": {
         *         "contributing_factors": [
         *           "person_count_elevated"
         *         ],
         *         "interpretation": "slightly_above_normal",
         *         "score": 1.8
         *       },
         *       "daily_patterns": {
         *         "monday": {
         *           "avg_detections": 45,
         *           "peak_hour": 17,
         *           "total_samples": 24
         *         }
         *       },
         *       "data_points": 720,
         *       "hourly_patterns": {
         *         "0": {
         *           "avg_detections": 0.5,
         *           "sample_count": 30,
         *           "std_dev": 0.3
         *         },
         *         "17": {
         *           "avg_detections": 5.2,
         *           "sample_count": 30,
         *           "std_dev": 1.1
         *         }
         *       },
         *       "object_baselines": {
         *         "person": {
         *           "avg_hourly": 2.3,
         *           "peak_hour": 17,
         *           "total_detections": 550
         *         }
         *       }
         *     }
         */
        BaselineSummaryResponse: {
            /**
             * Baseline Established
             * @description When baseline data collection started (null if no data)
             */
            baseline_established?: string | null;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name: string;
            /** @description Current deviation from baseline (null if insufficient data) */
            current_deviation?: components["schemas"]["CurrentDeviation"] | null;
            /**
             * Daily Patterns
             * @description Activity patterns by day of week (monday-sunday)
             */
            daily_patterns?: {
                [key: string]: components["schemas"]["DailyPattern"];
            };
            /**
             * Data Points
             * @description Total number of data points in baseline
             */
            data_points: number;
            /**
             * Hourly Patterns
             * @description Activity patterns by hour (0-23)
             */
            hourly_patterns?: {
                [key: string]: components["schemas"]["HourlyPattern"];
            };
            /**
             * Object Baselines
             * @description Baseline statistics by object type
             */
            object_baselines?: {
                [key: string]: components["schemas"]["ObjectBaseline"];
            };
        };
        /**
         * BatchAggregatorStatusResponse
         * @description Status information for the BatchAggregator service.
         * @example {
         *       "active_batches": 2,
         *       "batch_window_seconds": 90,
         *       "batches": [
         *         {
         *           "age_seconds": 45.5,
         *           "batch_id": "abc123",
         *           "camera_id": "front_door",
         *           "detection_count": 5,
         *           "last_activity_seconds": 10.2,
         *           "started_at": 1735500000
         *         }
         *       ],
         *       "idle_timeout_seconds": 30
         *     }
         */
        BatchAggregatorStatusResponse: {
            /**
             * Active Batches
             * @description Number of active batches being aggregated
             */
            active_batches: number;
            /**
             * Batch Window Seconds
             * @description Configured batch window timeout in seconds
             */
            batch_window_seconds: number;
            /**
             * Batches
             * @description Details of active batches
             */
            batches?: components["schemas"]["BatchInfoResponse"][];
            /**
             * Idle Timeout Seconds
             * @description Configured idle timeout in seconds
             */
            idle_timeout_seconds: number;
        };
        /**
         * BatchAuditJobResponse
         * @description Response for async batch audit job creation.
         *
         *     Returned immediately when triggering a batch audit, containing
         *     the job ID for progress tracking via GET /api/ai-audit/batch/{job_id}.
         * @example {
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Batch audit job created. Use GET /api/ai-audit/batch/550e8400-e29b-41d4-a716-446655440000 to track progress.",
         *       "status": "pending",
         *       "total_events": 75
         *     }
         */
        BatchAuditJobResponse: {
            /**
             * Job Id
             * @description Unique job ID for tracking progress
             */
            job_id: string;
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Status
             * @description Initial job status (pending)
             */
            status: string;
            /**
             * Total Events
             * @description Number of events queued for processing
             */
            total_events: number;
        };
        /**
         * BatchAuditJobStatusResponse
         * @description Response for batch audit job status query.
         *
         *     Provides detailed progress information for an ongoing or completed
         *     batch audit job.
         * @example {
         *       "created_at": "2026-01-03T10:30:00Z",
         *       "failed_events": 2,
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Processing event 45 of 100",
         *       "processed_events": 45,
         *       "progress": 45,
         *       "started_at": "2026-01-03T10:30:01Z",
         *       "status": "running",
         *       "total_events": 100
         *     }
         */
        BatchAuditJobStatusResponse: {
            /**
             * Completed At
             * @description When processing completed
             */
            completed_at?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description When the job was created
             */
            created_at: string;
            /**
             * Error
             * @description Error message if job failed
             */
            error?: string | null;
            /**
             * Failed Events
             * @description Events that failed processing
             * @default 0
             */
            failed_events: number;
            /**
             * Job Id
             * @description Unique job ID
             */
            job_id: string;
            /**
             * Message
             * @description Current status message
             */
            message?: string | null;
            /**
             * Processed Events
             * @description Events successfully processed
             */
            processed_events: number;
            /**
             * Progress
             * @description Progress percentage (0-100)
             */
            progress: number;
            /**
             * Started At
             * @description When processing started
             */
            started_at?: string | null;
            /**
             * Status
             * @description Current job status (pending, running, completed, failed)
             */
            status: string;
            /**
             * Total Events
             * @description Total events to process
             */
            total_events: number;
        };
        /**
         * BatchAuditRequest
         * @description Request for batch audit processing.
         * @example {
         *       "force_reevaluate": false,
         *       "limit": 100,
         *       "min_risk_score": 50
         *     }
         */
        BatchAuditRequest: {
            /**
             * Force Reevaluate
             * @default false
             */
            force_reevaluate: boolean;
            /**
             * Limit
             * @default 100
             */
            limit: number;
            /** Min Risk Score */
            min_risk_score?: number | null;
        };
        /**
         * BatchInfoResponse
         * @description Information about an active batch.
         */
        BatchInfoResponse: {
            /**
             * Age Seconds
             * @description Time since batch started in seconds
             */
            age_seconds: number;
            /**
             * Batch Id
             * @description Unique batch identifier
             */
            batch_id: string;
            /**
             * Camera Id
             * @description Camera ID this batch belongs to
             */
            camera_id: string;
            /**
             * Detection Count
             * @description Number of detections in this batch
             */
            detection_count: number;
            /**
             * Last Activity Seconds
             * @description Time since last activity in seconds
             */
            last_activity_seconds: number;
            /**
             * Started At
             * @description Batch start time (Unix timestamp)
             */
            started_at: number;
        };
        /**
         * BatchSettings
         * @description Batch processing settings for detection grouping.
         *
         *     Controls how detections are batched together before being sent to
         *     the Nemotron LLM for risk analysis.
         * @example {
         *       "idle_timeout_seconds": 30,
         *       "window_seconds": 90
         *     }
         */
        BatchSettings: {
            /**
             * Idle Timeout Seconds
             * @description Idle timeout in seconds before processing incomplete batch
             */
            idle_timeout_seconds: number;
            /**
             * Window Seconds
             * @description Time window in seconds for batch processing detections
             */
            window_seconds: number;
        };
        /**
         * BatchSettingsUpdate
         * @description Batch settings update schema (all fields optional).
         *
         *     Used for PATCH /api/v1/settings to partially update batch processing settings.
         *     Validates that idle_timeout_seconds < window_seconds when both are provided.
         * @example {
         *       "window_seconds": 120
         *     }
         */
        BatchSettingsUpdate: {
            /**
             * Idle Timeout Seconds
             * @description Idle timeout in seconds before processing incomplete batch (max 300)
             */
            idle_timeout_seconds?: number | null;
            /**
             * Window Seconds
             * @description Time window in seconds for batch processing detections (max 600)
             */
            window_seconds?: number | null;
        };
        /**
         * BulkCancelError
         * @description Error details for a single job in bulk cancellation.
         * @example {
         *       "error": "Job not found",
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000"
         *     }
         */
        BulkCancelError: {
            /**
             * Error
             * @description Error message
             */
            error: string;
            /**
             * Job Id
             * @description Job ID that failed to cancel
             */
            job_id: string;
        };
        /**
         * BulkCancelRequest
         * @description Request model for bulk job cancellation.
         * @example {
         *       "job_ids": [
         *         "550e8400-e29b-41d4-a716-446655440000",
         *         "550e8400-e29b-41d4-a716-446655440001"
         *       ]
         *     }
         */
        BulkCancelRequest: {
            /**
             * Job Ids
             * @description List of job IDs to cancel (1-100 jobs)
             */
            job_ids: string[];
        };
        /**
         * BulkCancelResponse
         * @description Response model for bulk job cancellation.
         * @example {
         *       "cancelled": 5,
         *       "errors": [
         *         {
         *           "error": "Job already completed",
         *           "job_id": "550e8400-e29b-41d4-a716-446655440005"
         *         }
         *       ],
         *       "failed": 1
         *     }
         */
        BulkCancelResponse: {
            /**
             * Cancelled
             * @description Number of jobs successfully cancelled
             */
            cancelled: number;
            /**
             * Errors
             * @description Details of cancellation failures
             */
            errors?: components["schemas"]["BulkCancelError"][];
            /**
             * Failed
             * @description Number of jobs that failed to cancel
             */
            failed: number;
        };
        /**
         * BulkItemResult
         * @description Result for a single item in a bulk operation.
         *
         *     Attributes:
         *         index: Zero-based index of the item in the request array
         *         status: Operation status (success, failed, skipped)
         *         id: ID of the created/updated resource (for successful operations)
         *         error: Error message (for failed operations)
         */
        BulkItemResult: {
            /**
             * Error
             * @description Error message for failed operations
             */
            error?: string | null;
            /**
             * Id
             * @description ID of the created/updated resource
             */
            id?: number | null;
            /**
             * Index
             * @description Zero-based index of the item in the request
             */
            index: number;
            /** @description Operation status */
            status: components["schemas"]["BulkOperationStatus"];
        };
        /**
         * BulkOperationResponse
         * @description Base response for bulk operations with partial success support.
         *
         *     Uses HTTP 207 Multi-Status when some operations succeed and others fail.
         *
         *     Attributes:
         *         total: Total number of items in the request
         *         succeeded: Number of successful operations
         *         failed: Number of failed operations
         *         skipped: Number of skipped operations
         *         results: Per-item results with status and error details
         */
        BulkOperationResponse: {
            /**
             * Failed
             * @description Number of failed operations
             */
            failed: number;
            /**
             * Results
             * @description Per-item results
             */
            results?: components["schemas"]["BulkItemResult"][];
            /**
             * Skipped
             * @description Number of skipped operations
             * @default 0
             */
            skipped: number;
            /**
             * Succeeded
             * @description Number of successful operations
             */
            succeeded: number;
            /**
             * Total
             * @description Total number of items in the request
             */
            total: number;
        };
        /**
         * BulkOperationStatus
         * @description Status of individual items in a bulk operation.
         * @enum {string}
         */
        BulkOperationStatus: "success" | "failed" | "skipped";
        /**
         * BulletPointSchema
         * @description Schema for a single bullet point in a structured summary.
         *
         *     Represents a visual bullet point for display in the dashboard UI,
         *     with an icon, text content, and optional severity level.
         * @example {
         *       "icon": "camera",
         *       "severity": "high",
         *       "text": "Activity at Beach Front Left: person detected"
         *     }
         */
        BulletPointSchema: {
            /**
             * Icon
             * @description Icon identifier (e.g., 'camera', 'alert-triangle')
             */
            icon: string;
            /**
             * Severity
             * @description Severity level ('low', 'medium', 'high', 'critical')
             */
            severity?: string | null;
            /**
             * Text
             * @description Text content of the bullet point
             */
            text: string;
        };
        /**
         * CalibrationDefaultsResponse
         * @description Schema for calibration defaults response.
         *
         *     Returns the system default threshold values.
         * @example {
         *       "decay_factor": 0.1,
         *       "high_threshold": 85,
         *       "low_threshold": 30,
         *       "medium_threshold": 60
         *     }
         */
        CalibrationDefaultsResponse: {
            /**
             * Decay Factor
             * @description Default decay factor value
             * @default 0.1
             */
            decay_factor: number;
            /**
             * High Threshold
             * @description Default high threshold value
             * @default 85
             */
            high_threshold: number;
            /**
             * Low Threshold
             * @description Default low threshold value
             * @default 30
             */
            low_threshold: number;
            /**
             * Medium Threshold
             * @description Default medium threshold value
             * @default 60
             */
            medium_threshold: number;
        };
        /**
         * CalibrationResetResponse
         * @description Schema for calibration reset response.
         *
         *     Returned after resetting calibration to default values.
         * @example {
         *       "calibration": {
         *         "created_at": "2025-01-01T12:00:00Z",
         *         "decay_factor": 0.1,
         *         "false_positive_count": 5,
         *         "high_threshold": 85,
         *         "id": 1,
         *         "low_threshold": 30,
         *         "medium_threshold": 60,
         *         "missed_threat_count": 3,
         *         "updated_at": "2025-01-01T12:00:00Z",
         *         "user_id": "default"
         *       },
         *       "message": "Calibration reset to default values"
         *     }
         */
        CalibrationResetResponse: {
            /** @description Reset calibration data */
            calibration: components["schemas"]["UserCalibrationResponse"];
            /**
             * Message
             * @description Success message
             */
            message: string;
        };
        /**
         * CameraCreate
         * @description Schema for creating a new camera.
         *
         *     NEM-2569: Enhanced with explicit Pydantic validators for:
         *     - Name: Control character rejection, whitespace stripping, empty validation
         *     - Folder path: Path traversal prevention, forbidden character rejection
         * @example {
         *       "folder_path": "/export/foscam/front_door",
         *       "name": "Front Door Camera",
         *       "status": "online"
         *     }
         */
        CameraCreate: {
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path: string;
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * @description Camera status (online, offline, error, unknown)
             * @default online
             */
            status: components["schemas"]["CameraStatus"];
        };
        /**
         * CameraLinkRequest
         * @description Schema for linking a camera to an area.
         *
         *     Used to establish the many-to-many relationship between areas and cameras.
         *     A camera can be linked to multiple areas, and an area can have multiple cameras.
         * @example {
         *       "camera_id": "front_door"
         *     }
         */
        CameraLinkRequest: {
            /**
             * Camera Id
             * @description ID of the camera to link to this area
             */
            camera_id: string;
        };
        /**
         * CameraLinkResponse
         * @description Schema for camera link/unlink response.
         * @example {
         *       "area_id": 1,
         *       "camera_id": "front_door",
         *       "linked": true
         *     }
         */
        CameraLinkResponse: {
            /**
             * Area Id
             * @description ID of the area
             */
            area_id: number;
            /**
             * Camera Id
             * @description ID of the camera
             */
            camera_id: string;
            /**
             * Linked
             * @description Whether the camera is now linked (True) or unlinked (False)
             */
            linked: boolean;
        };
        /**
         * CameraListResponse
         * @description Schema for camera list response.
         *
         *     NEM-2075: Standardized pagination envelope with items + pagination structure.
         * @example {
         *       "items": [
         *         {
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "folder_path": "/export/foscam/front_door",
         *           "id": "front_door",
         *           "last_seen_at": "2025-12-23T12:00:00Z",
         *           "name": "Front Door Camera",
         *           "status": "online"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        CameraListResponse: {
            /**
             * Items
             * @description List of cameras
             */
            items: components["schemas"]["CameraResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * CameraNotificationSettingResponse
         * @description Schema for camera notification setting response.
         * @example {
         *       "camera_id": "front_door",
         *       "enabled": true,
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "risk_threshold": 50
         *     }
         */
        CameraNotificationSettingResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Enabled
             * @description Whether notifications are enabled for this camera
             */
            enabled: boolean;
            /**
             * Id
             * @description Setting UUID
             */
            id: string;
            /**
             * Risk Threshold
             * @description Minimum risk score to trigger notifications (0-100)
             */
            risk_threshold: number;
        };
        /**
         * CameraNotificationSettingUpdate
         * @description Schema for updating camera notification setting.
         * @example {
         *       "enabled": false,
         *       "risk_threshold": 70
         *     }
         */
        CameraNotificationSettingUpdate: {
            /**
             * Enabled
             * @description Whether notifications are enabled for this camera
             */
            enabled?: boolean | null;
            /**
             * Risk Threshold
             * @description Minimum risk score to trigger notifications (0-100)
             */
            risk_threshold?: number | null;
        };
        /**
         * CameraNotificationSettingsListResponse
         * @description Schema for camera notification settings list response with pagination.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "enabled": true,
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "risk_threshold": 50
         *         },
         *         {
         *           "camera_id": "back_yard",
         *           "enabled": false,
         *           "id": "550e8400-e29b-41d4-a716-446655440001",
         *           "risk_threshold": 70
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 2
         *       }
         *     }
         */
        CameraNotificationSettingsListResponse: {
            /**
             * Items
             * @description List of camera notification settings
             */
            items: components["schemas"]["CameraNotificationSettingResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * CameraPathValidationResponse
         * @description Schema for camera path validation response.
         *
         *     NEM-2063: Response model for the /api/cameras/validation/paths endpoint.
         *     Validates all camera folder paths against the configured base path.
         * @example {
         *       "base_path": "/export/foscam",
         *       "invalid_cameras": [
         *         {
         *           "folder_path": "/export/foscam/garage",
         *           "id": "garage",
         *           "issues": [
         *             "directory does not exist"
         *           ],
         *           "name": "Garage Camera",
         *           "status": "offline"
         *         }
         *       ],
         *       "invalid_count": 2,
         *       "total_cameras": 6,
         *       "valid_cameras": [
         *         {
         *           "folder_path": "/export/foscam/front_door",
         *           "id": "front_door",
         *           "name": "Front Door Camera",
         *           "status": "online"
         *         }
         *       ],
         *       "valid_count": 4
         *     }
         */
        CameraPathValidationResponse: {
            /**
             * Base Path
             * @description Configured base path for camera folders
             */
            base_path: string;
            /**
             * Invalid Cameras
             * @description Cameras with validation issues
             */
            invalid_cameras: components["schemas"]["CameraValidationInfo"][];
            /**
             * Invalid Count
             * @description Number of cameras with invalid paths
             */
            invalid_count: number;
            /**
             * Total Cameras
             * @description Total number of cameras validated
             */
            total_cameras: number;
            /**
             * Valid Cameras
             * @description Cameras with valid paths
             */
            valid_cameras: components["schemas"]["CameraValidationInfo"][];
            /**
             * Valid Count
             * @description Number of cameras with valid paths
             */
            valid_count: number;
        };
        /**
         * CameraResponse
         * @description Schema for camera response.
         *
         *     NEM-3597: Added property_id and areas fields to expose camera relationships.
         * @example {
         *       "areas": [
         *         {
         *           "id": 1,
         *           "name": "Front Yard"
         *         }
         *       ],
         *       "created_at": "2025-12-23T10:00:00Z",
         *       "folder_path": "/export/foscam/front_door",
         *       "id": "front_door",
         *       "last_seen_at": "2025-12-23T12:00:00Z",
         *       "name": "Front Door Camera",
         *       "property_id": 1,
         *       "status": "online"
         *     }
         */
        CameraResponse: {
            /**
             * Areas
             * @description List of areas this camera is assigned to
             */
            areas?: components["schemas"]["AreaBasic"][] | null;
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when camera was created
             */
            created_at: string;
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path: string;
            /**
             * Id
             * @description Normalized camera ID derived from folder name (e.g., 'front_door')
             */
            id: string;
            /**
             * Last Seen At
             * @description Last time camera was active
             */
            last_seen_at?: string | null;
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * Property Id
             * @description ID of the property this camera belongs to
             */
            property_id?: number | null;
            /** @description Camera status (online, offline, error, unknown) */
            status: components["schemas"]["CameraStatus"];
        };
        /**
         * CameraStatus
         * @description Camera status values.
         *
         *     Indicates the operational state of a camera:
         *     - ONLINE: Camera is active and receiving images
         *     - OFFLINE: Camera is not currently active (e.g., disconnected)
         *     - ERROR: Camera is experiencing an error condition
         *     - UNKNOWN: Camera status cannot be determined
         * @enum {string}
         */
        CameraStatus: "online" | "offline" | "error" | "unknown";
        /**
         * CameraUpdate
         * @description Schema for updating an existing camera.
         *
         *     NEM-2569: Enhanced with explicit Pydantic validators for partial updates.
         *     All fields are optional; only provided fields are validated.
         * @example {
         *       "name": "Front Door Camera - Updated",
         *       "status": "offline"
         *     }
         */
        CameraUpdate: {
            /**
             * Folder Path
             * @description File system path for camera uploads
             */
            folder_path?: string | null;
            /**
             * Name
             * @description Camera name
             */
            name?: string | null;
            /** @description Camera status (online, offline, error, unknown) */
            status?: components["schemas"]["CameraStatus"] | null;
        };
        /**
         * CameraUptimeDataPoint
         * @description Schema for a single camera uptime data point.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "detection_count": 150,
         *       "uptime_percentage": 98.5
         *     }
         */
        CameraUptimeDataPoint: {
            /**
             * Camera Id
             * @description Normalized camera ID (e.g., 'front_door')
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera name
             */
            camera_name: string;
            /**
             * Detection Count
             * @description Total detections in date range
             */
            detection_count: number;
            /**
             * Uptime Percentage
             * @description Uptime percentage (0-100)
             */
            uptime_percentage: number;
        };
        /**
         * CameraUptimeResponse
         * @description Schema for camera uptime percentage per camera.
         * @example {
         *       "cameras": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_count": 150,
         *           "uptime_percentage": 98.5
         *         },
         *         {
         *           "camera_id": "back_door",
         *           "camera_name": "Back Door",
         *           "detection_count": 120,
         *           "uptime_percentage": 95.2
         *         }
         *       ],
         *       "end_date": "2025-01-07",
         *       "start_date": "2025-01-01"
         *     }
         */
        CameraUptimeResponse: {
            /**
             * Cameras
             * @description Uptime data per camera
             */
            cameras: components["schemas"]["CameraUptimeDataPoint"][];
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
        };
        /**
         * CameraValidationInfo
         * @description Schema for individual camera validation result.
         *
         *     NEM-2063: Response model for camera path validation details.
         * @example {
         *       "folder_path": "/export/foscam/front_door",
         *       "id": "front_door",
         *       "issues": [
         *         "directory does not exist"
         *       ],
         *       "name": "Front Door Camera",
         *       "resolved_path": "/export/foscam/front_door",
         *       "status": "online"
         *     }
         */
        CameraValidationInfo: {
            /**
             * Folder Path
             * @description Configured folder path
             */
            folder_path: string;
            /**
             * Id
             * @description Camera ID
             */
            id: string;
            /**
             * Issues
             * @description List of validation issues (only for invalid cameras)
             */
            issues?: string[] | null;
            /**
             * Name
             * @description Camera name
             */
            name: string;
            /**
             * Resolved Path
             * @description Resolved absolute path (included if path is outside base_path)
             */
            resolved_path?: string | null;
            /** @description Camera status */
            status: components["schemas"]["CameraStatus"];
        };
        /**
         * CameraZoneShape
         * @description Shape of the camera zone polygon.
         * @enum {string}
         */
        CameraZoneShape: "rectangle" | "polygon";
        /**
         * CameraZoneType
         * @description Type of camera zone for semantic categorization.
         * @enum {string}
         */
        CameraZoneType: "entry_point" | "driveway" | "sidewalk" | "yard" | "other";
        /**
         * CategorySummary
         * @description Summary of services in a category.
         *
         *     Provides a quick overview of service health within a category
         *     for dashboard displays.
         * @example {
         *       "healthy": 3,
         *       "total": 5,
         *       "unhealthy": 2
         *     }
         */
        CategorySummary: {
            /**
             * Healthy
             * @description Number of healthy (running) services
             */
            healthy: number;
            /**
             * Total
             * @description Total number of services in this category
             */
            total: number;
            /**
             * Unhealthy
             * @description Number of unhealthy/stopped/disabled services
             */
            unhealthy: number;
        };
        /**
         * CircuitBreakerConfigResponse
         * @description Configuration for a circuit breaker.
         */
        CircuitBreakerConfigResponse: {
            /**
             * Failure Threshold
             * @description Number of failures before opening circuit
             */
            failure_threshold: number;
            /**
             * Half Open Max Calls
             * @description Maximum calls allowed in half-open state
             */
            half_open_max_calls: number;
            /**
             * Recovery Timeout
             * @description Seconds to wait before transitioning to half-open
             */
            recovery_timeout: number;
            /**
             * Success Threshold
             * @description Successes needed in half-open to close circuit
             */
            success_threshold: number;
        };
        /**
         * CircuitBreakerResetResponse
         * @description Response for circuit breaker reset operation.
         */
        CircuitBreakerResetResponse: {
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
            /**
             * Name
             * @description Name of the circuit breaker that was reset
             */
            name: string;
            /** @description State after reset (should be closed) */
            new_state: components["schemas"]["CircuitBreakerStateEnum"];
            /** @description State before reset */
            previous_state: components["schemas"]["CircuitBreakerStateEnum"];
        };
        /**
         * CircuitBreakerStateEnum
         * @description Circuit breaker states.
         * @enum {string}
         */
        CircuitBreakerStateEnum: "closed" | "open" | "half_open" | "unavailable";
        /**
         * CircuitBreakerStatusResponse
         * @description Status of a single circuit breaker.
         * @example {
         *       "config": {
         *         "failure_threshold": 5,
         *         "half_open_max_calls": 3,
         *         "recovery_timeout": 30,
         *         "success_threshold": 2
         *       },
         *       "failure_count": 0,
         *       "name": "ai_service",
         *       "rejected_calls": 0,
         *       "state": "closed",
         *       "success_count": 0,
         *       "total_calls": 150
         *     }
         */
        CircuitBreakerStatusResponse: {
            /** @description Circuit breaker configuration */
            config: components["schemas"]["CircuitBreakerConfigResponse"];
            /**
             * Failure Count
             * @description Current consecutive failure count
             */
            failure_count: number;
            /**
             * Last Failure Time
             * @description Monotonic time of last failure (seconds)
             */
            last_failure_time?: number | null;
            /**
             * Name
             * @description Circuit breaker name
             */
            name: string;
            /**
             * Opened At
             * @description Monotonic time when circuit opened (seconds)
             */
            opened_at?: number | null;
            /**
             * Rejected Calls
             * @description Calls rejected due to open circuit
             */
            rejected_calls: number;
            /** @description Current circuit state: closed (normal), open (failing), half_open (testing) */
            state: components["schemas"]["CircuitBreakerStateEnum"];
            /**
             * Success Count
             * @description Current consecutive success count (relevant in half-open)
             */
            success_count: number;
            /**
             * Total Calls
             * @description Total calls attempted through this circuit
             */
            total_calls: number;
        };
        /**
         * CircuitBreakerSummary
         * @description Summary of all circuit breakers in the system.
         *
         *     Provides counts by state and individual breaker states for monitoring.
         * @example {
         *       "breakers": {
         *         "clip": "closed",
         *         "enrichment": "closed",
         *         "florence": "open",
         *         "nemotron": "closed",
         *         "yolo26": "closed"
         *       },
         *       "closed": 4,
         *       "half_open": 0,
         *       "open": 1,
         *       "total": 5
         *     }
         */
        CircuitBreakerSummary: {
            /**
             * Breakers
             * @description Individual circuit breaker states keyed by service name
             */
            breakers: {
                [key: string]: components["schemas"]["CircuitState"];
            };
            /**
             * Closed
             * @description Number of breakers in closed state
             */
            closed: number;
            /**
             * Half Open
             * @description Number of breakers in half-open state
             */
            half_open: number;
            /**
             * Open
             * @description Number of breakers in open state
             */
            open: number;
            /**
             * Total
             * @description Total number of circuit breakers
             */
            total: number;
        };
        /**
         * CircuitBreakersResponse
         * @description Response schema for circuit breakers status endpoint.
         * @example {
         *       "circuit_breakers": {
         *         "yolo26": {
         *           "config": {
         *             "failure_threshold": 5,
         *             "half_open_max_calls": 3,
         *             "recovery_timeout": 30,
         *             "success_threshold": 2
         *           },
         *           "failure_count": 0,
         *           "name": "yolo26",
         *           "rejected_calls": 0,
         *           "state": "closed",
         *           "success_count": 0,
         *           "total_calls": 100
         *         }
         *       },
         *       "open_count": 0,
         *       "timestamp": "2025-12-30T10:30:00Z",
         *       "total_count": 2
         *     }
         */
        CircuitBreakersResponse: {
            /**
             * Circuit Breakers
             * @description Status of all circuit breakers keyed by name
             */
            circuit_breakers: {
                [key: string]: components["schemas"]["CircuitBreakerStatusResponse"];
            };
            /**
             * Open Count
             * @description Number of circuit breakers currently open
             */
            open_count: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
            /**
             * Total Count
             * @description Total number of circuit breakers
             */
            total_count: number;
        };
        /**
         * CircuitState
         * @description Circuit breaker state for a service.
         *
         *     States:
         *     - closed: Normal operation, requests pass through
         *     - open: Service failing, requests fail immediately
         *     - half_open: Testing recovery, limited requests allowed
         * @enum {string}
         */
        CircuitState: "closed" | "open" | "half_open";
        /**
         * ClassBaselineEntry
         * @description Baseline entry for a specific object class at a specific hour.
         * @example {
         *       "frequency": 3.5,
         *       "hour": 17,
         *       "object_class": "person",
         *       "sample_count": 45
         *     }
         */
        ClassBaselineEntry: {
            /**
             * Frequency
             * @description Frequency of this class at this hour
             */
            frequency: number;
            /**
             * Hour
             * @description Hour of day (0-23)
             */
            hour: number;
            /**
             * Object Class
             * @description Object class (e.g., person, vehicle, animal)
             */
            object_class: string;
            /**
             * Sample Count
             * @description Number of samples for this class/hour combination
             */
            sample_count: number;
        };
        /**
         * ClassBaselineResponse
         * @description Response for camera class frequency baseline endpoint.
         * @example {
         *       "camera_id": "front_door",
         *       "entries": [
         *         {
         *           "frequency": 3.5,
         *           "hour": 17,
         *           "object_class": "person",
         *           "sample_count": 45
         *         },
         *         {
         *           "frequency": 2.1,
         *           "hour": 8,
         *           "object_class": "vehicle",
         *           "sample_count": 30
         *         }
         *       ],
         *       "most_common_class": "person",
         *       "total_samples": 150,
         *       "unique_classes": [
         *         "person",
         *         "vehicle",
         *         "animal"
         *       ]
         *     }
         */
        ClassBaselineResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Entries
             * @description Class baseline entries grouped by class and hour
             */
            entries?: components["schemas"]["ClassBaselineEntry"][];
            /**
             * Most Common Class
             * @description Most frequently detected object class
             */
            most_common_class?: string | null;
            /**
             * Total Samples
             * @description Total number of samples across all entries
             */
            total_samples: number;
            /**
             * Unique Classes
             * @description List of unique object classes detected for this camera
             */
            unique_classes?: string[];
        };
        /**
         * CleanupResponse
         * @description Response schema for data cleanup endpoint.
         *
         *     Returns statistics about the cleanup operation including counts of
         *     deleted records and files. When dry_run is True, the counts represent
         *     what would be deleted without actually deleting.
         * @example {
         *       "detections_deleted": 89,
         *       "dry_run": false,
         *       "events_deleted": 15,
         *       "gpu_stats_deleted": 2880,
         *       "images_deleted": 0,
         *       "logs_deleted": 150,
         *       "retention_days": 30,
         *       "space_reclaimed": 524288000,
         *       "thumbnails_deleted": 89,
         *       "timestamp": "2025-12-27T10:30:00Z"
         *     }
         */
        CleanupResponse: {
            /**
             * Detections Deleted
             * @description Number of detections deleted (or would be deleted in dry run)
             */
            detections_deleted: number;
            /**
             * Dry Run
             * @description Whether this was a dry run (no actual deletion performed)
             * @default false
             */
            dry_run: boolean;
            /**
             * Events Deleted
             * @description Number of events deleted (or would be deleted in dry run)
             */
            events_deleted: number;
            /**
             * Gpu Stats Deleted
             * @description Number of GPU stat records deleted (or would be deleted in dry run)
             */
            gpu_stats_deleted: number;
            /**
             * Images Deleted
             * @description Number of original image files deleted (or would be deleted in dry run)
             */
            images_deleted: number;
            /**
             * Logs Deleted
             * @description Number of log records deleted (or would be deleted in dry run)
             */
            logs_deleted: number;
            /**
             * Retention Days
             * @description Retention period used for cleanup
             */
            retention_days: number;
            /**
             * Space Reclaimed
             * @description Estimated disk space freed in bytes (or would be freed in dry run)
             */
            space_reclaimed: number;
            /**
             * Thumbnails Deleted
             * @description Number of thumbnail files deleted (or would be deleted in dry run)
             */
            thumbnails_deleted: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of cleanup operation
             */
            timestamp: string;
        };
        /**
         * CleanupStatusResponse
         * @description Response schema for cleanup service status endpoint.
         * @example {
         *       "cleanup_time": "03:00",
         *       "delete_images": false,
         *       "next_cleanup": "2025-12-31T03:00:00Z",
         *       "retention_days": 30,
         *       "running": true,
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        CleanupStatusResponse: {
            /**
             * Cleanup Time
             * @description Scheduled daily cleanup time in HH:MM format
             */
            cleanup_time: string;
            /**
             * Delete Images
             * @description Whether original images are deleted during cleanup
             */
            delete_images: boolean;
            /**
             * Next Cleanup
             * @description ISO timestamp of next scheduled cleanup (null if not running)
             */
            next_cleanup?: string | null;
            /**
             * Retention Days
             * @description Current retention period in days
             */
            retention_days: number;
            /**
             * Running
             * @description Whether the cleanup service is currently running
             */
            running: boolean;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * ClearCacheResponse
         * @description Response schema for cache clear endpoint.
         */
        ClearCacheResponse: {
            /** Cache Types */
            cache_types: string[];
            /** Duration Seconds */
            duration_seconds: number;
            /** Keys Cleared */
            keys_cleared: number;
            /** Message */
            message: string;
        };
        /**
         * ClearDataRequest
         * @description Request schema for clearing data - requires confirmation.
         */
        ClearDataRequest: {
            /**
             * Confirm
             * @description Must be exactly 'DELETE_ALL_DATA' to confirm deletion
             */
            confirm: string;
        };
        /**
         * ClearDataResponse
         * @description Response schema for clear data endpoint.
         */
        ClearDataResponse: {
            /** Cameras Cleared */
            cameras_cleared: number;
            /** Detections Cleared */
            detections_cleared: number;
            /** Events Cleared */
            events_cleared: number;
        };
        /**
         * ClipGenerateRequest
         * @description Schema for clip generation request (POST /api/events/{event_id}/clip/generate).
         *
         *     Offset validation (NEM-1355):
         *     - start_offset_seconds: -30 to 3600 seconds
         *     - end_offset_seconds: -30 to 3600 seconds
         *     - end_offset_seconds must be >= start_offset_seconds
         * @example {
         *       "end_offset_seconds": 30,
         *       "force": false,
         *       "start_offset_seconds": -15
         *     }
         */
        ClipGenerateRequest: {
            /**
             * End Offset Seconds
             * @description Seconds relative to event start to end clip (range: -30 to 3600, must be >= start_offset_seconds)
             * @default 30
             */
            end_offset_seconds: number;
            /**
             * Force
             * @description Force regeneration even if clip already exists
             * @default false
             */
            force: boolean;
            /**
             * Start Offset Seconds
             * @description Seconds relative to event start to begin clip (negative = before event, range: -30 to 3600)
             * @default -15
             */
            start_offset_seconds: number;
        };
        /**
         * ClipGenerateResponse
         * @description Schema for clip generation response.
         * @example {
         *       "clip_url": "/api/media/clips/123_clip.mp4",
         *       "event_id": 123,
         *       "generated_at": "2026-01-03T10:30:00Z",
         *       "message": "Clip generated successfully",
         *       "status": "completed"
         *     }
         */
        ClipGenerateResponse: {
            /**
             * Clip Url
             * @description URL to access the clip (if completed)
             */
            clip_url?: string | null;
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Generated At
             * @description Timestamp when the clip was generated
             */
            generated_at?: string | null;
            /**
             * Message
             * @description Status message or error details
             */
            message?: string | null;
            /** @description Status of clip generation */
            status: components["schemas"]["ClipStatus"];
        };
        /**
         * ClipInfoResponse
         * @description Schema for clip info response (GET /api/events/{event_id}/clip).
         * @example {
         *       "clip_available": true,
         *       "clip_url": "/api/media/clips/123_clip.mp4",
         *       "duration_seconds": 30,
         *       "event_id": 123,
         *       "file_size_bytes": 5242880,
         *       "generated_at": "2026-01-03T10:30:00Z"
         *     }
         */
        ClipInfoResponse: {
            /**
             * Clip Available
             * @description Whether a clip is available for this event
             */
            clip_available: boolean;
            /**
             * Clip Url
             * @description URL to access the clip (if available)
             */
            clip_url?: string | null;
            /**
             * Duration Seconds
             * @description Duration of the clip in seconds
             */
            duration_seconds?: number | null;
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * File Size Bytes
             * @description File size of the clip in bytes
             */
            file_size_bytes?: number | null;
            /**
             * Generated At
             * @description Timestamp when the clip was generated
             */
            generated_at?: string | null;
        };
        /**
         * ClipStatus
         * @description Status of clip generation.
         * @enum {string}
         */
        ClipStatus: "pending" | "completed" | "failed";
        /**
         * ClothingEnrichment
         * @description Clothing classification and segmentation results.
         * @example {
         *       "has_bag": true,
         *       "has_face_covered": false,
         *       "is_service_uniform": false,
         *       "is_suspicious": false,
         *       "lower": "blue jeans",
         *       "upper": "red t-shirt"
         *     }
         */
        ClothingEnrichment: {
            /**
             * Clothing Items
             * @description List of detected clothing items
             */
            clothing_items?: string[] | null;
            /**
             * Has Bag
             * @description Whether person is carrying a bag
             */
            has_bag?: boolean | null;
            /**
             * Has Face Covered
             * @description Whether face is covered (hat/sunglasses/mask)
             */
            has_face_covered?: boolean | null;
            /**
             * Is Service Uniform
             * @description Whether wearing service uniform
             */
            is_service_uniform?: boolean | null;
            /**
             * Is Suspicious
             * @description Whether clothing is flagged as suspicious
             */
            is_suspicious?: boolean | null;
            /**
             * Lower
             * @description Lower body clothing description
             */
            lower?: string | null;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
            /**
             * Upper
             * @description Upper body clothing description
             */
            upper?: string | null;
        };
        /**
         * ClusterEventSummary
         * @description Abbreviated event object for cluster response.
         * @example {
         *       "camera_id": "front_door",
         *       "id": 1,
         *       "risk_level": "high",
         *       "risk_score": 75,
         *       "started_at": "2026-01-25T10:00:00Z",
         *       "summary": "Person detected at front entrance"
         *     }
         */
        ClusterEventSummary: {
            /**
             * Camera Id
             * @description Camera ID that captured this event
             */
            camera_id: string;
            /**
             * Id
             * @description Event ID
             */
            id: number;
            /**
             * Risk Level
             * @description Risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score?: number | null;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Summary
             * @description Brief event summary
             */
            summary?: string | null;
        };
        /**
         * ClusterRiskLevels
         * @description Schema for aggregated risk levels within a cluster.
         * @example {
         *       "critical": 1,
         *       "high": 2,
         *       "low": 0,
         *       "medium": 2
         *     }
         */
        ClusterRiskLevels: {
            /**
             * Critical
             * @description Number of critical risk events in the cluster
             * @default 0
             */
            critical: number;
            /**
             * High
             * @description Number of high risk events in the cluster
             * @default 0
             */
            high: number;
            /**
             * Low
             * @description Number of low risk events in the cluster
             * @default 0
             */
            low: number;
            /**
             * Medium
             * @description Number of medium risk events in the cluster
             * @default 0
             */
            medium: number;
        };
        /**
         * ConfidenceFactors
         * @description Factors affecting confidence in the risk analysis.
         *
         *     These factors help explain the reliability of the risk assessment
         *     and can be used to understand when additional review may be needed.
         *
         *     Attributes:
         *         detection_quality: Quality of the detection data (good, fair, poor)
         *         weather_impact: Impact of weather on detection accuracy
         *         enrichment_coverage: Completeness of enrichment data used
         * @example {
         *       "detection_quality": "good",
         *       "enrichment_coverage": "full",
         *       "weather_impact": "none"
         *     }
         */
        ConfidenceFactors: {
            /**
             * Detection Quality
             * @description Quality of the detection data
             * @default good
             * @enum {string}
             */
            detection_quality: "good" | "fair" | "poor";
            /**
             * Enrichment Coverage
             * @description Completeness of enrichment data available
             * @default full
             * @enum {string}
             */
            enrichment_coverage: "full" | "partial" | "minimal";
            /**
             * Weather Impact
             * @description Impact of weather conditions on detection accuracy
             * @default none
             * @enum {string}
             */
            weather_impact: "none" | "minor" | "significant";
        };
        /**
         * ConfigResponse
         * @description Response schema for configuration endpoint.
         *
         *     Only includes public, non-sensitive configuration values.
         * @example {
         *       "app_name": "Home Security Intelligence",
         *       "batch_idle_timeout_seconds": 30,
         *       "batch_window_seconds": 90,
         *       "debug": false,
         *       "detection_confidence_threshold": 0.5,
         *       "fast_path_confidence_threshold": 0.9,
         *       "grafana_url": "/grafana",
         *       "log_retention_days": 7,
         *       "retention_days": 30,
         *       "version": "0.1.0"
         *     }
         */
        ConfigResponse: {
            /**
             * App Name
             * @description Application name
             */
            app_name: string;
            /**
             * Batch Idle Timeout Seconds
             * @description Idle timeout before processing incomplete batch
             */
            batch_idle_timeout_seconds: number;
            /**
             * Batch Window Seconds
             * @description Time window for batch processing detections
             */
            batch_window_seconds: number;
            /**
             * Debug
             * @description Whether debug mode is enabled (enables developer tools)
             */
            debug: boolean;
            /**
             * Detection Confidence Threshold
             * @deprecated
             * @description DEPRECATED: Use /api/v1/settings detection.confidence_threshold instead. Minimum confidence threshold for detections (0.0-1.0). This field will be removed in a future version.
             */
            detection_confidence_threshold: number;
            /**
             * Fast Path Confidence Threshold
             * @description Confidence threshold for fast-path high-priority analysis (0.0-1.0)
             */
            fast_path_confidence_threshold: number;
            /**
             * Grafana Url
             * @description Grafana dashboard URL for frontend link
             */
            grafana_url: string;
            /**
             * Log Retention Days
             * @description Number of days to retain logs (separate from event retention)
             */
            log_retention_days: number;
            /**
             * Retention Days
             * @description Number of days to retain events and detections
             */
            retention_days: number;
            /**
             * Version
             * @description Application version
             */
            version: string;
        };
        /**
         * ConfigUpdateRequest
         * @description Request schema for PATCH /api/system/config.
         *
         *     Only supports a subset of processing-related settings.
         */
        ConfigUpdateRequest: {
            /**
             * Batch Idle Timeout Seconds
             * @description Idle timeout before processing incomplete batch
             */
            batch_idle_timeout_seconds?: number | null;
            /**
             * Batch Window Seconds
             * @description Time window for batch processing detections
             */
            batch_window_seconds?: number | null;
            /**
             * Detection Confidence Threshold
             * @deprecated
             * @description DEPRECATED: Use /api/v1/settings detection.confidence_threshold instead. Minimum confidence threshold for detections (0.0-1.0). This field will be removed in a future version.
             */
            detection_confidence_threshold?: number | null;
            /**
             * Fast Path Confidence Threshold
             * @description Confidence threshold for fast-path high-priority analysis (0.0-1.0)
             */
            fast_path_confidence_threshold?: number | null;
            /**
             * Log Retention Days
             * @description Number of days to retain logs
             */
            log_retention_days?: number | null;
            /**
             * Retention Days
             * @description Number of days to retain events and detections
             */
            retention_days?: number | null;
        };
        /**
         * ContainerMetrics
         * @description Container health status.
         * @example {
         *       "health": "healthy",
         *       "name": "backend",
         *       "status": "running"
         *     }
         */
        ContainerMetrics: {
            /**
             * Health
             * @description Health status (healthy, unhealthy, starting)
             */
            health: string;
            /**
             * Name
             * @description Container name
             */
            name: string;
            /**
             * Status
             * @description Container status (running, stopped, restarting, etc.)
             */
            status: string;
        };
        /**
         * ContainerServiceStatus
         * @description Current status of a managed container service.
         *
         *     Status values:
         *     - RUNNING: Container is up and passing health checks
         *     - STARTING: Container is starting, not yet healthy
         *     - UNHEALTHY: Running but failing health checks
         *     - STOPPED: Container is not running
         *     - DISABLED: Exceeded failure limit, requires manual reset
         *     - NOT_FOUND: Container doesn't exist yet
         * @enum {string}
         */
        ContainerServiceStatus: "running" | "starting" | "unhealthy" | "stopped" | "disabled" | "not_found";
        /**
         * CurrentDeviation
         * @description Current activity deviation from established baseline.
         * @example {
         *       "contributing_factors": [
         *         "person_count_elevated",
         *         "unusual_hour"
         *       ],
         *       "interpretation": "slightly_above_normal",
         *       "score": 1.8
         *     }
         */
        CurrentDeviation: {
            /**
             * Contributing Factors
             * @description Factors contributing to current deviation
             */
            contributing_factors?: string[];
            /** @description Human-readable interpretation of the deviation */
            interpretation: components["schemas"]["DeviationInterpretation"];
            /**
             * Score
             * @description Deviation score (standard deviations from mean, can be negative)
             */
            score: number;
        };
        /**
         * CustomTestPromptRequest
         * @description Request to test a custom prompt against an existing event.
         *
         *     This is used for A/B testing in the Prompt Playground - testing a
         *     modified prompt without persisting results to the database.
         * @example {
         *       "custom_prompt": "You are a home security AI with enhanced context...",
         *       "event_id": 12345,
         *       "max_tokens": 2048,
         *       "model": "nemotron",
         *       "temperature": 0.7
         *     }
         */
        CustomTestPromptRequest: {
            /**
             * Custom Prompt
             * @description Custom prompt text to test
             */
            custom_prompt: string;
            /**
             * Event Id
             * @description Event ID to test the prompt against
             */
            event_id: number;
            /**
             * Max Tokens
             * @description Maximum tokens for LLM response (100-8192)
             * @default 2048
             */
            max_tokens: number;
            /**
             * Model
             * @description Model to use for testing (default: nemotron)
             * @default nemotron
             */
            model: string;
            /**
             * Temperature
             * @description Temperature for LLM generation (0-2)
             * @default 0.7
             */
            temperature: number;
        };
        /**
         * CustomTestPromptResponse
         * @description Response from testing a custom prompt against an event.
         *
         *     Results are NOT persisted - this is for A/B testing only.
         * @example {
         *       "entities": [
         *         {
         *           "confidence": 0.95,
         *           "type": "person"
         *         }
         *       ],
         *       "flags": [],
         *       "processing_time_ms": 1250,
         *       "reasoning": "The detected person matches the expected delivery pattern based on time and approach direction.",
         *       "recommended_action": "No action required",
         *       "risk_level": "low",
         *       "risk_score": 45,
         *       "summary": "Delivery person detected at front door during expected hours",
         *       "tokens_used": 512
         *     }
         */
        CustomTestPromptResponse: {
            /**
             * Entities
             * @description Entities detected in the analysis
             */
            entities?: {
                [key: string]: unknown;
            }[];
            /**
             * Flags
             * @description Any flags raised during analysis
             */
            flags?: string[];
            /**
             * Processing Time Ms
             * @description Processing time in milliseconds
             */
            processing_time_ms: number;
            /**
             * Reasoning
             * @description Detailed reasoning for the risk assessment
             */
            reasoning: string;
            /**
             * Recommended Action
             * @description Recommended action based on risk level
             */
            recommended_action: string;
            /**
             * Risk Level
             * @description Risk level: low, medium, high, or critical
             */
            risk_level: string;
            /**
             * Risk Score
             * @description Risk score from 0 (no risk) to 100 (critical)
             */
            risk_score: number;
            /**
             * Summary
             * @description Brief summary of the analysis
             */
            summary: string;
            /**
             * Tokens Used
             * @description Estimated tokens used for the analysis
             */
            tokens_used: number;
        };
        /**
         * DLQClearResponse
         * @description Response schema for clearing a DLQ.
         * @example {
         *       "message": "Cleared 5 jobs from dlq:detection_queue",
         *       "queue_name": "dlq:detection_queue",
         *       "success": true
         *     }
         */
        DLQClearResponse: {
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Queue Name
             * @description Name of the cleared queue
             */
            queue_name: string;
            /**
             * Success
             * @description Whether the clear operation succeeded
             */
            success: boolean;
        };
        /**
         * DLQJobResponse
         * @description Response schema for a single job in the dead-letter queue.
         *
         *     Includes enriched error context (NEM-1474) for faster debugging:
         *     - error_type: Exception class name for categorization
         *     - stack_trace: Truncated stack trace for debugging
         *     - http_status: HTTP status code (for network errors)
         *     - response_body: Truncated AI service response (for debugging)
         *     - retry_delays: Delays applied between retry attempts
         *     - context: System state snapshot at failure time
         * @example {
         *       "attempt_count": 3,
         *       "context": {
         *         "analysis_queue_depth": 25,
         *         "detection_queue_depth": 150,
         *         "dlq_circuit_breaker_state": "closed"
         *       },
         *       "error": "Connection refused: detector service unavailable",
         *       "error_type": "ConnectionRefusedError",
         *       "first_failed_at": "2025-12-23T10:30:05.000000",
         *       "last_failed_at": "2025-12-23T10:30:15.000000",
         *       "original_job": {
         *         "camera_id": "front_door",
         *         "file_path": "/export/foscam/front_door/image_001.jpg",
         *         "timestamp": "2025-12-23T10:30:00.000000"
         *       },
         *       "queue_name": "detection_queue",
         *       "retry_delays": [
         *         1,
         *         2
         *       ],
         *       "stack_trace": "Traceback (most recent call last):\n  ..."
         *     }
         */
        DLQJobResponse: {
            /**
             * Attempt Count
             * @description Number of processing attempts made
             */
            attempt_count: number;
            /**
             * Context
             * @description System state snapshot at failure time (queue depths, circuit breaker states)
             */
            context?: {
                [key: string]: unknown;
            } | null;
            /**
             * Error
             * @description Error message from the last failure attempt
             */
            error: string;
            /**
             * Error Type
             * @description Exception class name (e.g., 'ConnectionRefusedError')
             */
            error_type?: string | null;
            /**
             * First Failed At
             * @description ISO timestamp of the first failure
             */
            first_failed_at: string;
            /**
             * Http Status
             * @description HTTP status code if the error was from a network request
             */
            http_status?: number | null;
            /**
             * Last Failed At
             * @description ISO timestamp of the last failure
             */
            last_failed_at: string;
            /**
             * Original Job
             * @description Original job payload that failed
             */
            original_job: {
                [key: string]: unknown;
            };
            /**
             * Queue Name
             * @description Name of the original queue where the job came from
             */
            queue_name: string;
            /**
             * Response Body
             * @description Truncated response body (max 2KB) from AI service
             */
            response_body?: string | null;
            /**
             * Retry Delays
             * @description Delays (in seconds) applied between retry attempts
             */
            retry_delays?: number[] | null;
            /**
             * Stack Trace
             * @description Truncated stack trace (max 4KB) for debugging
             */
            stack_trace?: string | null;
        };
        /**
         * DLQJobsResponse
         * @description Response schema for listing jobs in a DLQ.
         *
         *     Uses standard pagination envelope format (NEM-2178):
         *     - items: List of DLQ jobs (renamed from 'jobs')
         *     - pagination: Standard pagination metadata
         *     - queue_name: Name of the dead-letter queue
         * @example {
         *       "items": [
         *         {
         *           "attempt_count": 3,
         *           "error": "Connection refused",
         *           "first_failed_at": "2025-12-23T10:30:05.000000",
         *           "last_failed_at": "2025-12-23T10:30:15.000000",
         *           "original_job": {
         *             "camera_id": "front_door",
         *             "file_path": "/export/foscam/front_door/image_001.jpg",
         *             "timestamp": "2025-12-23T10:30:00.000000"
         *           },
         *           "queue_name": "detection_queue"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 100,
         *         "offset": 0,
         *         "total": 1
         *       },
         *       "queue_name": "dlq:detection_queue"
         *     }
         */
        DLQJobsResponse: {
            /**
             * Items
             * @description List of jobs in the queue
             */
            items: components["schemas"]["DLQJobResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
            /**
             * Queue Name
             * @description Name of the dead-letter queue
             */
            queue_name: string;
        };
        /**
         * DLQName
         * @description Available dead-letter queue names.
         * @enum {string}
         */
        DLQName: "dlq:detection_queue" | "dlq:analysis_queue";
        /**
         * DLQRequeueResponse
         * @description Response schema for requeuing a job from DLQ.
         * @example {
         *       "job": {
         *         "camera_id": "front_door",
         *         "file_path": "/export/foscam/front_door/image_001.jpg",
         *         "timestamp": "2025-12-23T10:30:00.000000"
         *       },
         *       "message": "Job requeued from dlq:detection_queue to detection_queue",
         *       "success": true
         *     }
         */
        DLQRequeueResponse: {
            /**
             * Job
             * @description The requeued job data (if successful)
             */
            job?: {
                [key: string]: unknown;
            } | null;
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Success
             * @description Whether the requeue operation succeeded
             */
            success: boolean;
        };
        /**
         * DLQStatsResponse
         * @description Response schema for DLQ statistics.
         * @example {
         *       "analysis_queue_count": 1,
         *       "detection_queue_count": 2,
         *       "total_count": 3
         *     }
         */
        DLQStatsResponse: {
            /**
             * Analysis Queue Count
             * @description Number of jobs in the analysis DLQ
             */
            analysis_queue_count: number;
            /**
             * Detection Queue Count
             * @description Number of jobs in the detection DLQ
             */
            detection_queue_count: number;
            /**
             * Total Count
             * @description Total number of jobs across all DLQs
             */
            total_count: number;
        };
        /**
         * DailyAuditStats
         * @description Daily breakdown of audit statistics.
         *
         *     Provides a detailed view of audit activity for a single day,
         *     including quality metrics and model contribution counts.
         * @example {
         *       "avg_enrichment_utilization": 0.78,
         *       "avg_quality_score": 4.2,
         *       "count": 45,
         *       "date": "2026-01-01",
         *       "day_of_week": "Wednesday",
         *       "model_contributions": {
         *         "baseline": 25,
         *         "clip": 12,
         *         "clothing": 32,
         *         "cross_camera": 10,
         *         "florence": 38,
         *         "image_quality": 40,
         *         "pet": 3,
         *         "vehicle": 8,
         *         "violence": 5,
         *         "weather": 42,
         *         "yolo26": 45,
         *         "zones": 30
         *       }
         *     }
         */
        DailyAuditStats: {
            /**
             * Avg Enrichment Utilization
             * @description Average enrichment utilization for this day (0-1)
             */
            avg_enrichment_utilization?: number | null;
            /**
             * Avg Quality Score
             * @description Average quality score for this day (1-5 scale)
             */
            avg_quality_score?: number | null;
            /**
             * Count
             * @description Number of audits on this day
             */
            count: number;
            /**
             * Date
             * @description ISO date string (YYYY-MM-DD)
             */
            date: string;
            /**
             * Day Of Week
             * @description Day name (e.g., Monday, Tuesday)
             */
            day_of_week: string;
            /**
             * Model Contributions
             * @description Count of audits where each model contributed on this day
             */
            model_contributions?: {
                [key: string]: number;
            };
        };
        /**
         * DailyPattern
         * @description Activity pattern for a specific day of the week.
         * @example {
         *       "avg_detections": 45,
         *       "peak_hour": 17,
         *       "total_samples": 168
         *     }
         */
        DailyPattern: {
            /**
             * Avg Detections
             * @description Average number of detections for this day
             */
            avg_detections: number;
            /**
             * Peak Hour
             * @description Hour with most activity (0-23)
             */
            peak_hour: number;
            /**
             * Total Samples
             * @description Total samples for this day
             */
            total_samples: number;
        };
        /**
         * DatabaseMetrics
         * @description PostgreSQL database metrics.
         * @example {
         *       "cache_hit_ratio": 98.2,
         *       "connections_active": 5,
         *       "connections_max": 30,
         *       "status": "healthy",
         *       "transactions_per_min": 1200
         *     }
         */
        DatabaseMetrics: {
            /**
             * Cache Hit Ratio
             * @description Buffer cache hit ratio percentage
             */
            cache_hit_ratio: number;
            /**
             * Connections Active
             * @description Active connections
             */
            connections_active: number;
            /**
             * Connections Max
             * @description Maximum allowed connections
             */
            connections_max: number;
            /**
             * Status
             * @description Health status: healthy, unhealthy, unreachable
             */
            status: string;
            /**
             * Transactions Per Min
             * @description Transaction rate per minute
             */
            transactions_per_min: number;
        };
        /**
         * DebugCircuitBreakersResponse
         * @description Response for circuit breaker states.
         */
        DebugCircuitBreakersResponse: {
            /**
             * Circuit Breakers
             * @description All circuit breaker states keyed by name
             */
            circuit_breakers: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * DebugConfigResponse
         * @description Response for configuration inspection.
         */
        DebugConfigResponse: {
            /**
             * Config
             * @description Current configuration with sensitive values redacted
             */
            config: {
                [key: string]: unknown;
            };
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * DebugWebSocketBroadcasterStatus
         * @description Status of a WebSocket broadcaster.
         */
        DebugWebSocketBroadcasterStatus: {
            /**
             * Channel Name
             * @description Redis channel being listened to
             */
            channel_name?: string | null;
            /**
             * Circuit State
             * @description Circuit breaker state (CLOSED, OPEN, HALF_OPEN)
             */
            circuit_state: string;
            /**
             * Connection Count
             * @description Number of active connections
             */
            connection_count: number;
            /**
             * Is Degraded
             * @description Whether the broadcaster is in degraded mode
             */
            is_degraded: boolean;
            /**
             * Is Listening
             * @description Whether the broadcaster is listening for events
             */
            is_listening: boolean;
        };
        /**
         * DegradationModeEnum
         * @description System degradation modes.
         * @enum {string}
         */
        DegradationModeEnum: "normal" | "degraded" | "minimal" | "offline";
        /**
         * DegradationStatusResponse
         * @description Status information for the DegradationManager service.
         * @example {
         *       "available_features": [
         *         "detection",
         *         "analysis",
         *         "events",
         *         "media"
         *       ],
         *       "fallback_queues": {},
         *       "is_degraded": false,
         *       "memory_queue_size": 0,
         *       "mode": "normal",
         *       "redis_healthy": true,
         *       "services": [
         *         {
         *           "consecutive_failures": 0,
         *           "last_check": 1735500000,
         *           "name": "yolo26",
         *           "status": "healthy"
         *         }
         *       ]
         *     }
         */
        DegradationStatusResponse: {
            /**
             * Available Features
             * @description Features available in current degradation mode
             */
            available_features?: string[];
            /**
             * Fallback Queues
             * @description Count of items in disk-based fallback queues by name
             */
            fallback_queues?: {
                [key: string]: number;
            };
            /**
             * Is Degraded
             * @description Whether system is in any degraded state
             */
            is_degraded: boolean;
            /**
             * Memory Queue Size
             * @description Number of jobs in in-memory fallback queue
             */
            memory_queue_size: number;
            /** @description Current degradation mode */
            mode: components["schemas"]["DegradationModeEnum"];
            /**
             * Redis Healthy
             * @description Whether Redis is healthy
             */
            redis_healthy: boolean;
            /**
             * Services
             * @description Health status of registered services
             */
            services?: components["schemas"]["ServiceHealthStatusResponse"][];
        };
        /**
         * DeletedCamerasListResponse
         * @description Schema for listing soft-deleted cameras (trash view).
         *
         *     NEM-1955: Provides a trash view of soft-deleted cameras that can be restored.
         *     Cameras are ordered by deleted_at descending (most recently deleted first).
         *     NEM-2075: Standardized pagination envelope with items + pagination structure.
         * @example {
         *       "items": [
         *         {
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "folder_path": "/export/foscam/front_door",
         *           "id": "front_door",
         *           "last_seen_at": "2025-12-23T12:00:00Z",
         *           "name": "Front Door Camera",
         *           "status": "offline"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        DeletedCamerasListResponse: {
            /**
             * Items
             * @description List of soft-deleted cameras
             */
            items: components["schemas"]["CameraResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * DeletedEventsListResponse
         * @description Schema for listing soft-deleted events (trash view).
         *
         *     NEM-1955: Provides a trash view of soft-deleted events that can be restored.
         *     Events are ordered by deleted_at descending (most recently deleted first).
         *     NEM-2075: Standardized pagination envelope with items + pagination structure.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "reasoning": "Analysis details",
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Person detected near front entrance",
         *           "thumbnail_url": "/api/detections/1/image"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        DeletedEventsListResponse: {
            /**
             * Items
             * @description List of soft-deleted events
             */
            items: components["schemas"]["EventResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * DepthEnrichment
         * @description Depth estimation results (placeholder for future Depth Anything V2).
         * @example {
         *       "confidence": 0.78,
         *       "estimated_distance_m": 4.2
         *     }
         */
        DepthEnrichment: {
            /**
             * Confidence
             * @description Estimation confidence
             */
            confidence?: number | null;
            /**
             * Estimated Distance M
             * @description Estimated distance in meters
             */
            estimated_distance_m?: number | null;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
        };
        /**
         * DetectionBulkCreateItem
         * @description Schema for a single detection in a bulk create request.
         *
         *     Attributes:
         *         camera_id: Camera ID that captured this detection
         *         object_type: Type of detected object (person, vehicle, etc.)
         *         confidence: Detection confidence score (0.0-1.0)
         *         detected_at: Detection timestamp
         *         file_path: Path to the detection image
         *         bbox_x: Bounding box X coordinate
         *         bbox_y: Bounding box Y coordinate
         *         bbox_width: Bounding box width
         *         bbox_height: Bounding box height
         *         enrichment_data: Optional enrichment pipeline results
         */
        DetectionBulkCreateItem: {
            /**
             * Bbox Height
             * @description Bounding box height
             */
            bbox_height: number;
            /**
             * Bbox Width
             * @description Bounding box width
             */
            bbox_width: number;
            /**
             * Bbox X
             * @description Bounding box X coordinate
             */
            bbox_x: number;
            /**
             * Bbox Y
             * @description Bounding box Y coordinate
             */
            bbox_y: number;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Confidence
             * @description Confidence score (0.0-1.0)
             */
            confidence: number;
            /**
             * Detected At
             * Format: date-time
             * @description Detection timestamp
             */
            detected_at: string;
            /**
             * Enrichment Data
             * @description Enrichment pipeline results
             */
            enrichment_data?: {
                [key: string]: unknown;
            } | null;
            /**
             * File Path
             * @description Image file path
             */
            file_path: string;
            /**
             * Object Type
             * @description Object type (person, vehicle, etc.)
             */
            object_type: string;
        };
        /**
         * DetectionBulkCreateRequest
         * @description Request schema for bulk detection creation.
         *
         *     Attributes:
         *         detections: List of detections to create (max 100 per request)
         */
        DetectionBulkCreateRequest: {
            /**
             * Detections
             * @description Detections to create (max 100)
             */
            detections: components["schemas"]["DetectionBulkCreateItem"][];
        };
        /**
         * DetectionBulkCreateResponse
         * @description Response schema for bulk detection creation.
         *
         *     Extends BulkOperationResponse with created detection IDs.
         */
        DetectionBulkCreateResponse: {
            /**
             * Failed
             * @description Number of failed operations
             */
            failed: number;
            /**
             * Results
             * @description Per-item results
             */
            results?: components["schemas"]["BulkItemResult"][];
            /**
             * Skipped
             * @description Number of skipped operations
             * @default 0
             */
            skipped: number;
            /**
             * Succeeded
             * @description Number of successful operations
             */
            succeeded: number;
            /**
             * Total
             * @description Total number of items in the request
             */
            total: number;
        };
        /**
         * DetectionBulkDeleteRequest
         * @description Request schema for bulk detection deletion.
         *
         *     Note: Detection deletion is always hard delete as detections
         *     are raw data and soft-delete is not supported.
         *
         *     Attributes:
         *         detection_ids: List of detection IDs to delete (max 100 per request)
         */
        DetectionBulkDeleteRequest: {
            /**
             * Detection Ids
             * @description Detection IDs to delete (max 100)
             */
            detection_ids: number[];
        };
        /**
         * DetectionBulkUpdateItem
         * @description Schema for a single detection update in a bulk update request.
         *
         *     Attributes:
         *         id: Detection ID to update
         *         object_type: Updated object type
         *         confidence: Updated confidence score
         *         enrichment_data: Updated enrichment data
         */
        DetectionBulkUpdateItem: {
            /**
             * Confidence
             * @description Confidence score
             */
            confidence?: number | null;
            /**
             * Enrichment Data
             * @description Enrichment pipeline results
             */
            enrichment_data?: {
                [key: string]: unknown;
            } | null;
            /**
             * Id
             * @description Detection ID to update
             */
            id: number;
            /**
             * Object Type
             * @description Object type
             */
            object_type?: string | null;
        };
        /**
         * DetectionBulkUpdateRequest
         * @description Request schema for bulk detection updates.
         *
         *     Attributes:
         *         detections: List of detection updates (max 100 per request)
         */
        DetectionBulkUpdateRequest: {
            /**
             * Detections
             * @description Detection updates (max 100)
             */
            detections: components["schemas"]["DetectionBulkUpdateItem"][];
        };
        /**
         * DetectionLabelCount
         * @description Schema for a label with count.
         */
        DetectionLabelCount: {
            /** Count */
            count: number;
            /** Label */
            label: string;
        };
        /**
         * DetectionLabelsResponse
         * @description Schema for detection labels response.
         */
        DetectionLabelsResponse: {
            /** Labels */
            labels: components["schemas"]["DetectionLabelCount"][];
        };
        /**
         * DetectionListResponse
         * @description Schema for detection list response with standardized pagination envelope.
         *
         *     Uses the standard pagination envelope: {"items": [...], "pagination": {...}}
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         * @example {
         *       "items": [
         *         {
         *           "bbox_height": 400,
         *           "bbox_width": 200,
         *           "bbox_x": 100,
         *           "bbox_y": 150,
         *           "camera_id": "front_door",
         *           "confidence": 0.95,
         *           "detected_at": "2025-12-23T12:00:00Z",
         *           "file_path": "/export/foscam/front_door/20251223_120000.jpg",
         *           "file_type": "image/jpeg",
         *           "id": 1,
         *           "object_type": "person",
         *           "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=", // pragma: allowlist secret
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        DetectionListResponse: {
            /**
             * Deprecation Warning
             * @description Warning message when using deprecated offset pagination
             */
            deprecation_warning?: string | null;
            /**
             * Items
             * @description List of detections
             */
            items: components["schemas"]["DetectionResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * DetectionResponse
         * @description Schema for detection response.
         * @example {
         *       "bbox_height": 400,
         *       "bbox_width": 200,
         *       "bbox_x": 100,
         *       "bbox_y": 150,
         *       "camera_id": "front_door",
         *       "confidence": 0.95,
         *       "detected_at": "2025-12-23T12:00:00Z",
         *       "enrichment_data": {
         *         "errors": [],
         *         "person": {
         *           "action": "walking",
         *           "carrying": [
         *             "backpack"
         *           ],
         *           "clothing_description": "dark jacket",
         *           "is_suspicious": false
         *         },
         *         "vehicle": {
         *           "has_damage": false,
         *           "is_commercial": false,
         *           "vehicle_color": "blue",
         *           "vehicle_type": "sedan"
         *         },
         *         "weather": "sunny"
         *       },
         *       "file_path": "/export/foscam/front_door/20251223_120000.jpg",
         *       "file_type": "image/jpeg",
         *       "id": 1,
         *       "media_type": "image",
         *       "object_type": "person",
         *       "thumbnail_path": "/data/thumbnails/1_thumb.jpg"
         *     }
         */
        DetectionResponse: {
            /**
             * Association Created At
             * @description Timestamp when detection was associated with the event (NEM-3629). Only populated when fetching detections for an event with order_detections_by=created_at.
             */
            association_created_at?: string | null;
            /**
             * Bbox Height
             * @description Bounding box height
             */
            bbox_height?: number | null;
            /**
             * Bbox Width
             * @description Bounding box width
             */
            bbox_width?: number | null;
            /**
             * Bbox X
             * @description Bounding box X coordinate
             */
            bbox_x?: number | null;
            /**
             * Bbox Y
             * @description Bounding box Y coordinate
             */
            bbox_y?: number | null;
            /**
             * Camera Id
             * @description Normalized camera ID (e.g., 'front_door')
             */
            camera_id: string;
            /**
             * Confidence
             * @description Detection confidence score (0-1)
             */
            confidence?: number | null;
            /**
             * Detected At
             * Format: date-time
             * @description Timestamp when detection was made
             */
            detected_at: string;
            /**
             * Duration
             * @description Video duration in seconds (video only)
             */
            duration?: number | null;
            /**
             * Enrichment Data
             * @description AI enrichment data including vehicle classification, pet identification, person attributes, license plates, weather, and image quality scores
             */
            enrichment_data?: {
                [key: string]: unknown;
            } | null;
            /**
             * File Path
             * @description Path to source image or video file
             */
            file_path: string;
            /**
             * File Type
             * @description MIME type of source file
             */
            file_type?: string | null;
            /**
             * Id
             * @description Detection ID
             */
            id: number;
            /**
             * Media Type
             * @description Media type: 'image' or 'video'
             * @default image
             */
            media_type: string | null;
            /**
             * Object Type
             * @description Type of detected object (person, car, etc.)
             */
            object_type?: string | null;
            /**
             * Thumbnail Path
             * @description Path to thumbnail image with bbox overlay
             */
            thumbnail_path?: string | null;
            /**
             * Track Confidence
             * @description Confidence score for the track assignment (0-1)
             */
            track_confidence?: number | null;
            /**
             * Track Id
             * @description Unique track ID for tracking objects across frames
             */
            track_id?: number | null;
            /**
             * Video Codec
             * @description Video codec (e.g., h264, hevc)
             */
            video_codec?: string | null;
            /**
             * Video Height
             * @description Video resolution height
             */
            video_height?: number | null;
            /**
             * Video Width
             * @description Video resolution width
             */
            video_width?: number | null;
        };
        /**
         * DetectionSearchResponse
         * @description Schema for detection search response.
         */
        DetectionSearchResponse: {
            /** Limit */
            limit: number;
            /** Offset */
            offset: number;
            /**
             * Results
             * @description Search results
             */
            results: components["schemas"]["DetectionSearchResult"][];
            /**
             * Total Count
             * @description Total matching detections
             */
            total_count: number;
        };
        /**
         * DetectionSearchResult
         * @description Schema for a single detection search result.
         */
        DetectionSearchResult: {
            /** Bbox Height */
            bbox_height?: number | null;
            /** Bbox Width */
            bbox_width?: number | null;
            /** Bbox X */
            bbox_x?: number | null;
            /** Bbox Y */
            bbox_y?: number | null;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Confidence
             * @description Detection confidence score
             */
            confidence?: number | null;
            /**
             * Detected At
             * Format: date-time
             * @description Detection timestamp
             */
            detected_at: string;
            /** Enrichment Data */
            enrichment_data?: {
                [key: string]: unknown;
            } | null;
            /**
             * File Path
             * @description Path to source file
             */
            file_path: string;
            /**
             * Id
             * @description Detection ID
             */
            id: number;
            /**
             * Labels
             * @description Searchable labels
             */
            labels?: string[];
            /**
             * Object Type
             * @description Detected object type
             */
            object_type?: string | null;
            /**
             * Relevance Score
             * @description Search relevance score
             * @default 0
             */
            relevance_score: number;
            /**
             * Thumbnail Path
             * @description Path to thumbnail
             */
            thumbnail_path?: string | null;
            /**
             * Track Confidence
             * @description Confidence score for the track assignment (0-1)
             */
            track_confidence?: number | null;
            /**
             * Track Id
             * @description Unique track ID for tracking objects across frames
             */
            track_id?: number | null;
        };
        /**
         * DetectionSettings
         * @description Detection-related settings for object detection thresholds.
         *
         *     Controls the confidence thresholds used by YOLO26v2 for object detection
         *     and fast-path processing for high-priority alerts.
         * @example {
         *       "confidence_threshold": 0.5,
         *       "fast_path_threshold": 0.9
         *     }
         */
        DetectionSettings: {
            /**
             * Confidence Threshold
             * @description Minimum confidence threshold for object detections (0.0-1.0)
             */
            confidence_threshold: number;
            /**
             * Fast Path Threshold
             * @description Confidence threshold for fast-path high-priority analysis (0.0-1.0)
             */
            fast_path_threshold: number;
        };
        /**
         * DetectionSettingsUpdate
         * @description Detection settings update schema (all fields optional).
         *
         *     Used for PATCH /api/v1/settings to partially update detection settings.
         * @example {
         *       "confidence_threshold": 0.6
         *     }
         */
        DetectionSettingsUpdate: {
            /**
             * Confidence Threshold
             * @description Minimum confidence threshold for object detections (0.0-1.0)
             */
            confidence_threshold?: number | null;
            /**
             * Fast Path Threshold
             * @description Confidence threshold for fast-path high-priority analysis (0.0-1.0)
             */
            fast_path_threshold?: number | null;
        };
        /**
         * DetectionStatsResponse
         * @description Schema for detection statistics response.
         *
         *     Returns aggregate statistics about detections including counts by object class
         *     and detection trends over time. Used by the AI Performance page and Grafana
         *     Analytics dashboard.
         * @example {
         *       "average_confidence": 0.87,
         *       "detections_by_class": {
         *         "bicycle": 1,
         *         "car": 20,
         *         "person": 23,
         *         "truck": 6
         *       },
         *       "object_class_distribution": [
         *         {
         *           "count": 23,
         *           "object_class": "person"
         *         },
         *         {
         *           "count": 20,
         *           "object_class": "car"
         *         },
         *         {
         *           "count": 6,
         *           "object_class": "truck"
         *         },
         *         {
         *           "count": 1,
         *           "object_class": "bicycle"
         *         }
         *       ],
         *       "total_detections": 107,
         *       "trends": [
         *         {
         *           "detection_count": 10,
         *           "timestamp": "2026-01-16T00:00:00Z"
         *         },
         *         {
         *           "detection_count": 15,
         *           "timestamp": "2026-01-17T00:00:00Z"
         *         },
         *         {
         *           "detection_count": 12,
         *           "timestamp": "2026-01-18T00:00:00Z"
         *         },
         *         {
         *           "detection_count": 8,
         *           "timestamp": "2026-01-19T00:00:00Z"
         *         },
         *         {
         *           "detection_count": 20,
         *           "timestamp": "2026-01-20T00:00:00Z"
         *         },
         *         {
         *           "detection_count": 25,
         *           "timestamp": "2026-01-21T00:00:00Z"
         *         },
         *         {
         *           "detection_count": 50,
         *           "timestamp": "2026-01-22T00:00:00Z"
         *         }
         *       ]
         *     }
         */
        DetectionStatsResponse: {
            /**
             * Average Confidence
             * @description Average confidence score across all detections
             */
            average_confidence?: number | null;
            /**
             * Detections By Class
             * @description Detection counts grouped by object class (e.g., person, car, truck)
             */
            detections_by_class: {
                [key: string]: number;
            };
            /**
             * Object Class Distribution
             * @description Detections by class as array (for Grafana compatibility)
             */
            object_class_distribution?: components["schemas"]["ObjectClassDistributionItem"][];
            /**
             * Total Detections
             * @description Total number of detections
             */
            total_detections: number;
            /**
             * Trends
             * @description Detection counts by day for the last 7 days (for Grafana time series)
             */
            trends?: components["schemas"]["DetectionTrendItem"][];
        };
        /**
         * DetectionSummary
         * @description Summary of a detection linked to an entity.
         *
         *     Represents a single detection occurrence for an entity, used in
         *     the entity detections list endpoint.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "confidence": 0.95,
         *       "detection_id": 123,
         *       "object_type": "person",
         *       "thumbnail_url": "/api/detections/123/image",
         *       "timestamp": "2025-12-23T10:00:00Z"
         *     }
         */
        DetectionSummary: {
            /**
             * Camera Id
             * @description Camera ID where detection occurred
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name?: string | null;
            /**
             * Confidence
             * @description Detection confidence score
             */
            confidence?: number | null;
            /**
             * Detection Id
             * @description Detection database ID
             */
            detection_id: number;
            /**
             * Object Type
             * @description Detected object type
             */
            object_type?: string | null;
            /**
             * Thumbnail Url
             * @description URL to detection thumbnail
             */
            thumbnail_url?: string | null;
            /**
             * Timestamp
             * Format: date-time
             * @description When the detection occurred
             */
            timestamp: string;
        };
        /**
         * DetectionTrendDataPoint
         * @description Schema for a single detection trend data point.
         * @example {
         *       "count": 25,
         *       "date": "2025-01-07"
         *     }
         */
        DetectionTrendDataPoint: {
            /**
             * Count
             * @description Number of detections on this date
             */
            count: number;
            /**
             * Date
             * Format: date
             * @description Date of the data point
             */
            date: string;
        };
        /**
         * DetectionTrendItem
         * @description Schema for a single detection trend data point (for Grafana time series).
         *
         *     Used by the Grafana Analytics dashboard to display detection trends over time.
         *     The timestamp field is Unix epoch milliseconds for Grafana JSON datasource compatibility.
         * @example {
         *       "detection_count": 50,
         *       "timestamp": 1737504000000
         *     }
         */
        DetectionTrendItem: {
            /**
             * Detection Count
             * @description Number of detections on this date
             */
            detection_count: number;
            /**
             * Timestamp
             * @description Unix epoch milliseconds for the trend data point (start of day)
             */
            timestamp: number;
        };
        /**
         * DetectionTrendsResponse
         * @description Schema for detection trends aggregated by day.
         * @example {
         *       "data_points": [
         *         {
         *           "count": 20,
         *           "date": "2025-01-01"
         *         },
         *         {
         *           "count": 25,
         *           "date": "2025-01-02"
         *         },
         *         {
         *           "count": 18,
         *           "date": "2025-01-03"
         *         }
         *       ],
         *       "end_date": "2025-01-03",
         *       "start_date": "2025-01-01",
         *       "total_detections": 63
         *     }
         */
        DetectionTrendsResponse: {
            /**
             * Data Points
             * @description Detection counts aggregated by day
             */
            data_points: components["schemas"]["DetectionTrendDataPoint"][];
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
            /**
             * Total Detections
             * @description Total detections in date range
             */
            total_detections: number;
        };
        /**
         * DeviationInterpretation
         * @description Interpretation of current deviation from baseline.
         * @enum {string}
         */
        DeviationInterpretation: "far_below_normal" | "below_normal" | "normal" | "slightly_above_normal" | "above_normal" | "far_above_normal";
        /**
         * DwellHistoryResponse
         * @description Historical dwell time records for a zone.
         * @example {
         *       "end_time": "2026-01-26T13:00:00Z",
         *       "records": [
         *         {
         *           "camera_id": "front_door",
         *           "entry_time": "2026-01-26T12:00:00Z",
         *           "exit_time": "2026-01-26T12:05:30Z",
         *           "id": 1,
         *           "is_active": false,
         *           "object_class": "person",
         *           "total_seconds": 330,
         *           "track_id": 42,
         *           "triggered_alert": true,
         *           "zone_id": 1
         *         }
         *       ],
         *       "start_time": "2026-01-26T11:00:00Z",
         *       "total": 1,
         *       "zone_id": 1
         *     }
         */
        DwellHistoryResponse: {
            /**
             * End Time
             * Format: date-time
             * @description End of the query time window
             */
            end_time: string;
            /**
             * Records
             * @description Dwell time records in the time window
             */
            records: components["schemas"]["DwellTimeRecordResponse"][];
            /**
             * Start Time
             * Format: date-time
             * @description Start of the query time window
             */
            start_time: string;
            /**
             * Total
             * @description Total number of records
             */
            total: number;
            /**
             * Zone Id
             * @description ID of the polygon zone
             */
            zone_id: number;
        };
        /**
         * DwellStatisticsResponse
         * @description Statistics for dwell time in a zone.
         * @example {
         *       "alerts_triggered": 3,
         *       "avg_dwell_seconds": 120.5,
         *       "end_time": "2026-01-26T23:59:59Z",
         *       "max_dwell_seconds": 600,
         *       "min_dwell_seconds": 5,
         *       "start_time": "2026-01-26T00:00:00Z",
         *       "total_records": 50,
         *       "zone_id": 1
         *     }
         */
        DwellStatisticsResponse: {
            /**
             * Alerts Triggered
             * @description Number of loitering alerts triggered
             */
            alerts_triggered: number;
            /**
             * Avg Dwell Seconds
             * @description Average dwell time in seconds
             */
            avg_dwell_seconds: number;
            /**
             * End Time
             * Format: date-time
             * @description End of the statistics time window
             */
            end_time: string;
            /**
             * Max Dwell Seconds
             * @description Maximum dwell time in seconds
             */
            max_dwell_seconds: number;
            /**
             * Min Dwell Seconds
             * @description Minimum dwell time in seconds
             */
            min_dwell_seconds: number;
            /**
             * Start Time
             * Format: date-time
             * @description Start of the statistics time window
             */
            start_time: string;
            /**
             * Total Records
             * @description Total number of completed dwell records
             */
            total_records: number;
            /**
             * Zone Id
             * @description ID of the polygon zone
             */
            zone_id: number;
        };
        /**
         * DwellTimeRecordResponse
         * @description Response schema for a dwell time record.
         *
         *     Includes computed fields and database identifiers.
         * @example {
         *       "camera_id": "front_door",
         *       "entry_time": "2026-01-26T12:00:00Z",
         *       "exit_time": "2026-01-26T12:05:30Z",
         *       "id": 1,
         *       "is_active": false,
         *       "object_class": "person",
         *       "total_seconds": 330,
         *       "track_id": 42,
         *       "triggered_alert": true,
         *       "zone_id": 1
         *     }
         */
        DwellTimeRecordResponse: {
            /**
             * Camera Id
             * @description ID of the camera where detection occurred
             */
            camera_id: string;
            /**
             * Entry Time
             * Format: date-time
             * @description Timestamp when object entered the zone
             */
            entry_time: string;
            /**
             * Exit Time
             * @description Timestamp when object exited the zone (null if still present)
             */
            exit_time?: string | null;
            /**
             * Id
             * @description Unique dwell time record identifier
             */
            id: number;
            /**
             * Is Active
             * @description Whether the object is still in the zone (no exit time)
             * @default false
             */
            is_active: boolean;
            /**
             * Object Class
             * @description Classification of the object (e.g., person)
             */
            object_class: string;
            /**
             * Total Seconds
             * @description Total dwell time in seconds
             */
            total_seconds: number;
            /**
             * Track Id
             * @description Tracking ID of the detected object
             */
            track_id: number;
            /**
             * Triggered Alert
             * @description Whether this dwell time triggered a loitering alert
             */
            triggered_alert: boolean;
            /**
             * Zone Id
             * @description ID of the polygon zone
             */
            zone_id: number;
        };
        /**
         * EnrichmentModelInfo
         * @description Information about the AI model that produced an enrichment result (NEM-3535).
         *
         *     Exposes which model processed each enrichment, enabling model performance
         *     tracking and debugging.
         * @example {
         *       "inference_time_ms": 25.3,
         *       "model_name": "yolov11-face",
         *       "model_version": "1.0.0"
         *     }
         */
        EnrichmentModelInfo: {
            /**
             * Inference Time Ms
             * @description Time taken for model inference in milliseconds
             */
            inference_time_ms?: number | null;
            /**
             * Model Name
             * @description Name of the AI model that produced this enrichment
             */
            model_name: string;
            /**
             * Model Version
             * @description Version of the model (if available)
             */
            model_version?: string | null;
        };
        /**
         * EnrichmentResponse
         * @description Structured enrichment data for a single detection.
         *
         *     Contains results from all vision models run during the enrichment pipeline.
         * @example {
         *       "clothing": {
         *         "lower": "blue jeans",
         *         "upper": "red t-shirt"
         *       },
         *       "detection_id": 12345,
         *       "enriched_at": "2026-01-03T10:30:00Z",
         *       "errors": [],
         *       "face": {
         *         "confidence": 0.88,
         *         "count": 1,
         *         "detected": true
         *       },
         *       "image_quality": {
         *         "is_blurry": false,
         *         "score": 0.85
         *       },
         *       "license_plate": {
         *         "confidence": 0.92,
         *         "detected": true,
         *         "text": "ABC-1234"
         *       },
         *       "processing_time_ms": 125.5,
         *       "vehicle": {
         *         "color": "silver",
         *         "confidence": 0.91,
         *         "type": "sedan"
         *       },
         *       "violence": {
         *         "detected": false,
         *         "score": 0.12
         *       },
         *       "weather": {
         *         "condition": "clear",
         *         "confidence": 0.95
         *       }
         *     }
         */
        EnrichmentResponse: {
            /**
             * Clothing
             * @description Clothing analysis results
             */
            clothing?: components["schemas"]["ClothingEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Depth
             * @description Depth estimation results
             */
            depth?: components["schemas"]["DepthEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Detection Id
             * @description Detection ID
             */
            detection_id: number;
            /**
             * Enriched At
             * @description Timestamp when enrichment was performed
             */
            enriched_at?: string | null;
            /**
             * Errors
             * @description Errors encountered during enrichment
             */
            errors?: string[];
            /**
             * Face
             * @description Face detection results
             */
            face?: components["schemas"]["FaceEnrichment"] | {
                [key: string]: unknown;
            };
            /**
             * Image Quality
             * @description Image quality assessment
             */
            image_quality?: components["schemas"]["ImageQualityEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * License Plate
             * @description License plate detection results
             */
            license_plate?: components["schemas"]["LicensePlateEnrichment"] | {
                [key: string]: unknown;
            };
            /**
             * Pet
             * @description Pet classification results
             */
            pet?: components["schemas"]["PetEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Pose
             * @description Pose estimation results
             */
            pose?: components["schemas"]["PoseEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Processing Time Ms
             * @description Enrichment processing time in milliseconds
             */
            processing_time_ms?: number | null;
            /**
             * Vehicle
             * @description Vehicle classification results
             */
            vehicle?: components["schemas"]["VehicleEnrichment"] | {
                [key: string]: unknown;
            } | null;
            /**
             * Violence
             * @description Violence detection results
             */
            violence?: components["schemas"]["ViolenceEnrichment"] | {
                [key: string]: unknown;
            };
            /**
             * Weather
             * @description Weather classification results
             */
            weather?: components["schemas"]["WeatherEnrichment"] | {
                [key: string]: unknown;
            } | null;
        };
        /**
         * EnrichmentStatusEnum
         * @description Status of enrichment pipeline execution for an event.
         *
         *     Values:
         *         full: All enrichment models succeeded
         *         partial: Some models succeeded, some failed
         *         failed: All models failed (no enrichment data)
         *         skipped: Enrichment was not attempted
         * @enum {string}
         */
        EnrichmentStatusEnum: "full" | "partial" | "failed" | "skipped";
        /**
         * EnrichmentStatusResponse
         * @description Schema for enrichment status in event responses (NEM-1672).
         *
         *     Provides visibility into which enrichment models succeeded/failed
         *     for a given event, instead of silently degrading.
         * @example {
         *       "errors": {
         *         "clothing": "Model not loaded"
         *       },
         *       "failed_models": [
         *         "clothing"
         *       ],
         *       "status": "partial",
         *       "success_rate": 0.75,
         *       "successful_models": [
         *         "violence",
         *         "weather",
         *         "face"
         *       ]
         *     }
         */
        EnrichmentStatusResponse: {
            /**
             * Errors
             * @description Model name to error message mapping
             */
            errors?: {
                [key: string]: string;
            };
            /**
             * Failed Models
             * @description List of enrichment models that failed
             */
            failed_models?: string[];
            /** @description Overall enrichment status (full, partial, failed, skipped) */
            status: components["schemas"]["EnrichmentStatusEnum"];
            /**
             * Success Rate
             * @description Success rate (0.0 to 1.0)
             */
            success_rate: number;
            /**
             * Successful Models
             * @description List of enrichment models that succeeded
             */
            successful_models?: string[];
        };
        /**
         * EntityAppearance
         * @description Schema for a single entity appearance at a specific time and camera.
         *
         *     Represents one sighting of an entity, including the detection it came from
         *     and additional attributes extracted from the image.
         * @example {
         *       "attributes": {
         *         "carrying": "backpack",
         *         "clothing": "blue jacket"
         *       },
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "detection_id": "det_abc123",
         *       "similarity_score": 0.92,
         *       "thumbnail_url": "/api/detections/123/image",
         *       "timestamp": "2025-12-23T14:30:00Z"
         *     }
         */
        EntityAppearance: {
            /**
             * Attributes
             * @description Additional attributes extracted from the detection (clothing, carrying, etc.)
             */
            attributes?: {
                [key: string]: unknown;
            };
            /**
             * Camera Id
             * @description Camera ID where entity was seen
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name?: string | null;
            /**
             * Detection Id
             * @description Detection ID from original detection
             */
            detection_id: string;
            /**
             * Similarity Score
             * @description Similarity score to the entity's reference embedding
             */
            similarity_score?: number | null;
            /**
             * Thumbnail Url
             * @description URL to thumbnail image of this appearance
             */
            thumbnail_url?: string | null;
            /**
             * Timestamp
             * Format: date-time
             * @description When the entity was detected
             */
            timestamp: string;
        };
        /**
         * EntityDetail
         * @description Schema for detailed entity information including appearance history.
         *
         *     Extends EntitySummary with the full list of appearances.
         * @example {
         *       "appearance_count": 3,
         *       "appearances": [
         *         {
         *           "attributes": {
         *             "clothing": "blue jacket"
         *           },
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_id": "det_001",
         *           "similarity_score": 1,
         *           "thumbnail_url": "/api/detections/1/image",
         *           "timestamp": "2025-12-23T10:00:00Z"
         *         },
         *         {
         *           "attributes": {
         *             "carrying": "bag",
         *             "clothing": "blue jacket"
         *           },
         *           "camera_id": "backyard",
         *           "camera_name": "Backyard",
         *           "detection_id": "det_002",
         *           "similarity_score": 0.94,
         *           "thumbnail_url": "/api/detections/2/image",
         *           "timestamp": "2025-12-23T12:15:00Z"
         *         }
         *       ],
         *       "cameras_seen": [
         *         "front_door",
         *         "backyard"
         *       ],
         *       "entity_type": "person",
         *       "first_seen": "2025-12-23T10:00:00Z",
         *       "id": "entity_abc123",
         *       "last_seen": "2025-12-23T14:30:00Z",
         *       "thumbnail_url": "/api/detections/123/image"
         *     }
         */
        EntityDetail: {
            /**
             * Appearance Count
             * @description Total number of appearances
             */
            appearance_count: number;
            /**
             * Appearances
             * @description List of all appearances for this entity
             */
            appearances?: components["schemas"]["EntityAppearance"][];
            /**
             * Cameras Seen
             * @description List of camera IDs where entity was detected
             */
            cameras_seen?: string[];
            /**
             * Entity Type
             * @description Type of entity: 'person' or 'vehicle'
             */
            entity_type: string;
            /**
             * First Seen
             * Format: date-time
             * @description Timestamp of first appearance
             */
            first_seen: string;
            /**
             * Id
             * @description Unique entity identifier
             */
            id: string;
            /**
             * Last Seen
             * Format: date-time
             * @description Timestamp of most recent appearance
             */
            last_seen: string;
            /**
             * Thumbnail Url
             * @description URL to the most recent thumbnail image
             */
            thumbnail_url?: string | null;
            /**
             * Trust Status
             * @description Trust classification: 'trusted', 'untrusted', or 'unclassified'
             */
            trust_status?: string | null;
            /**
             * Trust Updated At
             * @description When the trust status was last updated
             */
            trust_updated_at?: string | null;
        };
        /**
         * EntityDetectionsResponse
         * @description Response for entity detections list endpoint.
         *
         *     Returns all detections linked to a specific entity with pagination.
         * @example {
         *       "detections": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "confidence": 0.95,
         *           "detection_id": 123,
         *           "object_type": "person",
         *           "thumbnail_url": "/api/detections/123/image",
         *           "timestamp": "2025-12-23T10:00:00Z"
         *         }
         *       ],
         *       "entity_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "entity_type": "person",
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 5
         *       }
         *     }
         */
        EntityDetectionsResponse: {
            /**
             * Detections
             * @description List of detections for this entity
             */
            detections?: components["schemas"]["DetectionSummary"][];
            /**
             * Entity Id
             * @description UUID of the entity
             */
            entity_id: string;
            /**
             * Entity Type
             * @description Type of entity
             */
            entity_type: string;
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationInfo"];
        };
        /**
         * EntityHistoryResponse
         * @description Schema for entity appearance history response.
         * @example {
         *       "appearances": [
         *         {
         *           "attributes": {},
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_id": "det_001",
         *           "similarity_score": 1,
         *           "thumbnail_url": "/api/detections/1/image",
         *           "timestamp": "2025-12-23T10:00:00Z"
         *         }
         *       ],
         *       "count": 1,
         *       "entity_id": "entity_abc123",
         *       "entity_type": "person"
         *     }
         */
        EntityHistoryResponse: {
            /**
             * Appearances
             * @description List of appearances in chronological order
             */
            appearances: components["schemas"]["EntityAppearance"][];
            /**
             * Count
             * @description Total number of appearances
             */
            count: number;
            /**
             * Entity Id
             * @description Entity identifier
             */
            entity_id: string;
            /**
             * Entity Type
             * @description Type of entity
             */
            entity_type: string;
        };
        /**
         * EntityListResponse
         * @description Schema for paginated entity list response (NEM-2075 pagination envelope).
         *
         *     Uses standardized pagination envelope with 'items' and 'pagination' fields.
         * @example {
         *       "items": [
         *         {
         *           "appearance_count": 5,
         *           "cameras_seen": [
         *             "front_door",
         *             "backyard"
         *           ],
         *           "entity_type": "person",
         *           "first_seen": "2025-12-23T10:00:00Z",
         *           "id": "entity_abc123",
         *           "last_seen": "2025-12-23T14:30:00Z",
         *           "thumbnail_url": "/api/detections/123/image"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        EntityListResponse: {
            /**
             * Items
             * @description List of tracked entities
             */
            items: components["schemas"]["EntitySummary"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationInfo"];
        };
        /**
         * EntityMatchItem
         * @description Schema for a single entity match result.
         *
         *     Represents a matching entity found through re-identification,
         *     including similarity score and time gap.
         * @example {
         *       "attributes": {
         *         "clothing": "blue jacket"
         *       },
         *       "camera_id": "backyard",
         *       "camera_name": "Backyard",
         *       "entity_id": "det_abc123",
         *       "entity_type": "person",
         *       "similarity_score": 0.92,
         *       "thumbnail_url": "/api/detections/123/image",
         *       "time_gap_seconds": 3600,
         *       "timestamp": "2025-12-23T10:00:00Z"
         *     }
         */
        EntityMatchItem: {
            /**
             * Attributes
             * @description Additional attributes extracted from the detection
             */
            attributes?: {
                [key: string]: unknown;
            };
            /**
             * Camera Id
             * @description Camera ID where entity was seen
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Human-readable camera name
             */
            camera_name?: string | null;
            /**
             * Entity Id
             * @description Detection ID of the matched entity
             */
            entity_id: string;
            /**
             * Entity Type
             * @description Type of entity: 'person' or 'vehicle'
             */
            entity_type: string;
            /**
             * Similarity Score
             * @description Cosine similarity score (0-1)
             */
            similarity_score: number;
            /**
             * Thumbnail Url
             * @description URL to thumbnail image
             */
            thumbnail_url?: string | null;
            /**
             * Time Gap Seconds
             * @description Time gap in seconds between query and match
             */
            time_gap_seconds: number;
            /**
             * Timestamp
             * Format: date-time
             * @description When the entity was detected
             */
            timestamp: string;
        };
        /**
         * EntityMatchResponse
         * @description Schema for entity match query response.
         *
         *     Returns entities matching a specific detection's embedding,
         *     used for showing re-ID matches in the EventDetailModal.
         * @example {
         *       "entity_type": "person",
         *       "matches": [
         *         {
         *           "attributes": {
         *             "clothing": "blue jacket"
         *           },
         *           "camera_id": "backyard",
         *           "camera_name": "Backyard",
         *           "entity_id": "det_002",
         *           "entity_type": "person",
         *           "similarity_score": 0.92,
         *           "thumbnail_url": "/api/detections/2/image",
         *           "time_gap_seconds": 3600,
         *           "timestamp": "2025-12-23T09:00:00Z"
         *         }
         *       ],
         *       "query_detection_id": "det_001",
         *       "threshold": 0.85,
         *       "total_matches": 1
         *     }
         */
        EntityMatchResponse: {
            /**
             * Entity Type
             * @description Type of entity searched
             */
            entity_type: string;
            /**
             * Matches
             * @description List of matching entities sorted by similarity
             */
            matches?: components["schemas"]["EntityMatchItem"][];
            /**
             * Query Detection Id
             * @description Detection ID used for the query
             */
            query_detection_id: string;
            /**
             * Threshold
             * @description Similarity threshold used for matching
             */
            threshold: number;
            /**
             * Total Matches
             * @description Total number of matches found
             */
            total_matches: number;
        };
        /**
         * EntityStatsResponse
         * @description Response for entity statistics endpoint.
         *
         *     Returns aggregated statistics about tracked entities.
         * @example {
         *       "by_camera": {
         *         "backyard": 42,
         *         "driveway": 68,
         *         "front_door": 85,
         *         "garage": 12
         *       },
         *       "by_type": {
         *         "animal": 12,
         *         "other": 0,
         *         "package": 0,
         *         "person": 150,
         *         "vehicle": 45
         *       },
         *       "repeat_visitors": 89,
         *       "time_range": {
         *         "since": "2025-12-23T00:00:00Z",
         *         "until": "2025-12-23T23:59:59Z"
         *       },
         *       "total_appearances": 1523,
         *       "total_entities": 207
         *     }
         */
        EntityStatsResponse: {
            /**
             * By Camera
             * @description Entity counts grouped by camera
             */
            by_camera?: {
                [key: string]: number;
            };
            /**
             * By Type
             * @description Entity counts grouped by entity type
             */
            by_type?: {
                [key: string]: number;
            };
            /**
             * Repeat Visitors
             * @description Count of entities seen more than once
             */
            repeat_visitors: number;
            /**
             * Time Range
             * @description Time range for the statistics query
             */
            time_range?: {
                [key: string]: string | null;
            } | null;
            /**
             * Total Appearances
             * @description Sum of all detection counts across entities
             */
            total_appearances: number;
            /**
             * Total Entities
             * @description Count of unique entities
             */
            total_entities: number;
        };
        /**
         * EntitySummary
         * @description Schema for entity summary in list responses.
         *
         *     Provides an overview of a tracked entity without the full appearance history.
         * @example {
         *       "appearance_count": 5,
         *       "cameras_seen": [
         *         "front_door",
         *         "backyard",
         *         "driveway"
         *       ],
         *       "entity_type": "person",
         *       "first_seen": "2025-12-23T10:00:00Z",
         *       "id": "entity_abc123",
         *       "last_seen": "2025-12-23T14:30:00Z",
         *       "thumbnail_url": "/api/detections/123/image",
         *       "trust_status": "trusted",
         *       "trust_updated_at": "2025-12-23T14:30:00Z"
         *     }
         */
        EntitySummary: {
            /**
             * Appearance Count
             * @description Total number of appearances
             */
            appearance_count: number;
            /**
             * Cameras Seen
             * @description List of camera IDs where entity was detected
             */
            cameras_seen?: string[];
            /**
             * Entity Type
             * @description Type of entity: 'person' or 'vehicle'
             */
            entity_type: string;
            /**
             * First Seen
             * Format: date-time
             * @description Timestamp of first appearance
             */
            first_seen: string;
            /**
             * Id
             * @description Unique entity identifier
             */
            id: string;
            /**
             * Last Seen
             * Format: date-time
             * @description Timestamp of most recent appearance
             */
            last_seen: string;
            /**
             * Thumbnail Url
             * @description URL to the most recent thumbnail image
             */
            thumbnail_url?: string | null;
            /**
             * Trust Status
             * @description Trust classification: 'trusted', 'untrusted', or 'unclassified'
             */
            trust_status?: string | null;
            /**
             * Trust Updated At
             * @description When the trust status was last updated
             */
            trust_updated_at?: string | null;
        };
        /**
         * EntityTrustResponse
         * @description Schema for entity trust status response.
         *
         *     Response from PATCH /api/entities/{entity_id}/trust endpoint and list endpoints.
         * @example {
         *       "appearance_count": 5,
         *       "entity_type": "person",
         *       "first_seen": "2025-12-23T10:00:00Z",
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "last_seen": "2025-12-23T14:30:00Z",
         *       "thumbnail_url": "/api/detections/123/image",
         *       "trust_notes": "Regular mail carrier, verified by homeowner",
         *       "trust_status": "trusted",
         *       "trust_updated_at": "2025-12-23T14:30:00Z"
         *     }
         */
        EntityTrustResponse: {
            /**
             * Appearance Count
             * @description Total number of appearances
             */
            appearance_count?: number | null;
            /**
             * Entity Type
             * @description Type of entity: person, vehicle, etc.
             */
            entity_type: string;
            /**
             * First Seen
             * @description Timestamp of first appearance
             */
            first_seen?: string | null;
            /**
             * Id
             * @description Unique entity identifier (UUID)
             */
            id: string;
            /**
             * Last Seen
             * @description Timestamp of most recent appearance
             */
            last_seen?: string | null;
            /**
             * Thumbnail Url
             * @description URL to thumbnail image
             */
            thumbnail_url?: string | null;
            /**
             * Trust Notes
             * @description Notes about the trust classification
             */
            trust_notes?: string | null;
            /** @description Current trust classification status */
            trust_status: components["schemas"]["TrustStatus"];
            /**
             * Trust Updated At
             * @description When the trust status was last updated
             */
            trust_updated_at?: string | null;
        };
        /**
         * EntityTrustUpdate
         * @description Schema for updating an entity's trust status.
         *
         *     Request body for PATCH /api/entities/{entity_id}/trust endpoint.
         * @example {
         *       "notes": "Regular mail carrier, verified by homeowner",
         *       "trust_status": "trusted"
         *     }
         */
        EntityTrustUpdate: {
            /**
             * Notes
             * @description Optional notes explaining the trust classification decision
             */
            notes?: string | null;
            /** @description The trust classification to assign to the entity */
            trust_status: components["schemas"]["TrustStatus"];
        };
        /**
         * EntityTypeFilter
         * @description Entity types for API query filtering.
         *
         *     A subset of EntityTypeEnum used for filtering in API endpoints.
         *     Currently only person and vehicle are supported for re-identification.
         * @enum {string}
         */
        EntityTypeFilter: "person" | "vehicle";
        /**
         * EventAuditResponse
         * @description Full audit response for a single event.
         * @example {
         *       "audited_at": "2026-01-03T10:30:00Z",
         *       "consistency_diff": 3,
         *       "consistency_risk_score": 62,
         *       "contributions": {
         *         "baseline": false,
         *         "clip": false,
         *         "clothing": true,
         *         "cross_camera": false,
         *         "florence": true,
         *         "image_quality": true,
         *         "pet": false,
         *         "vehicle": false,
         *         "violence": false,
         *         "weather": true,
         *         "yolo26": true,
         *         "zones": true
         *       },
         *       "enrichment_utilization": 0.85,
         *       "event_id": 12345,
         *       "id": 456,
         *       "improvements": {
         *         "confusing_sections": [],
         *         "format_suggestions": [],
         *         "missing_context": [
         *           "Time since last motion event"
         *         ],
         *         "model_gaps": [],
         *         "unused_data": []
         *       },
         *       "is_fully_evaluated": true,
         *       "prompt_length": 2048,
         *       "prompt_token_estimate": 512,
         *       "scores": {
         *         "consistency": 4,
         *         "context_usage": 4.2,
         *         "overall": 4.1,
         *         "reasoning_coherence": 4.5,
         *         "risk_justification": 3.8
         *       },
         *       "self_eval_critique": "More historical context would improve analysis."
         *     }
         */
        EventAuditResponse: {
            /**
             * Audited At
             * Format: date-time
             */
            audited_at: string;
            /** Consistency Diff */
            consistency_diff?: number | null;
            /** Consistency Risk Score */
            consistency_risk_score?: number | null;
            contributions: components["schemas"]["ModelContributions"];
            /** Enrichment Utilization */
            enrichment_utilization: number;
            /** Event Id */
            event_id: number;
            /** Id */
            id: number;
            improvements: components["schemas"]["PromptImprovements"];
            /** Is Fully Evaluated */
            is_fully_evaluated: boolean;
            /** Prompt Length */
            prompt_length: number;
            /** Prompt Token Estimate */
            prompt_token_estimate: number;
            scores: components["schemas"]["QualityScores"];
            /** Self Eval Critique */
            self_eval_critique?: string | null;
        };
        /**
         * EventBulkCreateItem
         * @description Schema for a single event in a bulk create request.
         *
         *     Attributes:
         *         batch_id: Batch ID that generated this event (tracks detection grouping)
         *         camera_id: Camera ID that generated this event
         *         started_at: Event start timestamp
         *         ended_at: Optional event end timestamp
         *         risk_score: Risk score from 0-100
         *         risk_level: Risk level (low, medium, high, critical)
         *         summary: Brief event summary
         *         reasoning: Detailed reasoning from LLM analysis
         *         detection_ids: List of detection IDs associated with this event
         */
        EventBulkCreateItem: {
            /**
             * Batch Id
             * @description Batch ID that generated this event
             */
            batch_id: string;
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Detection Ids
             * @description Associated detection IDs
             */
            detection_ids?: number[];
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning
             */
            reasoning?: string | null;
            /**
             * Risk Level
             * @description Risk level
             */
            risk_level: string;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score: number;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Summary
             * @description Event summary
             */
            summary: string;
        };
        /**
         * EventBulkCreateRequest
         * @description Request schema for bulk event creation.
         *
         *     Attributes:
         *         events: List of events to create (max 100 per request)
         */
        EventBulkCreateRequest: {
            /**
             * Events
             * @description Events to create (max 100)
             */
            events: components["schemas"]["EventBulkCreateItem"][];
        };
        /**
         * EventBulkCreateResponse
         * @description Response schema for bulk event creation.
         *
         *     Extends BulkOperationResponse with created event IDs.
         */
        EventBulkCreateResponse: {
            /**
             * Failed
             * @description Number of failed operations
             */
            failed: number;
            /**
             * Results
             * @description Per-item results
             */
            results?: components["schemas"]["BulkItemResult"][];
            /**
             * Skipped
             * @description Number of skipped operations
             * @default 0
             */
            skipped: number;
            /**
             * Succeeded
             * @description Number of successful operations
             */
            succeeded: number;
            /**
             * Total
             * @description Total number of items in the request
             */
            total: number;
        };
        /**
         * EventBulkDeleteRequest
         * @description Request schema for bulk event deletion.
         *
         *     Attributes:
         *         event_ids: List of event IDs to delete (max 100 per request)
         *         soft_delete: If true, mark as deleted instead of removing
         */
        EventBulkDeleteRequest: {
            /**
             * Event Ids
             * @description Event IDs to delete (max 100)
             */
            event_ids: number[];
            /**
             * Soft Delete
             * @description Soft delete (default) vs hard delete
             * @default true
             */
            soft_delete: boolean;
        };
        /**
         * EventBulkUpdateItem
         * @description Schema for a single event update in a bulk update request.
         *
         *     Attributes:
         *         id: Event ID to update
         *         reviewed: Mark event as reviewed/dismissed
         *         notes: Optional notes for the event
         */
        EventBulkUpdateItem: {
            /**
             * Id
             * @description Event ID to update
             */
            id: number;
            /**
             * Notes
             * @description Notes
             */
            notes?: string | null;
            /**
             * Reviewed
             * @description Mark as reviewed
             */
            reviewed?: boolean | null;
        };
        /**
         * EventBulkUpdateRequest
         * @description Request schema for bulk event updates.
         *
         *     Attributes:
         *         events: List of event updates (max 100 per request)
         */
        EventBulkUpdateRequest: {
            /**
             * Events
             * @description Event updates (max 100)
             */
            events: components["schemas"]["EventBulkUpdateItem"][];
        };
        /**
         * EventCluster
         * @description Schema for an event cluster.
         * @example {
         *       "cameras": [
         *         "front_door",
         *         "back_door"
         *       ],
         *       "cluster_id": "123e4567-e89b-12d3-a456-426614174000",
         *       "end_time": "2026-01-25T10:05:00Z",
         *       "event_count": 5,
         *       "events": [
         *         {
         *           "camera_id": "front_door",
         *           "id": 1,
         *           "risk_level": "critical",
         *           "risk_score": 85,
         *           "started_at": "2026-01-25T10:00:00Z",
         *           "summary": "Unknown person at door"
         *         }
         *       ],
         *       "object_types": {
         *         "person": 3,
         *         "vehicle": 2
         *       },
         *       "risk_levels": {
         *         "critical": 1,
         *         "high": 2,
         *         "low": 0,
         *         "medium": 2
         *       },
         *       "start_time": "2026-01-25T10:00:00Z"
         *     }
         */
        EventCluster: {
            /**
             * Cameras
             * @description List of camera IDs with events in this cluster
             */
            cameras: string[];
            /**
             * Cluster Id
             * @description Unique identifier for the cluster
             */
            cluster_id?: string;
            /**
             * End Time
             * Format: date-time
             * @description End time of the last event in the cluster
             */
            end_time: string;
            /**
             * Event Count
             * @description Total number of events in the cluster
             */
            event_count: number;
            /**
             * Events
             * @description Abbreviated event objects in the cluster
             */
            events: components["schemas"]["ClusterEventSummary"][];
            /**
             * Object Types
             * @description Count of events by detected object type
             */
            object_types?: {
                [key: string]: number;
            };
            /** @description Count of events by risk level in the cluster */
            risk_levels: components["schemas"]["ClusterRiskLevels"];
            /**
             * Start Time
             * Format: date-time
             * @description Start time of the first event in the cluster
             */
            start_time: string;
        };
        /**
         * EventClustersResponse
         * @description Schema for event clusters API response.
         * @example {
         *       "clusters": [
         *         {
         *           "cameras": [
         *             "front_door",
         *             "back_door"
         *           ],
         *           "cluster_id": "123e4567-e89b-12d3-a456-426614174000",
         *           "end_time": "2026-01-25T10:05:00Z",
         *           "event_count": 5,
         *           "events": [],
         *           "object_types": {
         *             "person": 3,
         *             "vehicle": 2
         *           },
         *           "risk_levels": {
         *             "critical": 1,
         *             "high": 2,
         *             "low": 0,
         *             "medium": 2
         *           },
         *           "start_time": "2026-01-25T10:00:00Z"
         *         }
         *       ],
         *       "total_clusters": 10,
         *       "unclustered_events": 15
         *     }
         */
        EventClustersResponse: {
            /**
             * Clusters
             * @description List of event clusters matching the query
             */
            clusters: components["schemas"]["EventCluster"][];
            /**
             * Total Clusters
             * @description Total number of clusters found
             */
            total_clusters: number;
            /**
             * Unclustered Events
             * @description Number of events not belonging to any cluster
             */
            unclustered_events: number;
        };
        /**
         * EventEnrichmentsResponse
         * @description Enrichment data for all detections in an event with pagination support.
         * @example {
         *       "count": 2,
         *       "enrichments": [
         *         {
         *           "detection_id": 1,
         *           "enriched_at": "2026-01-03T10:30:00Z",
         *           "face": {
         *             "count": 0,
         *             "detected": false
         *           },
         *           "license_plate": {
         *             "detected": true,
         *             "text": "ABC-1234"
         *           },
         *           "violence": {
         *             "detected": false,
         *             "score": 0
         *           }
         *         },
         *         {
         *           "detection_id": 2,
         *           "enriched_at": "2026-01-03T10:30:05Z",
         *           "face": {
         *             "count": 1,
         *             "detected": true
         *           },
         *           "license_plate": {
         *             "detected": false
         *           },
         *           "violence": {
         *             "detected": false,
         *             "score": 0
         *           }
         *         }
         *       ],
         *       "event_id": 100,
         *       "has_more": false,
         *       "limit": 50,
         *       "offset": 0,
         *       "total": 10
         *     }
         */
        EventEnrichmentsResponse: {
            /**
             * Count
             * @description Number of enrichments in this response (page size)
             */
            count: number;
            /**
             * Enrichments
             * @description Enrichment data per detection
             */
            enrichments: components["schemas"]["EnrichmentResponse"][];
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Has More
             * @description Whether there are more results available
             */
            has_more: boolean;
            /**
             * Limit
             * @description Maximum number of results requested
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
            /**
             * Total
             * @description Total number of detections with enrichment data for this event
             */
            total: number;
        };
        /**
         * EventFeedbackCreate
         * @description Schema for creating event feedback.
         *
         *     Used when submitting user feedback about an event's classification.
         *     Enhanced with calibration fields for Nemotron prompt improvement (NEM-3330).
         * @example {
         *       "actual_identity": "Mike (neighbor)",
         *       "actual_threat_level": "no_threat",
         *       "event_id": 123,
         *       "feedback_type": "false_positive",
         *       "model_failures": [
         *         "reid_model"
         *       ],
         *       "notes": "This was my neighbor's car, not a threat.",
         *       "suggested_score": 10,
         *       "what_was_wrong": "Re-ID should have matched this person"
         *     }
         */
        EventFeedbackCreate: {
            /**
             * Actual Identity
             * @description Identity correction for household member learning (e.g., 'Mike (neighbor)')
             */
            actual_identity?: string | null;
            /** @description User's assessment of true threat level (no_threat, minor_concern, genuine_threat) */
            actual_threat_level?: components["schemas"]["ActualThreatLevel"] | null;
            /**
             * Event Id
             * @description ID of the event this feedback is for
             */
            event_id: number;
            /** @description Type of feedback (accurate, false_positive, missed_threat, severity_wrong) */
            feedback_type: components["schemas"]["FeedbackType"];
            /**
             * Model Failures
             * @description List of specific AI models that failed (e.g., ['florence_vqa', 'pose_model'])
             */
            model_failures?: string[] | null;
            /**
             * Notes
             * @description Optional notes explaining the feedback
             */
            notes?: string | null;
            /**
             * Suggested Score
             * @description What the user thinks the risk score should have been (0-100)
             */
            suggested_score?: number | null;
            /**
             * What Was Wrong
             * @description Detailed explanation of what the AI got wrong
             */
            what_was_wrong?: string | null;
        };
        /**
         * EventFeedbackResponse
         * @description Schema for event feedback response.
         *
         *     Returned when retrieving feedback for an event.
         *     Enhanced with calibration fields for Nemotron prompt improvement (NEM-3330).
         * @example {
         *       "actual_identity": "Mike (neighbor)",
         *       "actual_threat_level": "no_threat",
         *       "created_at": "2025-01-01T12:00:00Z",
         *       "event_id": 123,
         *       "feedback_type": "false_positive",
         *       "id": 1,
         *       "model_failures": [
         *         "reid_model"
         *       ],
         *       "notes": "This was my neighbor's car, not a threat.",
         *       "suggested_score": 10,
         *       "what_was_wrong": "Re-ID should have matched this person"
         *     }
         */
        EventFeedbackResponse: {
            /**
             * Actual Identity
             * @description Identity correction for household member learning
             */
            actual_identity?: string | null;
            /**
             * Actual Threat Level
             * @description User's assessment of true threat level
             */
            actual_threat_level?: components["schemas"]["ActualThreatLevel"] | string | null;
            /**
             * Created At
             * Format: date-time
             * @description When feedback was submitted
             */
            created_at: string;
            /**
             * Event Id
             * @description Event ID this feedback belongs to
             */
            event_id: number;
            /**
             * Feedback Type
             * @description Type of feedback provided
             */
            feedback_type: components["schemas"]["FeedbackType"] | string;
            /**
             * Id
             * @description Feedback record ID
             */
            id: number;
            /**
             * Model Failures
             * @description List of specific AI models that failed
             */
            model_failures?: string[] | null;
            /**
             * Notes
             * @description Optional notes from user
             */
            notes?: string | null;
            /**
             * Suggested Score
             * @description What user thinks score should have been (0-100)
             */
            suggested_score?: number | null;
            /**
             * What Was Wrong
             * @description Detailed explanation of what AI got wrong
             */
            what_was_wrong?: string | null;
        };
        /**
         * EventListResponse
         * @description Schema for event list response with pagination.
         *
         *     NEM-2075: Standardized pagination envelope with items + pagination structure.
         *     Supports both cursor-based pagination (recommended) and offset pagination (deprecated).
         *     Use cursor-based pagination for better performance with large datasets.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "reasoning": "Person approaching entrance during daytime",
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Person detected near front entrance",
         *           "thumbnail_url": "/api/detections/1/image"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "next_cursor": "eyJpZCI6IDEsICJjcmVhdGVkX2F0IjogIjIwMjUtMTItMjNUMTI6MDA6MDBaIn0=", // pragma: allowlist secret
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        EventListResponse: {
            /**
             * Deprecation Warning
             * @description Warning message when using deprecated offset pagination
             */
            deprecation_warning?: string | null;
            /**
             * Items
             * @description List of events
             */
            items: components["schemas"]["EventResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * EventRegistryResponse
         * @description Response containing the complete WebSocket event registry.
         * @example {
         *       "channels": [
         *         "detections",
         *         "events",
         *         "alerts",
         *         "cameras",
         *         "jobs",
         *         "system"
         *       ],
         *       "deprecated_count": 3,
         *       "event_types": [],
         *       "total_count": 25
         *     }
         */
        EventRegistryResponse: {
            /**
             * Channels
             * @description List of all available WebSocket channels
             */
            channels: string[];
            /**
             * Deprecated Count
             * @description Number of deprecated event types
             */
            deprecated_count: number;
            /**
             * Event Types
             * @description List of all available event types
             */
            event_types: components["schemas"]["EventTypeInfo"][];
            /**
             * Total Count
             * @description Total number of event types
             */
            total_count: number;
        };
        /**
         * EventResponse
         * @description Schema for event response.
         * @example {
         *       "camera_id": "front_door",
         *       "confidence_factors": {
         *         "detection_quality": "good",
         *         "enrichment_coverage": "full",
         *         "weather_impact": "none"
         *       },
         *       "detection_count": 5,
         *       "detection_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "ended_at": "2025-12-23T12:02:30Z",
         *       "enrichment_status": {
         *         "errors": {},
         *         "failed_models": [],
         *         "status": "full",
         *         "success_rate": 1,
         *         "successful_models": [
         *           "violence",
         *           "weather",
         *           "face",
         *           "clothing"
         *         ]
         *       },
         *       "entities": [
         *         {
         *           "description": "Individual in casual clothing",
         *           "threat_level": "low",
         *           "type": "person"
         *         }
         *       ],
         *       "flags": [],
         *       "id": 1,
         *       "llm_prompt": "<|im_start|>system\nYou are a home security risk analyzer...",
         *       "reasoning": "Person approaching entrance during daytime, no suspicious behavior",
         *       "reviewed": false,
         *       "risk_factors": [
         *         {
         *           "contribution": -10,
         *           "description": "Activity during normal hours",
         *           "factor_name": "daytime_activity"
         *         },
         *         {
         *           "contribution": 5,
         *           "description": "Activity at primary entrance",
         *           "factor_name": "front_entrance"
         *         }
         *       ],
         *       "risk_level": "medium",
         *       "risk_score": 75,
         *       "started_at": "2025-12-23T12:00:00Z",
         *       "summary": "Person detected near front entrance",
         *       "thumbnail_url": "/api/detections/1/image",
         *       "version": 1
         *     }
         */
        EventResponse: {
            /**
             * Camera Id
             * @description Normalized camera ID (e.g., 'front_door')
             */
            camera_id: string;
            /** @description Factors affecting confidence in the analysis */
            confidence_factors?: components["schemas"]["ConfidenceFactors"] | null;
            /**
             * Deleted At
             * @description Timestamp when the event was soft-deleted (null if not deleted)
             */
            deleted_at?: string | null;
            /**
             * Detection Count
             * @description Number of detections in this event
             * @default 0
             */
            detection_count: number;
            /**
             * Detection Ids
             * @description List of detection IDs associated with this event
             */
            detection_ids?: number[];
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /** @description Enrichment pipeline status (NEM-1672) - shows which models succeeded/failed */
            enrichment_status?: components["schemas"]["EnrichmentStatusResponse"] | null;
            /**
             * Entities
             * @description Entities identified in the analysis (people, vehicles, objects)
             */
            entities?: components["schemas"]["RiskEntity"][];
            /**
             * Flagged
             * @description Whether event is flagged for follow-up (NEM-3839)
             * @default false
             */
            flagged: boolean;
            /**
             * Flags
             * @description Risk flags raised during analysis
             */
            flags?: components["schemas"]["RiskFlag"][];
            /**
             * Id
             * @description Event ID
             */
            id: number;
            /**
             * Llm Prompt
             * @description Full prompt sent to Nemotron LLM (for debugging/improvement)
             */
            llm_prompt?: string | null;
            /**
             * Notes
             * @description User notes for the event
             */
            notes?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning for risk score
             */
            reasoning?: string | null;
            /**
             * Recommended Action
             * @description Suggested action based on the analysis
             */
            recommended_action?: string | null;
            /**
             * Reviewed
             * @description Whether event has been reviewed
             * @default false
             */
            reviewed: boolean;
            /**
             * Risk Factors
             * @description Individual factors contributing to the risk score (NEM-3603)
             */
            risk_factors?: components["schemas"]["RiskFactor"][] | null;
            /**
             * Risk Level
             * @description Risk level (low/medium/high/critical), computed from risk_score using severity thresholds
             */
            readonly risk_level: string | null;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score?: number | null;
            /**
             * Snooze Until
             * @description Timestamp until which alerts for this event are snoozed (NEM-2359)
             */
            snooze_until?: string | null;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Summary
             * @description LLM-generated event summary
             */
            summary?: string | null;
            /**
             * Thumbnail Url
             * @description URL to thumbnail image (first detection's media)
             */
            thumbnail_url?: string | null;
            /**
             * Version
             * @description Optimistic locking version (NEM-3625). Include in updates to prevent conflicts.
             * @default 1
             */
            version: number;
        };
        /**
         * EventStatsResponse
         * @description Schema for aggregated event statistics.
         * @example {
         *       "events_by_camera": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "event_count": 30
         *         },
         *         {
         *           "camera_id": "back_door",
         *           "camera_name": "Back Door",
         *           "event_count": 14
         *         }
         *       ],
         *       "events_by_risk_level": {
         *         "critical": 2,
         *         "high": 5,
         *         "low": 25,
         *         "medium": 12
         *       },
         *       "risk_distribution": [
         *         {
         *           "count": 2,
         *           "risk_level": "critical"
         *         },
         *         {
         *           "count": 5,
         *           "risk_level": "high"
         *         },
         *         {
         *           "count": 12,
         *           "risk_level": "medium"
         *         },
         *         {
         *           "count": 25,
         *           "risk_level": "low"
         *         }
         *       ],
         *       "total_events": 44
         *     }
         */
        EventStatsResponse: {
            /**
             * Events By Camera
             * @description Events grouped by camera
             */
            events_by_camera: components["schemas"]["EventsByCamera"][];
            /** @description Events grouped by risk level */
            events_by_risk_level: components["schemas"]["EventsByRiskLevel"];
            /**
             * Risk Distribution
             * @description Events by risk level as array (for Grafana compatibility)
             */
            risk_distribution?: components["schemas"]["RiskDistributionItem"][];
            /**
             * Total Events
             * @description Total number of events
             */
            total_events: number;
        };
        /**
         * EventTypeInfo
         * @description Information about a single WebSocket event type.
         * @example {
         *       "channel": "detections",
         *       "deprecated": false,
         *       "description": "New detection from AI pipeline",
         *       "example": {
         *         "confidence": 0.95,
         *         "detection_id": "123",
         *         "label": "person"
         *       },
         *       "payload_schema": {
         *         "confidence": {
         *           "type": "number"
         *         },
         *         "detection_id": {
         *           "format": "uuid",
         *           "type": "string"
         *         },
         *         "label": {
         *           "type": "string"
         *         }
         *       },
         *       "type": "detection.new"
         *     }
         */
        EventTypeInfo: {
            /**
             * Channel
             * @description WebSocket channel this event is broadcast on
             */
            channel?: string | null;
            /**
             * Deprecated
             * @description Whether this event type is deprecated
             * @default false
             */
            deprecated: boolean;
            /**
             * Description
             * @description Human-readable description
             */
            description: string;
            /**
             * Example
             * @description Example payload
             */
            example?: {
                [key: string]: unknown;
            } | null;
            /**
             * Payload Schema
             * @description JSON Schema for the event payload
             */
            payload_schema: {
                [key: string]: unknown;
            };
            /**
             * Replacement
             * @description Replacement event type if deprecated
             */
            replacement?: string | null;
            /**
             * Type
             * @description Event type identifier
             */
            type: string;
        };
        /**
         * EventUpdate
         * @description Schema for updating an event (PATCH).
         *
         *     Supports optimistic locking (NEM-3625): Include the `version` field from the
         *     event response to prevent concurrent modification conflicts. If the version
         *     doesn't match, the server returns HTTP 409 Conflict.
         * @example {
         *       "notes": "Verified - delivery person",
         *       "reviewed": true,
         *       "snooze_until": "2025-12-24T12:00:00Z",
         *       "version": 1
         *     }
         */
        EventUpdate: {
            /**
             * Flagged
             * @description Flag or unflag event for follow-up (NEM-3839)
             */
            flagged?: boolean | null;
            /**
             * Notes
             * @description User notes for the event
             */
            notes?: string | null;
            /**
             * Reviewed
             * @description Mark event as reviewed or not reviewed
             */
            reviewed?: boolean | null;
            /**
             * Snooze Until
             * @description Set or clear the alert snooze timestamp (NEM-2359)
             */
            snooze_until?: string | null;
            /**
             * Version
             * @description Optimistic locking version (NEM-3625). Include the version from the event response to detect concurrent modifications. If the version doesn't match, returns HTTP 409 Conflict.
             */
            version?: number | null;
        };
        /**
         * EventsByCamera
         * @description Schema for events count by camera.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "event_count": 15
         *     }
         */
        EventsByCamera: {
            /**
             * Camera Id
             * @description Normalized camera ID (e.g., 'front_door')
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera name
             */
            camera_name: string;
            /**
             * Event Count
             * @description Number of events for this camera
             */
            event_count: number;
        };
        /**
         * EventsByRiskLevel
         * @description Schema for events count by risk level.
         * @example {
         *       "critical": 2,
         *       "high": 5,
         *       "low": 25,
         *       "medium": 12
         *     }
         */
        EventsByRiskLevel: {
            /**
             * Critical
             * @description Number of critical risk events
             * @default 0
             */
            critical: number;
            /**
             * High
             * @description Number of high risk events
             * @default 0
             */
            high: number;
            /**
             * Low
             * @description Number of low risk events
             * @default 0
             */
            low: number;
            /**
             * Medium
             * @description Number of medium risk events
             * @default 0
             */
            medium: number;
        };
        /**
         * ExportDownloadResponse
         * @description Schema for export file download metadata.
         *
         *     Returned when checking if a file is ready for download.
         *     The actual file is served via a separate streaming endpoint.
         * @example {
         *       "content_type": "text/csv",
         *       "download_url": "/api/exports/550e8400-e29b-41d4-a716-446655440000/download",
         *       "filename": "events_export_20250112_143000.csv",
         *       "ready": true,
         *       "size_bytes": 125432
         *     }
         */
        ExportDownloadResponse: {
            /**
             * Content Type
             * @description MIME type of the file
             */
            content_type?: string | null;
            /**
             * Download Url
             * @description URL to download the file
             */
            download_url?: string | null;
            /**
             * Filename
             * @description Exported filename
             */
            filename?: string | null;
            /**
             * Ready
             * @description Whether the file is ready for download
             */
            ready: boolean;
            /**
             * Size Bytes
             * @description File size in bytes
             */
            size_bytes?: number | null;
        };
        /**
         * ExportFormat
         * @description Supported export formats.
         * @enum {string}
         */
        ExportFormat: "csv" | "json" | "zip";
        /**
         * ExportFormatEnum
         * @description Export file formats.
         * @enum {string}
         */
        ExportFormatEnum: "csv" | "json" | "zip" | "excel";
        /**
         * ExportJobCancelResponse
         * @description Schema for export job cancellation response.
         * @example {
         *       "cancelled": true,
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Export job cancelled by user",
         *       "status": "failed"
         *     }
         */
        ExportJobCancelResponse: {
            /**
             * Cancelled
             * @description Whether cancellation was successful
             */
            cancelled: boolean;
            /**
             * Job Id
             * @description Job ID that was cancelled
             */
            job_id: string;
            /**
             * Message
             * @description Cancellation status message
             */
            message: string;
            /** @description New job status after cancellation */
            status: components["schemas"]["ExportJobStatusEnum"];
        };
        /**
         * ExportJobCreate
         * @description Schema for creating an export job.
         *
         *     Create a new background export job with optional filtering parameters.
         *     The job will be processed asynchronously and can be monitored via
         *     the job status endpoint.
         * @example {
         *       "camera_id": "front_door",
         *       "columns": [
         *         "event_id",
         *         "camera_name",
         *         "risk_score",
         *         "summary"
         *       ],
         *       "compliance_metadata": {
         *         "reason": "Monthly audit report",
         *         "requestor": "admin@example.com"
         *       },
         *       "end_date": "2025-01-12T23:59:59Z",
         *       "export_format": "csv",
         *       "export_type": "events",
         *       "legal_hold": false,
         *       "retention_days": 30,
         *       "risk_level": "high",
         *       "start_date": "2025-01-01T00:00:00Z"
         *     }
         */
        ExportJobCreate: {
            /**
             * Camera Id
             * @description Filter by camera ID
             */
            camera_id?: string | null;
            /**
             * Columns
             * @description List of column field names to include in export. Available: event_id, camera_name, started_at, ended_at, risk_score, risk_level, summary, detection_count, reviewed, object_types, reasoning. If null, all columns are included.
             */
            columns?: string[] | null;
            /**
             * Compliance Metadata
             * @description Audit trail info (requestor, reason, authorization)
             */
            compliance_metadata?: {
                [key: string]: unknown;
            } | null;
            /**
             * End Date
             * @description Filter events ending before this date (ISO format)
             */
            end_date?: string | null;
            /**
             * @description Output file format (csv, json, zip, excel)
             * @default csv
             */
            export_format: components["schemas"]["ExportFormatEnum"];
            /**
             * @description Type of data to export (events, alerts, full_backup)
             * @default events
             */
            export_type: components["schemas"]["ExportTypeEnum"];
            /**
             * Legal Hold
             * @description Prevent automatic deletion of this export
             * @default false
             */
            legal_hold: boolean;
            /**
             * Retention Days
             * @description Days to retain export file (overrides system default)
             */
            retention_days?: number | null;
            /**
             * Reviewed
             * @description Filter by reviewed status (true=reviewed, false=unreviewed, null=all)
             */
            reviewed?: boolean | null;
            /**
             * Risk Level
             * @description Filter by risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Start Date
             * @description Filter events starting from this date (ISO format)
             */
            start_date?: string | null;
        };
        /**
         * ExportJobListResponse
         * @description Schema for export job list response with pagination.
         * @example {
         *       "items": [
         *         {
         *           "completed_at": "2025-01-12T14:35:00Z",
         *           "created_at": "2025-01-12T14:30:00Z",
         *           "export_format": "csv",
         *           "export_type": "events",
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "progress": {
         *             "current_step": "Complete",
         *             "processed_items": 1230,
         *             "progress_percent": 100,
         *             "total_items": 1230
         *           },
         *           "result": {
         *             "event_count": 1230,
         *             "format": "csv",
         *             "output_path": "/api/exports/download/events_export_20250112_143000.csv",
         *             "output_size_bytes": 125432
         *           },
         *           "started_at": "2025-01-12T14:30:01Z",
         *           "status": "completed"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        ExportJobListResponse: {
            /**
             * Items
             * @description List of export jobs
             */
            items: components["schemas"]["ExportJobResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * ExportJobProgress
         * @description Schema for export job progress information.
         *
         *     Detailed progress information for an export job, including
         *     timing, item counts, and current step.
         * @example {
         *       "current_step": "Processing events...",
         *       "estimated_completion": "2025-01-12T14:35:00Z",
         *       "processed_items": 245,
         *       "progress_percent": 20,
         *       "total_items": 1230
         *     }
         */
        ExportJobProgress: {
            /**
             * Current Step
             * @description Current processing step description
             */
            current_step?: string | null;
            /**
             * Estimated Completion
             * @description Estimated completion time (ISO format)
             */
            estimated_completion?: string | null;
            /**
             * Processed Items
             * @description Number of items processed so far
             * @default 0
             */
            processed_items: number;
            /**
             * Progress Percent
             * @description Progress percentage (0-100)
             * @default 0
             */
            progress_percent: number;
            /**
             * Total Items
             * @description Total items to process (null if unknown)
             */
            total_items?: number | null;
        };
        /**
         * ExportJobRequest
         * @description Request to start an export job.
         * @example {
         *       "end_date": "2024-01-15T23:59:59Z",
         *       "format": "csv",
         *       "risk_level": "high",
         *       "start_date": "2024-01-01T00:00:00Z"
         *     }
         */
        ExportJobRequest: {
            /**
             * Camera Id
             * @description Filter by camera ID
             */
            camera_id?: string | null;
            /**
             * End Date
             * @description Filter by end date (ISO format)
             */
            end_date?: string | null;
            /**
             * @description Export format
             * @default csv
             */
            format: components["schemas"]["ExportFormat"];
            /**
             * Reviewed
             * @description Filter by reviewed status
             */
            reviewed?: boolean | null;
            /**
             * Risk Level
             * @description Filter by risk level (low, medium, high, critical)
             */
            risk_level?: string | null;
            /**
             * Start Date
             * @description Filter by start date (ISO format)
             */
            start_date?: string | null;
        };
        /**
         * ExportJobResponse
         * @description Schema for export job status response.
         *
         *     Complete status information for an export job, including
         *     progress, timing, result, and any error information.
         * @example {
         *       "created_at": "2025-01-12T14:30:00Z",
         *       "export_format": "csv",
         *       "export_type": "events",
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "progress": {
         *         "current_step": "Processing events...",
         *         "estimated_completion": "2025-01-12T14:35:00Z",
         *         "processed_items": 245,
         *         "progress_percent": 20,
         *         "total_items": 1230
         *       },
         *       "started_at": "2025-01-12T14:30:01Z",
         *       "status": "running"
         *     }
         */
        ExportJobResponse: {
            /**
             * Completed At
             * @description Job completion timestamp
             */
            completed_at?: string | null;
            /**
             * Compliance Metadata
             * @description Audit trail info (requestor, reason, authorization)
             */
            compliance_metadata?: {
                [key: string]: unknown;
            } | null;
            /**
             * Created At
             * Format: date-time
             * @description Job creation timestamp
             */
            created_at: string;
            /**
             * Error Message
             * @description Error message (populated when failed)
             */
            error_message?: string | null;
            /**
             * Export Format
             * @description Export file format
             */
            export_format: string;
            /**
             * Export Type
             * @description Type of export
             */
            export_type: string;
            /**
             * Filter Params
             * @description JSON-serialized filter parameters used for this export
             */
            filter_params?: string | null;
            /**
             * Id
             * @description Unique export job identifier
             */
            id: string;
            /**
             * Legal Hold
             * @description Whether automatic deletion is prevented
             * @default false
             */
            legal_hold: boolean;
            /** @description Progress information */
            progress?: components["schemas"]["ExportJobProgress"];
            /** @description Export result (populated when completed) */
            result?: components["schemas"]["ExportJobResult"] | null;
            /**
             * Retention Days
             * @description Days to retain export file
             */
            retention_days?: number | null;
            /**
             * Started At
             * @description Job start timestamp
             */
            started_at?: string | null;
            /** @description Current job status */
            status: components["schemas"]["ExportJobStatusEnum"];
        };
        /**
         * ExportJobResult
         * @description Schema for completed export job result.
         *
         *     Information about the completed export, including download path
         *     and file statistics.
         * @example {
         *       "event_count": 1230,
         *       "format": "csv",
         *       "output_path": "/api/exports/download/events_export_20250112_143000.csv",
         *       "output_size_bytes": 125432
         *     }
         */
        ExportJobResult: {
            /**
             * Event Count
             * @description Number of records exported
             * @default 0
             */
            event_count: number;
            /**
             * Format
             * @description Export format used
             */
            format: string;
            /**
             * Output Path
             * @description Download path for the exported file
             */
            output_path?: string | null;
            /**
             * Output Size Bytes
             * @description File size in bytes
             */
            output_size_bytes?: number | null;
        };
        /**
         * ExportJobStartResponse
         * @description Response when creating an export job.
         *
         *     Returns the job ID that can be used to track progress via
         *     GET /api/exports/{job_id}.
         * @example {
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Export job created. Use GET /api/exports/{job_id} to track progress.",
         *       "status": "pending"
         *     }
         */
        ExportJobStartResponse: {
            /**
             * Job Id
             * @description Unique job identifier for tracking progress
             */
            job_id: string;
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * @description Initial job status (always pending)
             * @default pending
             */
            status: components["schemas"]["ExportJobStatusEnum"];
        };
        /**
         * ExportJobStatusEnum
         * @description Export job status values.
         * @enum {string}
         */
        ExportJobStatusEnum: "pending" | "running" | "completed" | "failed";
        /**
         * ExportTypeEnum
         * @description Types of exports available.
         * @enum {string}
         */
        ExportTypeEnum: "events" | "alerts" | "full_backup";
        /**
         * ExporterStatus
         * @description Status information for a single Prometheus exporter.
         *
         *     Represents the health status of an exporter that provides metrics
         *     to Prometheus (e.g., redis-exporter, json-exporter, blackbox-exporter).
         * @example {
         *       "endpoint": "http://redis-exporter:9121",
         *       "last_scrape": "2026-01-13T10:30:00Z",
         *       "name": "redis-exporter",
         *       "status": "up"
         *     }
         */
        ExporterStatus: {
            /**
             * Endpoint
             * @description Scrape endpoint URL for this exporter
             */
            endpoint?: string | null;
            /**
             * Error
             * @description Error message if exporter is down
             */
            error?: string | null;
            /**
             * Last Scrape
             * @description Timestamp of last successful scrape (if available)
             */
            last_scrape?: string | null;
            /**
             * Name
             * @description Exporter name (e.g., 'redis-exporter', 'json-exporter')
             */
            name: string;
            /** @description Current status: up, down, or unknown */
            status: components["schemas"]["ExporterStatusEnum"];
        };
        /**
         * ExporterStatusEnum
         * @description Exporter status states.
         * @enum {string}
         */
        ExporterStatusEnum: "up" | "down" | "unknown";
        /**
         * FaceDetectionEventListResponse
         * @description Schema for list of face detection events.
         * @example {
         *       "items": [
         *         {
         *           "age_estimate": 40,
         *           "bbox": [
         *             100,
         *             150,
         *             200,
         *             300
         *           ],
         *           "camera_id": "front_door",
         *           "created_at": "2025-01-01T10:00:00Z",
         *           "gender_estimate": "M",
         *           "id": 1,
         *           "is_unknown": true,
         *           "quality_score": 0.75,
         *           "timestamp": "2025-01-01T10:00:00Z"
         *         }
         *       ],
         *       "total": 1
         *     }
         */
        FaceDetectionEventListResponse: {
            /**
             * Items
             * @description List of face detection events
             */
            items: components["schemas"]["FaceDetectionEventResponse"][];
            /**
             * Total
             * @description Total number of events
             */
            total: number;
        };
        /**
         * FaceDetectionEventResponse
         * @description Schema for face detection event response.
         * @example {
         *       "age_estimate": 35,
         *       "bbox": [
         *         100,
         *         150,
         *         200,
         *         300
         *       ],
         *       "camera_id": "front_door",
         *       "created_at": "2025-01-01T10:00:00Z",
         *       "gender_estimate": "M",
         *       "id": 1,
         *       "is_unknown": false,
         *       "match_confidence": 0.92,
         *       "matched_person_id": 1,
         *       "matched_person_name": "John Doe",
         *       "quality_score": 0.85,
         *       "timestamp": "2025-01-01T10:00:00Z"
         *     }
         */
        FaceDetectionEventResponse: {
            /**
             * Age Estimate
             * @description Estimated age
             */
            age_estimate?: number | null;
            /**
             * Bbox
             * @description Bounding box [x1, y1, x2, y2]
             */
            bbox: number[];
            /**
             * Camera Id
             * @description ID of the camera that detected the face
             */
            camera_id: string;
            /**
             * Created At
             * Format: date-time
             * @description When the event was recorded
             */
            created_at: string;
            /**
             * Gender Estimate
             * @description Estimated gender (M/F)
             */
            gender_estimate?: string | null;
            /**
             * Id
             * @description Unique identifier for the event
             */
            id: number;
            /**
             * Is Unknown
             * @description Whether face is unknown
             */
            is_unknown: boolean;
            /**
             * Match Confidence
             * @description Match confidence score
             */
            match_confidence?: number | null;
            /**
             * Matched Person Id
             * @description ID of matched person
             */
            matched_person_id?: number | null;
            /**
             * Matched Person Name
             * @description Name of matched person
             */
            matched_person_name?: string | null;
            /**
             * Quality Score
             * @description Face quality score
             */
            quality_score: number;
            /**
             * Timestamp
             * Format: date-time
             * @description When the face was detected
             */
            timestamp: string;
        };
        /**
         * FaceEmbeddingCreate
         * @description Schema for adding a face embedding.
         * @example {
         *       "embedding": [
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1
         *       ],
         *       "quality_score": 0.85,
         *       "source_image_path": "/data/images/john_doe_1.jpg"
         *     }
         */
        FaceEmbeddingCreate: {
            /**
             * Embedding
             * @description 512-dimensional ArcFace embedding vector
             */
            embedding: number[];
            /**
             * Quality Score
             * @description Face quality score when embedding was captured
             * @default 1
             */
            quality_score: number;
            /**
             * Source Image Path
             * @description Path to the source image
             */
            source_image_path?: string | null;
        };
        /**
         * FaceEmbeddingResponse
         * @description Schema for face embedding response.
         * @example {
         *       "created_at": "2025-01-01T10:00:00Z",
         *       "id": 1,
         *       "person_id": 1,
         *       "quality_score": 0.85,
         *       "source_image_path": "/data/images/john_doe_1.jpg"
         *     }
         */
        FaceEmbeddingResponse: {
            /**
             * Created At
             * Format: date-time
             * @description When the embedding was created
             */
            created_at: string;
            /**
             * Id
             * @description Unique identifier for the embedding
             */
            id: number;
            /**
             * Person Id
             * @description ID of the associated person
             */
            person_id: number;
            /**
             * Quality Score
             * @description Face quality score
             */
            quality_score: number;
            /**
             * Source Image Path
             * @description Path to source image
             */
            source_image_path?: string | null;
        };
        /**
         * FaceEnrichment
         * @description Face detection results.
         * @example {
         *       "confidence": 0.88,
         *       "count": 1,
         *       "detected": true
         *     }
         */
        FaceEnrichment: {
            /**
             * Confidence
             * @description Highest face confidence
             */
            confidence?: number | null;
            /**
             * Count
             * @description Number of faces detected
             * @default 0
             */
            count: number;
            /**
             * Detected
             * @description Whether faces were detected
             * @default false
             */
            detected: boolean;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
        };
        /**
         * FaceMatchRequest
         * @description Schema for face matching request.
         * @example {
         *       "embedding": [
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1,
         *         0.1
         *       ],
         *       "threshold": 0.68
         *     }
         */
        FaceMatchRequest: {
            /**
             * Embedding
             * @description 512-dimensional face embedding to match
             */
            embedding: number[];
            /**
             * Threshold
             * @description Minimum similarity threshold for a match
             * @default 0.68
             */
            threshold: number;
        };
        /**
         * FaceMatchResponse
         * @description Schema for face matching response.
         * @example {
         *       "is_household_member": true,
         *       "is_unknown": false,
         *       "matched": true,
         *       "person_id": 1,
         *       "person_name": "John Doe",
         *       "similarity": 0.92
         *     }
         */
        FaceMatchResponse: {
            /**
             * Is Household Member
             * @description Whether matched person is a household member
             */
            is_household_member?: boolean | null;
            /**
             * Is Unknown
             * @description Whether face is unknown
             */
            is_unknown: boolean;
            /**
             * Matched
             * @description Whether a match was found
             */
            matched: boolean;
            /**
             * Person Id
             * @description ID of matched person
             */
            person_id?: number | null;
            /**
             * Person Name
             * @description Name of matched person
             */
            person_name?: string | null;
            /**
             * Similarity
             * @description Best similarity score
             */
            similarity: number;
        };
        /**
         * FeatureSettings
         * @description Feature toggle settings for enabling/disabling AI pipeline components.
         *
         *     Controls which AI processing features are active in the detection pipeline.
         * @example {
         *       "background_eval_enabled": true,
         *       "clip_generation_enabled": true,
         *       "image_quality_enabled": true,
         *       "reid_enabled": true,
         *       "scene_change_enabled": true,
         *       "vision_extraction_enabled": true
         *     }
         */
        FeatureSettings: {
            /**
             * Background Eval Enabled
             * @description Enable automatic background AI audit evaluation when GPU is idle
             */
            background_eval_enabled: boolean;
            /**
             * Clip Generation Enabled
             * @description Enable automatic clip generation for events
             */
            clip_generation_enabled: boolean;
            /**
             * Image Quality Enabled
             * @description Enable BRISQUE image quality assessment (CPU-based)
             */
            image_quality_enabled: boolean;
            /**
             * Reid Enabled
             * @description Enable CLIP re-identification for tracking entities across cameras
             */
            reid_enabled: boolean;
            /**
             * Scene Change Enabled
             * @description Enable SSIM-based scene change detection
             */
            scene_change_enabled: boolean;
            /**
             * Vision Extraction Enabled
             * @description Enable Florence-2 vision extraction for vehicle/person attributes
             */
            vision_extraction_enabled: boolean;
        };
        /**
         * FeatureSettingsUpdate
         * @description Feature settings update schema (all fields optional).
         *
         *     Used for PATCH /api/v1/settings to partially update feature toggles.
         * @example {
         *       "reid_enabled": false
         *     }
         */
        FeatureSettingsUpdate: {
            /**
             * Background Eval Enabled
             * @description Enable automatic background AI audit evaluation when GPU is idle
             */
            background_eval_enabled?: boolean | null;
            /**
             * Clip Generation Enabled
             * @description Enable automatic clip generation for events
             */
            clip_generation_enabled?: boolean | null;
            /**
             * Image Quality Enabled
             * @description Enable BRISQUE image quality assessment (CPU-based)
             */
            image_quality_enabled?: boolean | null;
            /**
             * Reid Enabled
             * @description Enable CLIP re-identification for tracking entities across cameras
             */
            reid_enabled?: boolean | null;
            /**
             * Scene Change Enabled
             * @description Enable SSIM-based scene change detection
             */
            scene_change_enabled?: boolean | null;
            /**
             * Vision Extraction Enabled
             * @description Enable Florence-2 vision extraction for vehicle/person attributes
             */
            vision_extraction_enabled?: boolean | null;
        };
        /**
         * FeedbackStatsResponse
         * @description Schema for aggregate feedback statistics.
         *
         *     Returns counts of feedback by type and by camera to help
         *     calibrate the AI model's risk assessment.
         * @example {
         *       "by_camera": {
         *         "back_yard": 30,
         *         "front_door": 50,
         *         "garage": 20
         *       },
         *       "by_type": {
         *         "accurate": 10,
         *         "false_positive": 40,
         *         "missed_threat": 30,
         *         "severity_wrong": 20
         *       },
         *       "total_feedback": 100
         *     }
         */
        FeedbackStatsResponse: {
            /**
             * By Camera
             * @description Count of feedback entries grouped by camera ID
             */
            by_camera: {
                [key: string]: number;
            };
            /**
             * By Type
             * @description Count of feedback entries grouped by feedback type
             */
            by_type: {
                [key: string]: number;
            };
            /**
             * Total Feedback
             * @description Total number of feedback entries
             */
            total_feedback: number;
        };
        /**
         * FeedbackType
         * @description Types of feedback users can provide on events.
         *
         *     Values:
         *         ACCURATE: Event was correctly classified with appropriate severity
         *         FALSE_POSITIVE: Event was incorrectly flagged as concerning
         *         MISSED_THREAT: System failed to detect a concerning event
         *         SEVERITY_WRONG: Event was flagged but with incorrect severity level
         * @enum {string}
         */
        FeedbackType: "accurate" | "false_positive" | "missed_threat" | "severity_wrong";
        /**
         * FileWatcherStatusResponse
         * @description Status information for the FileWatcher service.
         * @example {
         *       "camera_root": "/export/foscam",
         *       "observer_type": "native",
         *       "pending_tasks": 3,
         *       "running": true
         *     }
         */
        FileWatcherStatusResponse: {
            /**
             * Camera Root
             * @description Root directory being watched for camera uploads
             */
            camera_root: string;
            /**
             * Observer Type
             * @description Type of filesystem observer (native or polling)
             */
            observer_type: string;
            /**
             * Pending Tasks
             * @description Number of files pending processing (debouncing)
             */
            pending_tasks: number;
            /**
             * Running
             * @description Whether the file watcher is currently running
             */
            running: boolean;
        };
        /**
         * FlushQueuesResponse
         * @description Response schema for queue flush endpoint.
         */
        FlushQueuesResponse: {
            /** Duration Seconds */
            duration_seconds: number;
            /** Items Cleared */
            items_cleared: {
                [key: string]: number;
            };
            /** Message */
            message: string;
            /** Queues Flushed */
            queues_flushed: string[];
        };
        /**
         * FrontendLogBatchRequest
         * @description Batch request for multiple frontend log entries.
         *
         *     The frontend batches log entries to reduce API calls. Each batch may
         *     contain logs from different components or at different levels.
         *
         *     Attributes:
         *         entries: List of log entries to ingest (1-100 entries)
         * @example {
         *       "entries": [
         *         {
         *           "component": "App",
         *           "level": "INFO",
         *           "message": "Page loaded successfully",
         *           "timestamp": "2024-01-15T10:30:00Z"
         *         },
         *         {
         *           "component": "API",
         *           "extra": {
         *             "endpoint": "/api/events",
         *             "status": 500
         *           },
         *           "level": "ERROR",
         *           "message": "API call failed",
         *           "timestamp": "2024-01-15T10:30:01Z"
         *         }
         *       ]
         *     }
         */
        FrontendLogBatchRequest: {
            /**
             * Entries
             * @description List of log entries to ingest (1-100 entries)
             */
            entries: components["schemas"]["FrontendLogEntry"][];
        };
        /**
         * FrontendLogEntry
         * @description A single log entry from the frontend.
         *
         *     This schema matches the structure sent by the frontend logger.ts service.
         *     All fields except level and message are optional to allow flexibility in
         *     what context the frontend can provide.
         *
         *     Attributes:
         *         level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
         *         message: The log message content
         *         timestamp: When the log was created (ISO 8601 format)
         *         component: Frontend component name (e.g., "Dashboard", "AlertForm")
         *         context: Additional structured context data (renamed from 'extra' in frontend)
         *         url: Browser URL where the log was generated
         *         user_agent: Browser user agent string
         * @example {
         *       "component": "Dashboard",
         *       "extra": {
         *         "error_code": "API_TIMEOUT",
         *         "retry_count": 3,
         *         "url": "https://example.com/dashboard"
         *       },
         *       "level": "ERROR",
         *       "message": "Failed to load dashboard data",
         *       "timestamp": "2024-01-15T10:30:00Z",
         *       "url": "https://example.com/dashboard"
         *     }
         */
        FrontendLogEntry: {
            /**
             * Component
             * @description Frontend component name
             */
            component?: string | null;
            /**
             * Extra
             * @description Additional structured context data
             */
            extra?: {
                [key: string]: unknown;
            } | null;
            /** @description Log level */
            level: components["schemas"]["FrontendLogLevel"];
            /**
             * Message
             * @description Log message content
             */
            message: string;
            /**
             * Timestamp
             * @description When the log was created (ISO 8601 format)
             */
            timestamp?: string | null;
            /**
             * Url
             * @description Browser URL where log was generated
             */
            url?: string | null;
            /**
             * User Agent
             * @description Browser user agent string
             */
            user_agent?: string | null;
        };
        /**
         * FrontendLogLevel
         * @description Supported frontend log levels.
         *
         *     These correspond to the log levels used by the frontend logger.ts service.
         * @enum {string}
         */
        FrontendLogLevel: "DEBUG" | "INFO" | "WARNING" | "ERROR" | "CRITICAL";
        /**
         * FrontendLogResponse
         * @description Response from the frontend log ingestion endpoints.
         *
         *     Attributes:
         *         success: Whether the ingestion was successful
         *         count: Number of log entries successfully ingested
         *         message: Human-readable status message
         * @example {
         *       "count": 5,
         *       "message": "Successfully ingested 5 log entry(ies)",
         *       "success": true
         *     }
         */
        FrontendLogResponse: {
            /**
             * Count
             * @description Number of entries successfully ingested
             */
            count: number;
            /**
             * Message
             * @description Human-readable status message
             */
            message?: string | null;
            /**
             * Success
             * @description Whether ingestion was successful
             */
            success: boolean;
        };
        /**
         * FullHealthResponse
         * @description Comprehensive health check response for GET /api/system/health/full.
         *
         *     Aggregates health status from all services:
         *     - Infrastructure (postgres, redis)
         *     - AI services (yolo26, nemotron, florence, clip, enrichment)
         *     - Circuit breakers
         *     - Background workers
         *
         *     HTTP Status Codes:
         *     - 200: System is healthy or degraded (can still serve traffic)
         *     - 503: Critical services are unhealthy (should not receive traffic)
         * @example {
         *       "ai_services": [
         *         {
         *           "circuit_state": "closed",
         *           "display_name": "YOLO26v2 Object Detection",
         *           "last_check": "2026-01-08T10:30:00Z",
         *           "name": "yolo26",
         *           "response_time_ms": 45.2,
         *           "status": "healthy",
         *           "url": "http://ai-detector:8090"
         *         }
         *       ],
         *       "circuit_breakers": {
         *         "breakers": {
         *           "nemotron": "closed",
         *           "yolo26": "closed"
         *         },
         *         "closed": 5,
         *         "half_open": 0,
         *         "open": 0,
         *         "total": 5
         *       },
         *       "message": "All systems operational",
         *       "postgres": {
         *         "message": "Database operational",
         *         "name": "postgres",
         *         "status": "healthy"
         *       },
         *       "ready": true,
         *       "redis": {
         *         "details": {
         *           "redis_version": "7.4.0"
         *         },
         *         "message": "Redis connected",
         *         "name": "redis",
         *         "status": "healthy"
         *       },
         *       "status": "healthy",
         *       "timestamp": "2026-01-08T10:30:00Z",
         *       "version": "0.1.0",
         *       "workers": [
         *         {
         *           "critical": true,
         *           "name": "file_watcher",
         *           "running": true
         *         }
         *       ]
         *     }
         */
        FullHealthResponse: {
            /**
             * Ai Services
             * @description Health status of all AI services
             */
            ai_services: components["schemas"]["AIServiceHealthStatus"][];
            /** @description Circuit breaker summary */
            circuit_breakers: components["schemas"]["CircuitBreakerSummary"];
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /** @description PostgreSQL health status */
            postgres: components["schemas"]["InfrastructureHealthStatus"];
            /**
             * Ready
             * @description Whether system is ready to receive traffic
             */
            ready: boolean;
            /** @description Redis health status */
            redis: components["schemas"]["InfrastructureHealthStatus"];
            /** @description Overall system health status */
            status: components["schemas"]["ServiceHealthState"];
            /**
             * Timestamp
             * Format: date-time
             * @description Response timestamp
             */
            timestamp: string;
            /**
             * Version
             * @description Application version
             */
            version: string;
            /**
             * Workers
             * @description Background worker statuses
             */
            workers: components["schemas"]["WorkerHealthStatus"][];
        };
        /**
         * GPUStatsHistoryResponse
         * @description Response schema for GPU stats history endpoint.
         *
         *     Uses standard pagination envelope format (NEM-2178):
         *     - items: GPU stats samples (renamed from 'samples')
         *     - pagination: Standard pagination metadata
         * @example {
         *       "items": [
         *         {
         *           "gpu_name": "NVIDIA RTX A5500",
         *           "inference_fps": 30.5,
         *           "memory_total": 24000,
         *           "memory_used": 12000,
         *           "power_usage": 150,
         *           "recorded_at": "2025-12-27T10:30:00Z",
         *           "temperature": 65,
         *           "utilization": 75.5
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 300,
         *         "total": 1
         *       }
         *     }
         */
        GPUStatsHistoryResponse: {
            /**
             * Items
             * @description GPU stats samples (chronological order)
             */
            items: components["schemas"]["GPUStatsSample"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * GPUStatsResponse
         * @description Response schema for GPU statistics endpoint.
         * @example {
         *       "bar1_used": 256,
         *       "compute_processes_count": 2,
         *       "decoder_utilization": 0,
         *       "encoder_utilization": 0,
         *       "fan_speed": 45,
         *       "gpu_name": "NVIDIA RTX A5500",
         *       "inference_fps": 30.5,
         *       "memory_bandwidth_utilization": 35.2,
         *       "memory_clock": 8001,
         *       "memory_clock_max": 8501,
         *       "memory_total": 24000,
         *       "memory_used": 12000,
         *       "pcie_link_gen": 4,
         *       "pcie_link_width": 16,
         *       "pcie_replay_counter": 0,
         *       "pcie_rx_throughput": 95000,
         *       "pcie_tx_throughput": 120000,
         *       "power_limit": 230,
         *       "power_usage": 150,
         *       "pstate": 0,
         *       "sm_clock": 1800,
         *       "sm_clock_max": 1980,
         *       "temp_slowdown_threshold": 83,
         *       "temperature": 65,
         *       "throttle_reasons": 0,
         *       "utilization": 75.5
         *     }
         */
        GPUStatsResponse: {
            /**
             * Bar1 Used
             * @description BAR1 memory used in MB
             */
            bar1_used?: number | null;
            /**
             * Compute Processes Count
             * @description Number of active compute processes
             */
            compute_processes_count?: number | null;
            /**
             * Decoder Utilization
             * @description Video decoder utilization percentage (0-100)
             */
            decoder_utilization?: number | null;
            /**
             * Encoder Utilization
             * @description Video encoder utilization percentage (0-100)
             */
            encoder_utilization?: number | null;
            /**
             * Fan Speed
             * @description GPU fan speed percentage (0-100)
             */
            fan_speed?: number | null;
            /**
             * Gpu Name
             * @description GPU device name (e.g., 'NVIDIA RTX A5500')
             */
            gpu_name?: string | null;
            /**
             * Inference Fps
             * @description Inference frames per second
             */
            inference_fps?: number | null;
            /**
             * Memory Bandwidth Utilization
             * @description Memory controller utilization percentage (0-100)
             */
            memory_bandwidth_utilization?: number | null;
            /**
             * Memory Clock
             * @description Current memory clock frequency in MHz
             */
            memory_clock?: number | null;
            /**
             * Memory Clock Max
             * @description Maximum memory clock frequency in MHz
             */
            memory_clock_max?: number | null;
            /**
             * Memory Total
             * @description Total GPU memory in MB
             */
            memory_total?: number | null;
            /**
             * Memory Used
             * @description GPU memory used in MB
             */
            memory_used?: number | null;
            /**
             * Pcie Link Gen
             * @description PCIe link generation (1-4)
             */
            pcie_link_gen?: number | null;
            /**
             * Pcie Link Width
             * @description PCIe link width (1, 2, 4, 8, 16)
             */
            pcie_link_width?: number | null;
            /**
             * Pcie Replay Counter
             * @description PCIe replay counter (error indicator, should be low)
             */
            pcie_replay_counter?: number | null;
            /**
             * Pcie Rx Throughput
             * @description PCIe RX throughput in KB/s
             */
            pcie_rx_throughput?: number | null;
            /**
             * Pcie Tx Throughput
             * @description PCIe TX throughput in KB/s
             */
            pcie_tx_throughput?: number | null;
            /**
             * Power Limit
             * @description Power limit in watts
             */
            power_limit?: number | null;
            /**
             * Power Usage
             * @description GPU power usage in watts
             */
            power_usage?: number | null;
            /**
             * Pstate
             * @description Performance state (P0=max performance, P15=idle)
             */
            pstate?: number | null;
            /**
             * Sm Clock
             * @description Current SM clock frequency in MHz
             */
            sm_clock?: number | null;
            /**
             * Sm Clock Max
             * @description Maximum SM clock frequency in MHz
             */
            sm_clock_max?: number | null;
            /**
             * Temp Slowdown Threshold
             * @description Temperature threshold for slowdown in Celsius
             */
            temp_slowdown_threshold?: number | null;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature?: number | null;
            /**
             * Throttle Reasons
             * @description Bitfield of current throttle reasons (0=none)
             */
            throttle_reasons?: number | null;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization?: number | null;
        };
        /**
         * GPUStatsSample
         * @description Single time-series sample of GPU statistics.
         */
        GPUStatsSample: {
            /**
             * Bar1 Used
             * @description BAR1 memory used in MB
             */
            bar1_used?: number | null;
            /**
             * Compute Processes Count
             * @description Active compute processes
             */
            compute_processes_count?: number | null;
            /**
             * Decoder Utilization
             * @description Decoder utilization %
             */
            decoder_utilization?: number | null;
            /**
             * Encoder Utilization
             * @description Encoder utilization %
             */
            encoder_utilization?: number | null;
            /**
             * Fan Speed
             * @description GPU fan speed percentage
             */
            fan_speed?: number | null;
            /**
             * Gpu Name
             * @description GPU device name
             */
            gpu_name?: string | null;
            /**
             * Inference Fps
             * @description Inference frames per second
             */
            inference_fps?: number | null;
            /**
             * Memory Bandwidth Utilization
             * @description Memory controller utilization %
             */
            memory_bandwidth_utilization?: number | null;
            /**
             * Memory Clock
             * @description Memory clock in MHz
             */
            memory_clock?: number | null;
            /**
             * Memory Clock Max
             * @description Max memory clock in MHz
             */
            memory_clock_max?: number | null;
            /**
             * Memory Total
             * @description Total GPU memory in MB
             */
            memory_total?: number | null;
            /**
             * Memory Used
             * @description GPU memory used in MB
             */
            memory_used?: number | null;
            /**
             * Pcie Link Gen
             * @description PCIe link generation
             */
            pcie_link_gen?: number | null;
            /**
             * Pcie Link Width
             * @description PCIe link width
             */
            pcie_link_width?: number | null;
            /**
             * Pcie Replay Counter
             * @description PCIe replay counter
             */
            pcie_replay_counter?: number | null;
            /**
             * Pcie Rx Throughput
             * @description PCIe RX throughput KB/s
             */
            pcie_rx_throughput?: number | null;
            /**
             * Pcie Tx Throughput
             * @description PCIe TX throughput KB/s
             */
            pcie_tx_throughput?: number | null;
            /**
             * Power Limit
             * @description Power limit in watts
             */
            power_limit?: number | null;
            /**
             * Power Usage
             * @description GPU power usage in watts
             */
            power_usage?: number | null;
            /**
             * Pstate
             * @description Performance state (P0-P15)
             */
            pstate?: number | null;
            /**
             * Recorded At
             * Format: date-time
             * @description When the GPU sample was recorded (UTC)
             */
            recorded_at: string;
            /**
             * Sm Clock
             * @description Current SM clock in MHz
             */
            sm_clock?: number | null;
            /**
             * Sm Clock Max
             * @description Max SM clock in MHz
             */
            sm_clock_max?: number | null;
            /**
             * Temp Slowdown Threshold
             * @description Slowdown temp threshold
             */
            temp_slowdown_threshold?: number | null;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature?: number | null;
            /**
             * Throttle Reasons
             * @description Throttle reasons bitfield
             */
            throttle_reasons?: number | null;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization?: number | null;
        };
        /**
         * GpuApplyResponse
         * @description Response schema for applying GPU configuration.
         *
         *     Returns the result of applying GPU configuration changes,
         *     including which services were restarted and any warnings.
         * @example {
         *       "restarted_services": [
         *         "ai-enrichment"
         *       ],
         *       "service_statuses": [
         *         {
         *           "service": "ai-enrichment",
         *           "status": "starting"
         *         }
         *       ],
         *       "success": true,
         *       "warnings": []
         *     }
         */
        GpuApplyResponse: {
            /**
             * Restarted Services
             * @description Services that were restarted to apply changes
             */
            restarted_services?: string[];
            /**
             * Service Statuses
             * @description Status of each affected service after apply
             */
            service_statuses?: components["schemas"]["ServiceStatus"][];
            /**
             * Success
             * @description Whether the configuration was applied successfully
             */
            success: boolean;
            /**
             * Warnings
             * @description Warnings about the configuration
             */
            warnings?: string[];
        };
        /**
         * GpuAssignment
         * @description Schema for a single service-to-GPU assignment.
         *
         *     Maps an AI service to a specific GPU with optional VRAM budget override.
         * @example {
         *       "gpu_index": 1,
         *       "service": "ai-enrichment",
         *       "vram_budget_override": 3.5
         *     }
         */
        GpuAssignment: {
            /**
             * Gpu Index
             * @description Target GPU index (null for auto-assign)
             */
            gpu_index?: number | null;
            /**
             * Service
             * @description Service name (e.g., 'ai-llm', 'ai-detector')
             */
            service: string;
            /**
             * Vram Budget Override
             * @description Override VRAM budget in GB (for services with dynamic VRAM needs)
             */
            vram_budget_override?: number | null;
        };
        /**
         * GpuAssignmentStrategy
         * @description GPU assignment strategies for AI services.
         *
         *     Strategies determine how models are distributed across GPUs:
         *     - MANUAL: User controls each assignment explicitly
         *     - VRAM_BASED: Largest models assigned to GPU with most VRAM
         *     - LATENCY_OPTIMIZED: Critical path models on fastest GPU
         *     - ISOLATION_FIRST: LLM gets dedicated GPU, others share
         *     - BALANCED: Distribute VRAM evenly across GPUs
         * @enum {string}
         */
        GpuAssignmentStrategy: "manual" | "vram_based" | "latency_optimized" | "isolation_first" | "balanced";
        /**
         * GpuConfigPreviewResponse
         * @description Response schema for previewing auto-assignment.
         *
         *     Returns the proposed assignments for a given strategy without applying.
         * @example {
         *       "proposed_assignments": [
         *         {
         *           "gpu_index": 0,
         *           "service": "ai-llm"
         *         },
         *         {
         *           "gpu_index": 0,
         *           "service": "ai-detector"
         *         },
         *         {
         *           "gpu_index": 1,
         *           "service": "ai-enrichment",
         *           "vram_budget_override": 3.5
         *         }
         *       ],
         *       "strategy": "vram_based",
         *       "warnings": [
         *         "ai-enrichment VRAM budget (6.8 GB) exceeds GPU 1 (4 GB). Suggested budget: 3.5 GB."
         *       ]
         *     }
         */
        GpuConfigPreviewResponse: {
            /**
             * Proposed Assignments
             * @description Proposed service-to-GPU assignments
             */
            proposed_assignments: components["schemas"]["GpuAssignment"][];
            /** @description Strategy used for preview */
            strategy: components["schemas"]["GpuAssignmentStrategy"];
            /**
             * Warnings
             * @description Warnings about the proposed configuration
             */
            warnings?: string[];
        };
        /**
         * GpuConfigResponse
         * @description Response schema for current GPU configuration.
         *
         *     Returns the current assignment strategy and all service-to-GPU mappings.
         * @example {
         *       "assignments": [
         *         {
         *           "gpu_index": 0,
         *           "service": "ai-llm"
         *         },
         *         {
         *           "gpu_index": 0,
         *           "service": "ai-detector"
         *         },
         *         {
         *           "gpu_index": 1,
         *           "service": "ai-enrichment",
         *           "vram_budget_override": 3.5
         *         }
         *       ],
         *       "strategy": "manual",
         *       "updated_at": "2026-01-23T10:30:00Z"
         *     }
         */
        GpuConfigResponse: {
            /**
             * Assignments
             * @description List of service-to-GPU assignments
             */
            assignments: components["schemas"]["GpuAssignment"][];
            /** @description Current GPU assignment strategy */
            strategy: components["schemas"]["GpuAssignmentStrategy"];
            /**
             * Updated At
             * @description Timestamp of last configuration update
             */
            updated_at?: string | null;
        };
        /**
         * GpuConfigStatusResponse
         * @description Response schema for GPU configuration apply status.
         *
         *     Returns the current status of a GPU configuration apply operation.
         * @example {
         *       "in_progress": false,
         *       "service_statuses": [
         *         {
         *           "service": "ai-enrichment",
         *           "status": "running"
         *         }
         *       ],
         *       "services_completed": [
         *         "ai-enrichment"
         *       ],
         *       "services_pending": []
         *     }
         */
        GpuConfigStatusResponse: {
            /**
             * In Progress
             * @description Whether an apply operation is currently in progress
             */
            in_progress: boolean;
            /**
             * Service Statuses
             * @description Current status of all affected services
             */
            service_statuses?: components["schemas"]["ServiceStatus"][];
            /**
             * Services Completed
             * @description Services that have completed restart
             */
            services_completed?: string[];
            /**
             * Services Pending
             * @description Services still pending restart
             */
            services_pending?: string[];
        };
        /**
         * GpuConfigUpdateRequest
         * @description Request schema for updating GPU configuration.
         *
         *     Allows updating the assignment strategy and/or individual assignments.
         * @example {
         *       "assignments": [
         *         {
         *           "gpu_index": 0,
         *           "service": "ai-llm"
         *         },
         *         {
         *           "gpu_index": 0,
         *           "service": "ai-detector"
         *         },
         *         {
         *           "gpu_index": 1,
         *           "service": "ai-enrichment",
         *           "vram_budget_override": 3.5
         *         }
         *       ],
         *       "strategy": "manual"
         *     }
         */
        GpuConfigUpdateRequest: {
            /**
             * Assignments
             * @description Service-to-GPU assignments (null to keep current)
             */
            assignments?: components["schemas"]["GpuAssignment"][] | null;
            /** @description GPU assignment strategy (null to keep current) */
            strategy?: components["schemas"]["GpuAssignmentStrategy"] | null;
        };
        /**
         * GpuConfigUpdateResponse
         * @description Response schema for GPU configuration update.
         *
         *     Returns success status and any warnings about the configuration.
         * @example {
         *       "success": true,
         *       "warnings": [
         *         "ai-enrichment VRAM budget (6.8 GB) exceeds GPU 1 (4 GB). Auto-adjusted to 3.5 GB."
         *       ]
         *     }
         */
        GpuConfigUpdateResponse: {
            /**
             * Success
             * @description Whether the configuration was saved successfully
             */
            success: boolean;
            /**
             * Warnings
             * @description Warnings about the configuration (e.g., VRAM overages)
             */
            warnings?: string[];
        };
        /**
         * GpuDeviceResponse
         * @description Response schema for a detected GPU device.
         *
         *     Contains metadata about a GPU including VRAM capacity
         *     and current utilization.
         * @example {
         *       "compute_capability": "8.6",
         *       "index": 0,
         *       "name": "RTX A5500",
         *       "vram_total_mb": 24564,
         *       "vram_used_mb": 19304
         *     }
         */
        GpuDeviceResponse: {
            /**
             * Compute Capability
             * @description CUDA compute capability (e.g., '8.6')
             */
            compute_capability?: string | null;
            /**
             * Index
             * @description GPU index (0-based)
             */
            index: number;
            /**
             * Name
             * @description GPU name (e.g., 'NVIDIA RTX A5500')
             */
            name: string;
            /**
             * Vram Total Mb
             * @description Total VRAM in megabytes
             */
            vram_total_mb: number;
            /**
             * Vram Used Mb
             * @description Currently used VRAM in megabytes
             */
            vram_used_mb: number;
        };
        /**
         * GpuDevicesResponse
         * @description Response schema for listing detected GPUs.
         * @example {
         *       "gpus": [
         *         {
         *           "compute_capability": "8.6",
         *           "index": 0,
         *           "name": "RTX A5500",
         *           "vram_total_mb": 24564,
         *           "vram_used_mb": 19304
         *         },
         *         {
         *           "compute_capability": "8.6",
         *           "index": 1,
         *           "name": "RTX A400",
         *           "vram_total_mb": 4094,
         *           "vram_used_mb": 329
         *         }
         *       ]
         *     }
         */
        GpuDevicesResponse: {
            /**
             * Gpus
             * @description List of detected GPU devices
             */
            gpus: components["schemas"]["GpuDeviceResponse"][];
        };
        /**
         * GpuMetrics
         * @description GPU metrics from nvidia-smi / pynvml.
         * @example {
         *       "name": "NVIDIA RTX A5500",
         *       "power_watts": 31,
         *       "temperature": 38,
         *       "utilization": 38,
         *       "vram_percent": 94.58,
         *       "vram_total_gb": 24,
         *       "vram_used_gb": 22.7
         *     }
         */
        GpuMetrics: {
            /**
             * Name
             * @description GPU device name (e.g., 'NVIDIA RTX A5500')
             */
            name: string;
            /**
             * Power Watts
             * @description GPU power usage in Watts
             */
            power_watts: number;
            /**
             * Temperature
             * @description GPU temperature in Celsius
             */
            temperature: number;
            /**
             * Utilization
             * @description GPU utilization percentage (0-100)
             */
            utilization: number;
            /**
             * Vram Percent
             * @description VRAM usage percentage (0-100), computed from vram_used_gb/vram_total_gb
             */
            readonly vram_percent: number;
            /**
             * Vram Total Gb
             * @description Total VRAM in GB
             */
            vram_total_gb: number;
            /**
             * Vram Used Gb
             * @description VRAM used in GB
             */
            vram_used_gb: number;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * HealthCheckServiceStatus
         * @description Status information for a service component in health checks.
         *
         *     Note: Renamed from ServiceStatus to avoid name collision with
         *     backend.api.schemas.services.ServiceStatus (orchestrator enum).
         */
        HealthCheckServiceStatus: {
            /**
             * Details
             * @description Additional service-specific details (may contain nested objects)
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
            /**
             * Status
             * @description Service status: healthy, unhealthy, or not_initialized
             */
            status: string;
        };
        /**
         * HealthEventResponse
         * @description Schema for a health event in the failure history.
         *
         *     Represents a single health-related event such as a failure, recovery, or restart.
         * @example {
         *       "event_type": "failure",
         *       "message": "Health check failed: connection refused",
         *       "service": "redis",
         *       "timestamp": "2025-12-23T10:30:00Z"
         *     }
         */
        HealthEventResponse: {
            /**
             * Event Type
             * @description Type of event: 'failure', 'recovery', or 'restart'
             */
            event_type: string;
            /**
             * Message
             * @description Optional descriptive message about the event
             */
            message?: string | null;
            /**
             * Service
             * @description Name of the service this event relates to
             */
            service: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the event occurred (UTC)
             */
            timestamp: string;
        };
        /**
         * HealthResponse
         * @description Response schema for health check endpoint.
         * @example {
         *       "recent_events": [
         *         {
         *           "event_type": "recovery",
         *           "message": "Service recovered",
         *           "service": "redis",
         *           "timestamp": "2025-12-23T10:25:00Z"
         *         },
         *         {
         *           "event_type": "failure",
         *           "message": "Health check failed",
         *           "service": "redis",
         *           "timestamp": "2025-12-23T10:20:00Z"
         *         }
         *       ],
         *       "services": {
         *         "ai": {
         *           "message": "AI services operational",
         *           "status": "healthy"
         *         },
         *         "database": {
         *           "message": "Database operational",
         *           "status": "healthy"
         *         },
         *         "redis": {
         *           "details": {
         *             "redis_version": "7.0.0"
         *           },
         *           "message": "Redis connected",
         *           "status": "healthy"
         *         }
         *       },
         *       "status": "healthy",
         *       "timestamp": "2025-12-23T10:30:00"
         *     }
         */
        HealthResponse: {
            /**
             * Recent Events
             * @description Recent health events for debugging intermittent issues
             */
            recent_events?: components["schemas"]["HealthEventResponse"][];
            /**
             * Services
             * @description Status of individual services (database, redis, ai)
             */
            services: {
                [key: string]: components["schemas"]["HealthCheckServiceStatus"];
            };
            /**
             * Status
             * @description Overall system status: healthy, degraded, or unhealthy
             */
            status: string;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of health check
             */
            timestamp: string;
        };
        /**
         * HeatmapListResponse
         * @description Response containing a list of heatmap metadata records.
         *
         *     Used for querying historical heatmaps without the full image data.
         *
         *     Attributes:
         *         heatmaps: List of heatmap metadata records.
         *         total: Total number of heatmaps matching the query.
         * @example {
         *       "heatmaps": [
         *         {
         *           "camera_id": "front_door",
         *           "created_at": "2026-01-26T11:00:00Z",
         *           "height": 48,
         *           "id": 1,
         *           "resolution": "hourly",
         *           "time_bucket": "2026-01-26T10:00:00Z",
         *           "total_detections": 150,
         *           "updated_at": "2026-01-26T11:00:00Z",
         *           "width": 64
         *         }
         *       ],
         *       "total": 1
         *     }
         */
        HeatmapListResponse: {
            /**
             * Heatmaps
             * @description List of heatmap metadata records
             */
            heatmaps: components["schemas"]["HeatmapMetadata"][];
            /**
             * Total
             * @description Total number of heatmaps matching the query
             */
            total: number;
        };
        /**
         * HeatmapMetadata
         * @description Metadata about a heatmap record.
         *
         *     Attributes:
         *         id: Unique identifier of the heatmap record.
         *         camera_id: ID of the camera this heatmap belongs to.
         *         time_bucket: Start time of the aggregation period.
         *         resolution: Aggregation resolution (hourly, daily, weekly).
         *         width: Width of the heatmap grid in pixels.
         *         height: Height of the heatmap grid in pixels.
         *         total_detections: Total number of detections in this time bucket.
         *         created_at: When this record was created.
         *         updated_at: When this record was last updated.
         * @example {
         *       "camera_id": "front_door",
         *       "created_at": "2026-01-26T11:00:00Z",
         *       "height": 48,
         *       "id": 1,
         *       "resolution": "hourly",
         *       "time_bucket": "2026-01-26T10:00:00Z",
         *       "total_detections": 150,
         *       "updated_at": "2026-01-26T11:00:00Z",
         *       "width": 64
         *     }
         */
        HeatmapMetadata: {
            /**
             * Camera Id
             * @description ID of the camera this heatmap belongs to
             */
            camera_id: string;
            /**
             * Created At
             * Format: date-time
             * @description When this record was created
             */
            created_at: string;
            /**
             * Height
             * @description Height of the heatmap grid in pixels
             */
            height: number;
            /**
             * Id
             * @description Unique identifier of the heatmap record
             */
            id: number;
            /** @description Aggregation resolution (hourly, daily, weekly) */
            resolution: components["schemas"]["HeatmapResolution"];
            /**
             * Time Bucket
             * Format: date-time
             * @description Start time of the aggregation period
             */
            time_bucket: string;
            /**
             * Total Detections
             * @description Total number of detections in this time bucket
             */
            total_detections: number;
            /**
             * Updated At
             * Format: date-time
             * @description When this record was last updated
             */
            updated_at: string;
            /**
             * Width
             * @description Width of the heatmap grid in pixels
             */
            width: number;
        };
        /**
         * HeatmapResolution
         * @description Resolution levels for heatmap data aggregation.
         * @enum {string}
         */
        HeatmapResolution: "hourly" | "daily" | "weekly";
        /**
         * HeatmapResponse
         * @description Response containing a heatmap image and metadata.
         *
         *     The image is returned as a base64-encoded PNG string that can be
         *     directly used in HTML img tags or decoded for further processing.
         *
         *     Attributes:
         *         camera_id: ID of the camera this heatmap belongs to.
         *         resolution: Aggregation resolution used.
         *         time_bucket: Start time of the aggregation period.
         *         image_base64: Base64-encoded PNG image of the heatmap.
         *         width: Width of the heatmap image in pixels.
         *         height: Height of the heatmap image in pixels.
         *         total_detections: Total detections used to generate this heatmap.
         *         colormap: Name of the colormap used (e.g., 'jet', 'hot', 'viridis').
         * @example {
         *       "camera_id": "front_door",
         *       "colormap": "jet",
         *       "height": 480,
         *       "image_base64": "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk...",
         *       "resolution": "hourly",
         *       "time_bucket": "2026-01-26T10:00:00Z",
         *       "total_detections": 150,
         *       "width": 640
         *     }
         */
        HeatmapResponse: {
            /**
             * Camera Id
             * @description ID of the camera this heatmap belongs to
             */
            camera_id: string;
            /**
             * Colormap
             * @description Name of the colormap used (e.g., 'jet', 'hot', 'viridis')
             * @default jet
             */
            colormap: string;
            /**
             * Height
             * @description Height of the heatmap image in pixels
             */
            height: number;
            /**
             * Image Base64
             * @description Base64-encoded PNG image of the heatmap
             */
            image_base64: string;
            /** @description Aggregation resolution used */
            resolution: components["schemas"]["HeatmapResolution"];
            /**
             * Time Bucket
             * Format: date-time
             * @description Start time of the aggregation period
             */
            time_bucket: string;
            /**
             * Total Detections
             * @description Total detections used to generate this heatmap
             */
            total_detections: number;
            /**
             * Width
             * @description Width of the heatmap image in pixels
             */
            width: number;
        };
        /**
         * HeatmapSnapshotRequest
         * @description Request to force save the current heatmap accumulator.
         *
         *     Attributes:
         *         resolution: Resolution at which to save the snapshot.
         * @example {
         *       "resolution": "hourly"
         *     }
         */
        HeatmapSnapshotRequest: {
            /**
             * @description Resolution at which to save the snapshot
             * @default hourly
             */
            resolution: components["schemas"]["HeatmapResolution"];
        };
        /**
         * HeatmapSnapshotResponse
         * @description Response after saving a heatmap snapshot.
         *
         *     Attributes:
         *         success: Whether the snapshot was saved successfully.
         *         message: Status message.
         *         heatmap_id: ID of the created heatmap record, if successful.
         *         total_detections: Number of detections in the saved snapshot.
         * @example {
         *       "heatmap_id": 42,
         *       "message": "Heatmap snapshot saved successfully",
         *       "success": true,
         *       "total_detections": 150
         *     }
         */
        HeatmapSnapshotResponse: {
            /**
             * Heatmap Id
             * @description ID of the created heatmap record, if successful
             */
            heatmap_id?: number | null;
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Success
             * @description Whether the snapshot was saved successfully
             */
            success: boolean;
            /**
             * Total Detections
             * @description Number of detections in the saved snapshot
             * @default 0
             */
            total_detections: number;
        };
        /**
         * HostMetrics
         * @description Host system metrics from psutil.
         * @example {
         *       "cpu_percent": 12,
         *       "disk_percent": 31.2,
         *       "disk_total_gb": 500,
         *       "disk_used_gb": 156,
         *       "ram_percent": 25.63,
         *       "ram_total_gb": 32,
         *       "ram_used_gb": 8.2
         *     }
         */
        HostMetrics: {
            /**
             * Cpu Percent
             * @description CPU utilization percentage
             */
            cpu_percent: number;
            /**
             * Disk Percent
             * @description Disk usage percentage (0-100), computed from disk_used_gb/disk_total_gb
             */
            readonly disk_percent: number;
            /**
             * Disk Total Gb
             * @description Total disk in GB
             */
            disk_total_gb: number;
            /**
             * Disk Used Gb
             * @description Disk used in GB
             */
            disk_used_gb: number;
            /**
             * Ram Percent
             * @description RAM usage percentage (0-100), computed from ram_used_gb/ram_total_gb
             */
            readonly ram_percent: number;
            /**
             * Ram Total Gb
             * @description Total RAM in GB
             */
            ram_total_gb: number;
            /**
             * Ram Used Gb
             * @description RAM used in GB
             */
            ram_used_gb: number;
        };
        /**
         * HourlyPattern
         * @description Activity pattern for a specific hour.
         * @example {
         *       "avg_detections": 2.5,
         *       "sample_count": 30,
         *       "std_dev": 0.8
         *     }
         */
        HourlyPattern: {
            /**
             * Avg Detections
             * @description Average number of detections during this hour
             */
            avg_detections: number;
            /**
             * Sample Count
             * @description Number of samples used for this calculation
             */
            sample_count: number;
            /**
             * Std Dev
             * @description Standard deviation of detection count
             */
            std_dev: number;
        };
        /**
         * HouseholdCreate
         * @description Schema for creating a new household.
         *
         *     A household is the top-level organizational unit that groups members,
         *     vehicles, and properties together.
         * @example {
         *       "name": "Svoboda Family"
         *     }
         */
        HouseholdCreate: {
            /**
             * Name
             * @description Household name (e.g., 'Svoboda Family')
             */
            name: string;
        };
        /**
         * HouseholdListResponse
         * @description Schema for listing households.
         *
         *     Returns a list of households with pagination metadata.
         * @example {
         *       "items": [
         *         {
         *           "created_at": "2026-01-20T10:00:00Z",
         *           "id": 1,
         *           "name": "Svoboda Family"
         *         }
         *       ],
         *       "total": 1
         *     }
         */
        HouseholdListResponse: {
            /**
             * Items
             * @description List of households
             */
            items: components["schemas"]["HouseholdResponse"][];
            /**
             * Total
             * @description Total number of households
             */
            total: number;
        };
        /**
         * HouseholdMemberCreate
         * @description Schema for creating a new household member.
         * @example {
         *       "name": "John Doe",
         *       "notes": "Works from home on Fridays",
         *       "role": "resident",
         *       "trusted_level": "full",
         *       "typical_schedule": {
         *         "weekdays": "9-17",
         *         "weekends": "flexible"
         *       }
         *     }
         */
        HouseholdMemberCreate: {
            /**
             * Name
             * @description Display name for the person
             */
            name: string;
            /**
             * Notes
             * @description Free-form notes about the person
             */
            notes?: string | null;
            /** @description Role/relationship of the person to the household */
            role: components["schemas"]["MemberRole"];
            /** @description Trust level determining alert suppression behavior */
            trusted_level: components["schemas"]["TrustLevel"];
            /**
             * Typical Schedule
             * @description JSON object defining expected presence schedule
             */
            typical_schedule?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * HouseholdMemberResponse
         * @description Schema for household member response.
         * @example {
         *       "created_at": "2025-01-01T10:00:00Z",
         *       "id": 1,
         *       "name": "John Doe",
         *       "notes": "Works from home on Fridays",
         *       "role": "resident",
         *       "trusted_level": "full",
         *       "typical_schedule": {
         *         "weekdays": "9-17"
         *       },
         *       "updated_at": "2025-01-01T12:00:00Z"
         *     }
         */
        HouseholdMemberResponse: {
            /**
             * Created At
             * Format: date-time
             * @description When the member was created
             */
            created_at: string;
            /**
             * Id
             * @description Unique identifier for the household member
             */
            id: number;
            /**
             * Name
             * @description Display name for the person
             */
            name: string;
            /**
             * Notes
             * @description Notes about the person
             */
            notes?: string | null;
            /** @description Role/relationship to the household */
            role: components["schemas"]["MemberRole"];
            /** @description Trust level for alert behavior */
            trusted_level: components["schemas"]["TrustLevel"];
            /**
             * Typical Schedule
             * @description Expected presence schedule
             */
            typical_schedule?: {
                [key: string]: unknown;
            } | null;
            /**
             * Updated At
             * Format: date-time
             * @description When the member was last updated
             */
            updated_at: string;
        };
        /**
         * HouseholdMemberUpdate
         * @description Schema for updating an existing household member.
         * @example {
         *       "name": "John Doe Updated",
         *       "notes": "Now works remotely full-time",
         *       "trusted_level": "partial"
         *     }
         */
        HouseholdMemberUpdate: {
            /**
             * Name
             * @description Display name for the person
             */
            name?: string | null;
            /**
             * Notes
             * @description Free-form notes about the person
             */
            notes?: string | null;
            /** @description Role/relationship of the person to the household */
            role?: components["schemas"]["MemberRole"] | null;
            /** @description Trust level determining alert suppression behavior */
            trusted_level?: components["schemas"]["TrustLevel"] | null;
            /**
             * Typical Schedule
             * @description JSON object defining expected presence schedule
             */
            typical_schedule?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * HouseholdResponse
         * @description Schema for household response.
         *
         *     Includes basic household information. Use nested endpoints or
         *     query parameters to include related members, vehicles, or properties.
         * @example {
         *       "created_at": "2026-01-20T10:00:00Z",
         *       "id": 1,
         *       "name": "Svoboda Family"
         *     }
         */
        HouseholdResponse: {
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when household was created
             */
            created_at: string;
            /**
             * Id
             * @description Unique household identifier
             */
            id: number;
            /**
             * Name
             * @description Household name
             */
            name: string;
        };
        /**
         * HouseholdUpdate
         * @description Schema for updating an existing household.
         *
         *     All fields are optional; only provided fields will be updated.
         * @example {
         *       "name": "Svoboda-Smith Family"
         *     }
         */
        HouseholdUpdate: {
            /**
             * Name
             * @description Household name
             */
            name?: string | null;
        };
        /**
         * ImageQualityEnrichment
         * @description Image quality assessment results.
         * @example {
         *       "is_blurry": false,
         *       "is_low_quality": false,
         *       "quality_issues": [],
         *       "score": 0.85
         *     }
         */
        ImageQualityEnrichment: {
            /**
             * Is Blurry
             * @description Whether image is blurry
             */
            is_blurry?: boolean | null;
            /**
             * Is Low Quality
             * @description Whether image has low quality
             */
            is_low_quality?: boolean | null;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
            /**
             * Quality Change Detected
             * @description Whether sudden quality change was detected
             */
            quality_change_detected?: boolean | null;
            /**
             * Quality Issues
             * @description List of detected quality issues
             */
            quality_issues?: string[] | null;
            /**
             * Score
             * @description Quality score (0-100)
             */
            score?: number | null;
        };
        /**
         * InferenceMetrics
         * @description AI inference latency and throughput metrics.
         * @example {
         *       "nemotron_latency_ms": {
         *         "avg": 2100,
         *         "p95": 4800,
         *         "p99": 8200
         *       },
         *       "pipeline_latency_ms": {
         *         "avg": 3200,
         *         "p95": 6100
         *       },
         *       "queues": {
         *         "analysis": 0,
         *         "detection": 0
         *       },
         *       "throughput": {
         *         "events_per_min": 2.1,
         *         "images_per_min": 12.4
         *       },
         *       "yolo26_latency_ms": {
         *         "avg": 45,
         *         "p95": 82,
         *         "p99": 120
         *       }
         *     }
         */
        InferenceMetrics: {
            /**
             * Nemotron Latency Ms
             * @description Nemotron latency stats (avg, p95, p99)
             */
            nemotron_latency_ms: {
                [key: string]: number;
            };
            /**
             * Pipeline Latency Ms
             * @description Full pipeline latency stats (avg, p95)
             */
            pipeline_latency_ms: {
                [key: string]: number;
            };
            /**
             * Queues
             * @description Queue depths (detection, analysis)
             */
            queues: {
                [key: string]: number;
            };
            /**
             * Throughput
             * @description Throughput metrics (images_per_min, events_per_min)
             */
            throughput: {
                [key: string]: number;
            };
            /**
             * Yolo26 Latency Ms
             * @description YOLO26v2 latency stats (avg, p95, p99)
             */
            yolo26_latency_ms: {
                [key: string]: number;
            };
        };
        /**
         * InfrastructureHealthStatus
         * @description Health status for infrastructure services (postgres, redis).
         *
         *     Provides detailed status including connection info and any error details.
         * @example {
         *       "message": "Database operational",
         *       "name": "postgres",
         *       "status": "healthy"
         *     }
         */
        InfrastructureHealthStatus: {
            /**
             * Details
             * @description Additional details (e.g., redis version)
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * Message
             * @description Status message or error description
             */
            message: string;
            /**
             * Name
             * @description Service name (e.g., 'postgres', 'redis')
             */
            name: string;
            /** @description Current health state */
            status: components["schemas"]["ServiceHealthState"];
        };
        /**
         * IntegrationType
         * @description Pre-built integration types.
         * @enum {string}
         */
        IntegrationType: "generic" | "slack" | "discord" | "telegram" | "teams";
        /**
         * JobAbortResponse
         * @description Response model for job abort request.
         * @example {
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Job abort requested - worker notified",
         *       "status": "failed"
         *     }
         */
        JobAbortResponse: {
            /**
             * Job Id
             * @description Job ID that is being aborted
             */
            job_id: string;
            /**
             * Message
             * @description Abort status message
             */
            message: string;
            /** @description New job status (aborting/failed) */
            status: components["schemas"]["JobStatusEnum"];
        };
        /**
         * JobAttemptResponse
         * @description A single job execution attempt record.
         * @example {
         *       "attempt_number": 1,
         *       "duration_seconds": 89,
         *       "ended_at": "2024-01-15T10:31:30Z",
         *       "result": {
         *         "processed": 1000
         *       },
         *       "started_at": "2024-01-15T10:30:01Z",
         *       "status": "succeeded",
         *       "worker_id": "worker-1"
         *     }
         */
        JobAttemptResponse: {
            /**
             * Attempt Number
             * @description Sequential attempt number (1-based)
             */
            attempt_number: number;
            /**
             * Duration Seconds
             * @description Duration in seconds if completed
             */
            duration_seconds?: number | null;
            /**
             * Ended At
             * @description When this attempt ended
             */
            ended_at?: string | null;
            /**
             * Error
             * @description Error message if failed
             */
            error?: string | null;
            /**
             * Result
             * @description Result data if successful
             */
            result?: {
                [key: string]: unknown;
            } | null;
            /**
             * Started At
             * Format: date-time
             * @description When this attempt started
             */
            started_at: string;
            /**
             * Status
             * @description Status of this attempt (started, succeeded, failed, cancelled)
             */
            status: string;
            /**
             * Worker Id
             * @description ID of worker that processed this attempt
             */
            worker_id?: string | null;
        };
        /**
         * JobCancelResponse
         * @description Response model for job cancellation request.
         * @example {
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "message": "Job cancellation requested",
         *       "status": "failed"
         *     }
         */
        JobCancelResponse: {
            /**
             * Job Id
             * @description Job ID that was cancelled
             */
            job_id: string;
            /**
             * Message
             * @description Cancellation status message
             */
            message: string;
            /** @description New job status after cancellation */
            status: components["schemas"]["JobStatusEnum"];
        };
        /**
         * JobDetailResponse
         * @description Detailed response model for a single job.
         *
         *     Provides comprehensive information about a job including progress details,
         *     timing information, retry status, and execution metadata.
         *
         *     NEM-2390: GET /api/jobs/{job_id} detail endpoint response.
         * @example {
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "job_type": "ai_analysis",
         *       "metadata": {
         *         "input_params": {
         *           "event_ids": [
         *             "evt-1",
         *             "evt-2"
         *           ]
         *         },
         *         "worker_id": "worker-001"
         *       },
         *       "priority": 1,
         *       "progress": {
         *         "current_step": "Analyzing detections",
         *         "items_processed": 450,
         *         "items_total": 1000,
         *         "percent": 45
         *       },
         *       "queue_name": "high_priority",
         *       "retry_info": {
         *         "attempt_number": 1,
         *         "max_attempts": 3,
         *         "previous_errors": []
         *       },
         *       "status": "running",
         *       "timing": {
         *         "created_at": "2024-01-15T10:30:00Z",
         *         "duration_seconds": 45.5,
         *         "estimated_remaining_seconds": 55,
         *         "started_at": "2024-01-15T10:30:01Z"
         *       }
         *     }
         */
        JobDetailResponse: {
            /**
             * Error
             * @description Error message (if failed)
             */
            error?: string | null;
            /**
             * Id
             * @description Unique job identifier
             */
            id: string;
            /**
             * Job Type
             * @description Type of job (e.g., 'export', 'ai_analysis')
             */
            job_type: string;
            /** @description Job execution metadata */
            metadata: components["schemas"]["JobMetadata"];
            /**
             * Priority
             * @description Job priority (0=lowest, 10=highest)
             * @default 0
             */
            priority: number;
            /** @description Detailed progress information */
            progress: components["schemas"]["JobProgressDetail"];
            /**
             * Queue Name
             * @description Name of the job queue
             */
            queue_name?: string | null;
            /**
             * Result
             * @description Job result data (if completed)
             */
            result?: unknown | null;
            /** @description Retry attempt information */
            retry_info: components["schemas"]["JobRetryInfo"];
            /** @description Current job status */
            status: components["schemas"]["JobStatusEnum"];
            /** @description Job timing and duration information */
            timing: components["schemas"]["JobTiming"];
        };
        /**
         * JobHistoryResponse
         * @description Complete job history with transitions and attempts.
         *
         *     NEM-2396: GET /api/jobs/{job_id}/history endpoint response.
         * @example {
         *       "attempts": [
         *         {
         *           "attempt_number": 1,
         *           "duration_seconds": 89,
         *           "ended_at": "2024-01-15T10:31:30Z",
         *           "result": {
         *             "events_exported": 1000
         *           },
         *           "started_at": "2024-01-15T10:30:01Z",
         *           "status": "succeeded",
         *           "worker_id": "worker-1"
         *         }
         *       ],
         *       "completed_at": "2024-01-15T10:31:30Z",
         *       "created_at": "2024-01-15T10:30:00Z",
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "job_type": "export",
         *       "started_at": "2024-01-15T10:30:01Z",
         *       "status": "completed",
         *       "transitions": [
         *         {
         *           "at": "2024-01-15T10:30:00Z",
         *           "to": "queued",
         *           "triggered_by": "api"
         *         },
         *         {
         *           "at": "2024-01-15T10:30:01Z",
         *           "details": {
         *             "worker_id": "worker-1"
         *           },
         *           "from": "queued",
         *           "to": "running",
         *           "triggered_by": "worker"
         *         },
         *         {
         *           "at": "2024-01-15T10:31:30Z",
         *           "from": "running",
         *           "to": "completed",
         *           "triggered_by": "worker"
         *         }
         *       ]
         *     }
         */
        JobHistoryResponse: {
            /**
             * Attempts
             * @description Execution attempts in order
             */
            attempts?: components["schemas"]["JobAttemptResponse"][];
            /**
             * Completed At
             * @description When the job finished
             */
            completed_at?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description When the job was created
             */
            created_at: string;
            /**
             * Job Id
             * @description Unique job identifier
             */
            job_id: string;
            /**
             * Job Type
             * @description Type of job (e.g., 'export', 'cleanup')
             */
            job_type: string;
            /**
             * Started At
             * @description When job execution started
             */
            started_at?: string | null;
            /**
             * Status
             * @description Current job status
             */
            status: string;
            /**
             * Transitions
             * @description State transitions in chronological order
             */
            transitions?: components["schemas"]["JobTransitionResponse"][];
        };
        /**
         * JobListResponse
         * @description Response model for listing jobs with pagination.
         *
         *     Uses the standardized pagination envelope format (NEM-2178).
         * @example {
         *       "items": [
         *         {
         *           "created_at": "2024-01-15T10:30:00Z",
         *           "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *           "job_type": "export",
         *           "message": "Exporting events: 450/1000",
         *           "progress": 45,
         *           "started_at": "2024-01-15T10:30:01Z",
         *           "status": "running"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": true,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 100
         *       }
         *     }
         */
        JobListResponse: {
            /**
             * Items
             * @description List of jobs
             */
            items: components["schemas"]["JobResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * JobLogEntryResponse
         * @description A single job log entry.
         * @example {
         *       "attempt_number": 1,
         *       "context": {
         *         "event_count": 1000
         *       },
         *       "level": "INFO",
         *       "message": "Starting export of 1000 events",
         *       "timestamp": "2024-01-15T10:30:05Z"
         *     }
         */
        JobLogEntryResponse: {
            /**
             * Attempt Number
             * @description Which attempt generated this log
             * @default 1
             */
            attempt_number: number;
            /**
             * Context
             * @description Additional context data
             */
            context?: {
                [key: string]: unknown;
            } | null;
            /**
             * Level
             * @description Log level (DEBUG, INFO, WARNING, ERROR)
             */
            level: string;
            /**
             * Message
             * @description Log message
             */
            message: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the log entry was created
             */
            timestamp: string;
        };
        /**
         * JobLogsResponse
         * @description Response for job logs endpoint.
         *
         *     NEM-2396: GET /api/jobs/{job_id}/logs endpoint response.
         * @example {
         *       "has_more": false,
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "logs": [
         *         {
         *           "attempt_number": 1,
         *           "level": "INFO",
         *           "message": "Job started",
         *           "timestamp": "2024-01-15T10:30:01Z"
         *         },
         *         {
         *           "attempt_number": 1,
         *           "context": {
         *             "progress": 0
         *           },
         *           "level": "INFO",
         *           "message": "Processing events: 0/1000",
         *           "timestamp": "2024-01-15T10:30:05Z"
         *         },
         *         {
         *           "attempt_number": 1,
         *           "context": {
         *             "events_exported": 1000
         *           },
         *           "level": "INFO",
         *           "message": "Export completed successfully",
         *           "timestamp": "2024-01-15T10:31:30Z"
         *         }
         *       ],
         *       "total": 3
         *     }
         */
        JobLogsResponse: {
            /**
             * Has More
             * @description Whether more logs exist beyond the limit
             * @default false
             */
            has_more: boolean;
            /**
             * Job Id
             * @description Unique job identifier
             */
            job_id: string;
            /**
             * Logs
             * @description Log entries in chronological order
             */
            logs?: components["schemas"]["JobLogEntryResponse"][];
            /**
             * Total
             * @description Total number of log entries returned
             */
            total: number;
        };
        /**
         * JobMetadata
         * @description Metadata about job execution.
         *
         *     Contains input parameters and execution context.
         * @example {
         *       "input_params": {
         *         "camera_id": "cam-1",
         *         "format": "csv"
         *       },
         *       "worker_id": "worker-abc-123"
         *     }
         */
        JobMetadata: {
            /**
             * Input Params
             * @description Input parameters provided when job was created
             */
            input_params?: {
                [key: string]: unknown;
            } | null;
            /**
             * Worker Id
             * @description ID of the worker executing the job
             */
            worker_id?: string | null;
        };
        /**
         * JobProgressDetail
         * @description Detailed progress information for a job.
         *
         *     Provides granular progress tracking beyond a simple percentage.
         * @example {
         *       "current_step": "Processing events",
         *       "items_processed": 450,
         *       "items_total": 1000,
         *       "percent": 45
         *     }
         */
        JobProgressDetail: {
            /**
             * Current Step
             * @description Current processing step description
             */
            current_step?: string | null;
            /**
             * Items Processed
             * @description Number of items processed so far
             */
            items_processed?: number | null;
            /**
             * Items Total
             * @description Total number of items to process
             */
            items_total?: number | null;
            /**
             * Percent
             * @description Progress percentage (0-100)
             */
            percent: number;
        };
        /**
         * JobResponse
         * @description Response model for job status.
         * @example {
         *       "created_at": "2024-01-15T10:30:00Z",
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "job_type": "export",
         *       "message": "Exporting events: 450/1000",
         *       "progress": 45,
         *       "started_at": "2024-01-15T10:30:01Z",
         *       "status": "running"
         *     }
         */
        JobResponse: {
            /**
             * Completed At
             * @description ISO 8601 timestamp when job finished
             */
            completed_at?: string | null;
            /**
             * Created At
             * @description ISO 8601 timestamp when job was created
             */
            created_at: string;
            /**
             * Error
             * @description Error message (if failed)
             */
            error?: string | null;
            /**
             * Job Id
             * @description Unique job identifier
             */
            job_id: string;
            /**
             * Job Type
             * @description Type of job (e.g., 'export')
             */
            job_type: string;
            /**
             * Message
             * @description Human-readable status message
             */
            message?: string | null;
            /**
             * Progress
             * @description Progress percentage (0-100)
             */
            progress: number;
            /**
             * Result
             * @description Job result data (if completed)
             */
            result?: unknown | null;
            /**
             * Started At
             * @description ISO 8601 timestamp when job started
             */
            started_at?: string | null;
            /** @description Current job status */
            status: components["schemas"]["JobStatusEnum"];
        };
        /**
         * JobRetryInfo
         * @description Retry information for a job.
         *
         *     Tracks retry attempts and failure history.
         * @example {
         *       "attempt_number": 2,
         *       "max_attempts": 3,
         *       "next_retry_at": "2024-01-15T10:35:00Z",
         *       "previous_errors": [
         *         "Connection timeout"
         *       ]
         *     }
         */
        JobRetryInfo: {
            /**
             * Attempt Number
             * @description Current attempt number (1-indexed)
             */
            attempt_number: number;
            /**
             * Max Attempts
             * @description Maximum number of retry attempts allowed
             */
            max_attempts: number;
            /**
             * Next Retry At
             * @description When the next retry will occur (if applicable)
             */
            next_retry_at?: string | null;
            /**
             * Previous Errors
             * @description List of error messages from previous attempts
             */
            previous_errors?: string[];
        };
        /**
         * JobSearchAggregations
         * @description Aggregation counts for job search results.
         * @example {
         *       "by_status": {
         *         "completed": 100,
         *         "failed": 35,
         *         "pending": 10,
         *         "running": 5
         *       },
         *       "by_type": {
         *         "ai_analysis": 120,
         *         "cleanup": 10,
         *         "export": 20
         *       }
         *     }
         */
        JobSearchAggregations: {
            /**
             * By Status
             * @description Count of matching jobs by status
             */
            by_status?: {
                [key: string]: number;
            };
            /**
             * By Type
             * @description Count of matching jobs by job type
             */
            by_type?: {
                [key: string]: number;
            };
        };
        /**
         * JobSearchResponse
         * @description Response model for job search with aggregations.
         *
         *     Extends the standard list response with aggregation data for faceted search.
         *
         *     NEM-2392: GET /api/jobs/search endpoint response.
         * @example {
         *       "aggregations": {
         *         "by_status": {
         *           "completed": 100,
         *           "failed": 35,
         *           "pending": 10,
         *           "running": 5
         *         },
         *         "by_type": {
         *           "backup": 10,
         *           "cleanup": 20,
         *           "export": 120
         *         }
         *       },
         *       "data": [
         *         {
         *           "completed_at": "2024-01-15T10:31:30Z",
         *           "created_at": "2024-01-15T10:30:00Z",
         *           "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *           "job_type": "export",
         *           "message": "Export completed successfully",
         *           "progress": 100,
         *           "result": {
         *             "file_path": "/exports/data.csv"
         *           },
         *           "started_at": "2024-01-15T10:30:01Z",
         *           "status": "completed"
         *         }
         *       ],
         *       "meta": {
         *         "has_more": true,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 150
         *       }
         *     }
         */
        JobSearchResponse: {
            /** @description Aggregation counts for faceted filtering */
            aggregations: components["schemas"]["JobSearchAggregations"];
            /**
             * Data
             * @description List of matching jobs
             */
            data: components["schemas"]["JobResponse"][];
            /** @description Pagination metadata */
            meta: components["schemas"]["PaginationMeta"];
        };
        /**
         * JobStatsResponse
         * @description Response model for job statistics.
         *
         *     Provides aggregate statistics about jobs including counts by status,
         *     counts by type, and timing information.
         * @example {
         *       "average_duration_seconds": 45.5,
         *       "by_status": [
         *         {
         *           "count": 75,
         *           "status": "completed"
         *         },
         *         {
         *           "count": 5,
         *           "status": "running"
         *         },
         *         {
         *           "count": 10,
         *           "status": "pending"
         *         },
         *         {
         *           "count": 10,
         *           "status": "failed"
         *         }
         *       ],
         *       "by_type": [
         *         {
         *           "count": 60,
         *           "job_type": "export"
         *         },
         *         {
         *           "count": 30,
         *           "job_type": "cleanup"
         *         },
         *         {
         *           "count": 10,
         *           "job_type": "backup"
         *         }
         *       ],
         *       "oldest_pending_job_age_seconds": 120,
         *       "total_jobs": 100
         *     }
         */
        JobStatsResponse: {
            /**
             * Average Duration Seconds
             * @description Average job duration in seconds (for completed jobs)
             */
            average_duration_seconds?: number | null;
            /**
             * By Status
             * @description Job counts by status
             */
            by_status: components["schemas"]["JobStatusCount"][];
            /**
             * By Type
             * @description Job counts by type
             */
            by_type: components["schemas"]["JobTypeCount"][];
            /**
             * Oldest Pending Job Age Seconds
             * @description Age of the oldest pending job in seconds
             */
            oldest_pending_job_age_seconds?: number | null;
            /**
             * Total Jobs
             * @description Total number of jobs tracked
             */
            total_jobs: number;
        };
        /**
         * JobStatusCount
         * @description Count of jobs by status.
         * @example {
         *       "count": 42,
         *       "status": "completed"
         *     }
         */
        JobStatusCount: {
            /**
             * Count
             * @description Number of jobs with this status
             */
            count: number;
            /** @description Job status */
            status: components["schemas"]["JobStatusEnum"];
        };
        /**
         * JobStatusEnum
         * @description Status of a background job.
         * @enum {string}
         */
        JobStatusEnum: "pending" | "running" | "completed" | "failed";
        /**
         * JobTargetSummary
         * @description Summary of target health for a specific Prometheus job.
         * @example {
         *       "down": 0,
         *       "job": "hsi-backend-metrics",
         *       "total": 1,
         *       "unknown": 0,
         *       "up": 1
         *     }
         */
        JobTargetSummary: {
            /**
             * Down
             * @description Number of targets that are down
             */
            down: number;
            /**
             * Job
             * @description Prometheus job name
             */
            job: string;
            /**
             * Total
             * @description Total number of targets in this job
             */
            total: number;
            /**
             * Unknown
             * @description Number of targets with unknown status
             * @default 0
             */
            unknown: number;
            /**
             * Up
             * @description Number of targets that are up
             */
            up: number;
        };
        /**
         * JobTiming
         * @description Timing information for a job.
         *
         *     Tracks job lifecycle timestamps and duration calculations.
         * @example {
         *       "created_at": "2024-01-15T10:30:00Z",
         *       "duration_seconds": 45.5,
         *       "estimated_remaining_seconds": 55,
         *       "started_at": "2024-01-15T10:30:01Z"
         *     }
         */
        JobTiming: {
            /**
             * Completed At
             * @description When the job completed or failed
             */
            completed_at?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description When the job was created
             */
            created_at: string;
            /**
             * Duration Seconds
             * @description Total duration in seconds (if started)
             */
            duration_seconds?: number | null;
            /**
             * Estimated Remaining Seconds
             * @description Estimated time remaining (if running)
             */
            estimated_remaining_seconds?: number | null;
            /**
             * Started At
             * @description When job execution started
             */
            started_at?: string | null;
        };
        /**
         * JobTransitionResponse
         * @description A single state transition record in job history.
         * @example {
         *       "at": "2024-01-15T10:30:00Z",
         *       "details": {
         *         "user": "system"
         *       },
         *       "to": "queued",
         *       "triggered_by": "api"
         *     }
         */
        JobTransitionResponse: {
            /**
             * At
             * Format: date-time
             * @description Timestamp of the transition
             */
            at: string;
            /**
             * Details
             * @description Additional transition details
             */
            details?: {
                [key: string]: unknown;
            } | null;
            /**
             * From
             * @description Previous status (null for initial)
             */
            from?: string | null;
            /**
             * To
             * @description New status after transition
             */
            to: string;
            /**
             * Triggered By
             * @description What triggered the transition (api, worker, system, etc)
             */
            triggered_by: string;
        };
        /**
         * JobTypeCount
         * @description Count of jobs by type.
         * @example {
         *       "count": 25,
         *       "job_type": "export"
         *     }
         */
        JobTypeCount: {
            /**
             * Count
             * @description Number of jobs of this type
             */
            count: number;
            /**
             * Job Type
             * @description Job type name
             */
            job_type: string;
        };
        /**
         * JobTypeInfo
         * @description Information about a job type.
         * @example {
         *       "description": "Export events to CSV, JSON, or ZIP format",
         *       "name": "export"
         *     }
         */
        JobTypeInfo: {
            /**
             * Description
             * @description Human-readable description of the job type
             */
            description: string;
            /**
             * Name
             * @description Job type name (e.g., 'export', 'cleanup')
             */
            name: string;
        };
        /**
         * JobTypesResponse
         * @description Response model for listing job types.
         * @example {
         *       "job_types": [
         *         {
         *           "description": "Export events to CSV, JSON, or ZIP format",
         *           "name": "export"
         *         },
         *         {
         *           "description": "Clean up old data and temporary files",
         *           "name": "cleanup"
         *         }
         *       ]
         *     }
         */
        JobTypesResponse: {
            /**
             * Job Types
             * @description List of available job types
             */
            job_types: components["schemas"]["JobTypeInfo"][];
        };
        /**
         * KnownPersonCreate
         * @description Schema for creating a new known person.
         * @example {
         *       "is_household_member": true,
         *       "name": "John Doe",
         *       "notes": "Family member - always trusted"
         *     }
         */
        KnownPersonCreate: {
            /**
             * Is Household Member
             * @description Whether person is a trusted household member
             * @default false
             */
            is_household_member: boolean;
            /**
             * Name
             * @description Display name of the person
             */
            name: string;
            /**
             * Notes
             * @description Optional notes about the person
             */
            notes?: string | null;
        };
        /**
         * KnownPersonListResponse
         * @description Schema for list of known persons.
         * @example {
         *       "items": [
         *         {
         *           "created_at": "2025-01-01T10:00:00Z",
         *           "embedding_count": 3,
         *           "id": 1,
         *           "is_household_member": true,
         *           "name": "John Doe",
         *           "notes": "Family member",
         *           "updated_at": "2025-01-01T12:00:00Z"
         *         }
         *       ],
         *       "total": 1
         *     }
         */
        KnownPersonListResponse: {
            /**
             * Items
             * @description List of known persons
             */
            items: components["schemas"]["KnownPersonResponse"][];
            /**
             * Total
             * @description Total number of known persons
             */
            total: number;
        };
        /**
         * KnownPersonResponse
         * @description Schema for known person response.
         * @example {
         *       "created_at": "2025-01-01T10:00:00Z",
         *       "embedding_count": 3,
         *       "id": 1,
         *       "is_household_member": true,
         *       "name": "John Doe",
         *       "notes": "Family member",
         *       "updated_at": "2025-01-01T12:00:00Z"
         *     }
         */
        KnownPersonResponse: {
            /**
             * Created At
             * Format: date-time
             * @description When the person was registered
             */
            created_at: string;
            /**
             * Embedding Count
             * @description Number of face embeddings stored for this person
             * @default 0
             */
            embedding_count: number;
            /**
             * Id
             * @description Unique identifier for the person
             */
            id: number;
            /**
             * Is Household Member
             * @description Whether person is a household member
             */
            is_household_member: boolean;
            /**
             * Name
             * @description Display name of the person
             */
            name: string;
            /**
             * Notes
             * @description Notes about the person
             */
            notes?: string | null;
            /**
             * Updated At
             * Format: date-time
             * @description When the record was last updated
             */
            updated_at: string;
        };
        /**
         * KnownPersonUpdate
         * @description Schema for updating an existing known person.
         * @example {
         *       "is_household_member": true,
         *       "name": "John Smith",
         *       "notes": "Updated notes"
         *     }
         */
        KnownPersonUpdate: {
            /**
             * Is Household Member
             * @description Whether person is a trusted household member
             */
            is_household_member?: boolean | null;
            /**
             * Name
             * @description Display name of the person
             */
            name?: string | null;
            /**
             * Notes
             * @description Optional notes about the person
             */
            notes?: string | null;
        };
        /**
         * LatencyHistorySnapshot
         * @description Single time-bucket snapshot of pipeline latency metrics.
         */
        LatencyHistorySnapshot: {
            /**
             * Stages
             * @description Latency stats for each pipeline stage (None if no samples)
             */
            stages: {
                [key: string]: components["schemas"]["LatencyHistoryStageStats"] | null;
            };
            /**
             * Timestamp
             * @description Bucket start time (ISO format)
             */
            timestamp: string;
        };
        /**
         * LatencyHistoryStageStats
         * @description Latency statistics for a single stage in a history snapshot.
         */
        LatencyHistoryStageStats: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms: number;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency
             */
            p50_ms: number;
            /**
             * P95 Ms
             * @description 95th percentile latency
             */
            p95_ms: number;
            /**
             * P99 Ms
             * @description 99th percentile latency
             */
            p99_ms: number;
            /**
             * Sample Count
             * @description Number of samples in this bucket
             */
            sample_count: number;
        };
        /**
         * LatestSummariesResponse
         * @description Schema for the combined latest summaries response.
         *
         *     Returns both the latest hourly and daily summaries in a single response.
         *     Either field can be null if no summary exists for that time period.
         * @example {
         *       "daily": {
         *         "content": "Today has seen minimal high-priority activity. The only notable event was at 2:15 PM at the front door. Morning and evening periods have been quiet with routine traffic only.",
         *         "event_count": 1,
         *         "generated_at": "2026-01-18T14:55:00Z",
         *         "id": 2,
         *         "window_end": "2026-01-18T15:00:00Z",
         *         "window_start": "2026-01-18T00:00:00Z"
         *       },
         *       "hourly": {
         *         "content": "Over the past hour, one critical event occurred at 2:15 PM when an unrecognized person approached the front door.",
         *         "event_count": 1,
         *         "generated_at": "2026-01-18T14:55:00Z",
         *         "id": 1,
         *         "window_end": "2026-01-18T15:00:00Z",
         *         "window_start": "2026-01-18T14:00:00Z"
         *       }
         *     }
         */
        LatestSummariesResponse: {
            /** @description Latest daily summary (since midnight), null if none exists */
            daily?: components["schemas"]["SummaryResponse"] | null;
            /** @description Latest hourly summary (past 60 minutes), null if none exists */
            hourly?: components["schemas"]["SummaryResponse"] | null;
        };
        /**
         * LeaderboardResponse
         * @description Model leaderboard response.
         * @example {
         *       "entries": [
         *         {
         *           "contribution_rate": 0.98,
         *           "event_count": 1200,
         *           "model_name": "yolo26",
         *           "quality_correlation": 0.85
         *         },
         *         {
         *           "contribution_rate": 0.85,
         *           "event_count": 1050,
         *           "model_name": "florence",
         *           "quality_correlation": 0.72
         *         }
         *       ],
         *       "period_days": 30
         *     }
         */
        LeaderboardResponse: {
            /** Entries */
            entries: components["schemas"]["ModelLeaderboardEntry"][];
            /** Period Days */
            period_days: number;
        };
        /**
         * LicensePlateEnrichment
         * @description License plate detection and OCR results.
         * @example {
         *       "bbox": [
         *         100,
         *         200,
         *         300,
         *         250
         *       ],
         *       "confidence": 0.92,
         *       "detected": true,
         *       "ocr_confidence": 0.88,
         *       "text": "ABC-1234"
         *     }
         */
        LicensePlateEnrichment: {
            /**
             * Bbox
             * @description Bounding box [x1, y1, x2, y2]
             */
            bbox?: number[] | null;
            /**
             * Confidence
             * @description Detection confidence
             */
            confidence?: number | null;
            /**
             * Detected
             * @description Whether a license plate was detected
             * @default false
             */
            detected: boolean;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
            /**
             * Ocr Confidence
             * @description OCR confidence
             */
            ocr_confidence?: number | null;
            /**
             * Text
             * @description OCR-extracted plate text
             */
            text?: string | null;
        };
        /**
         * LineZoneCreate
         * @description Schema for creating a new line zone.
         *
         *     Requires camera_id to associate the zone with a specific camera.
         * @example {
         *       "alert_on_cross": true,
         *       "camera_id": "front_door",
         *       "end_x": 400,
         *       "end_y": 200,
         *       "name": "Front Door Entry Line",
         *       "start_x": 100,
         *       "start_y": 200,
         *       "target_classes": [
         *         "person"
         *       ]
         *     }
         */
        LineZoneCreate: {
            /**
             * Alert On Cross
             * @description Whether to generate alerts when objects cross this line
             * @default true
             */
            alert_on_cross: boolean;
            /**
             * Camera Id
             * @description ID of the camera this line zone belongs to
             */
            camera_id: string;
            /**
             * End X
             * @description X coordinate of line end point (pixels)
             */
            end_x: number;
            /**
             * End Y
             * @description Y coordinate of line end point (pixels)
             */
            end_y: number;
            /**
             * Name
             * @description Descriptive name for the line zone
             */
            name: string;
            /**
             * Start X
             * @description X coordinate of line start point (pixels)
             */
            start_x: number;
            /**
             * Start Y
             * @description Y coordinate of line start point (pixels)
             */
            start_y: number;
            /**
             * Target Classes
             * @description Object classes to track for this line (e.g., person, car, dog)
             */
            target_classes?: string[];
        };
        /**
         * LineZoneListResponse
         * @description Paginated list of line zones.
         * @example {
         *       "total": 1,
         *       "zones": [
         *         {
         *           "alert_on_cross": true,
         *           "camera_id": "front_door",
         *           "created_at": "2026-01-26T10:00:00Z",
         *           "end_x": 400,
         *           "end_y": 200,
         *           "id": 1,
         *           "in_count": 42,
         *           "name": "Front Door Entry Line",
         *           "out_count": 38,
         *           "start_x": 100,
         *           "start_y": 200,
         *           "target_classes": [
         *             "person"
         *           ]
         *         }
         *       ]
         *     }
         */
        LineZoneListResponse: {
            /**
             * Total
             * @description Total number of line zones
             */
            total: number;
            /**
             * Zones
             * @description List of line zones
             */
            zones: components["schemas"]["LineZoneResponse"][];
        };
        /**
         * LineZoneResponse
         * @description Response schema for a line zone.
         *
         *     Includes computed counts from crossing events.
         * @example {
         *       "alert_on_cross": true,
         *       "camera_id": "front_door",
         *       "created_at": "2026-01-26T10:00:00Z",
         *       "end_x": 400,
         *       "end_y": 200,
         *       "id": 1,
         *       "in_count": 42,
         *       "name": "Front Door Entry Line",
         *       "out_count": 38,
         *       "start_x": 100,
         *       "start_y": 200,
         *       "target_classes": [
         *         "person"
         *       ]
         *     }
         */
        LineZoneResponse: {
            /**
             * Alert On Cross
             * @description Whether to generate alerts when objects cross this line
             * @default true
             */
            alert_on_cross: boolean;
            /**
             * Camera Id
             * @description ID of the camera this line zone belongs to
             */
            camera_id: string;
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when the zone was created
             */
            created_at: string;
            /**
             * End X
             * @description X coordinate of line end point (pixels)
             */
            end_x: number;
            /**
             * End Y
             * @description Y coordinate of line end point (pixels)
             */
            end_y: number;
            /**
             * Id
             * @description Unique line zone identifier
             */
            id: number;
            /**
             * In Count
             * @description Total number of inbound crossings
             * @default 0
             */
            in_count: number;
            /**
             * Name
             * @description Descriptive name for the line zone
             */
            name: string;
            /**
             * Out Count
             * @description Total number of outbound crossings
             * @default 0
             */
            out_count: number;
            /**
             * Start X
             * @description X coordinate of line start point (pixels)
             */
            start_x: number;
            /**
             * Start Y
             * @description Y coordinate of line start point (pixels)
             */
            start_y: number;
            /**
             * Target Classes
             * @description Object classes to track for this line (e.g., person, car, dog)
             */
            target_classes?: string[];
        };
        /**
         * LineZoneUpdate
         * @description Schema for updating an existing line zone.
         *
         *     All fields are optional; only provided fields are updated.
         * @example {
         *       "alert_on_cross": false,
         *       "name": "Updated Entry Line"
         *     }
         */
        LineZoneUpdate: {
            /**
             * Alert On Cross
             * @description Whether to generate alerts when objects cross this line
             */
            alert_on_cross?: boolean | null;
            /**
             * End X
             * @description X coordinate of line end point
             */
            end_x?: number | null;
            /**
             * End Y
             * @description Y coordinate of line end point
             */
            end_y?: number | null;
            /**
             * Name
             * @description Descriptive name for the line zone
             */
            name?: string | null;
            /**
             * Start X
             * @description X coordinate of line start point
             */
            start_x?: number | null;
            /**
             * Start Y
             * @description Y coordinate of line start point
             */
            start_y?: number | null;
            /**
             * Target Classes
             * @description Object classes to track for this line
             */
            target_classes?: string[] | null;
        };
        /**
         * LogEntryResponse
         * @description Schema for a single log entry in query responses.
         *
         *     This schema is used for GET /api/logs responses and represents
         *     a log record from the database.
         *
         *     Attributes:
         *         id: Unique log entry identifier
         *         timestamp: When the log was created (UTC)
         *         level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
         *         component: Component that generated the log (e.g., "backend.api.routes.events")
         *         message: The log message content
         *         camera_id: Optional camera ID associated with this log
         *         event_id: Optional event ID associated with this log
         *         request_id: Optional request ID for correlation
         *         detection_id: Optional detection ID associated with this log
         *         duration_ms: Optional duration in milliseconds (for timing logs)
         *         extra: Additional structured context data (JSON)
         *         source: Log source (backend or frontend)
         * @example {
         *       "camera_id": "front_door",
         *       "component": "backend.services.detector",
         *       "detection_id": 789,
         *       "duration_ms": 30000,
         *       "event_id": 456,
         *       "extra": {
         *         "error_code": "TIMEOUT",
         *         "retry_count": 3
         *       },
         *       "id": 12345,
         *       "level": "ERROR",
         *       "message": "Detection failed: timeout after 30s",
         *       "request_id": "req-abc123",
         *       "source": "backend",
         *       "timestamp": "2026-01-15T10:30:00Z"
         *     }
         */
        LogEntryResponse: {
            /**
             * Camera Id
             * @description Associated camera ID
             */
            camera_id?: string | null;
            /**
             * Component
             * @description Component that generated the log
             */
            component: string;
            /**
             * Detection Id
             * @description Associated detection ID
             */
            detection_id?: number | null;
            /**
             * Duration Ms
             * @description Duration in milliseconds
             */
            duration_ms?: number | null;
            /**
             * Event Id
             * @description Associated event ID
             */
            event_id?: number | null;
            /**
             * Extra
             * @description Additional structured context
             */
            extra?: {
                [key: string]: unknown;
            } | null;
            /**
             * Id
             * @description Unique log entry ID
             */
            id: number;
            /**
             * Level
             * @description Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
             */
            level: string;
            /**
             * Message
             * @description Log message content
             */
            message: string;
            /**
             * Request Id
             * @description Request ID for correlation
             */
            request_id?: string | null;
            /**
             * Source
             * @description Log source (backend or frontend)
             * @default backend
             */
            source: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the log was created (UTC)
             */
            timestamp: string;
        };
        /**
         * LogLevelRequest
         * @description Request to change log level.
         */
        LogLevelRequest: {
            /**
             * Level
             * @description New log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
             */
            level: string;
        };
        /**
         * LogLevelResponse
         * @description Response for log level operations.
         */
        LogLevelResponse: {
            /**
             * Level
             * @description Current log level
             */
            level: string;
            /**
             * Previous Level
             * @description Previous log level (on change)
             */
            previous_level?: string | null;
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * LogStats
         * @description Schema for log statistics dashboard.
         *
         *     Provides aggregated statistics about logs for the dashboard,
         *     including counts by level and component.
         *
         *     Attributes:
         *         errors_today: Number of ERROR logs today
         *         warnings_today: Number of WARNING logs today
         *         total_today: Total number of logs today
         *         top_component: The component with the most logs today (if any)
         *         by_component: Breakdown of log counts by component
         * @example {
         *       "by_component": {
         *         "backend.api.routes.events": 280,
         *         "backend.services.analyzer": 150,
         *         "backend.services.detector": 350,
         *         "frontend": 200
         *       },
         *       "errors_today": 15,
         *       "top_component": "backend.services.detector",
         *       "total_today": 1500,
         *       "warnings_today": 42
         *     }
         */
        LogStats: {
            /**
             * By Component
             * @description Log counts by component
             */
            by_component?: {
                [key: string]: number;
            };
            /**
             * Errors Today
             * @description Number of errors today
             */
            errors_today: number;
            /**
             * Top Component
             * @description Component with most logs today
             */
            top_component?: string | null;
            /**
             * Total Today
             * @description Total logs today
             */
            total_today: number;
            /**
             * Warnings Today
             * @description Number of warnings today
             */
            warnings_today: number;
        };
        /**
         * LogsListResponse
         * @description Schema for paginated log query response.
         *
         *     Supports both cursor-based pagination (recommended) and offset pagination.
         *     Cursor-based pagination offers better performance for large datasets.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "component": "backend.services.detector",
         *           "id": 12345,
         *           "level": "ERROR",
         *           "message": "Detection failed",
         *           "request_id": "req-abc123",
         *           "source": "backend",
         *           "timestamp": "2026-01-15T10:30:00Z"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": true,
         *         "limit": 50,
         *         "next_cursor": "eyJpZCI6IDEyMzQ1fQ==", // pragma: allowlist secret
         *         "offset": 0,
         *         "total": 1500
         *       }
         *     }
         */
        LogsListResponse: {
            /**
             * Deprecation Warning
             * @description Warning when using deprecated offset pagination
             */
            deprecation_warning?: string | null;
            /**
             * Items
             * @description List of log entries
             */
            items: components["schemas"]["LogEntryResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * LoiteringAlert
         * @description Alert generated when an object exceeds the loitering threshold.
         *
         *     This schema represents a loitering event where an object has been
         *     detected in a zone for longer than the configured threshold.
         * @example {
         *       "camera_id": "front_door",
         *       "dwell_seconds": 350.5,
         *       "entry_time": "2026-01-26T12:00:00Z",
         *       "object_class": "person",
         *       "record_id": 123,
         *       "threshold_seconds": 300,
         *       "track_id": 42,
         *       "zone_id": 1
         *     }
         */
        LoiteringAlert: {
            /**
             * Camera Id
             * @description ID of the camera where detection occurred
             */
            camera_id: string;
            /**
             * Dwell Seconds
             * @description Current dwell time in seconds
             */
            dwell_seconds: number;
            /**
             * Entry Time
             * Format: date-time
             * @description When the object entered the zone
             */
            entry_time: string;
            /**
             * Object Class
             * @description Classification of the loitering object
             */
            object_class: string;
            /**
             * Record Id
             * @description ID of the associated dwell time record
             */
            record_id: number;
            /**
             * Threshold Seconds
             * @description Loitering threshold that was exceeded
             */
            threshold_seconds: number;
            /**
             * Track Id
             * @description Tracking ID of the loitering object
             */
            track_id: number;
            /**
             * Zone Id
             * @description ID of the polygon zone where loitering detected
             */
            zone_id: number;
        };
        /**
         * LoiteringCheckRequest
         * @description Request to check for loitering in a zone.
         * @example {
         *       "threshold_seconds": 300
         *     }
         */
        LoiteringCheckRequest: {
            /**
             * Threshold Seconds
             * @description Dwell time threshold in seconds to trigger loitering alert
             */
            threshold_seconds: number;
        };
        /**
         * LoiteringCheckResponse
         * @description Response containing loitering alerts for a zone.
         * @example {
         *       "alerts": [
         *         {
         *           "camera_id": "front_door",
         *           "dwell_seconds": 350.5,
         *           "entry_time": "2026-01-26T12:00:00Z",
         *           "object_class": "person",
         *           "record_id": 123,
         *           "threshold_seconds": 300,
         *           "track_id": 42,
         *           "zone_id": 1
         *         }
         *       ],
         *       "threshold_seconds": 300,
         *       "total_alerts": 1,
         *       "zone_id": 1
         *     }
         */
        LoiteringCheckResponse: {
            /**
             * Alerts
             * @description Loitering alerts detected
             */
            alerts: components["schemas"]["LoiteringAlert"][];
            /**
             * Threshold Seconds
             * @description Threshold used for checking
             */
            threshold_seconds: number;
            /**
             * Total Alerts
             * @description Total number of alerts
             */
            total_alerts: number;
            /**
             * Zone Id
             * @description ID of the polygon zone checked
             */
            zone_id: number;
        };
        /**
         * MediaErrorResponse
         * @description Error response for media access failures.
         * @example {
         *       "error": "File not found",
         *       "path": "/export/foscam/front_door/image_001.jpg"
         *     }
         */
        MediaErrorResponse: {
            /**
             * Error
             * @description Error message describing what went wrong
             */
            error: string;
            /**
             * Path
             * @description The path that was attempted to be accessed
             */
            path: string;
        };
        /**
         * MemberRole
         * @description Role of a household member for access categorization.
         * @enum {string}
         */
        MemberRole: "resident" | "family" | "service_worker" | "frequent_visitor";
        /**
         * MemoryGCStats
         * @description Garbage collector statistics.
         */
        MemoryGCStats: {
            /**
             * Collected
             * @description Total objects collected
             */
            collected: number;
            /**
             * Collections
             * @description Number of collections per generation
             */
            collections: number[];
            /**
             * Thresholds
             * @description Collection thresholds per generation
             */
            thresholds: number[];
            /**
             * Uncollectable
             * @description Number of uncollectable objects
             */
            uncollectable: number;
        };
        /**
         * MemoryObjectStats
         * @description Statistics for a single object type.
         */
        MemoryObjectStats: {
            /**
             * Count
             * @description Number of instances
             */
            count: number;
            /**
             * Size Bytes
             * @description Total size in bytes
             */
            size_bytes: number;
            /**
             * Size Human
             * @description Human-readable size
             */
            size_human: string;
            /**
             * Type Name
             * @description Object type name
             */
            type_name: string;
        };
        /**
         * MemoryStatsResponse
         * @description Response for memory statistics.
         */
        MemoryStatsResponse: {
            /** @description Garbage collector statistics */
            gc_stats: components["schemas"]["MemoryGCStats"];
            /**
             * Process Rss Bytes
             * @description Process RSS memory in bytes
             */
            process_rss_bytes: number;
            /**
             * Process Rss Human
             * @description Human-readable RSS memory
             */
            process_rss_human: string;
            /**
             * Process Vms Bytes
             * @description Process virtual memory in bytes
             */
            process_vms_bytes: number;
            /**
             * Process Vms Human
             * @description Human-readable virtual memory
             */
            process_vms_human: string;
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
            /**
             * Top Objects
             * @description Top object types by memory usage
             */
            top_objects: components["schemas"]["MemoryObjectStats"][];
            /** @description Tracemalloc statistics */
            tracemalloc_stats: components["schemas"]["TraceMallocStats"];
        };
        /**
         * MetricsCollectionStatus
         * @description Status of metrics collection from Prometheus.
         * @example {
         *       "collecting": true,
         *       "last_successful_scrape": "2026-01-13T10:30:00Z",
         *       "scrape_interval_seconds": 15,
         *       "total_series": 15000
         *     }
         */
        MetricsCollectionStatus: {
            /**
             * Collecting
             * @description Whether Prometheus is actively collecting metrics
             */
            collecting: boolean;
            /**
             * Last Successful Scrape
             * @description Timestamp of most recent successful scrape across all targets
             */
            last_successful_scrape?: string | null;
            /**
             * Scrape Interval Seconds
             * @description Configured global scrape interval in seconds
             * @default 15
             */
            scrape_interval_seconds: number;
            /**
             * Total Series
             * @description Total number of time series in Prometheus (if available)
             */
            total_series?: number | null;
        };
        /**
         * ModelContributions
         * @description Model contribution flags.
         * @example {
         *       "baseline": false,
         *       "clip": false,
         *       "clothing": true,
         *       "cross_camera": false,
         *       "florence": true,
         *       "image_quality": true,
         *       "pet": false,
         *       "vehicle": false,
         *       "violence": false,
         *       "weather": true,
         *       "yolo26": true,
         *       "zones": true
         *     }
         */
        ModelContributions: {
            /**
             * Baseline
             * @description Baseline comparison
             * @default false
             */
            baseline: boolean;
            /**
             * Clip
             * @description CLIP embeddings
             * @default false
             */
            clip: boolean;
            /**
             * Clothing
             * @description Clothing analysis
             * @default false
             */
            clothing: boolean;
            /**
             * Cross Camera
             * @description Cross-camera correlation
             * @default false
             */
            cross_camera: boolean;
            /**
             * Florence
             * @description Florence-2 vision attributes
             * @default false
             */
            florence: boolean;
            /**
             * Image Quality
             * @description Image quality assessment
             * @default false
             */
            image_quality: boolean;
            /**
             * Pet
             * @description Pet classification
             * @default false
             */
            pet: boolean;
            /**
             * Vehicle
             * @description Vehicle classification
             * @default false
             */
            vehicle: boolean;
            /**
             * Violence
             * @description Violence detection
             * @default false
             */
            violence: boolean;
            /**
             * Weather
             * @description Weather classification
             * @default false
             */
            weather: boolean;
            /**
             * Yolo26
             * @description YOLO26 object detection
             * @default false
             */
            yolo26: boolean;
            /**
             * Zones
             * @description Zone analysis
             * @default false
             */
            zones: boolean;
        };
        /**
         * ModelLatencyHistoryResponse
         * @description Response schema for Model Zoo latency history endpoint.
         *
         *     Returns time-series latency data for a specific Model Zoo model.
         *     Used to populate the dropdown-controlled latency chart.
         * @example {
         *       "bucket_seconds": 60,
         *       "display_name": "YOLO11 License Plate",
         *       "has_data": true,
         *       "model_name": "yolo11-license-plate",
         *       "snapshots": [
         *         {
         *           "stats": {
         *             "avg_ms": 45,
         *             "p50_ms": 42,
         *             "p95_ms": 68,
         *             "sample_count": 15
         *           },
         *           "timestamp": "2026-01-04T10:00:00+00:00"
         *         }
         *       ],
         *       "timestamp": "2026-01-04T10:30:00Z",
         *       "window_minutes": 60
         *     }
         */
        ModelLatencyHistoryResponse: {
            /**
             * Bucket Seconds
             * @description Bucket size for aggregation
             */
            bucket_seconds: number;
            /**
             * Display Name
             * @description Human-readable display name
             */
            display_name: string;
            /**
             * Has Data
             * @description Whether any latency data exists for this model
             */
            has_data: boolean;
            /**
             * Model Name
             * @description Name of the model this data is for
             */
            model_name: string;
            /**
             * Snapshots
             * @description Chronologically ordered latency snapshots
             */
            snapshots: components["schemas"]["ModelLatencyHistorySnapshot"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp when history was retrieved
             */
            timestamp: string;
            /**
             * Window Minutes
             * @description Time window covered by the history
             */
            window_minutes: number;
        };
        /**
         * ModelLatencyHistorySnapshot
         * @description Single time-bucket snapshot of Model Zoo model latency.
         */
        ModelLatencyHistorySnapshot: {
            /** @description Latency statistics for this time bucket (None if no data) */
            stats?: components["schemas"]["ModelLatencyStageStats"] | null;
            /**
             * Timestamp
             * @description Bucket start time (ISO format)
             */
            timestamp: string;
        };
        /**
         * ModelLatencyStageStats
         * @description Latency statistics for a Model Zoo model at a point in time.
         */
        ModelLatencyStageStats: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms: number;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms: number;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms: number;
            /**
             * Sample Count
             * @description Number of samples in this time bucket
             */
            sample_count: number;
        };
        /**
         * ModelLeaderboardEntry
         * @description Single entry in model leaderboard.
         * @example {
         *       "contribution_rate": 0.85,
         *       "event_count": 1050,
         *       "model_name": "florence",
         *       "quality_correlation": 0.72
         *     }
         */
        ModelLeaderboardEntry: {
            /** Contribution Rate */
            contribution_rate: number;
            /** Event Count */
            event_count: number;
            /** Model Name */
            model_name: string;
            /** Quality Correlation */
            quality_correlation: number | null;
        };
        /**
         * ModelPromptConfig
         * @description Configuration for a specific AI model.
         * @example {
         *       "change_description": "Added weather context to prompt",
         *       "config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "You are a home security AI assistant...",
         *         "temperature": 0.7
         *       },
         *       "created_at": "2026-01-03T10:30:00Z",
         *       "created_by": "admin",
         *       "model": "nemotron",
         *       "version": 3
         *     }
         */
        ModelPromptConfig: {
            /**
             * Change Description
             * @description Description of changes
             */
            change_description?: string | null;
            /**
             * Config
             * @description Model-specific configuration
             */
            config: {
                [key: string]: unknown;
            };
            /**
             * Created At
             * @description When this version was created
             */
            created_at?: string | null;
            /**
             * Created By
             * @description Who created this version
             */
            created_by?: string | null;
            model: components["schemas"]["AIModelEnum"];
            /**
             * Version
             * @description Version number of this configuration
             */
            version: number;
        };
        /**
         * ModelRegistryResponse
         * @description Response schema for model registry endpoint.
         *
         *     Returns comprehensive information about all models in the Model Zoo
         *     including VRAM budget, current usage, and individual model statuses.
         * @example {
         *       "loading_strategy": "sequential",
         *       "max_concurrent_models": 1,
         *       "models": [],
         *       "vram_available_mb": 1350,
         *       "vram_budget_mb": 1650,
         *       "vram_used_mb": 300
         *     }
         */
        ModelRegistryResponse: {
            /**
             * Loading Strategy
             * @description Model loading strategy (sequential = one at a time)
             * @default sequential
             */
            loading_strategy: string;
            /**
             * Max Concurrent Models
             * @description Maximum number of models that can be loaded concurrently
             * @default 1
             */
            max_concurrent_models: number;
            /**
             * Models
             * @description List of all models in the registry with their status
             */
            models: components["schemas"]["ModelStatusResponse"][];
            /**
             * Vram Available Mb
             * @description Available VRAM for loading additional models
             */
            vram_available_mb: number;
            /**
             * Vram Budget Mb
             * @description Total VRAM budget available for Model Zoo models (excludes Nemotron and YOLO26v2)
             */
            vram_budget_mb: number;
            /**
             * Vram Used Mb
             * @description Currently used VRAM by loaded models
             */
            vram_used_mb: number;
        };
        /**
         * ModelStatusEnum
         * @description Model loading status.
         * @enum {string}
         */
        ModelStatusEnum: "loaded" | "unloaded" | "disabled" | "loading" | "error";
        /**
         * ModelStatusResponse
         * @description Status information for a single model in the Model Zoo.
         *
         *     Provides detailed information about a model including:
         *     - Identity: name, display_name, category
         *     - Configuration: vram_mb, enabled, available, path
         *     - Runtime status: status, load_count
         * @example {
         *       "available": false,
         *       "category": "detection",
         *       "display_name": "YOLO11 License Plate",
         *       "enabled": true,
         *       "load_count": 0,
         *       "name": "yolo11-license-plate",
         *       "path": "/models/model-zoo/yolo11-license-plate/license-plate-finetune-v1n.pt",
         *       "status": "unloaded",
         *       "vram_mb": 300
         *     }
         */
        ModelStatusResponse: {
            /**
             * Available
             * @description Whether the model has been successfully loaded at least once
             */
            available: boolean;
            /**
             * Category
             * @description Model category (detection, recognition, ocr, embedding, etc.)
             */
            category: string;
            /**
             * Display Name
             * @description Human-readable display name for the model
             */
            display_name: string;
            /**
             * Enabled
             * @description Whether the model is enabled for use
             */
            enabled: boolean;
            /**
             * Load Count
             * @description Current reference count for loaded model (0 if not loaded)
             * @default 0
             */
            load_count: number;
            /**
             * Name
             * @description Unique identifier for the model (e.g., 'yolo11-license-plate')
             */
            name: string;
            /**
             * Path
             * @description HuggingFace repo path or local file path for the model
             */
            path: string;
            /** @description Current loading status: loaded, unloaded, disabled, loading, error */
            status: components["schemas"]["ModelStatusEnum"];
            /**
             * Vram Mb
             * @description Estimated VRAM usage in megabytes when loaded
             */
            vram_mb: number;
        };
        /**
         * ModelZooStatusItem
         * @description Status information for a single Model Zoo model.
         *
         *     Used in the compact status card display for Model Zoo models.
         */
        ModelZooStatusItem: {
            /**
             * Category
             * @description Model category (detection, classification, segmentation, etc.)
             */
            category: string;
            /**
             * Display Name
             * @description Human-readable display name
             */
            display_name: string;
            /**
             * Enabled
             * @description Whether the model is enabled for use
             */
            enabled: boolean;
            /**
             * Last Used At
             * @description Timestamp of last model usage (null if never used)
             */
            last_used_at?: string | null;
            /**
             * Name
             * @description Model identifier (e.g., 'yolo11-license-plate')
             */
            name: string;
            /** @description Current status: loaded (green), unloaded (gray), disabled (yellow) */
            status: components["schemas"]["ModelStatusEnum"];
            /**
             * Vram Mb
             * @description VRAM usage in megabytes when loaded
             */
            vram_mb: number;
        };
        /**
         * ModelZooStatusResponse
         * @description Response schema for Model Zoo status endpoint.
         *
         *     Returns status information for all 18 Model Zoo models organized by category.
         *     Used to populate the compact status cards in the UI.
         * @example {
         *       "disabled_count": 3,
         *       "loaded_count": 0,
         *       "models": [
         *         {
         *           "category": "detection",
         *           "display_name": "YOLO11 License Plate",
         *           "enabled": true,
         *           "name": "yolo11-license-plate",
         *           "status": "unloaded",
         *           "vram_mb": 300
         *         }
         *       ],
         *       "timestamp": "2026-01-04T10:30:00Z",
         *       "total_models": 18,
         *       "vram_budget_mb": 1650,
         *       "vram_used_mb": 0
         *     }
         */
        ModelZooStatusResponse: {
            /**
             * Disabled Count
             * @description Number of disabled models
             */
            disabled_count: number;
            /**
             * Loaded Count
             * @description Number of currently loaded models
             */
            loaded_count: number;
            /**
             * Models
             * @description List of all Model Zoo models with their current status
             */
            models: components["schemas"]["ModelZooStatusItem"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
            /**
             * Total Models
             * @description Total number of models in the registry
             */
            total_models: number;
            /**
             * Vram Budget Mb
             * @description Total VRAM budget for Model Zoo
             */
            vram_budget_mb: number;
            /**
             * Vram Used Mb
             * @description Currently used VRAM
             */
            vram_used_mb: number;
        };
        /**
         * MonitoringHealthResponse
         * @description Response schema for monitoring stack health endpoint.
         *
         *     Provides comprehensive health status of the monitoring infrastructure:
         *     - Prometheus server reachability and status
         *     - Scrape target health summary by job
         *     - Exporter status (redis-exporter, json-exporter, blackbox-exporter)
         *     - Metrics collection status
         *
         *     This endpoint helps operators quickly identify issues with the
         *     monitoring stack without accessing Prometheus UI directly.
         * @example {
         *       "exporters": [
         *         {
         *           "endpoint": "http://redis-exporter:9121",
         *           "last_scrape": "2026-01-13T10:30:00Z",
         *           "name": "redis-exporter",
         *           "status": "up"
         *         },
         *         {
         *           "endpoint": "http://json-exporter:7979",
         *           "last_scrape": "2026-01-13T10:30:00Z",
         *           "name": "json-exporter",
         *           "status": "up"
         *         }
         *       ],
         *       "healthy": true,
         *       "issues": [],
         *       "metrics_collection": {
         *         "collecting": true,
         *         "last_successful_scrape": "2026-01-13T10:30:00Z",
         *         "scrape_interval_seconds": 15,
         *         "total_series": 15000
         *       },
         *       "prometheus_reachable": true,
         *       "prometheus_url": "http://prometheus:9090",
         *       "targets_summary": [
         *         {
         *           "down": 0,
         *           "job": "hsi-backend-metrics",
         *           "total": 1,
         *           "unknown": 0,
         *           "up": 1
         *         },
         *         {
         *           "down": 0,
         *           "job": "redis",
         *           "total": 1,
         *           "unknown": 0,
         *           "up": 1
         *         },
         *         {
         *           "down": 0,
         *           "job": "blackbox-http-health",
         *           "total": 1,
         *           "unknown": 0,
         *           "up": 1
         *         }
         *       ],
         *       "timestamp": "2026-01-13T10:30:00Z"
         *     }
         */
        MonitoringHealthResponse: {
            /**
             * Exporters
             * @description Status of known exporters
             */
            exporters: components["schemas"]["ExporterStatus"][];
            /**
             * Healthy
             * @description Overall monitoring stack health: True if Prometheus reachable and majority of targets up
             */
            healthy: boolean;
            /**
             * Issues
             * @description List of identified issues with the monitoring stack
             */
            issues?: string[];
            /** @description Metrics collection status */
            metrics_collection: components["schemas"]["MetricsCollectionStatus"];
            /**
             * Prometheus Reachable
             * @description Whether Prometheus server is reachable
             */
            prometheus_reachable: boolean;
            /**
             * Prometheus Url
             * @description Configured Prometheus server URL
             */
            prometheus_url: string;
            /**
             * Targets Summary
             * @description Summary of target health by job
             */
            targets_summary: components["schemas"]["JobTargetSummary"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of health check
             */
            timestamp: string;
        };
        /**
         * MonitoringTargetsResponse
         * @description Response schema for detailed monitoring targets endpoint.
         *
         *     Returns complete information about all Prometheus scrape targets
         *     including their health status, labels, and scrape timing.
         * @example {
         *       "down": 0,
         *       "jobs": [
         *         "hsi-backend-metrics",
         *         "redis"
         *       ],
         *       "targets": [
         *         {
         *           "health": "up",
         *           "instance": "backend:8000",
         *           "job": "hsi-backend-metrics",
         *           "labels": {
         *             "service": "home-security-intelligence"
         *           },
         *           "last_scrape": "2026-01-13T10:30:00Z",
         *           "scrape_duration_seconds": 0.025
         *         },
         *         {
         *           "health": "up",
         *           "instance": "redis-exporter:9121",
         *           "job": "redis",
         *           "labels": {},
         *           "last_scrape": "2026-01-13T10:30:00Z",
         *           "scrape_duration_seconds": 0.015
         *         }
         *       ],
         *       "timestamp": "2026-01-13T10:30:00Z",
         *       "total": 2,
         *       "up": 2
         *     }
         */
        MonitoringTargetsResponse: {
            /**
             * Down
             * @description Number of targets that are down
             */
            down: number;
            /**
             * Jobs
             * @description List of unique job names
             */
            jobs: string[];
            /**
             * Targets
             * @description Detailed status of all scrape targets
             */
            targets: components["schemas"]["TargetHealth"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of targets query
             */
            timestamp: string;
            /**
             * Total
             * @description Total number of targets
             */
            total: number;
            /**
             * Up
             * @description Number of targets that are up
             */
            up: number;
        };
        /**
         * MovementMetrics
         * @description Calculated movement metrics for a track.
         *
         *     Aggregated statistics computed from the track's trajectory points,
         *     useful for behavioral analysis and anomaly detection.
         * @example {
         *       "avg_speed": 45.2,
         *       "direction": 135,
         *       "duration_seconds": 27.7,
         *       "total_distance": 1250.5
         *     }
         */
        MovementMetrics: {
            /**
             * Avg Speed
             * @description Average speed (pixels/second)
             */
            avg_speed: number;
            /**
             * Direction
             * @description Overall direction in degrees (0-360, where 0=right, 90=down)
             */
            direction?: number | null;
            /**
             * Duration Seconds
             * @description Track duration in seconds
             */
            duration_seconds: number;
            /**
             * Total Distance
             * @description Total distance traveled (pixels)
             */
            total_distance: number;
        };
        /**
         * NemotronMetrics
         * @description Metrics for Nemotron LLM.
         * @example {
         *       "context_size": 4096,
         *       "slots_active": 1,
         *       "slots_total": 2,
         *       "status": "healthy"
         *     }
         */
        NemotronMetrics: {
            /**
             * Context Size
             * @description Context window size in tokens
             */
            context_size: number;
            /**
             * Slots Active
             * @description Number of active inference slots
             */
            slots_active: number;
            /**
             * Slots Total
             * @description Total available inference slots
             */
            slots_total: number;
            /**
             * Status
             * @description Health status: healthy, unhealthy, unreachable
             */
            status: string;
        };
        /**
         * NotificationChannel
         * @description Notification channel types.
         * @enum {string}
         */
        NotificationChannel: "email" | "webhook" | "push";
        /**
         * NotificationConfigResponse
         * @description Schema for notification configuration status.
         * @example {
         *       "available_channels": [
         *         "email",
         *         "webhook"
         *       ],
         *       "default_email_recipients": [
         *         "user@example.com"
         *       ],
         *       "default_webhook_url": "https://example.com/webhook",
         *       "email_configured": true,
         *       "notification_enabled": true,
         *       "push_configured": false,
         *       "smtp_from_address": "alerts@example.com",
         *       "smtp_host": "smtp.example.com",
         *       "smtp_port": 587,
         *       "smtp_use_tls": true,
         *       "webhook_configured": true,
         *       "webhook_timeout_seconds": 30
         *     }
         */
        NotificationConfigResponse: {
            /**
             * Available Channels
             * @description List of channels that are properly configured
             */
            available_channels: components["schemas"]["NotificationChannel"][];
            /**
             * Default Email Recipients
             * @description Default email recipients
             */
            default_email_recipients?: string[];
            /**
             * Default Webhook Url
             * @description Default webhook URL
             */
            default_webhook_url?: string | null;
            /**
             * Email Configured
             * @description Whether email (SMTP) is configured
             */
            email_configured: boolean;
            /**
             * Notification Enabled
             * @description Whether notifications are enabled
             */
            notification_enabled: boolean;
            /**
             * Push Configured
             * @description Whether push notifications are configured
             */
            push_configured: boolean;
            /**
             * Smtp From Address
             * @description Configured sender email
             */
            smtp_from_address?: string | null;
            /**
             * Smtp Host
             * @description Configured SMTP host (if any)
             */
            smtp_host?: string | null;
            /**
             * Smtp Port
             * @description Configured SMTP port
             */
            smtp_port?: number | null;
            /**
             * Smtp Use Tls
             * @description Whether TLS is enabled for SMTP
             */
            smtp_use_tls?: boolean | null;
            /**
             * Webhook Configured
             * @description Whether webhook is configured
             */
            webhook_configured: boolean;
            /**
             * Webhook Timeout Seconds
             * @description Webhook request timeout
             */
            webhook_timeout_seconds?: number | null;
        };
        /**
         * NotificationConfigUpdate
         * @description Schema for updating notification configuration.
         *
         *     All fields are optional to support partial updates.
         *     Only specified fields will be updated.
         * @example {
         *       "default_webhook_url": "https://hooks.example.com/webhook",
         *       "smtp_enabled": true,
         *       "smtp_from_address": "alerts@example.com",
         *       "smtp_host": "smtp.example.com",
         *       "smtp_port": 587,
         *       "webhook_enabled": true
         *     }
         */
        NotificationConfigUpdate: {
            /**
             * Default Webhook Url
             * @description Default webhook URL for notifications. Must be HTTPS and not point to private IPs.
             */
            default_webhook_url?: string | null;
            /**
             * Smtp Enabled
             * @description Enable or disable SMTP notifications
             */
            smtp_enabled?: boolean | null;
            /**
             * Smtp From Address
             * @description Sender email address for notifications
             */
            smtp_from_address?: string | null;
            /**
             * Smtp Host
             * @description SMTP server hostname
             */
            smtp_host?: string | null;
            /**
             * Smtp Port
             * @description SMTP server port (1-65535)
             */
            smtp_port?: number | null;
            /**
             * Webhook Enabled
             * @description Enable or disable webhook notifications
             */
            webhook_enabled?: boolean | null;
        };
        /**
         * NotificationConfigUpdateResponse
         * @description Schema for notification configuration update response.
         *
         *     Returns the full configuration state after the update.
         * @example {
         *       "default_webhook_url": "https://hooks.example.com/webhook",
         *       "message": "Configuration updated successfully",
         *       "smtp_enabled": true,
         *       "smtp_from_address": "alerts@example.com",
         *       "smtp_host": "smtp.example.com",
         *       "smtp_port": 587,
         *       "webhook_enabled": true
         *     }
         */
        NotificationConfigUpdateResponse: {
            /**
             * Default Webhook Url
             * @description Default webhook URL
             */
            default_webhook_url?: string | null;
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
            /**
             * Smtp Enabled
             * @description Whether SMTP notifications are enabled
             */
            smtp_enabled: boolean;
            /**
             * Smtp From Address
             * @description Configured sender email
             */
            smtp_from_address?: string | null;
            /**
             * Smtp Host
             * @description Configured SMTP host
             */
            smtp_host?: string | null;
            /**
             * Smtp Port
             * @description Configured SMTP port
             */
            smtp_port?: number | null;
            /**
             * Webhook Enabled
             * @description Whether webhook notifications are enabled
             */
            webhook_enabled: boolean;
        };
        /**
         * NotificationHistoryEntry
         * @description Schema for a notification history entry.
         * @example {
         *       "alert_id": "550e8400-e29b-41d4-a716-446655440001",
         *       "channel": "email",
         *       "created_at": "2025-12-28T12:00:29Z",
         *       "delivered_at": "2025-12-28T12:00:30Z",
         *       "id": "550e8400-e29b-41d4-a716-446655440002",
         *       "recipient": "user@example.com",
         *       "success": true
         *     }
         */
        NotificationHistoryEntry: {
            /**
             * Alert Id
             * @description Associated alert ID
             */
            alert_id: string;
            /** @description Notification channel */
            channel: components["schemas"]["NotificationChannel"];
            /**
             * Created At
             * Format: date-time
             * @description Record creation timestamp
             */
            created_at: string;
            /**
             * Delivered At
             * @description Delivery timestamp
             */
            delivered_at?: string | null;
            /**
             * Error
             * @description Error message if failed
             */
            error?: string | null;
            /**
             * Id
             * @description Notification delivery ID
             */
            id: string;
            /**
             * Recipient
             * @description Recipient identifier
             */
            recipient?: string | null;
            /**
             * Success
             * @description Whether delivery was successful
             */
            success: boolean;
        };
        /**
         * NotificationHistoryResponse
         * @description Schema for notification history list response.
         * @example {
         *       "count": 1,
         *       "entries": [
         *         {
         *           "alert_id": "550e8400-e29b-41d4-a716-446655440001",
         *           "channel": "email",
         *           "created_at": "2025-12-28T12:00:29Z",
         *           "delivered_at": "2025-12-28T12:00:30Z",
         *           "id": "550e8400-e29b-41d4-a716-446655440002",
         *           "recipient": "user@example.com",
         *           "success": true
         *         }
         *       ],
         *       "limit": 50,
         *       "offset": 0
         *     }
         */
        NotificationHistoryResponse: {
            /**
             * Count
             * @description Total number of entries matching filters
             */
            count: number;
            /**
             * Entries
             * @description Notification history entries
             */
            entries: components["schemas"]["NotificationHistoryEntry"][];
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
        };
        /**
         * NotificationPreferencesResponse
         * @description Schema for notification preferences response.
         * @example {
         *       "enabled": true,
         *       "id": 1,
         *       "risk_filters": [
         *         "critical",
         *         "high",
         *         "medium"
         *       ],
         *       "sound": "default"
         *     }
         */
        NotificationPreferencesResponse: {
            /**
             * Enabled
             * @description Whether notifications are globally enabled
             */
            enabled: boolean;
            /**
             * Id
             * @description Preferences ID (always 1, singleton)
             * @default 1
             */
            id: number;
            /**
             * Risk Filters
             * @description Risk levels that trigger notifications (critical, high, medium, low)
             */
            risk_filters: string[];
            /**
             * Sound
             * @description Notification sound (none, default, alert, chime, urgent)
             */
            sound: string;
        };
        /**
         * NotificationPreferencesUpdate
         * @description Schema for updating notification preferences.
         * @example {
         *       "enabled": true,
         *       "risk_filters": [
         *         "critical",
         *         "high"
         *       ],
         *       "sound": "alert"
         *     }
         */
        NotificationPreferencesUpdate: {
            /**
             * Enabled
             * @description Whether notifications are globally enabled
             */
            enabled?: boolean | null;
            /**
             * Risk Filters
             * @description Risk levels that trigger notifications (critical, high, medium, low)
             */
            risk_filters?: string[] | null;
            /**
             * Sound
             * @description Notification sound (none, default, alert, chime, urgent)
             */
            sound?: string | null;
        };
        /**
         * ObjectBaseline
         * @description Baseline statistics for a specific object class.
         * @example {
         *       "avg_hourly": 2.3,
         *       "peak_hour": 17,
         *       "total_detections": 550
         *     }
         */
        ObjectBaseline: {
            /**
             * Avg Hourly
             * @description Average hourly detection count for this object type
             */
            avg_hourly: number;
            /**
             * Peak Hour
             * @description Hour with most detections of this type (0-23)
             */
            peak_hour: number;
            /**
             * Total Detections
             * @description Total detections of this type in the baseline period
             */
            total_detections: number;
        };
        /**
         * ObjectClassDistributionItem
         * @description Schema for a single object class distribution item (for Grafana compatibility).
         * @example {
         *       "count": 23,
         *       "object_class": "person"
         *     }
         */
        ObjectClassDistributionItem: {
            /**
             * Count
             * @description Number of detections of this class
             */
            count: number;
            /**
             * Object Class
             * @description Object class name (e.g., person, car)
             */
            object_class: string;
        };
        /**
         * ObjectDistributionDataPoint
         * @description Schema for a single object distribution data point.
         * @example {
         *       "count": 120,
         *       "object_type": "person",
         *       "percentage": 45.5
         *     }
         */
        ObjectDistributionDataPoint: {
            /**
             * Count
             * @description Number of detections for this object type
             */
            count: number;
            /**
             * Object Type
             * @description Detected object type (e.g., 'person', 'car')
             */
            object_type: string;
            /**
             * Percentage
             * @description Percentage of total detections (0-100)
             */
            percentage: number;
        };
        /**
         * ObjectDistributionResponse
         * @description Schema for detection counts by object type.
         * @example {
         *       "end_date": "2025-01-07",
         *       "object_types": [
         *         {
         *           "count": 120,
         *           "object_type": "person",
         *           "percentage": 45.5
         *         },
         *         {
         *           "count": 80,
         *           "object_type": "car",
         *           "percentage": 30.3
         *         },
         *         {
         *           "count": 64,
         *           "object_type": "dog",
         *           "percentage": 24.2
         *         }
         *       ],
         *       "start_date": "2025-01-01",
         *       "total_detections": 264
         *     }
         */
        ObjectDistributionResponse: {
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Object Types
             * @description Detection counts by object type
             */
            object_types: components["schemas"]["ObjectDistributionDataPoint"][];
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
            /**
             * Total Detections
             * @description Total detections in date range
             */
            total_detections: number;
        };
        /**
         * OldestJobInfo
         * @description Information about the oldest job in a queue.
         * @example {
         *       "id": "job_12345",
         *       "queued_at": "2025-12-23T10:30:00.000000",
         *       "wait_seconds": 45.2
         *     }
         */
        OldestJobInfo: {
            /**
             * Id
             * @description Job identifier (if available)
             */
            id?: string | null;
            /**
             * Queued At
             * @description Timestamp when the job was queued
             */
            queued_at?: string | null;
            /**
             * Wait Seconds
             * @description How long the oldest job has been waiting in seconds
             */
            wait_seconds: number;
        };
        /**
         * OrphanCleanupRequest
         * @description Request schema for orphan cleanup endpoint.
         */
        OrphanCleanupRequest: {
            /**
             * Dry Run
             * @description If True, only report what would be deleted without actually deleting
             * @default true
             */
            dry_run: boolean;
            /**
             * Max Delete Gb
             * @description Maximum gigabytes to delete in one run (0.1-100)
             * @default 10
             */
            max_delete_gb: number;
            /**
             * Min Age Hours
             * @description Minimum age in hours before a file can be deleted (1-720)
             * @default 24
             */
            min_age_hours: number;
        };
        /**
         * OrphanCleanupResponse
         * @description Response schema for orphan cleanup endpoint.
         */
        OrphanCleanupResponse: {
            /** Deleted Bytes */
            deleted_bytes: number;
            /** Deleted Bytes Formatted */
            deleted_bytes_formatted: string;
            /** Deleted Files */
            deleted_files: number;
            /** Dry Run */
            dry_run: boolean;
            /** Duration Seconds */
            duration_seconds: number;
            /** Failed Count */
            failed_count: number;
            /** Failed Deletions */
            failed_deletions: string[];
            /** Orphaned Files */
            orphaned_files: number;
            /** Scanned Files */
            scanned_files: number;
            /** Skipped Size Limit */
            skipped_size_limit: number;
            /** Skipped Young */
            skipped_young: number;
        };
        /**
         * OrphanedFileCleanupResponse
         * @description Response schema for orphaned file cleanup endpoint.
         *
         *     Returns statistics about orphaned files found (and optionally deleted).
         *     Orphaned files are files on disk not referenced in the database.
         * @example {
         *       "dry_run": true,
         *       "job_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "orphaned_count": 25,
         *       "orphaned_files": [
         *         "/data/thumbnails/orphaned1.jpg",
         *         "/data/thumbnails/orphaned2.jpg"
         *       ],
         *       "timestamp": "2025-12-30T10:30:00Z",
         *       "total_size": 524288000,
         *       "total_size_formatted": "500.00 MB"
         *     }
         */
        OrphanedFileCleanupResponse: {
            /**
             * Dry Run
             * @description Whether this was a dry run (no actual deletion performed)
             */
            dry_run: boolean;
            /**
             * Job Id
             * @description Background job ID for tracking progress
             */
            job_id?: string | null;
            /**
             * Orphaned Count
             * @description Number of orphaned files found (or deleted if dry_run=False)
             */
            orphaned_count: number;
            /**
             * Orphaned Files
             * @description List of orphaned file paths (limited to first 100)
             */
            orphaned_files?: string[];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of cleanup operation
             */
            timestamp: string;
            /**
             * Total Size
             * @description Total size of orphaned files in bytes
             */
            total_size: number;
            /**
             * Total Size Formatted
             * @description Human-readable total size (e.g., '1.5 GB')
             */
            total_size_formatted: string;
        };
        /**
         * PaginationInfo
         * @description Pagination metadata for list responses (NEM-2075).
         *
         *     Standard pagination envelope used by entities and other list endpoints.
         *     Supports both cursor-based pagination (recommended) and offset pagination.
         */
        PaginationInfo: {
            /**
             * Cursor
             * @description Current cursor position
             */
            cursor?: string | null;
            /**
             * Has More
             * @description Whether more results are available
             * @default false
             */
            has_more: boolean;
            /**
             * Limit
             * @description Page size (1-1000)
             */
            limit: number;
            /**
             * Next Cursor
             * @description Cursor for next page
             */
            next_cursor?: string | null;
            /**
             * Offset
             * @description Page offset (0-based, for offset pagination)
             */
            offset?: number | null;
            /**
             * Total
             * @description Total count matching filters
             */
            total: number;
        };
        /**
         * PaginationMeta
         * @description Pagination metadata for list responses.
         *
         *     Contains information about the current page and total results.
         *     Supports both offset-based and cursor-based pagination.
         * @example {
         *       "has_more": true,
         *       "limit": 50,
         *       "next_cursor": "eyJpZCI6IDUwfQ",
         *       "offset": 0,
         *       "total": 150
         *     }
         */
        PaginationMeta: {
            /**
             * Cursor
             * @description Current cursor position (cursor-based pagination)
             */
            cursor?: string | null;
            /**
             * Has More
             * @description Whether more items are available beyond this page
             */
            has_more: boolean;
            /**
             * Limit
             * @description Maximum number of items returned per page
             */
            limit: number;
            /**
             * Next Cursor
             * @description Cursor for the next page of results
             */
            next_cursor?: string | null;
            /**
             * Offset
             * @description Number of items skipped (offset-based pagination)
             */
            offset?: number | null;
            /**
             * Total
             * @description Total number of items matching the query
             */
            total: number;
        };
        /**
         * PerformanceAlert
         * @description Alert when metric exceeds threshold.
         * @example {
         *       "message": "GPU temperature high: 82C",
         *       "metric": "gpu_temperature",
         *       "severity": "warning",
         *       "threshold": 80,
         *       "value": 82
         *     }
         */
        PerformanceAlert: {
            /**
             * Message
             * @description Human-readable alert message
             */
            message: string;
            /**
             * Metric
             * @description Metric name that triggered the alert
             */
            metric: string;
            /**
             * Severity
             * @description Alert severity: warning or critical
             */
            severity: string;
            /**
             * Threshold
             * @description Threshold that was exceeded
             */
            threshold: number;
            /**
             * Value
             * @description Current metric value
             */
            value: number;
        };
        /**
         * PerformanceHistoryResponse
         * @description Response containing historical performance data.
         *
         *     Used by GET /api/system/performance/history endpoint.
         * @example {
         *       "count": 0,
         *       "snapshots": [],
         *       "time_range": "5m"
         *     }
         */
        PerformanceHistoryResponse: {
            /**
             * Count
             * @description Number of snapshots returned
             */
            count: number;
            /**
             * Snapshots
             * @description List of performance snapshots ordered chronologically
             */
            snapshots: components["schemas"]["PerformanceUpdate"][];
            /** @description Time range of the history */
            time_range: components["schemas"]["TimeRange"];
        };
        /**
         * PerformanceUpdate
         * @description Complete performance update sent via WebSocket.
         *
         *     This is the main payload broadcast to frontend clients every 5 seconds.
         *     All fields are optional to allow partial updates.
         * @example {
         *       "ai_models": {
         *         "yolo26": {
         *           "device": "cuda:0",
         *           "model": "yolo26",
         *           "status": "healthy",
         *           "vram_gb": 0.17
         *         }
         *       },
         *       "alerts": [],
         *       "gpu": {
         *         "name": "NVIDIA RTX A5500",
         *         "power_watts": 31,
         *         "temperature": 38,
         *         "utilization": 38,
         *         "vram_total_gb": 24,
         *         "vram_used_gb": 22.7
         *       },
         *       "host": {
         *         "cpu_percent": 12,
         *         "disk_total_gb": 500,
         *         "disk_used_gb": 156,
         *         "ram_total_gb": 32,
         *         "ram_used_gb": 8.2
         *       },
         *       "timestamp": "2025-12-31T10:30:00Z"
         *     }
         */
        PerformanceUpdate: {
            /**
             * Ai Models
             * @description AI model metrics keyed by model name
             */
            ai_models?: {
                [key: string]: components["schemas"]["AiModelMetrics"] | components["schemas"]["NemotronMetrics"];
            };
            /**
             * Alerts
             * @description Active performance alerts
             */
            alerts?: components["schemas"]["PerformanceAlert"][];
            /**
             * Containers
             * @description Container health statuses
             */
            containers?: components["schemas"]["ContainerMetrics"][];
            /**
             * Databases
             * @description Database metrics keyed by name
             */
            databases?: {
                [key: string]: components["schemas"]["DatabaseMetrics"] | components["schemas"]["RedisMetrics"];
            };
            /** @description GPU metrics */
            gpu?: components["schemas"]["GpuMetrics"] | null;
            /** @description Host system metrics */
            host?: components["schemas"]["HostMetrics"] | null;
            /** @description AI inference latency and throughput */
            inference?: components["schemas"]["InferenceMetrics"] | null;
            /** @description Nemotron-specific metrics */
            nemotron?: components["schemas"]["NemotronMetrics"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description When this update was generated (UTC)
             */
            timestamp?: string;
        };
        /**
         * PersonEmbeddingResponse
         * @description Schema for person embedding response.
         * @example {
         *       "confidence": 0.95,
         *       "created_at": "2025-01-01T10:00:00Z",
         *       "id": 1,
         *       "member_id": 1,
         *       "source_event_id": 100
         *     }
         */
        PersonEmbeddingResponse: {
            /**
             * Confidence
             * @description Reliability score (0-1)
             */
            confidence: number;
            /**
             * Created At
             * Format: date-time
             * @description When the embedding was created
             */
            created_at: string;
            /**
             * Id
             * @description Unique identifier for the embedding
             */
            id: number;
            /**
             * Member Id
             * @description ID of the associated household member
             */
            member_id: number;
            /**
             * Source Event Id
             * @description Event ID where embedding was captured
             */
            source_event_id?: number | null;
        };
        /**
         * PetEnrichment
         * @description Pet classification results for false positive reduction.
         * @example {
         *       "confidence": 0.94,
         *       "detected": true,
         *       "is_household_pet": true,
         *       "type": "dog"
         *     }
         */
        PetEnrichment: {
            /**
             * Confidence
             * @description Classification confidence
             */
            confidence?: number | null;
            /**
             * Detected
             * @description Whether a pet was detected
             * @default false
             */
            detected: boolean;
            /**
             * Is Household Pet
             * @description Whether classified as household pet
             */
            is_household_pet?: boolean | null;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
            /**
             * Type
             * @description Pet type (cat, dog)
             */
            type?: string | null;
        };
        /**
         * PipelineErrorsResponse
         * @description Response for pipeline errors retrieval.
         */
        PipelineErrorsResponse: {
            /**
             * Errors
             * @description List of recent pipeline errors
             */
            errors: components["schemas"]["RecentError"][];
            /**
             * Limit
             * @description Maximum errors requested
             */
            limit: number;
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
            /**
             * Total
             * @description Total number of errors returned
             */
            total: number;
        };
        /**
         * PipelineLatencies
         * @description Latency statistics for all pipeline stages.
         *
         *     Pipeline stages:
         *     - watch: File watcher detecting new images (file event -> queue)
         *     - detect: YOLO26v2 object detection (image -> detections)
         *     - batch: Batch aggregation window (detections -> batch)
         *     - analyze: Nemotron LLM risk analysis (batch -> event)
         * @example {
         *       "analyze": {
         *         "avg_ms": 5000,
         *         "max_ms": 15000,
         *         "min_ms": 2000,
         *         "p50_ms": 4500,
         *         "p95_ms": 12000,
         *         "p99_ms": 14000,
         *         "sample_count": 100
         *       },
         *       "batch": {
         *         "avg_ms": 30000,
         *         "max_ms": 90000,
         *         "min_ms": 5000,
         *         "p50_ms": 25000,
         *         "p95_ms": 80000,
         *         "p99_ms": 88000,
         *         "sample_count": 100
         *       },
         *       "detect": {
         *         "avg_ms": 200,
         *         "max_ms": 800,
         *         "min_ms": 100,
         *         "p50_ms": 180,
         *         "p95_ms": 600,
         *         "p99_ms": 750,
         *         "sample_count": 500
         *       },
         *       "watch": {
         *         "avg_ms": 10,
         *         "max_ms": 50,
         *         "min_ms": 5,
         *         "p50_ms": 8,
         *         "p95_ms": 40,
         *         "p99_ms": 48,
         *         "sample_count": 500
         *       }
         *     }
         */
        PipelineLatencies: {
            /** @description LLM analysis stage latency (Nemotron inference) */
            analyze?: components["schemas"]["StageLatency"] | null;
            /** @description Batch aggregation window time */
            batch?: components["schemas"]["StageLatency"] | null;
            /** @description Object detection stage latency (YOLO26v2 inference) */
            detect?: components["schemas"]["StageLatency"] | null;
            /** @description File watcher stage latency (file event to queue) */
            watch?: components["schemas"]["StageLatency"] | null;
        };
        /**
         * PipelineLatencyHistoryResponse
         * @description Response schema for pipeline latency history endpoint.
         *
         *     Provides time-series latency data for charting and trend analysis.
         *     Each snapshot contains aggregated metrics for a time bucket.
         * @example {
         *       "bucket_seconds": 60,
         *       "snapshots": [
         *         {
         *           "stages": {
         *             "watch_to_detect": {
         *               "avg_ms": 50,
         *               "p50_ms": 45,
         *               "p95_ms": 120,
         *               "p99_ms": 150,
         *               "sample_count": 15
         *             }
         *           },
         *           "timestamp": "2025-12-28T10:00:00+00:00"
         *         }
         *       ],
         *       "timestamp": "2025-12-28T10:30:00Z",
         *       "window_minutes": 60
         *     }
         */
        PipelineLatencyHistoryResponse: {
            /**
             * Bucket Seconds
             * @description Bucket size for aggregation
             */
            bucket_seconds: number;
            /**
             * Snapshots
             * @description Chronologically ordered latency snapshots
             */
            snapshots: components["schemas"]["LatencyHistorySnapshot"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp when history was retrieved
             */
            timestamp: string;
            /**
             * Window Minutes
             * @description Time window covered by the history
             */
            window_minutes: number;
        };
        /**
         * PipelineLatencyResponse
         * @description Response schema for pipeline latency endpoint.
         *
         *     Provides latency metrics for each stage transition in the AI pipeline:
         *     - watch_to_detect: Time from file watcher detecting image to YOLO26 processing start
         *     - detect_to_batch: Time from detection completion to batch aggregation
         *     - batch_to_analyze: Time from batch completion to Nemotron analysis start
         *     - total_pipeline: Total end-to-end processing time
         * @example {
         *       "batch_to_analyze": {
         *         "avg_ms": 5000,
         *         "max_ms": 15000,
         *         "min_ms": 2000,
         *         "p50_ms": 4500,
         *         "p95_ms": 12000,
         *         "p99_ms": 14000,
         *         "sample_count": 100
         *       },
         *       "detect_to_batch": {
         *         "avg_ms": 100,
         *         "max_ms": 500,
         *         "min_ms": 20,
         *         "p50_ms": 80,
         *         "p95_ms": 400,
         *         "p99_ms": 480,
         *         "sample_count": 500
         *       },
         *       "timestamp": "2025-12-28T10:30:00Z",
         *       "total_pipeline": {
         *         "avg_ms": 35000,
         *         "max_ms": 120000,
         *         "min_ms": 10000,
         *         "p50_ms": 30000,
         *         "p95_ms": 100000,
         *         "p99_ms": 110000,
         *         "sample_count": 100
         *       },
         *       "watch_to_detect": {
         *         "avg_ms": 50,
         *         "max_ms": 200,
         *         "min_ms": 10,
         *         "p50_ms": 40,
         *         "p95_ms": 150,
         *         "p99_ms": 180,
         *         "sample_count": 500
         *       },
         *       "window_minutes": 60
         *     }
         */
        PipelineLatencyResponse: {
            /** @description Latency from batch to Nemotron analysis */
            batch_to_analyze?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Latency from detection to batch aggregation */
            detect_to_batch?: components["schemas"]["PipelineStageLatency"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of latency snapshot
             */
            timestamp: string;
            /** @description Total end-to-end pipeline latency */
            total_pipeline?: components["schemas"]["PipelineStageLatency"] | null;
            /** @description Latency from file detection to YOLO26 processing */
            watch_to_detect?: components["schemas"]["PipelineStageLatency"] | null;
            /**
             * Window Minutes
             * @description Time window used for calculating statistics
             */
            window_minutes: number;
        };
        /**
         * PipelineStageLatency
         * @description Latency statistics for a single pipeline transition stage.
         *
         *     Tracks time between pipeline stages:
         *     - watch_to_detect: File detection to YOLO26 processing
         *     - detect_to_batch: Detection to batch aggregation
         *     - batch_to_analyze: Batch to Nemotron analysis
         *     - total_pipeline: End-to-end latency
         * @example {
         *       "avg_ms": 150.5,
         *       "max_ms": 500,
         *       "min_ms": 50,
         *       "p50_ms": 120,
         *       "p95_ms": 400,
         *       "p99_ms": 480,
         *       "sample_count": 100
         *     }
         */
        PipelineStageLatency: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms?: number | null;
            /**
             * Max Ms
             * @description Maximum latency in milliseconds
             */
            max_ms?: number | null;
            /**
             * Min Ms
             * @description Minimum latency in milliseconds
             */
            min_ms?: number | null;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms?: number | null;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms?: number | null;
            /**
             * P99 Ms
             * @description 99th percentile latency in milliseconds
             */
            p99_ms?: number | null;
            /**
             * Sample Count
             * @description Number of samples used to calculate statistics
             */
            sample_count: number;
        };
        /**
         * PipelineStateResponse
         * @description Response for pipeline state inspection.
         */
        PipelineStateResponse: {
            /**
             * Correlation Id
             * @description Correlation ID from request
             */
            correlation_id?: string | null;
            /** @description Current queue depths */
            queue_depths: components["schemas"]["QueueDepths"];
            /**
             * Recent Errors
             * @description Recent errors (last 10)
             */
            recent_errors?: components["schemas"]["RecentError"][];
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
            /** @description Worker status */
            workers: components["schemas"]["PipelineWorkersStatus"];
        };
        /**
         * PipelineStatusResponse
         * @description Combined status of all pipeline operations.
         *
         *     Provides visibility into:
         *     - FileWatcher: Monitoring camera directories for new uploads
         *     - BatchAggregator: Grouping detections into time-based batches
         *     - DegradationManager: Graceful degradation and service health
         * @example {
         *       "batch_aggregator": {
         *         "active_batches": 1,
         *         "batch_window_seconds": 90,
         *         "batches": [],
         *         "idle_timeout_seconds": 30
         *       },
         *       "degradation": {
         *         "available_features": [
         *           "detection",
         *           "analysis",
         *           "events",
         *           "media"
         *         ],
         *         "fallback_queues": {},
         *         "is_degraded": false,
         *         "memory_queue_size": 0,
         *         "mode": "normal",
         *         "redis_healthy": true,
         *         "services": []
         *       },
         *       "file_watcher": {
         *         "camera_root": "/export/foscam",
         *         "observer_type": "native",
         *         "pending_tasks": 0,
         *         "running": true
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        PipelineStatusResponse: {
            /** @description BatchAggregator service status (null if not running) */
            batch_aggregator?: components["schemas"]["BatchAggregatorStatusResponse"] | null;
            /** @description DegradationManager service status (null if not initialized) */
            degradation?: components["schemas"]["DegradationStatusResponse"] | null;
            /** @description FileWatcher service status (null if not running) */
            file_watcher?: components["schemas"]["FileWatcherStatusResponse"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * PipelineWorkerStatus
         * @description Status of a pipeline worker.
         */
        PipelineWorkerStatus: {
            /**
             * Error Count
             * @description Number of recent errors
             * @default 0
             */
            error_count: number;
            /**
             * Last Activity
             * @description ISO timestamp of last activity
             */
            last_activity?: string | null;
            /**
             * Name
             * @description Worker name
             */
            name: string;
            /**
             * Running
             * @description Whether worker is currently running
             */
            running: boolean;
        };
        /**
         * PipelineWorkersStatus
         * @description Status of all pipeline workers.
         */
        PipelineWorkersStatus: {
            /** @description Analyzer worker status */
            analyzer: components["schemas"]["PipelineWorkerStatus"];
            /** @description Detector worker status */
            detector: components["schemas"]["PipelineWorkerStatus"];
            /** @description File watcher status */
            file_watcher: components["schemas"]["PipelineWorkerStatus"];
        };
        /**
         * PlateReadCreate
         * @description Schema for creating a new plate read record.
         *
         *     Used when manually creating plate reads via the API (e.g., from
         *     external ALPR systems or manual entry).
         * @example {
         *       "bbox": [
         *         100,
         *         200,
         *         250,
         *         240
         *       ],
         *       "camera_id": "driveway",
         *       "detection_confidence": 0.95,
         *       "image_quality_score": 0.85,
         *       "is_blurry": false,
         *       "is_enhanced": false,
         *       "ocr_confidence": 0.92,
         *       "plate_text": "ABC1234",
         *       "raw_text": "ABC-1234",
         *       "timestamp": "2026-01-26T14:30:00Z"
         *     }
         */
        PlateReadCreate: {
            /**
             * Bbox
             * @description Bounding box [x1, y1, x2, y2]
             */
            bbox: number[];
            /**
             * Camera Id
             * @description Camera ID where plate was detected
             */
            camera_id: string;
            /**
             * Detection Confidence
             * @description Plate detection confidence (0-1)
             */
            detection_confidence: number;
            /**
             * Image Quality Score
             * @description Image quality assessment (0-1)
             */
            image_quality_score: number;
            /**
             * Is Blurry
             * @description Whether motion blur was detected
             * @default false
             */
            is_blurry: boolean;
            /**
             * Is Enhanced
             * @description Whether low-light enhancement was applied
             * @default false
             */
            is_enhanced: boolean;
            /**
             * Ocr Confidence
             * @description Text recognition confidence (0-1)
             */
            ocr_confidence: number;
            /**
             * Plate Text
             * @description Recognized plate text (alphanumeric only)
             */
            plate_text: string;
            /**
             * Raw Text
             * @description Raw OCR output before filtering
             */
            raw_text: string;
            /**
             * Timestamp
             * Format: date-time
             * @description Detection timestamp
             */
            timestamp: string;
        };
        /**
         * PlateReadListResponse
         * @description Paginated list of plate reads.
         *
         *     Standard pagination envelope for plate read list endpoints.
         * @example {
         *       "page": 1,
         *       "page_size": 50,
         *       "plate_reads": [
         *         {
         *           "bbox": [
         *             100,
         *             200,
         *             250,
         *             240
         *           ],
         *           "camera_id": "driveway",
         *           "created_at": "2026-01-26T14:30:05Z",
         *           "detection_confidence": 0.95,
         *           "id": 1,
         *           "image_quality_score": 0.85,
         *           "is_blurry": false,
         *           "is_enhanced": false,
         *           "ocr_confidence": 0.92,
         *           "plate_text": "ABC1234",
         *           "raw_text": "ABC-1234",
         *           "timestamp": "2026-01-26T14:30:00Z"
         *         }
         *       ],
         *       "total": 1
         *     }
         */
        PlateReadListResponse: {
            /**
             * Page
             * @description Current page number (1-indexed)
             */
            page: number;
            /**
             * Page Size
             * @description Number of items per page
             */
            page_size: number;
            /**
             * Plate Reads
             * @description List of plate reads
             */
            plate_reads: components["schemas"]["PlateReadResponse"][];
            /**
             * Total
             * @description Total number of plate reads matching query
             */
            total: number;
        };
        /**
         * PlateReadResponse
         * @description Response schema for a plate read record.
         *
         *     Includes the database ID for reference and linking.
         * @example {
         *       "bbox": [
         *         100,
         *         200,
         *         250,
         *         240
         *       ],
         *       "camera_id": "driveway",
         *       "created_at": "2026-01-26T14:30:05Z",
         *       "detection_confidence": 0.95,
         *       "id": 1,
         *       "image_quality_score": 0.85,
         *       "is_blurry": false,
         *       "is_enhanced": false,
         *       "ocr_confidence": 0.92,
         *       "plate_text": "ABC1234",
         *       "raw_text": "ABC-1234",
         *       "timestamp": "2026-01-26T14:30:00Z"
         *     }
         */
        PlateReadResponse: {
            /**
             * Bbox
             * @description Bounding box [x1, y1, x2, y2]
             */
            bbox: number[];
            /**
             * Camera Id
             * @description Camera ID where plate was detected
             */
            camera_id: string;
            /**
             * Created At
             * Format: date-time
             * @description Record creation timestamp
             */
            created_at: string;
            /**
             * Detection Confidence
             * @description Plate detection confidence (0-1)
             */
            detection_confidence: number;
            /**
             * Id
             * @description Database record ID
             */
            id: number;
            /**
             * Image Quality Score
             * @description Image quality assessment (0-1)
             */
            image_quality_score: number;
            /**
             * Is Blurry
             * @description Whether motion blur was detected
             * @default false
             */
            is_blurry: boolean;
            /**
             * Is Enhanced
             * @description Whether low-light enhancement was applied
             * @default false
             */
            is_enhanced: boolean;
            /**
             * Ocr Confidence
             * @description Text recognition confidence (0-1)
             */
            ocr_confidence: number;
            /**
             * Plate Text
             * @description Recognized plate text (alphanumeric only)
             */
            plate_text: string;
            /**
             * Raw Text
             * @description Raw OCR output before filtering
             */
            raw_text: string;
            /**
             * Timestamp
             * Format: date-time
             * @description Detection timestamp
             */
            timestamp: string;
        };
        /**
         * PlateRecognizeRequest
         * @description Request schema for plate recognition from image data.
         *
         *     Used for the /recognize endpoint to extract plate text from
         *     uploaded images or base64-encoded image data.
         * @example {
         *       "camera_id": "driveway",
         *       "detection_bbox": [
         *         100,
         *         200,
         *         250,
         *         240
         *       ],
         *       "detection_confidence": 0.95,
         *       "image_base64": "data:image/jpeg;base64,/9j/4AAQSkZ..."
         *     }
         */
        PlateRecognizeRequest: {
            /**
             * Camera Id
             * @description Camera ID for the source image
             */
            camera_id: string;
            /**
             * Detection Bbox
             * @description Optional bounding box for plate region [x1, y1, x2, y2]
             */
            detection_bbox?: number[] | null;
            /**
             * Detection Confidence
             * @description Detection confidence from upstream detector
             * @default 1
             */
            detection_confidence: number;
            /**
             * Image Base64
             * @description Base64-encoded image data (JPEG or PNG)
             */
            image_base64: string;
        };
        /**
         * PlateRecognizeResponse
         * @description Response schema for plate recognition request.
         *
         *     Returns the recognized plate text and confidence metrics
         *     without storing to database (for preview/testing).
         * @example {
         *       "image_quality_score": 0.85,
         *       "is_blurry": false,
         *       "is_enhanced": false,
         *       "ocr_confidence": 0.92,
         *       "plate_read_id": 123,
         *       "plate_text": "ABC1234",
         *       "raw_text": "ABC-1234",
         *       "stored": true
         *     }
         */
        PlateRecognizeResponse: {
            /**
             * Image Quality Score
             * @description Image quality score (0-1)
             */
            image_quality_score: number;
            /**
             * Is Blurry
             * @description Whether motion blur was detected
             */
            is_blurry: boolean;
            /**
             * Is Enhanced
             * @description Whether low-light enhancement was applied
             */
            is_enhanced: boolean;
            /**
             * Ocr Confidence
             * @description OCR confidence (0-1)
             */
            ocr_confidence: number;
            /**
             * Plate Read Id
             * @description Database ID if stored (null if not stored)
             */
            plate_read_id?: number | null;
            /**
             * Plate Text
             * @description Recognized plate text (alphanumeric only)
             */
            plate_text: string;
            /**
             * Raw Text
             * @description Raw OCR output before filtering
             */
            raw_text: string;
            /**
             * Stored
             * @description Whether the read was stored in database
             */
            stored: boolean;
        };
        /**
         * PlateStatisticsResponse
         * @description Statistics for plate recognition performance and activity.
         *
         *     Aggregated metrics for monitoring ALPR system health and usage.
         * @example {
         *       "avg_ocr_confidence": 0.89,
         *       "avg_quality_score": 0.82,
         *       "blurry_count": 45,
         *       "enhanced_count": 127,
         *       "reads_last_24h": 198,
         *       "reads_last_hour": 23,
         *       "total_reads": 1523,
         *       "unique_plates": 342
         *     }
         */
        PlateStatisticsResponse: {
            /**
             * Avg Ocr Confidence
             * @description Average OCR confidence
             */
            avg_ocr_confidence: number;
            /**
             * Avg Quality Score
             * @description Average image quality score
             */
            avg_quality_score: number;
            /**
             * Blurry Count
             * @description Number of reads with motion blur
             */
            blurry_count: number;
            /**
             * Enhanced Count
             * @description Number of reads with low-light enhancement
             */
            enhanced_count: number;
            /**
             * Reads Last 24H
             * @description Reads in the last 24 hours
             */
            reads_last_24h: number;
            /**
             * Reads Last Hour
             * @description Reads in the last hour
             */
            reads_last_hour: number;
            /**
             * Total Reads
             * @description Total number of plate reads
             */
            total_reads: number;
            /**
             * Unique Plates
             * @description Count of unique plate texts
             */
            unique_plates: number;
        };
        /**
         * PolygonZoneCreate
         * @description Schema for creating a new polygon zone.
         *
         *     Requires camera_id to associate the zone with a specific camera.
         * @example {
         *       "alert_threshold": 1,
         *       "camera_id": "front_door",
         *       "color": "#FF0000",
         *       "is_active": true,
         *       "name": "Restricted Area",
         *       "polygon": [
         *         [
         *           100,
         *           100
         *         ],
         *         [
         *           400,
         *           100
         *         ],
         *         [
         *           400,
         *           300
         *         ],
         *         [
         *           100,
         *           300
         *         ]
         *       ],
         *       "target_classes": [
         *         "person"
         *       ],
         *       "zone_type": "restricted"
         *     }
         */
        PolygonZoneCreate: {
            /**
             * Alert Threshold
             * @description Number of objects that trigger an alert (0 = any entry alerts)
             * @default 0
             */
            alert_threshold: number;
            /**
             * Camera Id
             * @description ID of the camera this polygon zone belongs to
             */
            camera_id: string;
            /**
             * Color
             * @description Hex color for UI display
             * @default #FF0000
             */
            color: string;
            /**
             * Is Active
             * @description Whether the zone is actively monitoring
             * @default true
             */
            is_active: boolean;
            /**
             * Name
             * @description Descriptive name for the polygon zone
             */
            name: string;
            /**
             * Polygon
             * @description List of [x, y] points defining the polygon (minimum 3 points)
             */
            polygon: number[][];
            /**
             * Target Classes
             * @description Object classes to monitor in this zone
             */
            target_classes?: string[];
            /**
             * @description Type of zone: restricted, monitored, or entry
             * @default monitored
             */
            zone_type: components["schemas"]["PolygonZoneType"];
        };
        /**
         * PolygonZoneListResponse
         * @description Paginated list of polygon zones.
         * @example {
         *       "total": 1,
         *       "zones": [
         *         {
         *           "alert_threshold": 1,
         *           "camera_id": "front_door",
         *           "color": "#FF0000",
         *           "created_at": "2026-01-26T10:00:00Z",
         *           "current_count": 0,
         *           "id": 1,
         *           "is_active": true,
         *           "name": "Restricted Area",
         *           "polygon": [
         *             [
         *               100,
         *               100
         *             ],
         *             [
         *               400,
         *               100
         *             ],
         *             [
         *               400,
         *               300
         *             ],
         *             [
         *               100,
         *               300
         *             ]
         *           ],
         *           "target_classes": [
         *             "person"
         *           ],
         *           "zone_type": "restricted"
         *         }
         *       ]
         *     }
         */
        PolygonZoneListResponse: {
            /**
             * Total
             * @description Total number of polygon zones
             */
            total: number;
            /**
             * Zones
             * @description List of polygon zones
             */
            zones: components["schemas"]["PolygonZoneResponse"][];
        };
        /**
         * PolygonZoneResponse
         * @description Response schema for a polygon zone.
         *
         *     Includes current occupancy count.
         * @example {
         *       "alert_threshold": 1,
         *       "camera_id": "front_door",
         *       "color": "#FF0000",
         *       "created_at": "2026-01-26T10:00:00Z",
         *       "current_count": 0,
         *       "id": 1,
         *       "is_active": true,
         *       "name": "Restricted Area",
         *       "polygon": [
         *         [
         *           100,
         *           100
         *         ],
         *         [
         *           400,
         *           100
         *         ],
         *         [
         *           400,
         *           300
         *         ],
         *         [
         *           100,
         *           300
         *         ]
         *       ],
         *       "target_classes": [
         *         "person"
         *       ],
         *       "zone_type": "restricted"
         *     }
         */
        PolygonZoneResponse: {
            /**
             * Alert Threshold
             * @description Number of objects that trigger an alert (0 = any entry alerts)
             * @default 0
             */
            alert_threshold: number;
            /**
             * Camera Id
             * @description ID of the camera this zone belongs to
             */
            camera_id: string;
            /**
             * Color
             * @description Hex color for UI display
             * @default #FF0000
             */
            color: string;
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when the zone was created
             */
            created_at: string;
            /**
             * Current Count
             * @description Current object count in zone
             * @default 0
             */
            current_count: number;
            /**
             * Id
             * @description Unique polygon zone identifier
             */
            id: number;
            /**
             * Is Active
             * @description Whether the zone is actively monitoring
             * @default true
             */
            is_active: boolean;
            /**
             * Name
             * @description Descriptive name for the polygon zone
             */
            name: string;
            /**
             * Polygon
             * @description List of [x, y] points defining the polygon (minimum 3 points)
             */
            polygon: number[][];
            /**
             * Target Classes
             * @description Object classes to monitor in this zone
             */
            target_classes?: string[];
            /**
             * @description Type of zone: restricted, monitored, or entry
             * @default monitored
             */
            zone_type: components["schemas"]["PolygonZoneType"];
        };
        /**
         * PolygonZoneType
         * @description Type classification for polygon zones.
         * @enum {string}
         */
        PolygonZoneType: "restricted" | "monitored" | "entry";
        /**
         * PolygonZoneUpdate
         * @description Schema for updating an existing polygon zone.
         *
         *     All fields are optional; only provided fields are updated.
         * @example {
         *       "alert_threshold": 2,
         *       "is_active": false,
         *       "name": "Updated Restricted Area"
         *     }
         */
        PolygonZoneUpdate: {
            /**
             * Alert Threshold
             * @description Number of objects that trigger an alert
             */
            alert_threshold?: number | null;
            /**
             * Color
             * @description Hex color for UI display
             */
            color?: string | null;
            /**
             * Is Active
             * @description Whether the zone is actively monitoring
             */
            is_active?: boolean | null;
            /**
             * Name
             * @description Descriptive name for the polygon zone
             */
            name?: string | null;
            /**
             * Polygon
             * @description List of [x, y] points defining the polygon
             */
            polygon?: number[][] | null;
            /**
             * Target Classes
             * @description Object classes to monitor in this zone
             */
            target_classes?: string[] | null;
            /** @description Type of zone: restricted, monitored, or entry */
            zone_type?: components["schemas"]["PolygonZoneType"] | null;
        };
        /**
         * PoseEnrichment
         * @description Pose estimation results from ViTPose integration.
         * @example {
         *       "alerts": [
         *         "person_crouching"
         *       ],
         *       "confidence": 0.82,
         *       "keypoint_count": 17,
         *       "keypoints": [
         *         [
         *           100,
         *           150,
         *           0.9
         *         ],
         *         [
         *           120,
         *           160,
         *           0.85
         *         ]
         *       ],
         *       "posture": "standing",
         *       "security_alerts": [
         *         "person_crouching"
         *       ]
         *     }
         */
        PoseEnrichment: {
            /**
             * Alerts
             * @description Pose-related security alerts
             */
            alerts?: string[];
            /**
             * Confidence
             * @description Pose estimation confidence
             */
            confidence?: number | null;
            /**
             * Keypoint Count
             * @description Number of detected keypoints
             */
            keypoint_count?: number | null;
            /**
             * Keypoints
             * @description Body keypoints [[x, y, conf], ...]
             */
            keypoints?: number[][] | null;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
            /**
             * Posture
             * @description Detected posture (standing, sitting, etc.)
             */
            posture?: string | null;
            /**
             * Security Alerts
             * @description Backward compatibility alias for alerts
             */
            security_alerts?: string[];
        };
        /**
         * ProfileStartResponse
         * @description Response for starting profiling.
         */
        ProfileStartResponse: {
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Started At
             * @description ISO timestamp when profiling started
             */
            started_at: string;
            /**
             * Status
             * @description Profiling status ('started' or 'already_running')
             */
            status: string;
        };
        /**
         * ProfileStatsResponse
         * @description Response for profiling statistics.
         */
        ProfileStatsResponse: {
            /**
             * Is Profiling
             * @description Whether profiling is currently active
             */
            is_profiling: boolean;
            /**
             * Last Profile Path
             * @description Path to last saved profile
             */
            last_profile_path?: string | null;
            /**
             * Stats Text
             * @description Human-readable profiling statistics
             */
            stats_text?: string | null;
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * ProfileStopResponse
         * @description Response for stopping profiling.
         */
        ProfileStopResponse: {
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Profile Path
             * @description Path to saved profile file
             */
            profile_path?: string | null;
            /**
             * Status
             * @description Profiling status ('stopped' or 'not_running')
             */
            status: string;
            /**
             * Stopped At
             * @description ISO timestamp when profiling stopped
             */
            stopped_at: string;
        };
        /**
         * PrometheusAlertStatus
         * @description Prometheus alert status values.
         * @enum {string}
         */
        PrometheusAlertStatus: "firing" | "resolved";
        /**
         * PromptDiffEntry
         * @description Diff entry for a single model's configuration.
         * @example {
         *       "changes": [
         *         "temperature: 0.7 -> 0.8",
         *         "system_prompt: modified (length: 40 -> 55 chars)"
         *       ],
         *       "current_config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "You are a home security AI...",
         *         "temperature": 0.7
         *       },
         *       "current_version": 3,
         *       "has_changes": true,
         *       "imported_config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "You are a home security AI with enhanced context...",
         *         "temperature": 0.8
         *       },
         *       "model": "nemotron"
         *     }
         */
        PromptDiffEntry: {
            /**
             * Changes
             * @description List of human-readable change descriptions
             */
            changes?: string[];
            /**
             * Current Config
             * @description Current configuration
             */
            current_config?: {
                [key: string]: unknown;
            } | null;
            /**
             * Current Version
             * @description Current version number
             */
            current_version?: number | null;
            /**
             * Has Changes
             * @description Whether there are changes
             */
            has_changes: boolean;
            /**
             * Imported Config
             * @description Configuration to import
             */
            imported_config: {
                [key: string]: unknown;
            };
            /**
             * Model
             * @description Model name
             */
            model: string;
        };
        /**
         * PromptHistoryResponse
         * @description Response containing version history for prompts.
         * @example {
         *       "total_count": 3,
         *       "versions": [
         *         {
         *           "change_description": "Added weather context to prompt",
         *           "created_at": "2026-01-03T10:30:00Z",
         *           "created_by": "admin",
         *           "id": 15,
         *           "is_active": true,
         *           "model": "nemotron",
         *           "version": 3
         *         },
         *         {
         *           "change_description": "Initial configuration",
         *           "created_at": "2026-01-02T14:00:00Z",
         *           "created_by": "system",
         *           "id": 12,
         *           "is_active": false,
         *           "model": "nemotron",
         *           "version": 2
         *         }
         *       ]
         *     }
         */
        PromptHistoryResponse: {
            /** Total Count */
            total_count: number;
            /** Versions */
            versions: components["schemas"]["PromptVersionInfo"][];
        };
        /**
         * PromptImprovements
         * @description Prompt improvement suggestions from self-evaluation.
         * @example {
         *       "confusing_sections": [
         *         "Zone overlap handling unclear"
         *       ],
         *       "format_suggestions": [
         *         "Add structured detection summary"
         *       ],
         *       "missing_context": [
         *         "Time since last motion event",
         *         "Weather conditions"
         *       ],
         *       "model_gaps": [
         *         "Pet detection model not active"
         *       ],
         *       "unused_data": [
         *         "Vehicle color data not utilized"
         *       ]
         *     }
         */
        PromptImprovements: {
            /** Confusing Sections */
            confusing_sections?: string[];
            /** Format Suggestions */
            format_suggestions?: string[];
            /** Missing Context */
            missing_context?: string[];
            /** Model Gaps */
            model_gaps?: string[];
            /** Unused Data */
            unused_data?: string[];
        };
        /**
         * PromptRestoreResponse
         * @description Response after restoring a prompt version.
         * @example {
         *       "message": "Successfully restored version 2 as new version 4",
         *       "model": "nemotron",
         *       "new_version": 4,
         *       "restored_version": 2
         *     }
         */
        PromptRestoreResponse: {
            /** Message */
            message: string;
            model: components["schemas"]["AIModelEnum"];
            /**
             * New Version
             * @description The new active version number
             */
            new_version: number;
            /** Restored Version */
            restored_version: number;
        };
        /**
         * PromptTestRequest
         * @description Request to test a prompt with modified configuration.
         * @example {
         *       "config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "You are a home security AI assistant...",
         *         "temperature": 0.7
         *       },
         *       "event_id": 12345,
         *       "model": "nemotron"
         *     }
         */
        PromptTestRequest: {
            /**
             * Config
             * @description Configuration to test
             */
            config: {
                [key: string]: unknown;
            };
            /**
             * Event Id
             * @description Optional event ID to test against
             */
            event_id?: number | null;
            /**
             * Image Path
             * @description Optional image path to test with
             */
            image_path?: string | null;
            /** @description Model to test */
            model: components["schemas"]["AIModelEnum"];
        };
        /**
         * PromptTestResult
         * @description Result of a prompt test.
         * @example {
         *       "after_response": {
         *         "risk_level": "low",
         *         "risk_score": 45,
         *         "summary": "Regular visitor detected - matches known delivery pattern"
         *       },
         *       "after_score": 45,
         *       "before_response": {
         *         "risk_level": "medium",
         *         "risk_score": 65,
         *         "summary": "Person detected at front door during evening hours"
         *       },
         *       "before_score": 65,
         *       "improved": true,
         *       "model": "nemotron",
         *       "test_duration_ms": 1250
         *     }
         */
        PromptTestResult: {
            /**
             * After Response
             * @description Full response after changes
             */
            after_response?: {
                [key: string]: unknown;
            } | null;
            /**
             * After Score
             * @description Risk score after changes
             */
            after_score?: number | null;
            /**
             * Before Response
             * @description Full response before changes
             */
            before_response?: {
                [key: string]: unknown;
            } | null;
            /**
             * Before Score
             * @description Risk score before changes
             */
            before_score?: number | null;
            /**
             * Error
             * @description Error message if test failed
             */
            error?: string | null;
            /**
             * Improved
             * @description Whether the change improved results
             */
            improved?: boolean | null;
            model: components["schemas"]["AIModelEnum"];
            /**
             * Test Duration Ms
             * @description Test duration in milliseconds
             */
            test_duration_ms: number;
        };
        /**
         * PromptUpdateRequest
         * @description Request to update a model's prompt configuration.
         *
         *     Supports optimistic locking via expected_version field to prevent
         *     race conditions when multiple clients update simultaneously.
         * @example {
         *       "change_description": "Increased temperature for more creative responses",
         *       "config": {
         *         "max_tokens": 2048,
         *         "system_prompt": "You are a home security AI assistant with enhanced context awareness...",
         *         "temperature": 0.8
         *       },
         *       "expected_version": 3
         *     }
         */
        PromptUpdateRequest: {
            /**
             * Change Description
             * @description Optional description of what changed
             */
            change_description?: string | null;
            /**
             * Config
             * @description New configuration for the model
             */
            config: {
                [key: string]: unknown;
            };
            /**
             * Expected Version
             * @description Expected current version for optimistic locking. If provided, the update will fail with 409 Conflict if the current version doesn't match, indicating someone else updated the config concurrently.
             */
            expected_version?: number | null;
        };
        /**
         * PromptVersionInfo
         * @description Information about a single prompt version.
         * @example {
         *       "change_description": "Added weather context to prompt",
         *       "created_at": "2026-01-03T10:30:00Z",
         *       "created_by": "admin",
         *       "id": 15,
         *       "is_active": true,
         *       "model": "nemotron",
         *       "version": 3
         *     }
         */
        PromptVersionInfo: {
            /** Change Description */
            change_description: string | null;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Created By */
            created_by: string | null;
            /** Id */
            id: number;
            /** Is Active */
            is_active: boolean;
            model: components["schemas"]["AIModelEnum"];
            /** Version */
            version: number;
        };
        /**
         * PromptsExportResponse
         * @description Export of all prompt configurations.
         * @example {
         *       "exported_at": "2026-01-03T10:30:00Z",
         *       "prompts": {
         *         "florence2": {
         *           "vqa_queries": [
         *             "What is this person wearing?"
         *           ]
         *         },
         *         "nemotron": {
         *           "max_tokens": 2048,
         *           "system_prompt": "You are a home security AI assistant...",
         *           "temperature": 0.7
         *         },
         *         "yolo_world": {
         *           "confidence_threshold": 0.35,
         *           "object_classes": [
         *             "person",
         *             "car",
         *             "truck"
         *           ]
         *         }
         *       },
         *       "version": "1.0"
         *     }
         */
        PromptsExportResponse: {
            /**
             * Exported At
             * Format: date-time
             */
            exported_at: string;
            /**
             * Prompts
             * @description All model configurations
             */
            prompts: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
            /**
             * Version
             * @description Export format version
             * @default 1.0
             */
            version: string;
        };
        /**
         * PromptsImportPreviewRequest
         * @description Request to preview prompt configuration import without applying.
         * @example {
         *       "prompts": {
         *         "nemotron": {
         *           "max_tokens": 2048,
         *           "system_prompt": "You are a home security AI assistant...",
         *           "temperature": 0.8
         *         }
         *       },
         *       "version": "1.0"
         *     }
         */
        PromptsImportPreviewRequest: {
            /**
             * Prompts
             * @description Model configurations to preview
             */
            prompts: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
            /**
             * Version
             * @description Import format version
             * @default 1.0
             */
            version: string;
        };
        /**
         * PromptsImportPreviewResponse
         * @description Response with preview of import changes.
         * @example {
         *       "diffs": [
         *         {
         *           "changes": [
         *             "temperature: 0.7 -> 0.8"
         *           ],
         *           "current_config": {
         *             "system_prompt": "You are a home security AI...",
         *             "temperature": 0.7
         *           },
         *           "current_version": 3,
         *           "has_changes": true,
         *           "imported_config": {
         *             "system_prompt": "You are a home security AI...",
         *             "temperature": 0.8
         *           },
         *           "model": "nemotron"
         *         }
         *       ],
         *       "total_changes": 1,
         *       "unknown_models": [],
         *       "valid": true,
         *       "validation_errors": [],
         *       "version": "1.0"
         *     }
         */
        PromptsImportPreviewResponse: {
            /**
             * Diffs
             * @description Diff entries for each model
             */
            diffs?: components["schemas"]["PromptDiffEntry"][];
            /**
             * Total Changes
             * @description Total number of models with changes
             * @default 0
             */
            total_changes: number;
            /**
             * Unknown Models
             * @description Models not recognized
             */
            unknown_models?: string[];
            /**
             * Valid
             * @description Whether the import data is valid
             */
            valid: boolean;
            /**
             * Validation Errors
             * @description List of validation errors
             */
            validation_errors?: string[];
            /**
             * Version
             * @description Import format version
             */
            version: string;
        };
        /**
         * PromptsImportRequest
         * @description Request to import prompt configurations.
         * @example {
         *       "prompts": {
         *         "florence2": {
         *           "vqa_queries": [
         *             "What is this person wearing?"
         *           ]
         *         },
         *         "nemotron": {
         *           "max_tokens": 2048,
         *           "system_prompt": "You are a home security AI assistant...",
         *           "temperature": 0.7
         *         }
         *       },
         *       "version": "1.0"
         *     }
         */
        PromptsImportRequest: {
            /**
             * Prompts
             * @description Model configurations to import
             */
            prompts: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
            /**
             * Version
             * @description Import format version
             * @default 1.0
             */
            version: string;
        };
        /**
         * PromptsImportResponse
         * @description Response after importing prompt configurations.
         * @example {
         *       "imported_models": [
         *         "nemotron",
         *         "florence2"
         *       ],
         *       "message": "Successfully imported 2 prompt configurations, skipped 1",
         *       "new_versions": {
         *         "florence2": 2,
         *         "nemotron": 4
         *       },
         *       "skipped_models": [
         *         "yolo_world"
         *       ]
         *     }
         */
        PromptsImportResponse: {
            /** Imported Models */
            imported_models: string[];
            /** Message */
            message: string;
            /**
             * New Versions
             * @description New version numbers for each imported model
             */
            new_versions: {
                [key: string]: number;
            };
            /** Skipped Models */
            skipped_models?: string[];
        };
        /**
         * PropertyCreate
         * @description Schema for creating a new property.
         *
         *     A property represents a physical location within a household
         *     (e.g., main house, beach house).
         * @example {
         *       "address": "123 Main St, City, ST 12345",
         *       "name": "Main House",
         *       "timezone": "America/New_York"
         *     }
         */
        PropertyCreate: {
            /**
             * Address
             * @description Optional street address
             */
            address?: string | null;
            /**
             * Name
             * @description Property name (e.g., 'Main House')
             */
            name: string;
            /**
             * Timezone
             * @description Timezone for the property (IANA format)
             * @default UTC
             */
            timezone: string;
        };
        /**
         * PropertyListResponse
         * @description Schema for listing properties.
         * @example {
         *       "items": [
         *         {
         *           "address": "123 Main St",
         *           "created_at": "2026-01-20T10:00:00Z",
         *           "household_id": 1,
         *           "id": 1,
         *           "name": "Main House",
         *           "timezone": "America/New_York"
         *         }
         *       ],
         *       "total": 1
         *     }
         */
        PropertyListResponse: {
            /**
             * Items
             * @description List of properties
             */
            items: components["schemas"]["PropertyResponse"][];
            /**
             * Total
             * @description Total number of properties
             */
            total: number;
        };
        /**
         * PropertyResponse
         * @description Schema for property response.
         * @example {
         *       "address": "123 Main St, City, ST 12345",
         *       "created_at": "2026-01-20T10:00:00Z",
         *       "household_id": 1,
         *       "id": 1,
         *       "name": "Main House",
         *       "timezone": "America/New_York"
         *     }
         */
        PropertyResponse: {
            /**
             * Address
             * @description Street address
             */
            address?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when property was created
             */
            created_at: string;
            /**
             * Household Id
             * @description ID of the owning household
             */
            household_id: number;
            /**
             * Id
             * @description Unique property identifier
             */
            id: number;
            /**
             * Name
             * @description Property name
             */
            name: string;
            /**
             * Timezone
             * @description Timezone (IANA format)
             */
            timezone: string;
        };
        /**
         * PropertyUpdate
         * @description Schema for updating an existing property.
         *
         *     All fields are optional; only provided fields will be updated.
         * @example {
         *       "name": "Main Residence",
         *       "timezone": "America/Chicago"
         *     }
         */
        PropertyUpdate: {
            /**
             * Address
             * @description Street address
             */
            address?: string | null;
            /**
             * Name
             * @description Property name
             */
            name?: string | null;
            /**
             * Timezone
             * @description Timezone (IANA format)
             */
            timezone?: string | null;
        };
        /**
         * QualityScores
         * @description Self-evaluation quality scores (1-5 scale).
         * @example {
         *       "consistency": 4,
         *       "context_usage": 4.2,
         *       "overall": 4.1,
         *       "reasoning_coherence": 4.5,
         *       "risk_justification": 3.8
         *     }
         */
        QualityScores: {
            /** Consistency */
            consistency?: number | null;
            /** Context Usage */
            context_usage?: number | null;
            /** Overall */
            overall?: number | null;
            /** Reasoning Coherence */
            reasoning_coherence?: number | null;
            /** Risk Justification */
            risk_justification?: number | null;
        };
        /**
         * QueueDepthInfo
         * @description Queue depth information for a processing queue.
         *
         *     Tracks the number of items in the main queue and the dead letter queue
         *     for monitoring backlog and failed processing.
         * @example {
         *       "depth": 5,
         *       "dlq_depth": 0
         *     }
         */
        QueueDepthInfo: {
            /**
             * Depth
             * @description Number of items currently in the queue
             */
            depth: number;
            /**
             * Dlq Depth
             * @description Number of items in the dead letter queue
             * @default 0
             */
            dlq_depth: number;
        };
        /**
         * QueueDepths
         * @description Queue depth information for pipeline queues.
         * @example {
         *       "analysis_queue": 2,
         *       "detection_queue": 5
         *     }
         */
        QueueDepths: {
            /**
             * Analysis Queue
             * @description Number of batches in analysis queue waiting for Nemotron LLM analysis
             */
            analysis_queue: number;
            /**
             * Detection Queue
             * @description Number of items in detection queue waiting for YOLO26v2 processing
             */
            detection_queue: number;
        };
        /**
         * QueueHealthStatus
         * @description Health status for a queue based on depth and wait time.
         * @enum {string}
         */
        QueueHealthStatus: "healthy" | "warning" | "critical";
        /**
         * QueueSettings
         * @description Queue settings for Redis-based processing queues.
         *
         *     Controls queue size limits and backpressure thresholds for the detection
         *     and analysis processing queues.
         * @example {
         *       "backpressure_threshold": 0.8,
         *       "max_size": 10000
         *     }
         */
        QueueSettings: {
            /**
             * Backpressure Threshold
             * @description Queue fill ratio (0.0-1.0) at which to start backpressure warnings
             */
            backpressure_threshold: number;
            /**
             * Max Size
             * @description Maximum size of Redis queues
             */
            max_size: number;
        };
        /**
         * QueueSettingsUpdate
         * @description Queue settings update schema (all fields optional).
         *
         *     Used for PATCH /api/v1/settings to partially update queue configuration.
         * @example {
         *       "max_size": 15000
         *     }
         */
        QueueSettingsUpdate: {
            /**
             * Backpressure Threshold
             * @description Queue fill ratio (0.0-1.0) at which to start backpressure warnings
             */
            backpressure_threshold?: number | null;
            /**
             * Max Size
             * @description Maximum size of Redis queues
             */
            max_size?: number | null;
        };
        /**
         * QueueStatus
         * @description Status of a single job queue.
         * @example {
         *       "depth": 15,
         *       "name": "ai_analysis",
         *       "oldest_job": {
         *         "id": "job_12345",
         *         "queued_at": "2025-12-23T10:30:00.000000",
         *         "wait_seconds": 45.2
         *       },
         *       "running": 2,
         *       "status": "healthy",
         *       "throughput": {
         *         "avg_processing_seconds": 4.8,
         *         "jobs_per_minute": 12.5
         *       },
         *       "workers": 4
         *     }
         */
        QueueStatus: {
            /**
             * Depth
             * @description Number of jobs waiting in the queue
             */
            depth: number;
            /**
             * Name
             * @description Queue name
             */
            name: string;
            /** @description Information about the oldest job waiting (if any) */
            oldest_job?: components["schemas"]["OldestJobInfo"] | null;
            /**
             * Running
             * @description Number of jobs currently being processed
             */
            running: number;
            /** @description Health status of the queue */
            status: components["schemas"]["QueueHealthStatus"];
            /** @description Throughput metrics for the queue */
            throughput: components["schemas"]["ThroughputMetrics"];
            /**
             * Workers
             * @description Number of workers available for this queue
             */
            workers: number;
        };
        /**
         * QueueStatusSummary
         * @description Summary statistics across all queues.
         * @example {
         *       "overall_status": "healthy",
         *       "total_queued": 45,
         *       "total_running": 8,
         *       "total_workers": 12
         *     }
         */
        QueueStatusSummary: {
            /** @description Overall health status (worst status across all queues) */
            overall_status: components["schemas"]["QueueHealthStatus"];
            /**
             * Total Queued
             * @description Total number of jobs waiting across all queues
             */
            total_queued: number;
            /**
             * Total Running
             * @description Total number of jobs currently being processed
             */
            total_running: number;
            /**
             * Total Workers
             * @description Total number of workers across all queues
             */
            total_workers: number;
        };
        /**
         * QueuesStatusResponse
         * @description Response schema for GET /api/queues/status endpoint.
         * @example {
         *       "queues": [
         *         {
         *           "depth": 15,
         *           "name": "ai_analysis",
         *           "oldest_job": {
         *             "id": "job_12345",
         *             "queued_at": "2025-12-23T10:30:00.000000",
         *             "wait_seconds": 45.2
         *           },
         *           "running": 2,
         *           "status": "healthy",
         *           "throughput": {
         *             "avg_processing_seconds": 4.8,
         *             "jobs_per_minute": 12.5
         *           },
         *           "workers": 4
         *         },
         *         {
         *           "depth": 55,
         *           "name": "detection",
         *           "running": 3,
         *           "status": "warning",
         *           "throughput": {
         *             "avg_processing_seconds": 7.3,
         *             "jobs_per_minute": 8.2
         *           },
         *           "workers": 4
         *         }
         *       ],
         *       "summary": {
         *         "overall_status": "warning",
         *         "total_queued": 70,
         *         "total_running": 5,
         *         "total_workers": 8
         *       }
         *     }
         */
        QueuesStatusResponse: {
            /**
             * Queues
             * @description Status of each queue
             */
            queues: components["schemas"]["QueueStatus"][];
            /** @description Summary statistics across all queues */
            summary: components["schemas"]["QueueStatusSummary"];
        };
        /**
         * QuietHoursPeriodCreate
         * @description Schema for creating a quiet hours period.
         * @example {
         *       "days": [
         *         "monday",
         *         "tuesday",
         *         "wednesday",
         *         "thursday",
         *         "friday"
         *       ],
         *       "end_time": "06:00:00",
         *       "label": "Night Time",
         *       "start_time": "22:00:00"
         *     }
         */
        QuietHoursPeriodCreate: {
            /**
             * Days
             * @description Days of week when period is active
             */
            days?: string[];
            /**
             * End Time
             * Format: time
             * @description End time (HH:MM:SS)
             */
            end_time: string;
            /**
             * Label
             * @description Period label
             */
            label: string;
            /**
             * Start Time
             * Format: time
             * @description Start time (HH:MM:SS)
             */
            start_time: string;
        };
        /**
         * QuietHoursPeriodResponse
         * @description Schema for quiet hours period response.
         * @example {
         *       "days": [
         *         "monday",
         *         "tuesday",
         *         "wednesday",
         *         "thursday",
         *         "friday"
         *       ],
         *       "end_time": "06:00:00",
         *       "id": "550e8400-e29b-41d4-a716-446655440000",
         *       "label": "Night Time",
         *       "start_time": "22:00:00"
         *     }
         */
        QuietHoursPeriodResponse: {
            /**
             * Days
             * @description Days of week when period is active
             */
            days: string[];
            /**
             * End Time
             * Format: time
             * @description End time
             */
            end_time: string;
            /**
             * Id
             * @description Period UUID
             */
            id: string;
            /**
             * Label
             * @description Period label
             */
            label: string;
            /**
             * Start Time
             * Format: time
             * @description Start time
             */
            start_time: string;
        };
        /**
         * QuietHoursPeriodsListResponse
         * @description Schema for quiet hours periods list response with pagination.
         * @example {
         *       "items": [
         *         {
         *           "days": [
         *             "monday",
         *             "tuesday",
         *             "wednesday",
         *             "thursday",
         *             "friday"
         *           ],
         *           "end_time": "06:00:00",
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "label": "Night Time",
         *           "start_time": "22:00:00"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        QuietHoursPeriodsListResponse: {
            /**
             * Items
             * @description List of quiet hours periods
             */
            items: components["schemas"]["QuietHoursPeriodResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * RUMBatchRequest
         * @description Batch request for multiple Core Web Vitals metrics.
         *
         *     The frontend batches metrics to reduce API calls. Each batch may contain
         *     metrics from different pages or navigation events.
         *
         *     Attributes:
         *         metrics: List of Core Web Vital metrics to ingest
         *         session_id: Optional session identifier for correlating metrics
         *         user_agent: Optional user agent string for device/browser analysis
         * @example {
         *       "metrics": [
         *         {
         *           "delta": 2500,
         *           "id": "v1-1234567890123-1234567890123",
         *           "name": "LCP",
         *           "rating": "good",
         *           "value": 2500
         *         },
         *         {
         *           "delta": 0.02,
         *           "id": "v1-1234567890123-1234567890124",
         *           "name": "CLS",
         *           "rating": "good",
         *           "value": 0.05
         *         }
         *       ],
         *       "session_id": "sess-12345"
         *     }
         */
        RUMBatchRequest: {
            /**
             * Metrics
             * @description List of metrics to ingest (non-empty)
             */
            metrics: components["schemas"]["WebVitalMetric"][];
            /**
             * Session Id
             * @description Optional session identifier
             */
            session_id?: string | null;
            /**
             * User Agent
             * @description Optional user agent string
             */
            user_agent?: string | null;
        };
        /**
         * RUMIngestResponse
         * @description Response from the RUM metrics ingestion endpoint.
         *
         *     Attributes:
         *         success: Whether the ingestion was successful
         *         metrics_count: Number of metrics successfully ingested
         *         message: Human-readable status message
         *         errors: List of any errors encountered during ingestion
         * @example {
         *       "errors": [],
         *       "message": "Successfully ingested 5 metrics",
         *       "metrics_count": 5,
         *       "success": true
         *     }
         */
        RUMIngestResponse: {
            /**
             * Errors
             * @description List of any errors encountered
             */
            errors?: string[];
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Metrics Count
             * @description Number of metrics successfully ingested
             */
            metrics_count: number;
            /**
             * Success
             * @description Whether ingestion was successful
             */
            success: boolean;
        };
        /**
         * RateLimitingSettings
         * @description Rate limiting settings for API protection.
         *
         *     Controls request rate limits to prevent abuse and ensure fair resource usage.
         * @example {
         *       "burst_size": 10,
         *       "enabled": true,
         *       "requests_per_minute": 60
         *     }
         */
        RateLimitingSettings: {
            /**
             * Burst Size
             * @description Additional burst allowance for short request spikes
             */
            burst_size: number;
            /**
             * Enabled
             * @description Enable rate limiting for API endpoints
             */
            enabled: boolean;
            /**
             * Requests Per Minute
             * @description Maximum requests per minute per client IP
             */
            requests_per_minute: number;
        };
        /**
         * RateLimitingSettingsUpdate
         * @description Rate limiting settings update schema (all fields optional).
         *
         *     Used for PATCH /api/v1/settings to partially update rate limiting.
         * @example {
         *       "requests_per_minute": 120
         *     }
         */
        RateLimitingSettingsUpdate: {
            /**
             * Burst Size
             * @description Additional burst allowance for short request spikes
             */
            burst_size?: number | null;
            /**
             * Enabled
             * @description Enable rate limiting for API endpoints
             */
            enabled?: boolean | null;
            /**
             * Requests Per Minute
             * @description Maximum requests per minute per client IP
             */
            requests_per_minute?: number | null;
        };
        /**
         * ReadinessResponse
         * @description Response schema for readiness probe endpoint.
         *
         *     Readiness probes indicate whether the application is ready to receive
         *     traffic and process requests. This checks all dependencies:
         *     - Database connectivity
         *     - Redis connectivity
         *     - AI services availability
         *     - Background worker status
         * @example {
         *       "ready": true,
         *       "services": {
         *         "ai": {
         *           "message": "AI services operational",
         *           "status": "healthy"
         *         },
         *         "database": {
         *           "message": "Database operational",
         *           "status": "healthy"
         *         },
         *         "redis": {
         *           "details": {
         *             "redis_version": "7.0.0"
         *           },
         *           "message": "Redis connected",
         *           "status": "healthy"
         *         }
         *       },
         *       "status": "ready",
         *       "supervisor_healthy": true,
         *       "timestamp": "2025-12-23T10:30:00",
         *       "workers": [
         *         {
         *           "name": "gpu_monitor",
         *           "running": true
         *         },
         *         {
         *           "name": "cleanup_service",
         *           "running": true
         *         }
         *       ]
         *     }
         */
        ReadinessResponse: {
            /**
             * Ai Warmth Status
             * @description Warmth status of AI models (NEM-1670). Keys are model names (e.g., 'yolo26', 'nemotron'), values are states: 'cold', 'warming', 'warm'
             */
            ai_warmth_status?: {
                [key: string]: string;
            } | null;
            /**
             * Ready
             * @description Overall readiness status: True if system can process requests
             */
            ready: boolean;
            /**
             * Services
             * @description Status of infrastructure services (database, redis, ai)
             */
            services: {
                [key: string]: components["schemas"]["HealthCheckServiceStatus"];
            };
            /**
             * Status
             * @description Status string: 'ready', 'degraded', or 'not_ready'
             */
            status: string;
            /**
             * Supervisor Healthy
             * @description Whether the worker supervisor is running and healthy (NEM-2462). True if supervisor is active, False if not initialized or has failed workers.
             * @default true
             */
            supervisor_healthy: boolean;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of readiness check
             */
            timestamp: string;
            /**
             * Workers
             * @description Status of background workers
             */
            workers?: components["schemas"]["WorkerStatus"][];
        };
        /**
         * RecentError
         * @description Recent error information.
         */
        RecentError: {
            /**
             * Component
             * @description Component that generated error
             */
            component: string;
            /**
             * Error Type
             * @description Type of error
             */
            error_type: string;
            /**
             * Message
             * @description Error message
             */
            message?: string | null;
            /**
             * Timestamp
             * @description ISO timestamp of error
             */
            timestamp: string;
        };
        /**
         * RecommendationItem
         * @description Single recommendation item.
         * @example {
         *       "category": "missing_context",
         *       "frequency": 25,
         *       "priority": "high",
         *       "suggestion": "Add time since last motion event to prompt"
         *     }
         */
        RecommendationItem: {
            /** Category */
            category: string;
            /** Frequency */
            frequency: number;
            /** Priority */
            priority: string;
            /** Suggestion */
            suggestion: string;
        };
        /**
         * RecommendationsResponse
         * @description Aggregated recommendations response.
         * @example {
         *       "recommendations": [
         *         {
         *           "category": "missing_context",
         *           "frequency": 25,
         *           "priority": "high",
         *           "suggestion": "Add time since last motion event"
         *         },
         *         {
         *           "category": "model_gaps",
         *           "frequency": 12,
         *           "priority": "medium",
         *           "suggestion": "Enable pet detection model"
         *         }
         *       ],
         *       "total_events_analyzed": 500
         *     }
         */
        RecommendationsResponse: {
            /** Recommendations */
            recommendations: components["schemas"]["RecommendationItem"][];
            /** Total Events Analyzed */
            total_events_analyzed: number;
        };
        /**
         * RecordingResponse
         * @description Response for a single recording.
         */
        RecordingResponse: {
            /**
             * Body Truncated
             * @description Whether body was truncated
             * @default false
             */
            body_truncated: boolean;
            /**
             * Duration Ms
             * @description Request duration in milliseconds
             */
            duration_ms: number;
            /**
             * Method
             * @description HTTP method
             */
            method: string;
            /**
             * Path
             * @description Request path
             */
            path: string;
            /**
             * Recording Id
             * @description Unique recording ID
             */
            recording_id: string;
            /**
             * Status Code
             * @description HTTP response status code
             */
            status_code: number;
            /**
             * Timestamp
             * @description ISO timestamp when recorded
             */
            timestamp: string;
        };
        /**
         * RecordingsListResponse
         * @description Response for listing recordings.
         */
        RecordingsListResponse: {
            /**
             * Recordings
             * @description List of recordings
             */
            recordings: components["schemas"]["RecordingResponse"][];
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
            /**
             * Total
             * @description Total number of recordings
             */
            total: number;
        };
        /**
         * RedisInfoResponse
         * @description Response for Redis connection stats.
         */
        RedisInfoResponse: {
            /**
             * Info
             * @description Redis INFO command output
             */
            info?: {
                [key: string]: unknown;
            } | null;
            /**
             * Pubsub
             * @description Pub/sub channel information
             */
            pubsub?: {
                [key: string]: unknown;
            } | null;
            /**
             * Status
             * @description Redis connection status (connected, unavailable)
             */
            status: string;
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * RedisMetrics
         * @description Redis cache metrics.
         * @example {
         *       "blocked_clients": 0,
         *       "connected_clients": 8,
         *       "hit_ratio": 99.5,
         *       "memory_mb": 1.5,
         *       "status": "healthy"
         *     }
         */
        RedisMetrics: {
            /**
             * Blocked Clients
             * @description Number of blocked clients
             */
            blocked_clients: number;
            /**
             * Connected Clients
             * @description Number of connected clients
             */
            connected_clients: number;
            /**
             * Hit Ratio
             * @description Cache hit ratio percentage
             */
            hit_ratio: number;
            /**
             * Memory Mb
             * @description Memory used in MB
             */
            memory_mb: number;
            /**
             * Status
             * @description Health status: healthy, unhealthy, unreachable
             */
            status: string;
        };
        /**
         * RegisteredVehicleCreate
         * @description Schema for creating a new registered vehicle.
         * @example {
         *       "color": "Silver",
         *       "description": "Silver Tesla Model 3",
         *       "license_plate": "ABC123",
         *       "owner_id": 1,
         *       "trusted": true,
         *       "vehicle_type": "car"
         *     }
         */
        RegisteredVehicleCreate: {
            /**
             * Color
             * @description Color description
             */
            color?: string | null;
            /**
             * Description
             * @description Human-readable description (e.g., 'Silver Tesla Model 3')
             */
            description: string;
            /**
             * License Plate
             * @description License plate number
             */
            license_plate?: string | null;
            /**
             * Owner Id
             * @description ID of the vehicle owner (HouseholdMember)
             */
            owner_id?: number | null;
            /**
             * Trusted
             * @description Whether this vehicle should suppress alerts
             * @default true
             */
            trusted: boolean;
            /** @description Type/category of the vehicle */
            vehicle_type: components["schemas"]["VehicleType"];
        };
        /**
         * RegisteredVehicleResponse
         * @description Schema for registered vehicle response.
         * @example {
         *       "color": "Silver",
         *       "created_at": "2025-01-01T10:00:00Z",
         *       "description": "Silver Tesla Model 3",
         *       "id": 1,
         *       "license_plate": "ABC123",
         *       "owner_id": 1,
         *       "trusted": true,
         *       "vehicle_type": "car"
         *     }
         */
        RegisteredVehicleResponse: {
            /**
             * Color
             * @description Color description
             */
            color?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description When the vehicle was registered
             */
            created_at: string;
            /**
             * Description
             * @description Human-readable description
             */
            description: string;
            /**
             * Id
             * @description Unique identifier for the vehicle
             */
            id: number;
            /**
             * License Plate
             * @description License plate number
             */
            license_plate?: string | null;
            /**
             * Owner Id
             * @description ID of the vehicle owner
             */
            owner_id?: number | null;
            /**
             * Trusted
             * @description Whether vehicle suppresses alerts
             */
            trusted: boolean;
            /** @description Type of vehicle */
            vehicle_type: components["schemas"]["VehicleType"];
        };
        /**
         * RegisteredVehicleUpdate
         * @description Schema for updating an existing registered vehicle.
         * @example {
         *       "description": "Updated Tesla Description",
         *       "license_plate": "NEW456",
         *       "trusted": false
         *     }
         */
        RegisteredVehicleUpdate: {
            /**
             * Color
             * @description Color description
             */
            color?: string | null;
            /**
             * Description
             * @description Human-readable description
             */
            description?: string | null;
            /**
             * License Plate
             * @description License plate number
             */
            license_plate?: string | null;
            /**
             * Owner Id
             * @description ID of the vehicle owner (HouseholdMember)
             */
            owner_id?: number | null;
            /**
             * Trusted
             * @description Whether this vehicle should suppress alerts
             */
            trusted?: boolean | null;
            /** @description Type/category of the vehicle */
            vehicle_type?: components["schemas"]["VehicleType"] | null;
        };
        /**
         * ReplayResponse
         * @description Response for request replay.
         */
        ReplayResponse: {
            /**
             * Original Status Code
             * @description Original response status code
             */
            original_status_code: number;
            /**
             * Recording Id
             * @description ID of the replayed recording
             */
            recording_id: string;
            /**
             * Replay Metadata
             * @description Metadata about the replay
             */
            replay_metadata: {
                [key: string]: unknown;
            };
            /**
             * Replay Response
             * @description Response from replayed request
             */
            replay_response: unknown;
            /**
             * Replay Status Code
             * @description Replay response status code
             */
            replay_status_code: number;
            /**
             * Timestamp
             * @description ISO timestamp of replay
             */
            timestamp: string;
        };
        /**
         * ReportFormat
         * @description Output format options for scheduled reports.
         *
         *     Values:
         *         PDF: Portable Document Format with charts and summaries
         *         CSV: Comma-separated values for data analysis
         *         JSON: Machine-readable JSON format
         * @enum {string}
         */
        ReportFormat: "pdf" | "csv" | "json";
        /**
         * ReportFrequency
         * @description Frequency options for scheduled reports.
         *
         *     Values:
         *         DAILY: Report runs every day at specified time
         *         WEEKLY: Report runs on specified day of week
         *         MONTHLY: Report runs on specified day of month
         * @enum {string}
         */
        ReportFrequency: "daily" | "weekly" | "monthly";
        /**
         * RestartHistoryEvent
         * @description A single restart event in the history.
         *
         *     Records when a worker was restarted (automatically or manually).
         * @example {
         *       "attempt": 1,
         *       "error": "Connection timeout",
         *       "status": "success",
         *       "timestamp": "2026-01-13T10:30:00Z",
         *       "worker_name": "file_watcher"
         *     }
         */
        RestartHistoryEvent: {
            /**
             * Attempt
             * @description Restart attempt number (0 for manual restarts)
             */
            attempt: number;
            /**
             * Error
             * @description Error message that triggered the restart, if any
             */
            error?: string | null;
            /**
             * Status
             * @description Result of the restart: 'success' or 'failed'
             */
            status: string;
            /**
             * Timestamp
             * Format: date-time
             * @description When the restart occurred (UTC)
             */
            timestamp: string;
            /**
             * Worker Name
             * @description Name of the worker that was restarted
             */
            worker_name: string;
        };
        /**
         * RestartHistoryResponse
         * @description Response schema for restart history endpoint.
         *
         *     Provides paginated list of worker restart events.
         * @example {
         *       "items": [
         *         {
         *           "attempt": 1,
         *           "error": "Connection timeout",
         *           "status": "success",
         *           "timestamp": "2026-01-13T10:30:00Z",
         *           "worker_name": "file_watcher"
         *         },
         *         {
         *           "attempt": 2,
         *           "error": "Memory allocation failed",
         *           "status": "success",
         *           "timestamp": "2026-01-13T10:25:00Z",
         *           "worker_name": "detector"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 15
         *       }
         *     }
         */
        RestartHistoryResponse: {
            /**
             * Items
             * @description List of restart events (newest first)
             */
            items?: components["schemas"]["RestartHistoryEvent"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * RetentionSettings
         * @description Data retention settings for events and logs.
         *
         *     Controls how long events, detections, and logs are retained before cleanup.
         * @example {
         *       "days": 30,
         *       "log_days": 7
         *     }
         */
        RetentionSettings: {
            /**
             * Days
             * @description Number of days to retain events and detections
             */
            days: number;
            /**
             * Log Days
             * @description Number of days to retain logs
             */
            log_days: number;
        };
        /**
         * RetentionSettingsUpdate
         * @description Retention settings update schema (all fields optional).
         *
         *     Used for PATCH /api/v1/settings to partially update retention policies.
         * @example {
         *       "days": 60
         *     }
         */
        RetentionSettingsUpdate: {
            /**
             * Days
             * @description Number of days to retain events and detections (1-365)
             */
            days?: number | null;
            /**
             * Log Days
             * @description Number of days to retain logs (1-365)
             */
            log_days?: number | null;
        };
        /**
         * RiskDistributionItem
         * @description Schema for a single risk distribution item (for Grafana compatibility).
         * @example {
         *       "count": 5,
         *       "risk_level": "high"
         *     }
         */
        RiskDistributionItem: {
            /**
             * Count
             * @description Number of events with this risk level
             */
            count: number;
            /**
             * Risk Level
             * @description Risk level name (critical, high, medium, low)
             */
            risk_level: string;
        };
        /**
         * RiskEntity
         * @description Entity identified during risk analysis.
         *
         *     Entities represent objects of interest detected in the scene that
         *     contribute to the overall risk assessment (e.g., people, vehicles,
         *     packages).
         *
         *     Attributes:
         *         type: Category of entity (e.g., "person", "vehicle", "package")
         *         description: Detailed description of the entity
         *         threat_level: Risk level attributed to this entity
         * @example {
         *       "description": "Unknown individual near front entrance",
         *       "threat_level": "medium",
         *       "type": "person"
         *     }
         */
        RiskEntity: {
            /**
             * Description
             * @description Detailed description of the entity
             */
            description: string;
            /**
             * Threat Level
             * @description Risk level attributed to this entity
             * @enum {string}
             */
            threat_level: "low" | "medium" | "high";
            /**
             * Type
             * @description Category of entity (e.g., person, vehicle, package)
             */
            type: string;
        };
        /**
         * RiskFactor
         * @description Individual factor contributing to the overall risk score (NEM-3603).
         *
         *     Risk factors represent specific aspects of the analysis that contribute
         *     positively or negatively to the overall risk score. Positive contributions
         *     increase risk (e.g., nighttime activity, unknown person), while negative
         *     contributions decrease risk (e.g., recognized face, routine timing).
         *
         *     Attributes:
         *         factor_name: Name of the risk factor (e.g., "nighttime_activity", "recognized_face")
         *         contribution: Contribution to risk score (positive increases risk, negative decreases)
         *         description: Optional explanation of why this factor applies
         * @example {
         *       "contribution": 15,
         *       "description": "Activity detected outside normal hours (11 PM - 6 AM)",
         *       "factor_name": "nighttime_activity"
         *     }
         */
        RiskFactor: {
            /**
             * Contribution
             * @description Contribution to risk score (positive increases, negative decreases)
             */
            contribution: number;
            /**
             * Description
             * @description Optional explanation of why this factor applies
             */
            description?: string | null;
            /**
             * Factor Name
             * @description Name of the risk factor
             */
            factor_name: string;
        };
        /**
         * RiskFlag
         * @description Risk flag indicating a specific concern or anomaly.
         *
         *     Flags represent specific behaviors, patterns, or conditions that
         *     warrant attention (e.g., loitering, nighttime activity, weapon detected).
         *
         *     Attributes:
         *         type: Category of flag (e.g., "loitering", "weapon_detected")
         *         description: Explanation of the flag
         *         severity: How severe this flag is (warning, alert, critical)
         * @example {
         *       "description": "Person has been stationary for over 5 minutes",
         *       "severity": "warning",
         *       "type": "loitering"
         *     }
         */
        RiskFlag: {
            /**
             * Description
             * @description Explanation of the flag
             */
            description: string;
            /**
             * Severity
             * @description Severity level of this flag
             * @enum {string}
             */
            severity: "warning" | "alert" | "critical";
            /**
             * Type
             * @description Category of flag (e.g., loitering, weapon_detected)
             */
            type: string;
        };
        /**
         * RiskHistoryDataPoint
         * @description Schema for a single risk history data point.
         * @example {
         *       "critical": 1,
         *       "date": "2025-01-07",
         *       "high": 2,
         *       "low": 10,
         *       "medium": 5
         *     }
         */
        RiskHistoryDataPoint: {
            /**
             * Critical
             * @description Count of critical risk events
             * @default 0
             */
            critical: number;
            /**
             * Date
             * Format: date
             * @description Date of the data point
             */
            date: string;
            /**
             * High
             * @description Count of high risk events
             * @default 0
             */
            high: number;
            /**
             * Low
             * @description Count of low risk events
             * @default 0
             */
            low: number;
            /**
             * Medium
             * @description Count of medium risk events
             * @default 0
             */
            medium: number;
        };
        /**
         * RiskHistoryResponse
         * @description Schema for risk score distribution over time.
         * @example {
         *       "data_points": [
         *         {
         *           "critical": 1,
         *           "date": "2025-01-01",
         *           "high": 2,
         *           "low": 10,
         *           "medium": 5
         *         },
         *         {
         *           "critical": 0,
         *           "date": "2025-01-02",
         *           "high": 3,
         *           "low": 12,
         *           "medium": 4
         *         }
         *       ],
         *       "end_date": "2025-01-02",
         *       "start_date": "2025-01-01"
         *     }
         */
        RiskHistoryResponse: {
            /**
             * Data Points
             * @description Risk level counts aggregated by day
             */
            data_points: components["schemas"]["RiskHistoryDataPoint"][];
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
        };
        /**
         * RiskScoreDistributionBucket
         * @description Schema for a single risk score distribution bucket.
         * @example {
         *       "count": 15,
         *       "max_score": 10,
         *       "min_score": 0
         *     }
         */
        RiskScoreDistributionBucket: {
            /**
             * Count
             * @description Number of events in this bucket
             */
            count: number;
            /**
             * Max Score
             * @description Maximum score in this bucket (exclusive)
             */
            max_score: number;
            /**
             * Min Score
             * @description Minimum score in this bucket (inclusive)
             */
            min_score: number;
        };
        /**
         * RiskScoreDistributionResponse
         * @description Schema for risk score distribution histogram.
         * @example {
         *       "bucket_size": 10,
         *       "buckets": [
         *         {
         *           "count": 15,
         *           "max_score": 10,
         *           "min_score": 0
         *         },
         *         {
         *           "count": 12,
         *           "max_score": 20,
         *           "min_score": 10
         *         },
         *         {
         *           "count": 8,
         *           "max_score": 30,
         *           "min_score": 20
         *         },
         *         {
         *           "count": 6,
         *           "max_score": 40,
         *           "min_score": 30
         *         },
         *         {
         *           "count": 4,
         *           "max_score": 50,
         *           "min_score": 40
         *         },
         *         {
         *           "count": 3,
         *           "max_score": 60,
         *           "min_score": 50
         *         },
         *         {
         *           "count": 2,
         *           "max_score": 70,
         *           "min_score": 60
         *         },
         *         {
         *           "count": 2,
         *           "max_score": 80,
         *           "min_score": 70
         *         },
         *         {
         *           "count": 1,
         *           "max_score": 90,
         *           "min_score": 80
         *         },
         *         {
         *           "count": 1,
         *           "max_score": 100,
         *           "min_score": 90
         *         }
         *       ],
         *       "end_date": "2025-01-07",
         *       "start_date": "2025-01-01",
         *       "total_events": 54
         *     }
         */
        RiskScoreDistributionResponse: {
            /**
             * Bucket Size
             * @description Size of each bucket
             */
            bucket_size: number;
            /**
             * Buckets
             * @description Risk score distribution buckets
             */
            buckets: components["schemas"]["RiskScoreDistributionBucket"][];
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
            /**
             * Total Events
             * @description Total events with risk scores in date range
             */
            total_events: number;
        };
        /**
         * RiskScoreTrendDataPoint
         * @description Schema for a single risk score trend data point.
         * @example {
         *       "avg_score": 45.5,
         *       "count": 12,
         *       "date": "2025-01-07"
         *     }
         */
        RiskScoreTrendDataPoint: {
            /**
             * Avg Score
             * @description Average risk score on this date
             */
            avg_score: number;
            /**
             * Count
             * @description Number of events on this date
             */
            count: number;
            /**
             * Date
             * Format: date
             * @description Date of the data point
             */
            date: string;
        };
        /**
         * RiskScoreTrendsResponse
         * @description Schema for risk score trends over time.
         * @example {
         *       "data_points": [
         *         {
         *           "avg_score": 35.2,
         *           "count": 10,
         *           "date": "2025-01-01"
         *         },
         *         {
         *           "avg_score": 42.1,
         *           "count": 15,
         *           "date": "2025-01-02"
         *         },
         *         {
         *           "avg_score": 38.7,
         *           "count": 12,
         *           "date": "2025-01-03"
         *         }
         *       ],
         *       "end_date": "2025-01-03",
         *       "start_date": "2025-01-01"
         *     }
         */
        RiskScoreTrendsResponse: {
            /**
             * Data Points
             * @description Average risk score aggregated by day
             */
            data_points: components["schemas"]["RiskScoreTrendDataPoint"][];
            /**
             * End Date
             * Format: date
             * @description End date of the date range
             */
            end_date: string;
            /**
             * Start Date
             * Format: date
             * @description Start date of the date range
             */
            start_date: string;
        };
        /**
         * RuleTestEventResult
         * @description Schema for a single event's test result.
         * @example {
         *       "camera_id": "front_door",
         *       "event_id": 123,
         *       "matched_conditions": [
         *         "risk_score >= 70",
         *         "object_type in ['person']"
         *       ],
         *       "matches": true,
         *       "object_types": [
         *         "person"
         *       ],
         *       "risk_score": 75,
         *       "started_at": "2025-12-28T22:15:00Z"
         *     }
         */
        RuleTestEventResult: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Event Id
             * @description Event ID
             */
            event_id: number;
            /**
             * Matched Conditions
             * @description List of conditions that matched
             */
            matched_conditions?: string[];
            /**
             * Matches
             * @description Whether the rule matched this event
             */
            matches: boolean;
            /**
             * Object Types
             * @description Detected object types
             */
            object_types?: string[];
            /**
             * Risk Score
             * @description Event risk score
             */
            risk_score?: number | null;
            /**
             * Started At
             * @description Event start timestamp
             */
            started_at?: string | null;
        };
        /**
         * RuleTestRequest
         * @description Schema for testing a rule against historical events.
         * @example {
         *       "event_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "test_time": "2025-12-28T22:30:00Z"
         *     }
         */
        RuleTestRequest: {
            /**
             * Event Ids
             * @description Specific event IDs to test against. If not provided, tests against recent events.
             */
            event_ids?: number[] | null;
            /**
             * Limit
             * @description Maximum number of recent events to test (if event_ids not provided)
             * @default 10
             */
            limit: number;
            /**
             * Test Time
             * @description Override current time for schedule testing (ISO format)
             */
            test_time?: string | null;
        };
        /**
         * RuleTestResponse
         * @description Schema for rule test response.
         * @example {
         *       "events_matched": 3,
         *       "events_tested": 10,
         *       "match_rate": 0.3,
         *       "results": [
         *         {
         *           "camera_id": "front_door",
         *           "event_id": 123,
         *           "matched_conditions": [
         *             "risk_score >= 70",
         *             "object_type in ['person']"
         *           ],
         *           "matches": true,
         *           "object_types": [
         *             "person"
         *           ],
         *           "risk_score": 75,
         *           "started_at": "2025-12-28T22:15:00Z"
         *         }
         *       ],
         *       "rule_id": "550e8400-e29b-41d4-a716-446655440000",
         *       "rule_name": "Night Intruder Alert"
         *     }
         */
        RuleTestResponse: {
            /**
             * Events Matched
             * @description Number of events that matched the rule
             */
            events_matched: number;
            /**
             * Events Tested
             * @description Number of events tested
             */
            events_tested: number;
            /**
             * Match Rate
             * @description Proportion of events that matched (0.0-1.0)
             */
            match_rate: number;
            /**
             * Results
             * @description Per-event test results
             */
            results: components["schemas"]["RuleTestEventResult"][];
            /**
             * Rule Id
             * @description Rule ID that was tested
             */
            rule_id: string;
            /**
             * Rule Name
             * @description Rule name
             */
            rule_name: string;
        };
        /**
         * SceneChangeAcknowledgeResponse
         * @description Response schema for acknowledging a scene change.
         *
         *     Confirms that a scene change has been acknowledged.
         * @example {
         *       "acknowledged": true,
         *       "acknowledged_at": "2026-01-03T11:00:00Z",
         *       "id": 1
         *     }
         */
        SceneChangeAcknowledgeResponse: {
            /**
             * Acknowledged
             * @description Acknowledgement status (always True)
             * @default true
             */
            acknowledged: boolean;
            /**
             * Acknowledged At
             * Format: date-time
             * @description When the change was acknowledged
             */
            acknowledged_at: string;
            /**
             * Id
             * @description Scene change ID
             */
            id: number;
        };
        /**
         * SceneChangeListResponse
         * @description Response schema for listing scene changes.
         *
         *     Returns a list of scene changes for a camera with cursor-based pagination.
         * @example {
         *       "camera_id": "front_door",
         *       "has_more": true,
         *       "next_cursor": "2026-01-03T09:30:00Z",
         *       "scene_changes": [
         *         {
         *           "acknowledged": false,
         *           "change_type": "view_blocked",
         *           "detected_at": "2026-01-03T10:30:00Z",
         *           "id": 1,
         *           "similarity_score": 0.23
         *         }
         *       ],
         *       "total_changes": 1
         *     }
         */
        SceneChangeListResponse: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Has More
             * @description Whether there are more results available
             * @default false
             */
            has_more: boolean;
            /**
             * Next Cursor
             * @description Cursor for fetching the next page (ISO 8601 timestamp)
             */
            next_cursor?: string | null;
            /**
             * Scene Changes
             * @description List of scene changes
             */
            scene_changes?: components["schemas"]["SceneChangeResponse"][];
            /**
             * Total Changes
             * @description Number of scene changes returned
             * @default 0
             */
            total_changes: number;
        };
        /**
         * SceneChangeResponse
         * @description Response schema for a single scene change.
         *
         *     Represents a detected camera view change that may indicate
         *     tampering, angle changes, or blocked views.
         * @example {
         *       "acknowledged": false,
         *       "change_type": "view_blocked",
         *       "detected_at": "2026-01-03T10:30:00Z",
         *       "file_path": "/export/foscam/front_door/image.jpg",
         *       "id": 1,
         *       "similarity_score": 0.23
         *     }
         */
        SceneChangeResponse: {
            /**
             * Acknowledged
             * @description Whether the change has been acknowledged
             * @default false
             */
            acknowledged: boolean;
            /**
             * Acknowledged At
             * @description When the change was acknowledged
             */
            acknowledged_at?: string | null;
            /**
             * Change Type
             * @description Type of change: view_blocked, angle_changed, view_tampered, unknown
             */
            change_type: string;
            /**
             * Detected At
             * Format: date-time
             * @description When the scene change was detected
             */
            detected_at: string;
            /**
             * File Path
             * @description Path to the image that triggered detection
             */
            file_path?: string | null;
            /**
             * Id
             * @description Unique scene change ID
             */
            id: number;
            /**
             * Similarity Score
             * @description SSIM similarity score (0-1, lower means more different)
             */
            similarity_score: number;
        };
        /**
         * ScheduledReportCreate
         * @description Schema for creating a new scheduled report.
         *
         *     Used when setting up a new automated report schedule.
         * @example {
         *       "day_of_week": 1,
         *       "email_recipients": [
         *         "admin@example.com"
         *       ],
         *       "enabled": true,
         *       "format": "pdf",
         *       "frequency": "weekly",
         *       "hour": 8,
         *       "include_charts": true,
         *       "include_event_details": true,
         *       "minute": 0,
         *       "name": "Weekly Security Summary",
         *       "timezone": "America/New_York"
         *     }
         */
        ScheduledReportCreate: {
            /**
             * Day Of Month
             * @description Day of month (1-31) for monthly reports
             */
            day_of_month?: number | null;
            /**
             * Day Of Week
             * @description Day of week (0=Monday, 6=Sunday) for weekly reports
             */
            day_of_week?: number | null;
            /**
             * Email Recipients
             * @description Email addresses to send report to (max 10)
             */
            email_recipients?: string[] | null;
            /**
             * Enabled
             * @description Whether the scheduled report is active
             * @default true
             */
            enabled: boolean;
            /**
             * @description Output format for the report (pdf, csv, json)
             * @default pdf
             */
            format: components["schemas"]["ReportFormat"];
            /** @description How often the report should run (daily, weekly, monthly) */
            frequency: components["schemas"]["ReportFrequency"];
            /**
             * Hour
             * @description Hour of day to run report (0-23, default 8)
             * @default 8
             */
            hour: number;
            /**
             * Include Charts
             * @description Include visual charts in the report
             * @default true
             */
            include_charts: boolean;
            /**
             * Include Event Details
             * @description Include detailed event breakdowns
             * @default true
             */
            include_event_details: boolean;
            /**
             * Minute
             * @description Minute of hour to run report (0-59, default 0)
             * @default 0
             */
            minute: number;
            /**
             * Name
             * @description Name/title of the scheduled report
             */
            name: string;
            /**
             * Timezone
             * @description Timezone for schedule (e.g., 'America/New_York', 'UTC')
             * @default UTC
             */
            timezone: string;
        };
        /**
         * ScheduledReportListResponse
         * @description Schema for scheduled report list response.
         *
         *     Returns a list of scheduled reports with total count.
         * @example {
         *       "items": [
         *         {
         *           "created_at": "2025-01-01T12:00:00Z",
         *           "day_of_week": 1,
         *           "email_recipients": [
         *             "admin@example.com"
         *           ],
         *           "enabled": true,
         *           "format": "pdf",
         *           "frequency": "weekly",
         *           "hour": 8,
         *           "id": 1,
         *           "include_charts": true,
         *           "include_event_details": true,
         *           "last_run_at": "2025-01-20T08:00:00Z",
         *           "minute": 0,
         *           "name": "Weekly Security Summary",
         *           "next_run_at": "2025-01-27T08:00:00Z",
         *           "timezone": "America/New_York",
         *           "updated_at": "2025-01-15T09:30:00Z"
         *         }
         *       ],
         *       "total": 1
         *     }
         */
        ScheduledReportListResponse: {
            /**
             * Items
             * @description List of scheduled reports
             */
            items: components["schemas"]["ScheduledReportResponse"][];
            /**
             * Total
             * @description Total number of scheduled reports
             */
            total: number;
        };
        /**
         * ScheduledReportResponse
         * @description Schema for scheduled report response.
         *
         *     Returned when retrieving or creating a scheduled report.
         * @example {
         *       "created_at": "2025-01-01T12:00:00Z",
         *       "day_of_week": 1,
         *       "email_recipients": [
         *         "admin@example.com"
         *       ],
         *       "enabled": true,
         *       "format": "pdf",
         *       "frequency": "weekly",
         *       "hour": 8,
         *       "id": 1,
         *       "include_charts": true,
         *       "include_event_details": true,
         *       "last_run_at": "2025-01-20T08:00:00Z",
         *       "minute": 0,
         *       "name": "Weekly Security Summary",
         *       "next_run_at": "2025-01-27T08:00:00Z",
         *       "timezone": "America/New_York",
         *       "updated_at": "2025-01-15T09:30:00Z"
         *     }
         */
        ScheduledReportResponse: {
            /**
             * Created At
             * Format: date-time
             * @description When the report was created
             */
            created_at: string;
            /**
             * Day Of Month
             * @description Day of month (1-31) for monthly reports
             */
            day_of_month?: number | null;
            /**
             * Day Of Week
             * @description Day of week (0=Monday, 6=Sunday) for weekly reports
             */
            day_of_week?: number | null;
            /**
             * Email Recipients
             * @description Email addresses to send report to
             */
            email_recipients?: string[] | null;
            /**
             * Enabled
             * @description Whether the scheduled report is active
             */
            enabled: boolean;
            /**
             * Format
             * @description Output format for the report
             */
            format: components["schemas"]["ReportFormat"] | string;
            /**
             * Frequency
             * @description How often the report runs
             */
            frequency: components["schemas"]["ReportFrequency"] | string;
            /**
             * Hour
             * @description Hour of day to run report (0-23)
             */
            hour: number;
            /**
             * Id
             * @description Scheduled report ID
             */
            id: number;
            /**
             * Include Charts
             * @description Include visual charts in the report
             */
            include_charts: boolean;
            /**
             * Include Event Details
             * @description Include detailed event breakdowns
             */
            include_event_details: boolean;
            /**
             * Last Run At
             * @description When the report last ran successfully
             */
            last_run_at?: string | null;
            /**
             * Minute
             * @description Minute of hour to run report (0-59)
             */
            minute: number;
            /**
             * Name
             * @description Name/title of the scheduled report
             */
            name: string;
            /**
             * Next Run At
             * @description When the report is scheduled to run next
             */
            next_run_at?: string | null;
            /**
             * Timezone
             * @description Timezone for schedule
             */
            timezone: string;
            /**
             * Updated At
             * Format: date-time
             * @description When the report was last updated
             */
            updated_at: string;
        };
        /**
         * ScheduledReportRunResponse
         * @description Schema for manual report run response.
         *
         *     Returned when a report is manually triggered.
         * @example {
         *       "message": "Report generation started",
         *       "report_id": 1,
         *       "started_at": "2025-01-25T10:30:00Z",
         *       "status": "running"
         *     }
         */
        ScheduledReportRunResponse: {
            /**
             * Message
             * @description Status message
             */
            message: string;
            /**
             * Report Id
             * @description ID of the report being run
             */
            report_id: number;
            /**
             * Started At
             * Format: date-time
             * @description When the run was initiated
             */
            started_at: string;
            /**
             * Status
             * @description Status of the run (running, queued, failed)
             */
            status: string;
        };
        /**
         * ScheduledReportUpdate
         * @description Schema for updating an existing scheduled report.
         *
         *     All fields are optional for partial updates.
         * @example {
         *       "enabled": false,
         *       "name": "Updated Weekly Report"
         *     }
         */
        ScheduledReportUpdate: {
            /**
             * Day Of Month
             * @description Day of month (1-31) for monthly reports
             */
            day_of_month?: number | null;
            /**
             * Day Of Week
             * @description Day of week (0=Monday, 6=Sunday) for weekly reports
             */
            day_of_week?: number | null;
            /**
             * Email Recipients
             * @description Email addresses to send report to (max 10)
             */
            email_recipients?: string[] | null;
            /**
             * Enabled
             * @description Whether the scheduled report is active
             */
            enabled?: boolean | null;
            /** @description Output format for the report (pdf, csv, json) */
            format?: components["schemas"]["ReportFormat"] | null;
            /** @description How often the report should run (daily, weekly, monthly) */
            frequency?: components["schemas"]["ReportFrequency"] | null;
            /**
             * Hour
             * @description Hour of day to run report (0-23)
             */
            hour?: number | null;
            /**
             * Include Charts
             * @description Include visual charts in the report
             */
            include_charts?: boolean | null;
            /**
             * Include Event Details
             * @description Include detailed event breakdowns
             */
            include_event_details?: boolean | null;
            /**
             * Minute
             * @description Minute of hour to run report (0-59)
             */
            minute?: number | null;
            /**
             * Name
             * @description Name/title of the scheduled report
             */
            name?: string | null;
            /**
             * Timezone
             * @description Timezone for schedule (e.g., 'America/New_York', 'UTC')
             */
            timezone?: string | null;
        };
        /**
         * SearchResponse
         * @description Schema for search response with pagination.
         * @example {
         *       "limit": 50,
         *       "offset": 0,
         *       "results": [
         *         {
         *           "camera_id": "front_door",
         *           "camera_name": "Front Door",
         *           "detection_count": 5,
         *           "detection_ids": [
         *             1,
         *             2,
         *             3,
         *             4,
         *             5
         *           ],
         *           "ended_at": "2025-12-23T12:02:30Z",
         *           "id": 1,
         *           "object_types": "person, vehicle",
         *           "reasoning": "Unknown individual approaching entrance during nighttime",
         *           "relevance_score": 0.85,
         *           "reviewed": false,
         *           "risk_level": "medium",
         *           "risk_score": 75,
         *           "started_at": "2025-12-23T12:00:00Z",
         *           "summary": "Suspicious person detected near front entrance"
         *         }
         *       ],
         *       "total_count": 42
         *     }
         */
        SearchResponse: {
            /**
             * Limit
             * @description Maximum number of results returned
             */
            limit: number;
            /**
             * Offset
             * @description Number of results skipped
             */
            offset: number;
            /**
             * Results
             * @description List of search results
             */
            results: components["schemas"]["SearchResult"][];
            /**
             * Total Count
             * @description Total number of matching events
             */
            total_count: number;
        };
        /**
         * SearchResult
         * @description Schema for a single search result.
         * @example {
         *       "camera_id": "front_door",
         *       "camera_name": "Front Door",
         *       "detection_count": 5,
         *       "detection_ids": [
         *         1,
         *         2,
         *         3,
         *         4,
         *         5
         *       ],
         *       "ended_at": "2025-12-23T12:02:30Z",
         *       "id": 1,
         *       "object_types": "person, vehicle",
         *       "reasoning": "Unknown individual approaching entrance during nighttime hours",
         *       "relevance_score": 0.85,
         *       "reviewed": false,
         *       "risk_level": "medium",
         *       "risk_score": 75,
         *       "started_at": "2025-12-23T12:00:00Z",
         *       "summary": "Suspicious person detected near front entrance"
         *     }
         */
        SearchResult: {
            /**
             * Camera Id
             * @description Camera ID
             */
            camera_id: string;
            /**
             * Camera Name
             * @description Camera display name
             */
            camera_name?: string | null;
            /**
             * Detection Count
             * @description Number of detections in this event
             * @default 0
             */
            detection_count: number;
            /**
             * Detection Ids
             * @description List of detection IDs associated with this event
             */
            detection_ids?: number[];
            /**
             * Ended At
             * @description Event end timestamp
             */
            ended_at?: string | null;
            /**
             * Id
             * @description Event ID
             */
            id: number;
            /**
             * Object Types
             * @description Comma-separated detected object types
             */
            object_types?: string | null;
            /**
             * Reasoning
             * @description LLM reasoning for risk score
             */
            reasoning?: string | null;
            /**
             * Relevance Score
             * @description Full-text search relevance score (higher is more relevant)
             * @default 0
             */
            relevance_score: number;
            /**
             * Reviewed
             * @description Whether event has been reviewed
             * @default false
             */
            reviewed: boolean;
            /**
             * Risk Level
             * @description Risk level (low/medium/high/critical), computed from risk_score using severity thresholds
             */
            readonly risk_level: string | null;
            /**
             * Risk Score
             * @description Risk score (0-100)
             */
            risk_score?: number | null;
            /**
             * Started At
             * Format: date-time
             * @description Event start timestamp
             */
            started_at: string;
            /**
             * Summary
             * @description LLM-generated event summary
             */
            summary?: string | null;
            /**
             * Thumbnail Url
             * @description URL to event thumbnail image (from first detection)
             */
            thumbnail_url?: string | null;
        };
        /**
         * SeedCamerasRequest
         * @description Request schema for seeding cameras.
         */
        SeedCamerasRequest: {
            /**
             * Clear Existing
             * @description Remove existing cameras first
             * @default false
             */
            clear_existing: boolean;
            /**
             * Count
             * @description Number of cameras to create (1-6)
             * @default 6
             */
            count: number;
            /**
             * Create Folders
             * @description Create camera folders on filesystem
             * @default false
             */
            create_folders: boolean;
        };
        /**
         * SeedCamerasResponse
         * @description Response schema for seed cameras endpoint.
         */
        SeedCamerasResponse: {
            /** Cameras */
            cameras: {
                [key: string]: unknown;
            }[];
            /** Cleared */
            cleared: number;
            /** Created */
            created: number;
        };
        /**
         * SeedEventsRequest
         * @description Request schema for seeding events.
         */
        SeedEventsRequest: {
            /**
             * Clear Existing
             * @description Remove existing events and detections
             * @default false
             */
            clear_existing: boolean;
            /**
             * Count
             * @description Number of events to create (1-100)
             * @default 15
             */
            count: number;
        };
        /**
         * SeedEventsResponse
         * @description Response schema for seed events endpoint.
         */
        SeedEventsResponse: {
            /** Detections Cleared */
            detections_cleared: number;
            /** Detections Created */
            detections_created: number;
            /** Events Cleared */
            events_cleared: number;
            /** Events Created */
            events_created: number;
        };
        /**
         * SeedPipelineLatencyRequest
         * @description Request schema for seeding pipeline latency data.
         */
        SeedPipelineLatencyRequest: {
            /**
             * Num Samples
             * @description Number of latency samples to generate per stage (10-1000)
             * @default 100
             */
            num_samples: number;
            /**
             * Time Span Hours
             * @description Time span in hours for the generated samples (1-168)
             * @default 24
             */
            time_span_hours: number;
        };
        /**
         * SeedPipelineLatencyResponse
         * @description Response schema for seed pipeline latency endpoint.
         */
        SeedPipelineLatencyResponse: {
            /** Message */
            message: string;
            /** Samples Per Stage */
            samples_per_stage: number;
            /** Stages Seeded */
            stages_seeded: string[];
            /** Time Span Hours */
            time_span_hours: number;
        };
        /**
         * ServiceActionResponse
         * @description Response for service action endpoints (restart, enable, disable, start).
         *
         *     Returned after POST /api/system/services/{name}/restart, enable, disable, or start.
         * @example {
         *       "message": "Service restarted successfully",
         *       "service": {
         *         "category": "ai",
         *         "container_id": "abc123...",
         *         "display_name": "YOLO26v2",
         *         "enabled": true,
         *         "failure_count": 0,
         *         "image": "ghcr.io/.../yolo26:latest",
         *         "last_restart_at": "2026-01-05T15:50:00Z",
         *         "name": "ai-detector",
         *         "port": 8090,
         *         "restart_count": 3,
         *         "status": "starting"
         *       },
         *       "success": true
         *     }
         */
        ServiceActionResponse: {
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
            /** @description Updated service information after the action */
            service: components["schemas"]["ServiceInfo"];
            /**
             * Success
             * @description Whether the action completed successfully
             */
            success: boolean;
        };
        /**
         * ServiceCategory
         * @description Service category for classification and restart policy.
         *
         *     Categories determine restart behavior and priority:
         *     - INFRASTRUCTURE: Critical services (PostgreSQL, Redis) with aggressive restart
         *     - AI: AI/ML services with standard backoff
         *     - MONITORING: Optional monitoring services with lenient restart
         * @enum {string}
         */
        ServiceCategory: "infrastructure" | "ai" | "monitoring";
        /**
         * ServiceHealthResponse
         * @description Response schema for AI service health status.
         *
         *     Returns health status of all AI services including GPU assignments.
         * @example {
         *       "services": [
         *         {
         *           "gpu_index": 0,
         *           "health": "healthy",
         *           "name": "ai-llm",
         *           "status": "running"
         *         },
         *         {
         *           "gpu_index": 1,
         *           "health": "healthy",
         *           "name": "ai-detector",
         *           "status": "running"
         *         }
         *       ]
         *     }
         */
        ServiceHealthResponse: {
            /**
             * Services
             * @description Status of all AI services
             */
            services: components["schemas"]["ServiceHealthStatus"][];
        };
        /**
         * ServiceHealthState
         * @description Health state for a service in the full health check.
         *
         *     States:
         *     - healthy: Service is fully operational
         *     - unhealthy: Service is down or experiencing critical issues
         *     - degraded: Service is partially operational
         *     - unknown: Service status cannot be determined
         * @enum {string}
         */
        ServiceHealthState: "healthy" | "unhealthy" | "degraded" | "unknown";
        /**
         * ServiceHealthStatus
         * @description Schema for service health status including GPU assignment.
         *
         *     Provides comprehensive service health information for the GPU settings UI,
         *     including container status, health check result, and GPU assignment.
         * @example {
         *       "gpu_index": 0,
         *       "health": "healthy",
         *       "name": "ai-llm",
         *       "status": "running"
         *     }
         */
        ServiceHealthStatus: {
            /**
             * Gpu Index
             * @description Assigned GPU index
             */
            gpu_index?: number | null;
            /**
             * Health
             * @description Health check result (healthy, unhealthy, unknown)
             */
            health: string;
            /**
             * Name
             * @description Service name (e.g., 'ai-llm')
             */
            name: string;
            /**
             * Restart Status
             * @description Restart status if currently restarting (pending, completed)
             */
            restart_status?: string | null;
            /**
             * Status
             * @description Container status (running, stopped, etc.)
             */
            status: string;
        };
        /**
         * ServiceHealthStatusResponse
         * @description Health status of a registered service.
         */
        ServiceHealthStatusResponse: {
            /**
             * Consecutive Failures
             * @description Count of consecutive health check failures
             */
            consecutive_failures: number;
            /**
             * Error Message
             * @description Last error message if unhealthy
             */
            error_message?: string | null;
            /**
             * Last Check
             * @description Monotonic time of last health check
             */
            last_check?: number | null;
            /**
             * Name
             * @description Service name
             */
            name: string;
            /**
             * Status
             * @description Health status (healthy, unhealthy, unknown)
             */
            status: string;
        };
        /**
         * ServiceInfo
         * @description Information about a single managed service.
         *
         *     Contains identity, configuration, and runtime status for a container
         *     managed by the orchestrator.
         * @example {
         *       "category": "ai",
         *       "container_id": "abc123def456",
         *       "display_name": "YOLO26v2",
         *       "enabled": true,
         *       "failure_count": 0,
         *       "image": "ghcr.io/.../yolo26:latest",
         *       "last_restart_at": "2026-01-05T10:30:00Z",
         *       "name": "ai-detector",
         *       "port": 8090,
         *       "restart_count": 2,
         *       "status": "running",
         *       "uptime_seconds": 3600
         *     }
         */
        ServiceInfo: {
            /** @description Service category: infrastructure, ai, or monitoring */
            category: components["schemas"]["ServiceCategory"];
            /**
             * Container Id
             * @description Docker container ID (short form)
             */
            container_id?: string | null;
            /**
             * Display Name
             * @description Human-readable display name (e.g., 'YOLO26v2', 'PostgreSQL')
             */
            display_name: string;
            /**
             * Enabled
             * @description Whether auto-restart is enabled for this service
             * @default true
             */
            enabled: boolean;
            /**
             * Failure Count
             * @description Consecutive health check failure count
             * @default 0
             */
            failure_count: number;
            /**
             * Image
             * @description Container image (e.g., 'postgres:16-alpine', 'ghcr.io/.../yolo26:latest')
             */
            image?: string | null;
            /**
             * Last Restart At
             * @description Timestamp of last restart (null if never restarted)
             */
            last_restart_at?: string | null;
            /**
             * Name
             * @description Service identifier (e.g., 'ai-detector', 'postgres', 'grafana')
             */
            name: string;
            /**
             * Port
             * @description Primary service port
             */
            port: number;
            /**
             * Restart Count
             * @description Total restarts since backend boot
             * @default 0
             */
            restart_count: number;
            /** @description Current service status: running, starting, unhealthy, stopped, disabled, not_found */
            status: components["schemas"]["ContainerServiceStatus"];
            /**
             * Uptime Seconds
             * @description Seconds since container started (null if not running)
             */
            uptime_seconds?: number | null;
        };
        /**
         * ServiceStatus
         * @description Schema for service status after GPU config apply.
         *
         *     Reports the status of a service after applying GPU configuration changes.
         * @example {
         *       "service": "ai-llm",
         *       "status": "running"
         *     }
         */
        ServiceStatus: {
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
            /**
             * Service
             * @description Service name
             */
            service: string;
            /**
             * Status
             * @description Service status (running, starting, stopped, error)
             */
            status: string;
        };
        /**
         * ServicesResponse
         * @description Response for GET /api/system/services.
         *
         *     Returns a list of all managed services with their current status
         *     and category-level summaries.
         * @example {
         *       "by_category": {
         *         "ai": {
         *           "healthy": 3,
         *           "total": 5,
         *           "unhealthy": 2
         *         },
         *         "infrastructure": {
         *           "healthy": 2,
         *           "total": 2,
         *           "unhealthy": 0
         *         },
         *         "monitoring": {
         *           "healthy": 4,
         *           "total": 4,
         *           "unhealthy": 0
         *         }
         *       },
         *       "services": [
         *         {
         *           "category": "infrastructure",
         *           "container_id": "def456...",
         *           "display_name": "PostgreSQL",
         *           "enabled": true,
         *           "failure_count": 0,
         *           "image": "postgres:16-alpine",
         *           "name": "postgres",
         *           "port": 5432,
         *           "restart_count": 0,
         *           "status": "running",
         *           "uptime_seconds": 86400
         *         },
         *         {
         *           "category": "ai",
         *           "container_id": "abc123...",
         *           "display_name": "YOLO26v2",
         *           "enabled": true,
         *           "failure_count": 0,
         *           "image": "ghcr.io/.../yolo26:latest",
         *           "last_restart_at": "2026-01-05T10:30:00Z",
         *           "name": "ai-detector",
         *           "port": 8090,
         *           "restart_count": 2,
         *           "status": "running",
         *           "uptime_seconds": 3600
         *         }
         *       ],
         *       "timestamp": "2026-01-05T15:45:00Z"
         *     }
         */
        ServicesResponse: {
            /**
             * By Category
             * @description Health summary by category (infrastructure, ai, monitoring)
             */
            by_category: {
                [key: string]: components["schemas"]["CategorySummary"];
            };
            /**
             * Services
             * @description List of all managed services with current status
             */
            services: components["schemas"]["ServiceInfo"][];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status snapshot
             */
            timestamp: string;
        };
        /**
         * SettingsResponse
         * @description Complete settings response with all configurable settings grouped by category.
         *
         *     This is the response schema for GET /api/v1/settings, containing all
         *     user-configurable settings organized into logical groups.
         * @example {
         *       "batch": {
         *         "idle_timeout_seconds": 30,
         *         "window_seconds": 90
         *       },
         *       "detection": {
         *         "confidence_threshold": 0.5,
         *         "fast_path_threshold": 0.9
         *       },
         *       "features": {
         *         "background_eval_enabled": true,
         *         "clip_generation_enabled": true,
         *         "image_quality_enabled": true,
         *         "reid_enabled": true,
         *         "scene_change_enabled": true,
         *         "vision_extraction_enabled": true
         *       },
         *       "queue": {
         *         "backpressure_threshold": 0.8,
         *         "max_size": 10000
         *       },
         *       "rate_limiting": {
         *         "burst_size": 10,
         *         "enabled": true,
         *         "requests_per_minute": 60
         *       },
         *       "retention": {
         *         "days": 30,
         *         "log_days": 7
         *       },
         *       "severity": {
         *         "high_max": 84,
         *         "low_max": 29,
         *         "medium_max": 59
         *       }
         *     }
         */
        SettingsResponse: {
            /** @description Batch processing settings */
            batch: components["schemas"]["BatchSettings"];
            /** @description Detection confidence threshold settings */
            detection: components["schemas"]["DetectionSettings"];
            /** @description Feature toggle settings */
            features: components["schemas"]["FeatureSettings"];
            /** @description Queue settings */
            queue: components["schemas"]["QueueSettings"];
            /** @description Rate limiting settings */
            rate_limiting: components["schemas"]["RateLimitingSettings"];
            /** @description Data retention settings */
            retention: components["schemas"]["RetentionSettings"];
            /** @description Severity threshold settings for risk categorization */
            severity: components["schemas"]["SeveritySettings"];
        };
        /**
         * SettingsUpdate
         * @description Schema for updating runtime settings via PATCH.
         *
         *     All fields are optional to support partial updates. Only provided
         *     fields will be updated. Changes are written to data/runtime.env
         *     and take effect immediately without server restart.
         * @example {
         *       "detection": {
         *         "confidence_threshold": 0.6
         *       },
         *       "features": {
         *         "reid_enabled": false
         *       }
         *     }
         */
        SettingsUpdate: {
            /** @description Batch processing settings */
            batch?: components["schemas"]["BatchSettingsUpdate"] | null;
            /** @description Detection confidence threshold settings */
            detection?: components["schemas"]["DetectionSettingsUpdate"] | null;
            /** @description Feature toggle settings */
            features?: components["schemas"]["FeatureSettingsUpdate"] | null;
            /** @description Queue settings */
            queue?: components["schemas"]["QueueSettingsUpdate"] | null;
            /** @description Rate limiting settings */
            rate_limiting?: components["schemas"]["RateLimitingSettingsUpdate"] | null;
            /** @description Data retention settings */
            retention?: components["schemas"]["RetentionSettingsUpdate"] | null;
            /** @description Severity threshold settings for risk categorization */
            severity?: components["schemas"]["SeveritySettingsUpdate"] | null;
        };
        /**
         * SeverityDefinitionResponse
         * @description Definition of a single severity level.
         * @example {
         *       "color": "#f97316",
         *       "description": "Concerning activity, review soon",
         *       "label": "High",
         *       "max_score": 84,
         *       "min_score": 60,
         *       "priority": 1,
         *       "severity": "high"
         *     }
         */
        SeverityDefinitionResponse: {
            /**
             * Color
             * @description Hex color code for UI display (e.g., '#22c55e')
             */
            color: string;
            /**
             * Description
             * @description Description of when this severity applies
             */
            description: string;
            /**
             * Label
             * @description Human-readable label for the severity level
             */
            label: string;
            /**
             * Max Score
             * @description Maximum risk score for this severity (inclusive)
             */
            max_score: number;
            /**
             * Min Score
             * @description Minimum risk score for this severity (inclusive)
             */
            min_score: number;
            /**
             * Priority
             * @description Sort priority (0 = highest priority, 3 = lowest)
             */
            priority: number;
            /** @description The severity level identifier */
            severity: components["schemas"]["SeverityEnum"];
        };
        /**
         * SeverityEnum
         * @description Severity levels for API responses.
         * @enum {string}
         */
        SeverityEnum: "low" | "medium" | "high" | "critical";
        /**
         * SeverityMetadataResponse
         * @description Response schema for severity metadata endpoint.
         *
         *     Provides complete information about severity levels including:
         *     - All severity definitions with thresholds and colors
         *     - Current threshold configuration
         *     - Useful for frontend to display severity information consistently
         * @example {
         *       "definitions": [
         *         {
         *           "color": "#22c55e",
         *           "description": "Routine activity, no concern",
         *           "label": "Low",
         *           "max_score": 29,
         *           "min_score": 0,
         *           "priority": 3,
         *           "severity": "low"
         *         },
         *         {
         *           "color": "#eab308",
         *           "description": "Notable activity, worth reviewing",
         *           "label": "Medium",
         *           "max_score": 59,
         *           "min_score": 30,
         *           "priority": 2,
         *           "severity": "medium"
         *         },
         *         {
         *           "color": "#f97316",
         *           "description": "Concerning activity, review soon",
         *           "label": "High",
         *           "max_score": 84,
         *           "min_score": 60,
         *           "priority": 1,
         *           "severity": "high"
         *         },
         *         {
         *           "color": "#ef4444",
         *           "description": "Immediate attention required",
         *           "label": "Critical",
         *           "max_score": 100,
         *           "min_score": 85,
         *           "priority": 0,
         *           "severity": "critical"
         *         }
         *       ],
         *       "thresholds": {
         *         "high_max": 84,
         *         "low_max": 29,
         *         "medium_max": 59
         *       }
         *     }
         */
        SeverityMetadataResponse: {
            /**
             * Definitions
             * @description List of all severity level definitions
             */
            definitions: components["schemas"]["SeverityDefinitionResponse"][];
            /** @description Current severity threshold configuration */
            thresholds: components["schemas"]["SeverityThresholds"];
        };
        /**
         * SeveritySettings
         * @description Severity threshold settings for risk score categorization.
         *
         *     Defines the maximum risk score values for each severity level.
         *     Risk scores are 0-100, and severity is determined by:
         *     - LOW: 0 to low_max
         *     - MEDIUM: low_max+1 to medium_max
         *     - HIGH: medium_max+1 to high_max
         *     - CRITICAL: above high_max
         * @example {
         *       "high_max": 84,
         *       "low_max": 29,
         *       "medium_max": 59
         *     }
         */
        SeveritySettings: {
            /**
             * High Max
             * @description Maximum risk score for HIGH severity (above = CRITICAL)
             */
            high_max: number;
            /**
             * Low Max
             * @description Maximum risk score for LOW severity (0 to this value = LOW)
             */
            low_max: number;
            /**
             * Medium Max
             * @description Maximum risk score for MEDIUM severity
             */
            medium_max: number;
        };
        /**
         * SeveritySettingsUpdate
         * @description Severity settings update schema (all fields optional).
         *
         *     Used for PATCH /api/v1/settings to partially update severity thresholds.
         *     Validates that severity thresholds maintain proper ordering (low < medium < high).
         * @example {
         *       "low_max": 25
         *     }
         */
        SeveritySettingsUpdate: {
            /**
             * High Max
             * @description Maximum risk score for HIGH severity (above = CRITICAL)
             */
            high_max?: number | null;
            /**
             * Low Max
             * @description Maximum risk score for LOW severity (0 to this value = LOW)
             */
            low_max?: number | null;
            /**
             * Medium Max
             * @description Maximum risk score for MEDIUM severity
             */
            medium_max?: number | null;
        };
        /**
         * SeverityThresholds
         * @description Current severity threshold configuration.
         * @example {
         *       "high_max": 84,
         *       "low_max": 29,
         *       "medium_max": 59
         *     }
         */
        SeverityThresholds: {
            /**
             * High Max
             * @description Maximum risk score for HIGH severity (medium_max+1 to this value = HIGH)
             */
            high_max: number;
            /**
             * Low Max
             * @description Maximum risk score for LOW severity (0 to this value = LOW)
             */
            low_max: number;
            /**
             * Medium Max
             * @description Maximum risk score for MEDIUM severity (low_max+1 to this value = MEDIUM)
             */
            medium_max: number;
        };
        /**
         * SeverityThresholdsUpdateRequest
         * @description Request schema for updating severity thresholds.
         *
         *     The thresholds must form contiguous ranges from 0-100:
         *     - LOW: 0 to low_max (inclusive)
         *     - MEDIUM: low_max+1 to medium_max (inclusive)
         *     - HIGH: medium_max+1 to high_max (inclusive)
         *     - CRITICAL: high_max+1 to 100 (inclusive)
         *
         *     Validation rules:
         *     - 0 < low_max < medium_max < high_max < 100
         *     - This ensures all ranges are valid and cover 0-100 without gaps or overlaps
         * @example {
         *       "high_max": 84,
         *       "low_max": 29,
         *       "medium_max": 59
         *     }
         */
        SeverityThresholdsUpdateRequest: {
            /**
             * High Max
             * @description Maximum risk score for HIGH severity (3-99)
             */
            high_max: number;
            /**
             * Low Max
             * @description Maximum risk score for LOW severity (1-98)
             */
            low_max: number;
            /**
             * Medium Max
             * @description Maximum risk score for MEDIUM severity (2-99)
             */
            medium_max: number;
        };
        /**
         * SourceFilter
         * @description Data source for entity queries.
         *
         *     Controls which storage backend to query for entities:
         *     - redis: Only query Redis hot cache (24h window)
         *     - postgres: Only query PostgreSQL (30d retention)
         *     - both: Query both and merge results (default)
         * @enum {string}
         */
        SourceFilter: "redis" | "postgres" | "both";
        /**
         * StageLatency
         * @description Latency statistics for a single pipeline stage.
         * @example {
         *       "avg_ms": 150.5,
         *       "max_ms": 500,
         *       "min_ms": 50,
         *       "p50_ms": 120,
         *       "p95_ms": 400,
         *       "p99_ms": 480,
         *       "sample_count": 100
         *     }
         */
        StageLatency: {
            /**
             * Avg Ms
             * @description Average latency in milliseconds
             */
            avg_ms?: number | null;
            /**
             * Max Ms
             * @description Maximum latency in milliseconds
             */
            max_ms?: number | null;
            /**
             * Min Ms
             * @description Minimum latency in milliseconds
             */
            min_ms?: number | null;
            /**
             * P50 Ms
             * @description 50th percentile (median) latency in milliseconds
             */
            p50_ms?: number | null;
            /**
             * P95 Ms
             * @description 95th percentile latency in milliseconds
             */
            p95_ms?: number | null;
            /**
             * P99 Ms
             * @description 99th percentile latency in milliseconds
             */
            p99_ms?: number | null;
            /**
             * Sample Count
             * @description Number of samples used to calculate statistics
             */
            sample_count: number;
        };
        /**
         * StorageCategoryStats
         * @description Storage statistics for a single category.
         */
        StorageCategoryStats: {
            /**
             * File Count
             * @description Number of files in this category
             */
            file_count: number;
            /**
             * Size Bytes
             * @description Total size in bytes for this category
             */
            size_bytes: number;
        };
        /**
         * StorageStatsResponse
         * @description Response schema for storage statistics endpoint.
         *
         *     Provides detailed storage usage information including:
         *     - Disk usage for the storage volume
         *     - Breakdown by data category (thumbnails, images, clips)
         *     - Database record counts
         * @example {
         *       "clips": {
         *         "file_count": 50,
         *         "size_bytes": 500000000
         *       },
         *       "detections_count": 892,
         *       "disk_free_bytes": 429496729600,
         *       "disk_total_bytes": 536870912000,
         *       "disk_usage_percent": 20,
         *       "disk_used_bytes": 107374182400,
         *       "events_count": 156,
         *       "gpu_stats_count": 2880,
         *       "images": {
         *         "file_count": 10000,
         *         "size_bytes": 5000000000
         *       },
         *       "logs_count": 5000,
         *       "thumbnails": {
         *         "file_count": 1500,
         *         "size_bytes": 75000000
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        StorageStatsResponse: {
            /** @description Storage used by event video clips */
            clips: components["schemas"]["StorageCategoryStats"];
            /**
             * Detections Count
             * @description Total number of detections in database
             */
            detections_count: number;
            /**
             * Disk Free Bytes
             * @description Free disk space in bytes
             */
            disk_free_bytes: number;
            /**
             * Disk Total Bytes
             * @description Total disk space available in bytes
             */
            disk_total_bytes: number;
            /**
             * Disk Usage Percent
             * @description Disk usage percentage (0-100)
             */
            disk_usage_percent: number;
            /**
             * Disk Used Bytes
             * @description Total disk space used in bytes
             */
            disk_used_bytes: number;
            /**
             * Events Count
             * @description Total number of events in database
             */
            events_count: number;
            /**
             * Gpu Stats Count
             * @description Total number of GPU stats records in database
             */
            gpu_stats_count: number;
            /** @description Storage used by original camera images */
            images: components["schemas"]["StorageCategoryStats"];
            /**
             * Logs Count
             * @description Total number of log entries in database
             */
            logs_count: number;
            /** @description Storage used by detection thumbnails */
            thumbnails: components["schemas"]["StorageCategoryStats"];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of storage stats snapshot
             */
            timestamp: string;
        };
        /**
         * StructuredSummarySchema
         * @description Schema for structured summary data extracted from LLM content.
         *
         *     Contains categorized information extracted from the narrative summary
         *     for display in the dashboard UI with visual elements.
         * @example {
         *       "bullet_points": [
         *         {
         *           "icon": "camera",
         *           "severity": "high",
         *           "text": "Activity at Beach Front Left: person approaching"
         *         },
         *         {
         *           "icon": "alert-circle",
         *           "severity": "high",
         *           "text": "Loitering behavior detected"
         *         }
         *       ],
         *       "dominant_patterns": [
         *         "loitering",
         *         "obscured face"
         *       ],
         *       "focus_areas": [
         *         "Beach Front Left",
         *         "Dock Right"
         *       ],
         *       "max_risk_score": 85,
         *       "weather_conditions": [
         *         "nighttime"
         *       ]
         *     }
         */
        StructuredSummarySchema: {
            /**
             * Bullet Points
             * @description List of bullet points for visual display
             */
            bullet_points?: components["schemas"]["BulletPointSchema"][];
            /**
             * Dominant Patterns
             * @description Behavior patterns detected (loitering, obscured face, etc.)
             */
            dominant_patterns?: string[];
            /**
             * Focus Areas
             * @description Camera names mentioned in the summary
             */
            focus_areas?: string[];
            /**
             * Max Risk Score
             * @description Maximum risk score from events (0-100)
             */
            max_risk_score?: number | null;
            /**
             * Weather Conditions
             * @description Weather/environmental conditions (rainy, nighttime, etc.)
             */
            weather_conditions?: string[];
        };
        /**
         * SummaryResponse
         * @description Schema for a single summary (hourly or daily).
         *
         *     Represents an LLM-generated narrative summary of security events within
         *     a specific time window, with both raw content and structured data.
         * @example {
         *       "content": "Over the past hour, one critical event occurred at 2:15 PM when an unrecognized person approached the front door. The individual remained at the door for approximately 45 seconds before leaving via the driveway.",
         *       "event_count": 1,
         *       "generated_at": "2026-01-18T14:55:00Z",
         *       "id": 1,
         *       "structured": {
         *         "bullet_points": [
         *           {
         *             "icon": "camera",
         *             "severity": "critical",
         *             "text": "Activity at front door: unrecognized person"
         *           }
         *         ],
         *         "dominant_patterns": [],
         *         "focus_areas": [
         *           "Front Door"
         *         ],
         *         "max_risk_score": 85,
         *         "weather_conditions": []
         *       },
         *       "window_end": "2026-01-18T15:00:00Z",
         *       "window_start": "2026-01-18T14:00:00Z"
         *     }
         */
        SummaryResponse: {
            /**
             * Content
             * @description LLM-generated narrative text (2-4 sentences)
             */
            content: string;
            /**
             * Event Count
             * @description Number of high/critical events included in this summary
             */
            event_count: number;
            /**
             * Generated At
             * Format: date-time
             * @description When the LLM produced this summary
             */
            generated_at: string;
            /**
             * Id
             * @description Summary ID
             */
            id: number;
            /** @description Structured data extracted from the summary content */
            structured?: components["schemas"]["StructuredSummarySchema"] | null;
            /**
             * Window End
             * Format: date-time
             * @description End of the time window covered
             */
            window_end: string;
            /**
             * Window Start
             * Format: date-time
             * @description Start of the time window covered
             */
            window_start: string;
        };
        /**
         * SupervisedWorkerInfo
         * @description Information about a supervised worker.
         *
         *     Provides detailed status and restart metrics for a single worker
         *     managed by the WorkerSupervisor.
         * @example {
         *       "last_started_at": "2026-01-13T10:30:00Z",
         *       "max_restarts": 5,
         *       "name": "detection_worker",
         *       "restart_count": 0,
         *       "status": "running"
         *     }
         */
        SupervisedWorkerInfo: {
            /**
             * Error
             * @description Last error message if worker crashed
             */
            error?: string | null;
            /**
             * Last Crashed At
             * @description When the worker last crashed
             */
            last_crashed_at?: string | null;
            /**
             * Last Started At
             * @description When the worker was last started
             */
            last_started_at?: string | null;
            /**
             * Max Restarts
             * @description Maximum allowed restart attempts before failing
             */
            max_restarts: number;
            /**
             * Name
             * @description Unique identifier for the worker
             */
            name: string;
            /**
             * Restart Count
             * @description Number of times the worker has been restarted
             */
            restart_count: number;
            /** @description Current health status of the worker */
            status: components["schemas"]["SupervisedWorkerStatusEnum"];
        };
        /**
         * SupervisedWorkerStatusEnum
         * @description Status enum for supervised workers.
         * @enum {string}
         */
        SupervisedWorkerStatusEnum: "running" | "stopped" | "crashed" | "restarting" | "failed";
        /**
         * SuspiciousActionsResponse
         * @description Schema for suspicious actions summary response.
         * @example {
         *       "items": [
         *         {
         *           "action": "climbing",
         *           "all_scores": {
         *             "climbing": 0.92,
         *             "walking normally": 0.05
         *           },
         *           "camera_id": "back_yard",
         *           "confidence": 0.92,
         *           "created_at": "2026-01-26T14:30:00Z",
         *           "frame_count": 8,
         *           "id": 5,
         *           "is_suspicious": true,
         *           "timestamp": "2026-01-26T14:30:00Z",
         *           "track_id": 17
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       },
         *       "suspicious_count": 1,
         *       "total_count": 25
         *     }
         */
        SuspiciousActionsResponse: {
            /**
             * Items
             * @description List of suspicious action events
             */
            items: components["schemas"]["ActionEventResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
            /**
             * Suspicious Count
             * @description Total count of suspicious actions
             */
            suspicious_count: number;
            /**
             * Total Count
             * @description Total count of all action events
             */
            total_count: number;
        };
        /**
         * SystemSettingListResponse
         * @description Response schema for listing all system settings.
         * @example {
         *       "items": [
         *         {
         *           "key": "default_gpu_strategy",
         *           "updated_at": "2026-01-25T12:00:00Z",
         *           "value": {
         *             "strategy": "vram_based"
         *           }
         *         },
         *         {
         *           "key": "notification_defaults",
         *           "updated_at": "2026-01-25T11:00:00Z",
         *           "value": {
         *             "email": true,
         *             "push": false
         *           }
         *         }
         *       ],
         *       "total": 2
         *     }
         */
        SystemSettingListResponse: {
            /**
             * Items
             * @description List of system settings
             */
            items: components["schemas"]["SystemSettingResponse"][];
            /**
             * Total
             * @description Total number of settings
             */
            total: number;
        };
        /**
         * SystemSettingResponse
         * @description Response schema for a system setting.
         *
         *     Represents a single key-value pair from the SystemSetting table.
         * @example {
         *       "key": "default_gpu_strategy",
         *       "updated_at": "2026-01-25T12:00:00Z",
         *       "value": {
         *         "fallback": "balanced",
         *         "strategy": "vram_based"
         *       }
         *     }
         */
        SystemSettingResponse: {
            /**
             * Key
             * @description Setting key (primary key)
             */
            key: string;
            /**
             * Updated At
             * Format: date-time
             * @description Last update timestamp
             */
            updated_at: string;
            /**
             * Value
             * @description Setting value as JSON object
             */
            value: {
                [key: string]: unknown;
            };
        };
        /**
         * SystemSettingUpdate
         * @description Request schema for updating a system setting.
         *
         *     The value is a flexible JSON object that can store any configuration.
         * @example {
         *       "value": {
         *         "fallback": "balanced",
         *         "strategy": "vram_based"
         *       }
         *     }
         */
        SystemSettingUpdate: {
            /**
             * Value
             * @description New value for the setting (JSON object). Replaces the existing value entirely (not merged).
             */
            value: {
                [key: string]: unknown;
            };
        };
        /**
         * SystemStatsResponse
         * @description Response schema for system statistics endpoint.
         * @example {
         *       "total_cameras": 4,
         *       "total_detections": 892,
         *       "total_events": 156,
         *       "uptime_seconds": 86400.5
         *     }
         */
        SystemStatsResponse: {
            /**
             * Total Cameras
             * @description Total number of cameras in the system
             */
            total_cameras: number;
            /**
             * Total Detections
             * @description Total number of detections recorded
             */
            total_detections: number;
            /**
             * Total Events
             * @description Total number of events recorded
             */
            total_events: number;
            /**
             * Uptime Seconds
             * @description Application uptime in seconds
             */
            uptime_seconds: number;
        };
        /**
         * TargetHealth
         * @description Health status for a single Prometheus scrape target.
         * @example {
         *       "health": "up",
         *       "instance": "backend:8000",
         *       "job": "hsi-backend-metrics",
         *       "labels": {
         *         "service": "home-security-intelligence"
         *       },
         *       "last_scrape": "2026-01-13T10:30:00Z",
         *       "scrape_duration_seconds": 0.025
         *     }
         */
        TargetHealth: {
            /**
             * Health
             * @description Target health: 'up' or 'down'
             */
            health: string;
            /**
             * Instance
             * @description Target instance identifier (typically host:port)
             */
            instance: string;
            /**
             * Job
             * @description Job name this target belongs to
             */
            job: string;
            /**
             * Labels
             * @description Labels associated with this target
             */
            labels?: {
                [key: string]: string;
            };
            /**
             * Last Error
             * @description Error from last failed scrape (if any)
             */
            last_error?: string | null;
            /**
             * Last Scrape
             * @description Timestamp of last scrape attempt
             */
            last_scrape?: string | null;
            /**
             * Scrape Duration Seconds
             * @description Duration of last scrape in seconds
             */
            scrape_duration_seconds?: number | null;
        };
        /**
         * TelemetryResponse
         * @description Response schema for pipeline telemetry endpoint.
         *
         *     Provides real-time visibility into:
         *     - Queue depths: How many items are waiting in detection/analysis queues
         *     - Stage latencies: How long each pipeline stage is taking
         *
         *     This helps operators:
         *     - Identify pipeline bottlenecks
         *     - Detect backlog situations
         *     - Monitor processing performance
         *     - Debug pipeline stalls
         * @example {
         *       "latencies": {
         *         "detect": {
         *           "avg_ms": 200,
         *           "max_ms": 800,
         *           "min_ms": 100,
         *           "p50_ms": 180,
         *           "p95_ms": 600,
         *           "p99_ms": 750,
         *           "sample_count": 500
         *         },
         *         "watch": {
         *           "avg_ms": 10,
         *           "max_ms": 50,
         *           "min_ms": 5,
         *           "p50_ms": 8,
         *           "p95_ms": 40,
         *           "p99_ms": 48,
         *           "sample_count": 500
         *         }
         *       },
         *       "queues": {
         *         "analysis_queue": 2,
         *         "detection_queue": 5
         *       },
         *       "timestamp": "2025-12-27T10:30:00Z"
         *     }
         */
        TelemetryResponse: {
            /** @description Latency statistics for each pipeline stage */
            latencies?: components["schemas"]["PipelineLatencies"] | null;
            /** @description Current queue depths for detection and analysis queues */
            queues: components["schemas"]["QueueDepths"];
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of telemetry snapshot
             */
            timestamp: string;
        };
        /**
         * TestNotificationResponse
         * @description Schema for test notification result.
         * @example {
         *       "channel": "email",
         *       "message": "Test email sent successfully to test@example.com",
         *       "success": true
         *     }
         */
        TestNotificationResponse: {
            /** @description Channel that was tested */
            channel: components["schemas"]["NotificationChannel"];
            /**
             * Error
             * @description Error message if test failed
             */
            error?: string | null;
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
            /**
             * Success
             * @description Whether the test was successful
             */
            success: boolean;
        };
        /**
         * ThroughputMetrics
         * @description Throughput metrics for a queue.
         * @example {
         *       "avg_processing_seconds": 4.8,
         *       "jobs_per_minute": 12.5
         *     }
         */
        ThroughputMetrics: {
            /**
             * Avg Processing Seconds
             * @description Average time to process a job in seconds
             */
            avg_processing_seconds: number;
            /**
             * Jobs Per Minute
             * @description Average number of jobs processed per minute
             */
            jobs_per_minute: number;
        };
        /**
         * TimeRange
         * @description Time range options for historical data.
         * @enum {string}
         */
        TimeRange: "5m" | "15m" | "60m";
        /**
         * TimelineBucketResponse
         * @description Schema for a single time bucket in the timeline summary (NEM-2932).
         *
         *     Each bucket represents a time period with aggregated event data.
         * @example {
         *       "event_count": 15,
         *       "max_risk_score": 85,
         *       "timestamp": "2026-01-15T12:00:00Z"
         *     }
         */
        TimelineBucketResponse: {
            /**
             * Event Count
             * @description Number of events in this bucket
             */
            event_count: number;
            /**
             * Max Risk Score
             * @description Maximum risk score of events in this bucket
             * @default 0
             */
            max_risk_score: number;
            /**
             * Timestamp
             * Format: date-time
             * @description Start timestamp of this bucket
             */
            timestamp: string;
        };
        /**
         * TimelineSummaryResponse
         * @description Schema for timeline summary response (NEM-2932).
         *
         *     Returns bucketed event data for timeline visualization.
         *     Supports different zoom levels with varying bucket sizes.
         * @example {
         *       "buckets": [
         *         {
         *           "event_count": 5,
         *           "max_risk_score": 45,
         *           "timestamp": "2026-01-15T06:00:00Z"
         *         },
         *         {
         *           "event_count": 12,
         *           "max_risk_score": 85,
         *           "timestamp": "2026-01-15T07:00:00Z"
         *         },
         *         {
         *           "event_count": 3,
         *           "max_risk_score": 25,
         *           "timestamp": "2026-01-15T08:00:00Z"
         *         }
         *       ],
         *       "end_date": "2026-01-15T09:00:00Z",
         *       "start_date": "2026-01-15T06:00:00Z",
         *       "total_events": 20
         *     }
         */
        TimelineSummaryResponse: {
            /**
             * Buckets
             * @description List of time buckets with aggregated event data
             */
            buckets: components["schemas"]["TimelineBucketResponse"][];
            /**
             * End Date
             * Format: date-time
             * @description End of the timeline range
             */
            end_date: string;
            /**
             * Start Date
             * Format: date-time
             * @description Start of the timeline range
             */
            start_date: string;
            /**
             * Total Events
             * @description Total events in the time range
             */
            total_events: number;
        };
        /**
         * TraceMallocStats
         * @description Tracemalloc statistics if enabled.
         */
        TraceMallocStats: {
            /**
             * Current Bytes
             * @description Current traced memory in bytes
             * @default 0
             */
            current_bytes: number;
            /**
             * Enabled
             * @description Whether tracemalloc is enabled
             */
            enabled: boolean;
            /**
             * Peak Bytes
             * @description Peak traced memory in bytes
             * @default 0
             */
            peak_bytes: number;
            /**
             * Top Allocations
             * @description Top memory allocations by size
             */
            top_allocations?: {
                [key: string]: unknown;
            }[];
        };
        /**
         * TrackHistoryResponse
         * @description Response with full track history including trajectory.
         *
         *     Includes complete trajectory data for visualization and analysis.
         *     Use for track detail views and trajectory plotting.
         * @example {
         *       "camera_id": "front_door",
         *       "first_seen": "2026-01-26T12:00:00Z",
         *       "id": 1,
         *       "last_seen": "2026-01-26T12:00:27Z",
         *       "metrics": {
         *         "avg_speed": 45.2,
         *         "direction": 135,
         *         "duration_seconds": 27.7,
         *         "total_distance": 1250.5
         *       },
         *       "object_class": "person",
         *       "track_id": 42,
         *       "trajectory": [
         *         {
         *           "timestamp": "2026-01-26T12:00:00Z",
         *           "x": 100,
         *           "y": 200
         *         },
         *         {
         *           "timestamp": "2026-01-26T12:00:05Z",
         *           "x": 150.5,
         *           "y": 220.3
         *         },
         *         {
         *           "timestamp": "2026-01-26T12:00:10Z",
         *           "x": 210.2,
         *           "y": 245.8
         *         },
         *         {
         *           "timestamp": "2026-01-26T12:00:15Z",
         *           "x": 280,
         *           "y": 270
         *         },
         *         {
         *           "timestamp": "2026-01-26T12:00:20Z",
         *           "x": 350.5,
         *           "y": 300.2
         *         },
         *         {
         *           "timestamp": "2026-01-26T12:00:27Z",
         *           "x": 420,
         *           "y": 330.5
         *         }
         *       ]
         *     }
         */
        TrackHistoryResponse: {
            /**
             * Camera Id
             * @description Camera ID where track was observed
             */
            camera_id: string;
            /**
             * First Seen
             * Format: date-time
             * @description Timestamp of first observation
             */
            first_seen: string;
            /**
             * Id
             * @description Database track ID
             */
            id: number;
            /**
             * Last Seen
             * Format: date-time
             * @description Timestamp of last observation
             */
            last_seen: string;
            /** @description Computed movement metrics */
            metrics: components["schemas"]["MovementMetrics"];
            /**
             * Object Class
             * @description Detected object class (person, car, etc.)
             */
            object_class: string;
            /**
             * Track Id
             * @description Tracker-assigned ID (unique per camera session)
             */
            track_id: number;
            /**
             * Trajectory
             * @description Ordered list of trajectory points
             */
            trajectory: components["schemas"]["TrajectoryPoint"][];
        };
        /**
         * TrackListResponse
         * @description Paginated list of tracks.
         *
         *     Standard pagination envelope for track list endpoints.
         * @example {
         *       "page": 1,
         *       "page_size": 50,
         *       "total": 2,
         *       "tracks": [
         *         {
         *           "camera_id": "front_door",
         *           "first_seen": "2026-01-26T12:00:00Z",
         *           "id": 1,
         *           "last_seen": "2026-01-26T12:00:27Z",
         *           "metrics": {
         *             "avg_speed": 45.2,
         *             "direction": 135,
         *             "duration_seconds": 27.7,
         *             "total_distance": 1250.5
         *           },
         *           "object_class": "person",
         *           "track_id": 42
         *         },
         *         {
         *           "camera_id": "front_door",
         *           "first_seen": "2026-01-26T12:01:00Z",
         *           "id": 2,
         *           "last_seen": "2026-01-26T12:01:15Z",
         *           "metrics": {
         *             "avg_speed": 140,
         *             "direction": 270,
         *             "duration_seconds": 15,
         *             "total_distance": 2100
         *           },
         *           "object_class": "car",
         *           "track_id": 43
         *         }
         *       ]
         *     }
         */
        TrackListResponse: {
            /**
             * Page
             * @description Current page number (1-indexed)
             */
            page: number;
            /**
             * Page Size
             * @description Number of items per page
             */
            page_size: number;
            /**
             * Total
             * @description Total number of tracks matching the query
             */
            total: number;
            /**
             * Tracks
             * @description List of tracks
             */
            tracks: components["schemas"]["TrackResponse"][];
        };
        /**
         * TrackResponse
         * @description Response for a single track.
         *
         *     Basic track information without full trajectory data.
         *     Use TrackHistoryResponse for full trajectory details.
         * @example {
         *       "camera_id": "front_door",
         *       "first_seen": "2026-01-26T12:00:00Z",
         *       "id": 1,
         *       "last_seen": "2026-01-26T12:00:27Z",
         *       "metrics": {
         *         "avg_speed": 45.2,
         *         "direction": 135,
         *         "duration_seconds": 27.7,
         *         "total_distance": 1250.5
         *       },
         *       "object_class": "person",
         *       "track_id": 42
         *     }
         */
        TrackResponse: {
            /**
             * Camera Id
             * @description Camera ID where track was observed
             */
            camera_id: string;
            /**
             * First Seen
             * Format: date-time
             * @description Timestamp of first observation
             */
            first_seen: string;
            /**
             * Id
             * @description Database track ID
             */
            id: number;
            /**
             * Last Seen
             * Format: date-time
             * @description Timestamp of last observation
             */
            last_seen: string;
            /** @description Computed movement metrics (may be null for short tracks) */
            metrics?: components["schemas"]["MovementMetrics"] | null;
            /**
             * Object Class
             * @description Detected object class (person, car, etc.)
             */
            object_class: string;
            /**
             * Track Id
             * @description Tracker-assigned ID (unique per camera session)
             */
            track_id: number;
        };
        /**
         * TrajectoryPoint
         * @description Single point in a track trajectory.
         *
         *     Represents a discrete position observation of a tracked object
         *     at a specific point in time.
         * @example {
         *       "timestamp": "2026-01-26T12:00:00Z",
         *       "x": 640.5,
         *       "y": 480.2
         *     }
         */
        TrajectoryPoint: {
            /**
             * Timestamp
             * Format: date-time
             * @description Time of this position
             */
            timestamp: string;
            /**
             * X
             * @description X coordinate (pixels)
             */
            x: number;
            /**
             * Y
             * @description Y coordinate (pixels)
             */
            y: number;
        };
        /**
         * TrustCheckResponse
         * @description Schema for trust check response.
         *
         *     Indicates the trust level an entity has in a specific zone.
         * @example {
         *       "entity_id": 1,
         *       "entity_type": "member",
         *       "reason": "Entity is the zone owner",
         *       "trust_level": "full",
         *       "zone_id": "550e8400-e29b-41d4-a716-446655440000"
         *     }
         */
        TrustCheckResponse: {
            /**
             * Entity Id
             * @description ID of the entity being checked
             */
            entity_id: number;
            /**
             * Entity Type
             * @description Type of entity ('member' or 'vehicle')
             */
            entity_type: string;
            /**
             * Reason
             * @description Human-readable explanation of the trust level
             */
            reason: string;
            /** @description Trust level result (full, partial, monitor, none) */
            trust_level: components["schemas"]["TrustLevelResult"];
            /**
             * Zone Id
             * @description ID of the zone
             */
            zone_id: string;
        };
        /**
         * TrustLevel
         * @description Trust level for household members determining alert behavior.
         *
         *     - FULL: Never trigger alerts for this person
         *     - PARTIAL: Reduced alert severity, still monitored
         *     - MONITOR: Log activity but don't suppress alerts
         * @enum {string}
         */
        TrustLevel: "full" | "partial" | "monitor";
        /**
         * TrustLevelResult
         * @description Trust level result from zone access check.
         *
         *     These values indicate the level of trust an entity has in a specific zone:
         *     - FULL: Entity is the zone owner - full trust, never alert
         *     - PARTIAL: Entity is allowed member/vehicle - reduced alert severity
         *     - MONITOR: Entity is scheduled for access at current time - log only
         *     - NONE: Entity has no special trust in this zone
         * @enum {string}
         */
        TrustLevelResult: "full" | "partial" | "monitor" | "none";
        /**
         * TrustStatus
         * @description Trust classification status for entities.
         *
         *     Entities can be classified as trusted (known/safe), untrusted (unknown/suspicious),
         *     or unclassified (no classification assigned yet).
         * @enum {string}
         */
        TrustStatus: "trusted" | "untrusted" | "unclassified";
        /**
         * TrustedEntityListResponse
         * @description Schema for paginated list of trusted or untrusted entities.
         *
         *     Response from GET /api/entities/trusted and GET /api/entities/untrusted endpoints.
         * @example {
         *       "items": [
         *         {
         *           "appearance_count": 5,
         *           "entity_type": "person",
         *           "first_seen": "2025-12-23T10:00:00Z",
         *           "id": "550e8400-e29b-41d4-a716-446655440000",
         *           "last_seen": "2025-12-23T14:30:00Z",
         *           "thumbnail_url": "/api/detections/123/image",
         *           "trust_notes": "Mail carrier",
         *           "trust_status": "trusted",
         *           "trust_updated_at": "2025-12-23T14:30:00Z"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        TrustedEntityListResponse: {
            /**
             * Items
             * @description List of entities with their trust status
             */
            items: components["schemas"]["EntityTrustResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationInfo"];
        };
        /**
         * UnknownStrangerAlert
         * @description Schema for unknown stranger alert.
         * @example {
         *       "age_estimate": 35,
         *       "bbox": [
         *         100,
         *         150,
         *         200,
         *         300
         *       ],
         *       "camera_id": "front_door",
         *       "event_id": 1,
         *       "gender_estimate": "M",
         *       "quality_score": 0.85,
         *       "thumbnail_path": "/data/thumbnails/stranger_1.jpg",
         *       "timestamp": "2025-01-01T10:00:00Z"
         *     }
         */
        UnknownStrangerAlert: {
            /**
             * Age Estimate
             * @description Estimated age
             */
            age_estimate?: number | null;
            /**
             * Bbox
             * @description Bounding box coordinates
             */
            bbox: number[];
            /**
             * Camera Id
             * @description ID of the camera
             */
            camera_id: string;
            /**
             * Event Id
             * @description ID of the face detection event
             */
            event_id: number;
            /**
             * Gender Estimate
             * @description Estimated gender
             */
            gender_estimate?: string | null;
            /**
             * Quality Score
             * @description Face quality score
             */
            quality_score: number;
            /**
             * Thumbnail Path
             * @description Path to face thumbnail
             */
            thumbnail_path?: string | null;
            /**
             * Timestamp
             * Format: date-time
             * @description When the stranger was detected
             */
            timestamp: string;
        };
        /**
         * UnknownStrangerListResponse
         * @description Schema for list of unknown stranger alerts.
         * @example {
         *       "items": [
         *         {
         *           "age_estimate": 35,
         *           "bbox": [
         *             100,
         *             150,
         *             200,
         *             300
         *           ],
         *           "camera_id": "front_door",
         *           "event_id": 1,
         *           "gender_estimate": "M",
         *           "quality_score": 0.85,
         *           "timestamp": "2025-01-01T10:00:00Z"
         *         }
         *       ],
         *       "total": 1
         *     }
         */
        UnknownStrangerListResponse: {
            /**
             * Items
             * @description List of unknown strangers
             */
            items: components["schemas"]["UnknownStrangerAlert"][];
            /**
             * Total
             * @description Total number of unknown strangers
             */
            total: number;
        };
        /**
         * UserCalibrationResponse
         * @description Schema for user calibration response.
         *
         *     Returned when retrieving or modifying calibration settings.
         *     Includes feedback counts to show calibration history.
         * @example {
         *       "created_at": "2025-01-01T12:00:00Z",
         *       "decay_factor": 0.1,
         *       "false_positive_count": 5,
         *       "high_threshold": 85,
         *       "id": 1,
         *       "low_threshold": 30,
         *       "medium_threshold": 60,
         *       "missed_threat_count": 3,
         *       "updated_at": "2025-01-01T12:00:00Z",
         *       "user_id": "default"
         *     }
         */
        UserCalibrationResponse: {
            /**
             * Created At
             * Format: date-time
             * @description When calibration was created
             */
            created_at: string;
            /**
             * Decay Factor
             * @description Learning rate for threshold adjustment (0.0-1.0)
             */
            decay_factor: number;
            /**
             * False Positive Count
             * @description Number of false positive feedbacks received
             */
            false_positive_count: number;
            /**
             * High Threshold
             * @description Score threshold for high risk (0-100)
             */
            high_threshold: number;
            /**
             * Id
             * @description Calibration record ID
             */
            id: number;
            /**
             * Low Threshold
             * @description Score threshold for low risk (0-100)
             */
            low_threshold: number;
            /**
             * Medium Threshold
             * @description Score threshold for medium risk (0-100)
             */
            medium_threshold: number;
            /**
             * Missed Threat Count
             * @description Number of missed threat feedbacks received
             */
            missed_threat_count: number;
            /**
             * Updated At
             * Format: date-time
             * @description When calibration was last modified
             */
            updated_at: string;
            /**
             * User Id
             * @description User identifier
             */
            user_id: string;
        };
        /**
         * UserCalibrationUpdate
         * @description Schema for updating user calibration settings.
         *
         *     All fields are optional - only provided fields will be updated.
         *     When all three thresholds are provided, ordering is validated
         *     (low < medium < high).
         * @example {
         *       "decay_factor": 0.15,
         *       "high_threshold": 80,
         *       "low_threshold": 25,
         *       "medium_threshold": 55
         *     }
         */
        UserCalibrationUpdate: {
            /**
             * Decay Factor
             * @description Learning rate for threshold adjustment (0.0-1.0)
             */
            decay_factor?: number | null;
            /**
             * High Threshold
             * @description Score threshold for high risk classification (0-100)
             */
            high_threshold?: number | null;
            /**
             * Low Threshold
             * @description Score threshold for low risk classification (0-100)
             */
            low_threshold?: number | null;
            /**
             * Medium Threshold
             * @description Score threshold for medium risk classification (0-100)
             */
            medium_threshold?: number | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * VehicleEnrichment
         * @description Vehicle classification results.
         * @example {
         *       "color": "silver",
         *       "confidence": 0.91,
         *       "is_commercial": false,
         *       "type": "sedan"
         *     }
         */
        VehicleEnrichment: {
            /**
             * Color
             * @description Vehicle color (if detected)
             */
            color?: string | null;
            /**
             * Confidence
             * @description Classification confidence
             */
            confidence?: number | null;
            /**
             * Damage Detected
             * @description Whether vehicle damage was detected
             */
            damage_detected?: boolean | null;
            /**
             * Damage Types
             * @description Types of damage detected
             */
            damage_types?: string[] | null;
            /**
             * Is Commercial
             * @description Whether vehicle is commercial/delivery
             */
            is_commercial?: boolean | null;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
            /**
             * Type
             * @description Vehicle type (sedan, suv, truck, etc.)
             */
            type?: string | null;
        };
        /**
         * VehicleType
         * @description Type of vehicle for categorization.
         * @enum {string}
         */
        VehicleType: "car" | "truck" | "motorcycle" | "suv" | "van" | "other";
        /**
         * ViolenceEnrichment
         * @description Violence detection results.
         * @example {
         *       "confidence": 0.88,
         *       "detected": false,
         *       "score": 0.12
         *     }
         */
        ViolenceEnrichment: {
            /**
             * Confidence
             * @description Model confidence
             */
            confidence?: number | null;
            /**
             * Detected
             * @description Whether violence was detected
             * @default false
             */
            detected: boolean;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
            /**
             * Score
             * @description Violence probability score
             * @default 0
             */
            score: number;
        };
        /**
         * WeatherEnrichment
         * @description Weather classification results.
         * @example {
         *       "condition": "clear",
         *       "confidence": 0.95
         *     }
         */
        WeatherEnrichment: {
            /**
             * Condition
             * @description Weather condition (clear, rain, fog, etc.)
             */
            condition?: string | null;
            /**
             * Confidence
             * @description Classification confidence
             */
            confidence?: number | null;
            /** @description Model that produced this result */
            model_info?: components["schemas"]["EnrichmentModelInfo"] | null;
        };
        /**
         * WebSocketBroadcasterStatus
         * @description Status of a WebSocket broadcaster's circuit breaker.
         */
        WebSocketBroadcasterStatus: {
            /**
             * Failure Count
             * @description Current consecutive failure count
             */
            failure_count: number;
            /**
             * Is Degraded
             * @description Whether the broadcaster is in degraded mode
             */
            is_degraded: boolean;
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
            /** @description Current circuit state: closed (normal), open (failing), half_open (testing), unavailable (not initialized) */
            state: components["schemas"]["CircuitBreakerStateEnum"];
        };
        /**
         * WebSocketConnectionsResponse
         * @description Response for WebSocket connection states.
         */
        WebSocketConnectionsResponse: {
            /** @description Event broadcaster status */
            event_broadcaster: components["schemas"]["DebugWebSocketBroadcasterStatus"];
            /** @description System broadcaster status */
            system_broadcaster: components["schemas"]["DebugWebSocketBroadcasterStatus"];
            /**
             * Timestamp
             * @description ISO timestamp of response
             */
            timestamp: string;
        };
        /**
         * WebSocketHealthResponse
         * @description Response schema for WebSocket health endpoint.
         * @example {
         *       "event_broadcaster": {
         *         "failure_count": 0,
         *         "is_degraded": false,
         *         "state": "closed"
         *       },
         *       "system_broadcaster": {
         *         "failure_count": 0,
         *         "is_degraded": false,
         *         "state": "closed"
         *       },
         *       "timestamp": "2025-12-30T10:30:00Z"
         *     }
         */
        WebSocketHealthResponse: {
            /** @description Status of the event broadcaster circuit breaker */
            event_broadcaster?: components["schemas"]["WebSocketBroadcasterStatus"] | null;
            /** @description Status of the system broadcaster circuit breaker */
            system_broadcaster?: components["schemas"]["WebSocketBroadcasterStatus"] | null;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of health check
             */
            timestamp: string;
        };
        /**
         * WebVitalMetric
         * @description A single Core Web Vital metric measurement from the frontend.
         *
         *     This schema matches the structure returned by the web-vitals library's
         *     onLCP, onFID, onINP, onCLS, onTTFB, and onFCP functions.
         *
         *     Attributes:
         *         name: The Core Web Vital metric name (LCP, FID, INP, CLS, TTFB, FCP)
         *         value: The metric value (milliseconds for most, dimensionless for CLS)
         *         rating: Performance rating based on thresholds (good, needs-improvement, poor)
         *         delta: The delta since the last report (for CLS this accumulates)
         *         id: Unique identifier for this metric instance
         *         navigationType: The type of navigation (navigate, reload, back_forward, prerender)
         *         path: The page path where the metric was measured
         * @example {
         *       "delta": 2500,
         *       "id": "v1-1234567890123-1234567890123",
         *       "name": "LCP",
         *       "navigationType": "navigate",
         *       "path": "/dashboard",
         *       "rating": "good",
         *       "value": 2500
         *     }
         */
        WebVitalMetric: {
            /**
             * Delta
             * @description Delta since last report
             */
            delta: number;
            /**
             * Id
             * @description Unique metric identifier from web-vitals
             */
            id: string;
            /** @description Core Web Vital metric name */
            name: components["schemas"]["WebVitalName"];
            /**
             * Navigationtype
             * @description Navigation type (navigate, reload, back_forward, prerender)
             */
            navigationType?: string | null;
            /**
             * Path
             * @description Page path where metric was measured
             */
            path?: string | null;
            /**
             * Rating
             * @description Performance rating
             * @enum {string}
             */
            rating: "good" | "needs-improvement" | "poor";
            /**
             * Value
             * @description Metric value (ms for most, dimensionless for CLS)
             */
            value: number;
        };
        /**
         * WebVitalName
         * @description Supported Core Web Vitals metric names.
         *
         *     These correspond to the metrics collected by the web-vitals library,
         *     plus custom metrics like PAGE_LOAD_TIME from Navigation Timing API.
         * @enum {string}
         */
        WebVitalName: "LCP" | "FID" | "INP" | "CLS" | "TTFB" | "FCP" | "PAGE_LOAD_TIME";
        /**
         * WebhookAlert
         * @description Schema for a single alert in webhook payload.
         *
         *     Represents one alert instance with its labels, annotations, and timing.
         *     This is the legacy webhook schema - prefer AlertmanagerAlert from alertmanager.py.
         * @example {
         *       "annotations": {
         *         "description": "GPU memory usage is above 90% for 5 minutes",
         *         "summary": "GPU memory usage is high"
         *       },
         *       "endsAt": "0001-01-01T00:00:00Z",
         *       "fingerprint": "abc123def456",
         *       "generatorURL": "http://prometheus:9090/graph?...",
         *       "labels": {
         *         "alertname": "HSIGPUMemoryHigh",
         *         "component": "gpu",
         *         "severity": "warning"
         *       },
         *       "startsAt": "2026-01-17T12:22:56.068Z",
         *       "status": "firing"
         *     }
         */
        WebhookAlert: {
            /**
             * Annotations
             * @description Alert annotations (summary, description)
             */
            annotations?: {
                [key: string]: string;
            };
            /**
             * Endsat
             * @description When the alert was resolved
             */
            endsAt?: string | null;
            /**
             * Fingerprint
             * @description Unique identifier for deduplication
             */
            fingerprint: string;
            /**
             * Generatorurl
             * @description URL to the Prometheus graph
             */
            generatorURL?: string | null;
            /**
             * Labels
             * @description Alert labels (alertname, severity, etc.)
             */
            labels?: {
                [key: string]: string;
            };
            /**
             * Startsat
             * Format: date-time
             * @description When the alert started firing
             */
            startsAt: string;
            /** @description Alert status (firing or resolved) */
            status: components["schemas"]["AlertmanagerStatus"];
        };
        /**
         * WebhookAuthConfig
         * @description Authentication configuration for webhook requests.
         *
         *     Supports multiple authentication types:
         *     - none: No authentication
         *     - bearer: Bearer token authentication
         *     - basic: Basic authentication with username/password
         *     - header: Custom header authentication
         *
         *     Attributes:
         *         type: Authentication type (none, bearer, basic, header).
         *         token: Bearer token for bearer auth.
         *         username: Username for basic auth.
         *         password: Password for basic auth.
         *         header_name: Custom header name for header auth.
         *         header_value: Custom header value for header auth.
         */
        WebhookAuthConfig: {
            /**
             * Header Name
             * @description Custom header name (if type=header)
             */
            header_name?: string | null;
            /**
             * Header Value
             * @description Custom header value (if type=header)
             */
            header_value?: string | null;
            /**
             * Password
             * @description Password (if type=basic)
             */
            password?: string | null;
            /**
             * Token
             * @description Bearer token (if type=bearer)
             */
            token?: string | null;
            /**
             * Type
             * @description Auth type: none, bearer, basic, header
             * @default none
             */
            type: string;
            /**
             * Username
             * @description Username (if type=basic)
             */
            username?: string | null;
        };
        /**
         * WebhookCreate
         * @description Schema for creating a new outbound webhook.
         *
         *     Create a new webhook configuration for sending notifications to external
         *     systems when specified events occur.
         *
         *     Attributes:
         *         name: Human-readable name for the webhook.
         *         url: Webhook endpoint URL.
         *         event_types: List of events that trigger this webhook.
         *         integration_type: Type of integration (generic, slack, discord, etc.).
         *         enabled: Whether the webhook is active.
         *         auth: Optional authentication configuration.
         *         custom_headers: Additional HTTP headers to send.
         *         payload_template: Optional Jinja2 template for custom payload.
         *         max_retries: Maximum number of retry attempts on failure.
         *         retry_delay_seconds: Initial delay between retries.
         * @example {
         *       "auth": {
         *         "type": "none"
         *       },
         *       "custom_headers": {},
         *       "enabled": true,
         *       "event_types": [
         *         "alert_fired",
         *         "alert_dismissed"
         *       ],
         *       "integration_type": "slack",
         *       "name": "Slack Alerts",
         *       "url": "https://hooks.slack.com/services/xxx/yyy/zzz"
         *     }
         */
        WebhookCreate: {
            /** @description Authentication config */
            auth?: components["schemas"]["WebhookAuthConfig"] | null;
            /**
             * Custom Headers
             * @description Custom HTTP headers
             */
            custom_headers?: {
                [key: string]: string;
            };
            /**
             * Enabled
             * @description Whether webhook is active
             * @default true
             */
            enabled: boolean;
            /**
             * Event Types
             * @description Events to subscribe to
             */
            event_types: components["schemas"]["WebhookEventType"][];
            /**
             * @description Integration type
             * @default generic
             */
            integration_type: components["schemas"]["IntegrationType"];
            /**
             * Max Retries
             * @description Max retry attempts
             * @default 4
             */
            max_retries: number;
            /**
             * Name
             * @description Webhook name
             */
            name: string;
            /**
             * Payload Template
             * @description Custom payload template (Jinja2)
             */
            payload_template?: string | null;
            /**
             * Retry Delay Seconds
             * @description Initial retry delay
             * @default 10
             */
            retry_delay_seconds: number;
            /**
             * Url
             * Format: uri
             * @description Webhook endpoint URL
             */
            url: string;
        };
        /**
         * WebhookDeliveryListResponse
         * @description Response for listing webhook deliveries.
         *
         *     Includes pagination information for navigating large delivery histories.
         *
         *     Attributes:
         *         deliveries: List of delivery records.
         *         total: Total number of deliveries.
         *         limit: Page size.
         *         offset: Page offset.
         *         has_more: Whether more pages exist.
         */
        WebhookDeliveryListResponse: {
            /** Deliveries */
            deliveries?: components["schemas"]["WebhookDeliveryResponse"][];
            /**
             * Has More
             * @default false
             */
            has_more: boolean;
            /**
             * Limit
             * @default 50
             */
            limit: number;
            /**
             * Offset
             * @default 0
             */
            offset: number;
            /**
             * Total
             * @default 0
             */
            total: number;
        };
        /**
         * WebhookDeliveryResponse
         * @description Response for a webhook delivery attempt.
         *
         *     Provides details about a single webhook delivery attempt including
         *     status, timing, and any error information.
         *
         *     Attributes:
         *         id: Delivery ID.
         *         webhook_id: Parent webhook ID.
         *         event_type: Event that triggered delivery.
         *         event_id: Related event ID.
         *         status: Delivery status.
         *         status_code: HTTP response status code.
         *         response_time_ms: Response time in milliseconds.
         *         error_message: Error message if failed.
         *         attempt_count: Number of attempts.
         *         next_retry_at: Next retry timestamp.
         *         created_at: Delivery creation timestamp.
         *         delivered_at: Successful delivery timestamp.
         */
        WebhookDeliveryResponse: {
            /**
             * Attempt Count
             * @description Number of attempts
             * @default 1
             */
            attempt_count: number;
            /**
             * Created At
             * Format: date-time
             * @description Delivery creation timestamp
             */
            created_at: string;
            /**
             * Delivered At
             * @description Successful delivery timestamp
             */
            delivered_at?: string | null;
            /**
             * Error Message
             * @description Error message if failed
             */
            error_message?: string | null;
            /**
             * Event Id
             * @description Related event ID
             */
            event_id?: string | null;
            /** @description Event that triggered delivery */
            event_type: components["schemas"]["WebhookEventType"];
            /**
             * Id
             * @description Delivery ID
             */
            id: string;
            /**
             * Next Retry At
             * @description Next retry timestamp
             */
            next_retry_at?: string | null;
            /**
             * Response Time Ms
             * @description Response time in milliseconds
             */
            response_time_ms?: number | null;
            /** @description Delivery status */
            status: components["schemas"]["WebhookDeliveryStatus"];
            /**
             * Status Code
             * @description HTTP response status code
             */
            status_code?: number | null;
            /**
             * Webhook Id
             * @description Parent webhook ID
             */
            webhook_id: string;
        };
        /**
         * WebhookDeliveryStatus
         * @description Webhook delivery attempt status.
         * @enum {string}
         */
        WebhookDeliveryStatus: "pending" | "success" | "failed" | "retrying";
        /**
         * WebhookEventType
         * @description Event types that can trigger webhooks.
         * @enum {string}
         */
        WebhookEventType: "alert_fired" | "alert_dismissed" | "alert_acknowledged" | "event_created" | "event_enriched" | "entity_discovered" | "anomaly_detected" | "system_health_changed" | "batch_analysis_started" | "batch_analysis_completed" | "batch_analysis_failed";
        /**
         * WebhookHealthSummary
         * @description Health summary for all webhooks.
         *
         *     Provides an overview of webhook health across the system including
         *     delivery statistics for the last 24 hours.
         *
         *     Attributes:
         *         total_webhooks: Total number of configured webhooks.
         *         enabled_webhooks: Number of enabled webhooks.
         *         healthy_webhooks: Webhooks with >90% success rate.
         *         unhealthy_webhooks: Webhooks with <50% success rate.
         *         total_deliveries_24h: Total deliveries in last 24 hours.
         *         successful_deliveries_24h: Successful deliveries in last 24 hours.
         *         failed_deliveries_24h: Failed deliveries in last 24 hours.
         *         average_response_time_ms: Average response time.
         */
        WebhookHealthSummary: {
            /** Average Response Time Ms */
            average_response_time_ms?: number | null;
            /**
             * Enabled Webhooks
             * @default 0
             */
            enabled_webhooks: number;
            /**
             * Failed Deliveries 24H
             * @default 0
             */
            failed_deliveries_24h: number;
            /**
             * Healthy Webhooks
             * @description Webhooks with >90% success rate
             * @default 0
             */
            healthy_webhooks: number;
            /**
             * Successful Deliveries 24H
             * @default 0
             */
            successful_deliveries_24h: number;
            /**
             * Total Deliveries 24H
             * @default 0
             */
            total_deliveries_24h: number;
            /**
             * Total Webhooks
             * @default 0
             */
            total_webhooks: number;
            /**
             * Unhealthy Webhooks
             * @description Webhooks with <50% success rate
             * @default 0
             */
            unhealthy_webhooks: number;
        };
        /**
         * WebhookListResponse
         * @description Response for listing webhooks.
         *
         *     Attributes:
         *         webhooks: List of webhook configurations.
         *         total: Total number of webhooks.
         */
        WebhookListResponse: {
            /**
             * Total
             * @description Total count
             * @default 0
             */
            total: number;
            /** Webhooks */
            webhooks?: components["schemas"]["backend__api__schemas__outbound_webhook__WebhookResponse"][];
        };
        /**
         * WebhookResponse
         * @description Schema for webhook processing response.
         * @example {
         *       "message": "Processed 1 alert(s)",
         *       "processed": 1,
         *       "received": 1,
         *       "status": "ok"
         *     }
         */
        WebhookResponse: {
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Processed
             * @description Number of alerts processed
             */
            processed: number;
            /**
             * Received
             * @description Number of alerts received
             */
            received: number;
            /**
             * Status
             * @description Processing status (ok or error)
             */
            status: string;
        };
        /**
         * WebhookTestNotificationRequest
         * @description Schema for testing notification configuration.
         * @example {
         *       "channel": "email",
         *       "email_recipients": [
         *         "test@example.com"
         *       ]
         *     }
         */
        WebhookTestNotificationRequest: {
            /** @description Channel to test */
            channel: components["schemas"]["NotificationChannel"];
            /**
             * Email Recipients
             * @description Email recipients for email test
             */
            email_recipients?: string[] | null;
            /**
             * Webhook Url
             * @description Webhook URL for webhook test. Must be HTTPS and not point to private IPs.
             */
            webhook_url?: string | null;
        };
        /**
         * WebhookTestRequest
         * @description Request to test a webhook with sample data.
         *
         *     Allows testing a webhook configuration with a simulated event
         *     to verify connectivity and payload format.
         *
         *     Attributes:
         *         event_type: Event type to use for test payload.
         */
        WebhookTestRequest: {
            /**
             * @description Event type for test payload
             * @default alert_fired
             */
            event_type: components["schemas"]["WebhookEventType"];
        };
        /**
         * WebhookTestResponse
         * @description Response from testing a webhook.
         *
         *     Returns the result of a webhook test including response details
         *     and any errors encountered.
         *
         *     Attributes:
         *         success: Whether test succeeded.
         *         status_code: HTTP response code.
         *         response_time_ms: Response time.
         *         response_body: Response body (truncated).
         *         error_message: Error if failed.
         */
        WebhookTestResponse: {
            /**
             * Error Message
             * @description Error if failed
             */
            error_message?: string | null;
            /**
             * Response Body
             * @description Response body (truncated)
             */
            response_body?: string | null;
            /**
             * Response Time Ms
             * @description Response time
             */
            response_time_ms?: number | null;
            /**
             * Status Code
             * @description HTTP response code
             */
            status_code?: number | null;
            /**
             * Success
             * @description Whether test succeeded
             */
            success: boolean;
        };
        /**
         * WebhookUpdate
         * @description Schema for updating an existing webhook.
         *
         *     All fields are optional - only provided fields will be updated.
         *
         *     Attributes:
         *         name: New webhook name.
         *         url: New webhook URL.
         *         event_types: New list of subscribed events.
         *         integration_type: New integration type.
         *         enabled: New enabled status.
         *         auth: New authentication configuration.
         *         custom_headers: New custom headers.
         *         payload_template: New payload template.
         *         max_retries: New max retry count.
         *         retry_delay_seconds: New retry delay.
         */
        WebhookUpdate: {
            auth?: components["schemas"]["WebhookAuthConfig"] | null;
            /** Custom Headers */
            custom_headers?: {
                [key: string]: string;
            } | null;
            /** Enabled */
            enabled?: boolean | null;
            /** Event Types */
            event_types?: components["schemas"]["WebhookEventType"][] | null;
            integration_type?: components["schemas"]["IntegrationType"] | null;
            /** Max Retries */
            max_retries?: number | null;
            /** Name */
            name?: string | null;
            /** Payload Template */
            payload_template?: string | null;
            /** Retry Delay Seconds */
            retry_delay_seconds?: number | null;
            /** Url */
            url?: string | null;
        };
        /**
         * WorkerControlResponse
         * @description Response schema for worker control operations (start/stop/restart).
         *
         *     Used by endpoints that control individual workers.
         * @example {
         *       "message": "Worker 'file_watcher' restarted successfully",
         *       "success": true,
         *       "worker_name": "file_watcher"
         *     }
         */
        WorkerControlResponse: {
            /**
             * Message
             * @description Human-readable status message
             */
            message: string;
            /**
             * Success
             * @description Whether the operation was successful
             */
            success: boolean;
            /**
             * Worker Name
             * @description Name of the worker that was controlled
             */
            worker_name: string;
        };
        /**
         * WorkerHealthStatus
         * @description Health status for a background worker.
         *
         *     Workers are background processes that perform periodic or event-driven tasks.
         * @example {
         *       "critical": true,
         *       "name": "file_watcher",
         *       "running": true
         *     }
         */
        WorkerHealthStatus: {
            /**
             * Critical
             * @description Whether this worker is critical for system operation
             */
            critical: boolean;
            /**
             * Name
             * @description Worker name (e.g., 'file_watcher')
             */
            name: string;
            /**
             * Running
             * @description Whether the worker is currently running
             */
            running: boolean;
        };
        /**
         * WorkerStatus
         * @description Status information for a background worker/service.
         */
        WorkerStatus: {
            /**
             * Message
             * @description Optional status message or error details
             */
            message?: string | null;
            /**
             * Name
             * @description Worker/service name
             */
            name: string;
            /**
             * Running
             * @description Whether the worker is currently running
             */
            running: boolean;
        };
        /**
         * WorkerSupervisorStatusResponse
         * @description Response schema for worker supervisor status endpoint.
         *
         *     Provides overall supervisor status and detailed information about
         *     all supervised workers including their health status and restart metrics.
         * @example {
         *       "running": true,
         *       "timestamp": "2026-01-13T10:35:00Z",
         *       "worker_count": 4,
         *       "workers": [
         *         {
         *           "last_started_at": "2026-01-13T10:30:00Z",
         *           "max_restarts": 5,
         *           "name": "detection_worker",
         *           "restart_count": 0,
         *           "status": "running"
         *         },
         *         {
         *           "error": "Connection timeout",
         *           "last_crashed_at": "2026-01-13T10:30:30Z",
         *           "last_started_at": "2026-01-13T10:31:00Z",
         *           "max_restarts": 5,
         *           "name": "analysis_worker",
         *           "restart_count": 1,
         *           "status": "running"
         *         }
         *       ]
         *     }
         */
        WorkerSupervisorStatusResponse: {
            /**
             * Running
             * @description Whether the supervisor is currently running
             */
            running: boolean;
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of status query
             */
            timestamp: string;
            /**
             * Worker Count
             * @description Total number of registered workers
             */
            worker_count: number;
            /**
             * Workers
             * @description Detailed status of all supervised workers
             */
            workers?: components["schemas"]["SupervisedWorkerInfo"][];
        };
        /**
         * ZoneAnomalyAcknowledgeResponse
         * @description Response schema for acknowledging an anomaly.
         * @example {
         *       "acknowledged": true,
         *       "acknowledged_at": "2025-01-24T04:00:00Z",
         *       "id": "123e4567-e89b-12d3-a456-426614174000"
         *     }
         */
        ZoneAnomalyAcknowledgeResponse: {
            /**
             * Acknowledged
             * @description Whether the anomaly is now acknowledged
             */
            acknowledged: boolean;
            /**
             * Acknowledged At
             * Format: date-time
             * @description When the anomaly was acknowledged
             */
            acknowledged_at: string;
            /**
             * Acknowledged By
             * @description Who acknowledged the anomaly
             */
            acknowledged_by?: string | null;
            /**
             * Id
             * @description Anomaly ID
             */
            id: string;
        };
        /**
         * ZoneAnomalyListResponse
         * @description Response schema for zone anomaly list endpoint.
         * @example {
         *       "items": [
         *         {
         *           "acknowledged": false,
         *           "actual_value": 1,
         *           "anomaly_type": "unusual_time",
         *           "camera_id": "front_door",
         *           "created_at": "2025-01-24T03:15:00Z",
         *           "description": "Activity detected in Front Door at 03:15.",
         *           "detection_id": 12345,
         *           "deviation": 3.5,
         *           "expected_value": 0.1,
         *           "id": "123e4567-e89b-12d3-a456-426614174000",
         *           "severity": "warning",
         *           "thumbnail_url": "/api/detections/12345/image",
         *           "timestamp": "2025-01-24T03:15:00Z",
         *           "title": "Unusual activity at 03:15",
         *           "updated_at": "2025-01-24T03:15:00Z",
         *           "zone_id": "456e7890-e89b-12d3-a456-426614174001"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        ZoneAnomalyListResponse: {
            /**
             * Items
             * @description List of anomalies
             */
            items: components["schemas"]["ZoneAnomalyResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * ZoneAnomalyResponse
         * @description Response schema for a single zone anomaly.
         * @example {
         *       "acknowledged": false,
         *       "actual_value": 1,
         *       "anomaly_type": "unusual_time",
         *       "camera_id": "front_door",
         *       "created_at": "2025-01-24T03:15:00Z",
         *       "description": "Activity detected in Front Door at 03:15 when typical activity is 0.1.",
         *       "detection_id": 12345,
         *       "deviation": 3.5,
         *       "expected_value": 0.1,
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "severity": "warning",
         *       "thumbnail_url": "/api/detections/12345/image",
         *       "timestamp": "2025-01-24T03:15:00Z",
         *       "title": "Unusual activity at 03:15",
         *       "updated_at": "2025-01-24T03:15:00Z",
         *       "zone_id": "456e7890-e89b-12d3-a456-426614174001"
         *     }
         */
        ZoneAnomalyResponse: {
            /**
             * Acknowledged
             * @description Whether the anomaly has been acknowledged
             */
            acknowledged: boolean;
            /**
             * Acknowledged At
             * @description When the anomaly was acknowledged
             */
            acknowledged_at?: string | null;
            /**
             * Acknowledged By
             * @description Who acknowledged the anomaly
             */
            acknowledged_by?: string | null;
            /**
             * Actual Value
             * @description Actual observed value
             */
            actual_value?: number | null;
            /**
             * Anomaly Type
             * @description Type of anomaly detected
             */
            anomaly_type: string;
            /**
             * Camera Id
             * @description Camera ID associated with the zone
             */
            camera_id: string;
            /**
             * Created At
             * Format: date-time
             * @description When the record was created
             */
            created_at: string;
            /**
             * Description
             * @description Detailed description of the anomaly
             */
            description?: string | null;
            /**
             * Detection Id
             * @description Related detection ID if applicable
             */
            detection_id?: number | null;
            /**
             * Deviation
             * @description Statistical deviation from baseline
             */
            deviation?: number | null;
            /**
             * Expected Value
             * @description Expected value from baseline
             */
            expected_value?: number | null;
            /**
             * Id
             * @description Unique identifier for the anomaly
             */
            id: string;
            /**
             * Severity
             * @description Severity level of the anomaly
             */
            severity: string;
            /**
             * Thumbnail Url
             * @description URL to thumbnail image for visual context
             */
            thumbnail_url?: string | null;
            /**
             * Timestamp
             * Format: date-time
             * @description When the anomaly occurred
             */
            timestamp: string;
            /**
             * Title
             * @description Human-readable title
             */
            title: string;
            /**
             * Updated At
             * Format: date-time
             * @description When the record was last updated
             */
            updated_at: string;
            /**
             * Zone Id
             * @description Zone ID where anomaly was detected
             */
            zone_id: string;
        };
        /**
         * ZoneCreate
         * @description Schema for creating a new zone.
         * @example {
         *       "color": "#3B82F6",
         *       "coordinates": [
         *         [
         *           0.1,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.8
         *         ],
         *         [
         *           0.1,
         *           0.8
         *         ]
         *       ],
         *       "enabled": true,
         *       "name": "Front Door",
         *       "priority": 1,
         *       "shape": "rectangle",
         *       "zone_type": "entry_point"
         *     }
         */
        ZoneCreate: {
            /**
             * Color
             * @description Hex color for UI display
             * @default #3B82F6
             */
            color: string;
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates: number[][];
            /**
             * Enabled
             * @description Whether zone is active
             * @default true
             */
            enabled: boolean;
            /**
             * Name
             * @description Zone name
             */
            name: string;
            /**
             * Priority
             * @description Priority for overlapping zones (higher = more important)
             * @default 0
             */
            priority: number;
            /**
             * @description Shape of the zone
             * @default rectangle
             */
            shape: components["schemas"]["CameraZoneShape"];
            /**
             * @description Type of zone
             * @default other
             */
            zone_type: components["schemas"]["CameraZoneType"];
        };
        /**
         * ZoneHouseholdConfigCreate
         * @description Schema for creating a zone household configuration.
         *
         *     Used when initially configuring household linkage for a zone.
         * @example {
         *       "access_schedules": [
         *         {
         *           "cron_expression": "0 9-17 * * 1-5",
         *           "description": "Weekday daytime access",
         *           "member_ids": [
         *             4,
         *             5
         *           ]
         *         }
         *       ],
         *       "allowed_member_ids": [
         *         2,
         *         3
         *       ],
         *       "allowed_vehicle_ids": [
         *         1,
         *         2
         *       ],
         *       "owner_id": 1
         *     }
         */
        ZoneHouseholdConfigCreate: {
            /**
             * Access Schedules
             * @description Time-based access schedules for specific members
             */
            access_schedules?: components["schemas"]["AccessSchedule"][];
            /**
             * Allowed Member Ids
             * @description IDs of household members allowed in this zone (partial trust)
             */
            allowed_member_ids?: number[];
            /**
             * Allowed Vehicle Ids
             * @description IDs of registered vehicles allowed in this zone (partial trust)
             */
            allowed_vehicle_ids?: number[];
            /**
             * Owner Id
             * @description ID of the household member who owns this zone (full trust)
             */
            owner_id?: number | null;
        };
        /**
         * ZoneHouseholdConfigResponse
         * @description Schema for zone household configuration response.
         * @example {
         *       "access_schedules": [
         *         {
         *           "cron_expression": "0 9-17 * * 1-5",
         *           "description": "Weekday access",
         *           "member_ids": [
         *             4
         *           ]
         *         }
         *       ],
         *       "allowed_member_ids": [
         *         2,
         *         3
         *       ],
         *       "allowed_vehicle_ids": [
         *         1
         *       ],
         *       "created_at": "2026-01-21T10:00:00Z",
         *       "id": 1,
         *       "owner_id": 1,
         *       "updated_at": "2026-01-21T12:00:00Z",
         *       "zone_id": "550e8400-e29b-41d4-a716-446655440000"
         *     }
         */
        ZoneHouseholdConfigResponse: {
            /**
             * Access Schedules
             * @description Time-based access schedules
             */
            access_schedules: {
                [key: string]: unknown;
            }[];
            /**
             * Allowed Member Ids
             * @description IDs of household members allowed in this zone
             */
            allowed_member_ids: number[];
            /**
             * Allowed Vehicle Ids
             * @description IDs of registered vehicles allowed in this zone
             */
            allowed_vehicle_ids: number[];
            /**
             * Created At
             * Format: date-time
             * @description When the configuration was created
             */
            created_at: string;
            /**
             * Id
             * @description Configuration ID
             */
            id: number;
            /**
             * Owner Id
             * @description ID of the zone owner (household member with full trust)
             */
            owner_id?: number | null;
            /**
             * Updated At
             * Format: date-time
             * @description When the configuration was last updated
             */
            updated_at: string;
            /**
             * Zone Id
             * @description ID of the zone this configuration applies to
             */
            zone_id: string;
        };
        /**
         * ZoneHouseholdConfigUpdate
         * @description Schema for updating a zone household configuration.
         *
         *     All fields are optional - only provided fields will be updated.
         * @example {
         *       "allowed_member_ids": [
         *         3,
         *         4,
         *         5
         *       ],
         *       "owner_id": 2
         *     }
         */
        ZoneHouseholdConfigUpdate: {
            /**
             * Access Schedules
             * @description Time-based access schedules for specific members
             */
            access_schedules?: components["schemas"]["AccessSchedule"][] | null;
            /**
             * Allowed Member Ids
             * @description IDs of household members allowed in this zone
             */
            allowed_member_ids?: number[] | null;
            /**
             * Allowed Vehicle Ids
             * @description IDs of registered vehicles allowed in this zone
             */
            allowed_vehicle_ids?: number[] | null;
            /**
             * Owner Id
             * @description ID of the household member who owns this zone
             */
            owner_id?: number | null;
        };
        /**
         * ZoneListResponse
         * @description Schema for zone list response.
         * @example {
         *       "items": [
         *         {
         *           "camera_id": "front_door",
         *           "color": "#3B82F6",
         *           "coordinates": [
         *             [
         *               0.1,
         *               0.2
         *             ],
         *             [
         *               0.3,
         *               0.2
         *             ],
         *             [
         *               0.3,
         *               0.8
         *             ],
         *             [
         *               0.1,
         *               0.8
         *             ]
         *           ],
         *           "created_at": "2025-12-23T10:00:00Z",
         *           "enabled": true,
         *           "id": "123e4567-e89b-12d3-a456-426614174000",
         *           "name": "Front Door",
         *           "priority": 1,
         *           "shape": "rectangle",
         *           "updated_at": "2025-12-23T12:00:00Z",
         *           "zone_type": "entry_point"
         *         }
         *       ],
         *       "pagination": {
         *         "has_more": false,
         *         "limit": 50,
         *         "offset": 0,
         *         "total": 1
         *       }
         *     }
         */
        ZoneListResponse: {
            /**
             * Items
             * @description List of zones
             */
            items: components["schemas"]["ZoneResponse"][];
            /** @description Pagination metadata */
            pagination: components["schemas"]["PaginationMeta"];
        };
        /**
         * ZoneResponse
         * @description Schema for zone response.
         * @example {
         *       "camera_id": "front_door",
         *       "color": "#3B82F6",
         *       "coordinates": [
         *         [
         *           0.1,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.2
         *         ],
         *         [
         *           0.3,
         *           0.8
         *         ],
         *         [
         *           0.1,
         *           0.8
         *         ]
         *       ],
         *       "created_at": "2025-12-23T10:00:00Z",
         *       "enabled": true,
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "name": "Front Door",
         *       "priority": 1,
         *       "shape": "rectangle",
         *       "updated_at": "2025-12-23T12:00:00Z",
         *       "zone_type": "entry_point"
         *     }
         */
        ZoneResponse: {
            /**
             * Camera Id
             * @description Camera ID this zone belongs to
             */
            camera_id: string;
            /**
             * Color
             * @description Hex color for UI display
             */
            color: string;
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates: number[][];
            /**
             * Created At
             * Format: date-time
             * @description Timestamp when zone was created
             */
            created_at: string;
            /**
             * Enabled
             * @description Whether zone is active
             */
            enabled: boolean;
            /**
             * Id
             * @description Zone UUID
             */
            id: string;
            /**
             * Name
             * @description Zone name
             */
            name: string;
            /**
             * Priority
             * @description Priority for overlapping zones
             */
            priority: number;
            /** @description Shape of the zone */
            shape: components["schemas"]["CameraZoneShape"];
            /**
             * Updated At
             * Format: date-time
             * @description Timestamp when zone was last updated
             */
            updated_at: string;
            /** @description Type of zone */
            zone_type: components["schemas"]["CameraZoneType"];
        };
        /**
         * ZoneUpdate
         * @description Schema for updating an existing zone.
         * @example {
         *       "enabled": false,
         *       "name": "Front Door - Updated"
         *     }
         */
        ZoneUpdate: {
            /**
             * Color
             * @description Hex color for UI display
             */
            color?: string | null;
            /**
             * Coordinates
             * @description Array of normalized [x, y] points (0-1 range)
             */
            coordinates?: number[][] | null;
            /**
             * Enabled
             * @description Whether zone is active
             */
            enabled?: boolean | null;
            /**
             * Name
             * @description Zone name
             */
            name?: string | null;
            /**
             * Priority
             * @description Priority for overlapping zones (higher = more important)
             */
            priority?: number | null;
            /** @description Shape of the zone */
            shape?: components["schemas"]["CameraZoneShape"] | null;
            /** @description Type of zone */
            zone_type?: components["schemas"]["CameraZoneType"] | null;
        };
        /**
         * WebhookResponse
         * @description Full webhook configuration response.
         *
         *     Returns complete webhook information including configuration,
         *     metadata, and delivery statistics.
         *
         *     Attributes:
         *         id: Unique webhook identifier.
         *         name: Webhook name.
         *         url: Webhook endpoint URL.
         *         event_types: Subscribed event types.
         *         integration_type: Integration type.
         *         enabled: Whether active.
         *         custom_headers: Custom HTTP headers.
         *         payload_template: Jinja2 payload template.
         *         max_retries: Max retry attempts.
         *         retry_delay_seconds: Initial retry delay.
         *         created_at: Creation timestamp.
         *         updated_at: Last update timestamp.
         *         total_deliveries: Total delivery attempts.
         *         successful_deliveries: Successful delivery count.
         *         last_delivery_at: Last delivery timestamp.
         *         last_delivery_status: Status of last delivery.
         */
        backend__api__schemas__outbound_webhook__WebhookResponse: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp
             */
            created_at: string;
            /** Custom Headers */
            custom_headers?: {
                [key: string]: string;
            };
            /**
             * Enabled
             * @description Whether active
             */
            enabled: boolean;
            /**
             * Event Types
             * @description Subscribed events
             */
            event_types: components["schemas"]["WebhookEventType"][];
            /**
             * Id
             * @description Unique webhook identifier
             */
            id: string;
            /** @description Integration type */
            integration_type: components["schemas"]["IntegrationType"];
            /**
             * Last Delivery At
             * @description Last delivery timestamp
             */
            last_delivery_at?: string | null;
            last_delivery_status?: components["schemas"]["WebhookDeliveryStatus"] | null;
            /** Max Retries */
            max_retries: number;
            /**
             * Name
             * @description Webhook name
             */
            name: string;
            /** Payload Template */
            payload_template?: string | null;
            /** Retry Delay Seconds */
            retry_delay_seconds: number;
            /**
             * Successful Deliveries
             * @description Successful deliveries
             * @default 0
             */
            successful_deliveries: number;
            /**
             * Total Deliveries
             * @description Total delivery attempts
             * @default 0
             */
            total_deliveries: number;
            /**
             * Updated At
             * Format: date-time
             * @description Last update timestamp
             */
            updated_at: string;
            /**
             * Url
             * @description Webhook endpoint URL
             */
            url: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    root: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    "action-events_list_action_events": {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by track ID */
                track_id?: number | null;
                /** @description Filter by action label */
                action?: string | null;
                /** @description Filter by suspicious flag */
                is_suspicious?: boolean | null;
                /** @description Filter by minimum confidence */
                min_confidence?: number | null;
                /** @description Filter by start time */
                start_time?: string | null;
                /** @description Filter by end time */
                end_time?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ActionEventListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "action-events_create_action_event": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ActionEventCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ActionEventResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "action-events_analyze_action": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ActionAnalyzeRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ActionAnalyzeResponse"];
                };
            };
            /** @description Invalid request (no valid frames) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description X-CLIP model unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "action-events_get_camera_action_events": {
        parameters: {
            query?: {
                /** @description Filter by start time */
                start_time?: string | null;
                /** @description Filter by end time */
                end_time?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path: {
                /** @description Camera ID */
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ActionEventListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "action-events_list_suspicious_actions": {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by minimum confidence */
                min_confidence?: number | null;
                /** @description Filter by start time */
                start_time?: string | null;
                /** @description Filter by end time */
                end_time?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuspiciousActionsResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "action-events_get_action_event": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Action event ID */
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ActionEventResponse"];
                };
            };
            /** @description Action event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "action-events_delete_action_event": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Action event ID */
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Action event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    admin_cleanup_orphans: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrphanCleanupRequest"];
            };
        };
        responses: {
            /** @description Orphan cleanup completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrphanCleanupResponse"];
                };
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    admin_clear_cache: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Cache cleared successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClearCacheResponse"];
                };
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    admin_flush_queues: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Queues flushed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FlushQueuesResponse"];
                };
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    admin_seed_cameras: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeedCamerasRequest"];
            };
        };
        responses: {
            /** @description Cameras created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeedCamerasResponse"];
                };
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    admin_clear_seeded_data: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ClearDataRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClearDataResponse"];
                };
            };
            /** @description Bad request - Confirmation required */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    admin_seed_events: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeedEventsRequest"];
            };
        };
        responses: {
            /** @description Events and detections created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeedEventsResponse"];
                };
            };
            /** @description Bad request - No cameras found */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    admin_seed_pipeline_latency: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeedPipelineLatencyRequest"];
            };
        };
        responses: {
            /** @description Pipeline latency data seeded successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeedPipelineLatencyResponse"];
                };
            };
            /** @description Unauthorized - Admin API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Debug mode or admin not enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ai-audit_trigger_batch_audit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BatchAuditRequest"];
            };
        };
        responses: {
            /** @description Batch audit job created successfully */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchAuditJobResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ai-audit_get_batch_audit_status": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchAuditJobStatusResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ai-audit_get_event_audit": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventAuditResponse"];
                };
            };
            /** @description Event or audit not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ai-audit_evaluate_event": {
        parameters: {
            query?: {
                /** @description Force re-evaluation even if already evaluated */
                force?: boolean;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventAuditResponse"];
                };
            };
            /** @description Event or audit not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ai-audit_get_model_leaderboard": {
        parameters: {
            query?: {
                /** @description Number of days to include */
                days?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LeaderboardResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ai-audit_get_recommendations": {
        parameters: {
            query?: {
                /** @description Number of days to include */
                days?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecommendationsResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ai-audit_get_audit_stats": {
        parameters: {
            query?: {
                /** @description Number of days to include */
                days?: number;
                /** @description Filter by camera ID */
                camera_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditStatsResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alert-rules_list_rules": {
        parameters: {
            query?: {
                /** @description Filter by enabled status */
                enabled?: boolean | null;
                /** @description Filter by severity level */
                severity?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alert-rules_create_rule": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertRuleCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alert-rules_get_rule": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Alert rule not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alert-rules_update_rule": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertRuleUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertRuleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "alert-rules_delete_rule": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Alert rule not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alert-rules_test_rule": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                rule_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RuleTestRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RuleTestResponse"];
                };
            };
            /** @description Alert rule not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    alerts_acknowledge_alert: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                alert_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertResponse"];
                };
            };
            /** @description Alert not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Alert cannot be acknowledged (wrong status or concurrent modification) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    alerts_dismiss_alert: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                alert_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertResponse"];
                };
            };
            /** @description Alert not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Alert cannot be dismissed (wrong status or concurrent modification) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "analytics-zones_create_line_zone": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LineZoneCreate"];
            };
        };
        responses: {
            /** @description Line zone created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LineZoneResponse"];
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_get_line_zones_by_camera": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Line zones retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LineZoneListResponse"];
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_get_line_zone": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Line zone retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LineZoneResponse"];
                };
            };
            /** @description Line zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_delete_line_zone": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Line zone deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Line zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_update_line_zone": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LineZoneUpdate"];
            };
        };
        responses: {
            /** @description Line zone updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LineZoneResponse"];
                };
            };
            /** @description Line zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_reset_line_zone_counts": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Counts reset successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LineZoneResponse"];
                };
            };
            /** @description Line zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_create_polygon_zone": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PolygonZoneCreate"];
            };
        };
        responses: {
            /** @description Polygon zone created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PolygonZoneResponse"];
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_get_polygon_zones_by_camera": {
        parameters: {
            query?: {
                /** @description If True, only return active zones. If False, return all zones. */
                active_only?: boolean;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Polygon zones retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PolygonZoneListResponse"];
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_get_polygon_zone": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Polygon zone retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PolygonZoneResponse"];
                };
            };
            /** @description Polygon zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_delete_polygon_zone": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Polygon zone deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Polygon zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_update_polygon_zone": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PolygonZoneUpdate"];
            };
        };
        responses: {
            /** @description Polygon zone updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PolygonZoneResponse"];
                };
            };
            /** @description Polygon zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_check_loitering": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoiteringCheckRequest"];
            };
        };
        responses: {
            /** @description Loitering check completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LoiteringCheckResponse"];
                };
            };
            /** @description Polygon zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_get_dwell_history": {
        parameters: {
            query?: {
                /** @description Start of time window (defaults to 24 hours ago) */
                start_time?: string | null;
                /** @description End of time window (defaults to now) */
                end_time?: string | null;
                /** @description Whether to include currently active dwellers */
                include_active?: boolean;
            };
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Dwell history retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DwellHistoryResponse"];
                };
            };
            /** @description Polygon zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_get_dwell_statistics": {
        parameters: {
            query?: {
                /** @description Start of statistics window (defaults to 24 hours ago) */
                start_time?: string | null;
                /** @description End of statistics window (defaults to now) */
                end_time?: string | null;
            };
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Dwell statistics retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DwellStatisticsResponse"];
                };
            };
            /** @description Polygon zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_get_active_dwellers": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Active dwellers retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ActiveDwellersListResponse"];
                };
            };
            /** @description Polygon zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "analytics-zones_toggle_polygon_zone_active": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Active status toggled successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PolygonZoneResponse"];
                };
            };
            /** @description Polygon zone not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    analytics_get_camera_uptime: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraUptimeResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    analytics_get_detection_trends: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionTrendsResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    analytics_get_object_distribution: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ObjectDistributionResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    analytics_get_risk_history: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RiskHistoryResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    analytics_get_risk_score_distribution: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
                /** @description Size of each score bucket (default: 10) */
                bucket_size?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RiskScoreDistributionResponse"];
                };
            };
            /** @description Bad request - Invalid date range or bucket size */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    analytics_get_risk_score_trends: {
        parameters: {
            query: {
                /** @description Start date for analytics (ISO format) */
                start_date: string;
                /** @description End date for analytics (ISO format) */
                end_date: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RiskScoreTrendsResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    audit_list_audit_logs: {
        parameters: {
            query?: {
                /** @description Filter by action type */
                action?: string | null;
                /** @description Filter by resource type */
                resource_type?: string | null;
                /** @description Filter by resource ID */
                resource_id?: string | null;
                /** @description Filter by actor */
                actor?: string | null;
                /** @description Filter by status (success/failure) */
                status?: string | null;
                /** @description Filter from date (ISO format) */
                start_date?: string | null;
                /** @description Filter to date (ISO format) */
                end_date?: string | null;
                /** @description Page size */
                limit?: number;
                /** @description Number of results to skip (deprecated, use cursor) */
                offset?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string | null;
                /** @description Include total count in response. Defaults to False for performance. Total count queries are expensive for large datasets. For cursor-based pagination, has_more and next_cursor provide sufficient information without the total count. */
                include_total_count?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogListResponse"];
                };
            };
            /** @description Invalid date range or cursor */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    audit_get_audit_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogStats"];
                };
            };
            /** @description Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    audit_get_audit_log: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                audit_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogResponse"];
                };
            };
            /** @description Audit log not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    calibration_get_calibration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserCalibrationResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    calibration_update_calibration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserCalibrationUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserCalibrationResponse"];
                };
            };
            /** @description Validation error (invalid threshold ordering) */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    calibration_patch_calibration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserCalibrationUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserCalibrationResponse"];
                };
            };
            /** @description Validation error (invalid threshold ordering) */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    calibration_get_calibration_defaults: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CalibrationDefaultsResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    calibration_reset_calibration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CalibrationResetResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    cameras_list_cameras: {
        parameters: {
            query?: {
                /** @description Filter by camera status */
                status?: string | null;
                /** @description Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, name, folder_path, status, created_at, last_seen_at */
                fields?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_create_camera: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_list_deleted_cameras: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of soft-deleted cameras */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeletedCamerasListResponse"];
                };
            };
        };
    };
    cameras_validate_camera_paths: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraPathValidationResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    cameras_get_camera: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_delete_camera: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_update_camera: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_get_camera_baseline: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BaselineSummaryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_get_camera_activity_baseline: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ActivityBaselineResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_get_camera_baseline_anomalies: {
        parameters: {
            query?: {
                /** @description Number of days to look back */
                days?: number;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AnomalyListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_get_camera_class_baseline: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClassBaselineResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_restore_camera: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Camera restored successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraResponse"];
                };
            };
            /** @description Camera is not deleted */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_get_camera_scene_changes: {
        parameters: {
            query?: {
                /** @description Filter by acknowledgement status */
                acknowledged?: boolean | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Cursor for pagination (detected_at timestamp) */
                cursor?: string | null;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SceneChangeListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_acknowledge_scene_change: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                scene_change_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SceneChangeAcknowledgeResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cameras_get_camera_snapshot: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Snapshot served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Camera or snapshot not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    zones_list_zones: {
        parameters: {
            query?: {
                /** @description Filter by enabled status */
                enabled?: boolean | null;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    zones_create_zone: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    zones_get_zone: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    zones_update_zone: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    zones_delete_zone: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    debug_get_circuit_breakers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DebugCircuitBreakersResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_get_config: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DebugConfigResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_get_log_level: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogLevelResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_set_log_level: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LogLevelRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogLevelResponse"];
                };
            };
            /** @description Bad request - Invalid log level */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_get_memory_stats: {
        parameters: {
            query?: {
                top_n?: number;
                force_gc?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MemoryStatsResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_trigger_gc: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_start_tracemalloc: {
        parameters: {
            query?: {
                nframes?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_stop_tracemalloc: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_get_pipeline_errors: {
        parameters: {
            query?: {
                limit?: number;
                component?: string | null;
                error_type?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineErrorsResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_get_pipeline_state: {
        parameters: {
            query?: {
                error_limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineStateResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_start_profiling: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProfileStartResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_get_profile_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProfileStatsResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_stop_profiling: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProfileStopResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_list_recordings: {
        parameters: {
            query?: {
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecordingsListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    debug_get_recording: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                recording_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    debug_delete_recording: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                recording_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    debug_get_redis_info: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RedisInfoResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    debug_replay_request: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                recording_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReplayResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    debug_get_websocket_connections: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebSocketConnectionsResponse"];
                };
            };
            /** @description Not found - Debug mode disabled */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    detections_list_detections: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by object type */
                object_type?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Minimum confidence score */
                min_confidence?: number | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip (deprecated, use cursor) */
                offset?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string | null;
                /** @description Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, file_path, file_type, detected_at, object_type, confidence, bbox_x, bbox_y, bbox_width, bbox_height, thumbnail_path, media_type, duration, video_codec, video_width, video_height, enrichment_data */
                fields?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    detections_bulk_create_detections: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DetectionBulkCreateRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionBulkCreateResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    detections_bulk_delete_detections: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DetectionBulkDeleteRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkOperationResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    detections_bulk_update_detections: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DetectionBulkUpdateRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkOperationResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    detections_export_detections: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by object type */
                object_type?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Minimum confidence threshold */
                min_confidence?: number | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Exported detections file */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example [
                     *       {
                     *         "camera_name": "Front Door",
                     *         "detection_id": 1
                     *       }
                     *     ]
                     */
                    "application/json": Record<string, never>[];
                    /** @example detection_id,camera_name,detected_at,... */
                    "text/csv": string;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    detections_list_detection_labels: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionLabelsResponse"];
                };
            };
        };
    };
    detections_search_detections: {
        parameters: {
            query: {
                q: string;
                labels?: string[] | null;
                min_confidence?: number | null;
                camera_id?: string | null;
                start_date?: string | null;
                end_date?: string | null;
                limit?: number;
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionSearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    detections_get_detection_stats: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    detections_get_detection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    detections_get_detection_enrichment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EnrichmentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    detections_get_detection_image: {
        parameters: {
            query?: {
                /** @description Return full-size original image instead of thumbnail */
                full?: boolean;
            };
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Image served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection or image not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to generate thumbnail */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    detections_get_detection_thumbnail: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "image/jpeg": unknown;
                    "image/png": unknown;
                };
            };
            /** @description Detection or thumbnail not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to generate thumbnail */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    detections_stream_detection_video: {
        parameters: {
            query?: never;
            header?: {
                Range?: string | null;
            };
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Full video content */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Partial video content (range request) */
            206: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection is not a video */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection or video file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Range not satisfiable */
            416: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Transcoding failed */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    detections_get_video_thumbnail: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                detection_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Thumbnail served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection is not a video */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Detection or video not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to generate thumbnail */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    dlq_get_dlq_jobs: {
        parameters: {
            query?: {
                /** @description Start index (0-based) */
                start?: number;
                /** @description Maximum number of jobs to return */
                limit?: number;
            };
            header?: never;
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQJobsResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    dlq_requeue_all_dlq_jobs: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQRequeueResponse"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    dlq_requeue_dlq_job: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQRequeueResponse"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    dlq_get_dlq_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQStatsResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    dlq_clear_dlq: {
        parameters: {
            query?: {
                api_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                queue_name: components["schemas"]["DLQName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DLQClearResponse"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_list_entities: {
        parameters: {
            query?: {
                /** @description Filter by entity type: 'person' or 'vehicle' */
                entity_type?: components["schemas"]["EntityTypeFilter"] | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter entities seen since this time */
                since?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_get_entity_matches: {
        parameters: {
            query?: {
                /** @description Type of entity to search for matches */
                entity_type?: components["schemas"]["EntityTypeFilter"];
                /** @description Minimum similarity threshold for matches */
                threshold?: number;
            };
            header?: never;
            path: {
                detection_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityMatchResponse"];
                };
            };
            /** @description Detection not found or no embedding stored */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Redis service unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_get_entity_stats: {
        parameters: {
            query?: {
                /** @description Filter entities seen since this time */
                since?: string | null;
                /** @description Filter entities seen until this time */
                until?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_list_trusted_entities: {
        parameters: {
            query?: {
                /** @description Filter by entity type: 'person' or 'vehicle' */
                entity_type?: components["schemas"]["EntityTypeFilter"] | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TrustedEntityListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_list_untrusted_entities: {
        parameters: {
            query?: {
                /** @description Filter by entity type: 'person' or 'vehicle' */
                entity_type?: components["schemas"]["EntityTypeFilter"] | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TrustedEntityListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_list_entities_v2: {
        parameters: {
            query?: {
                /** @description Filter by entity type: 'person' or 'vehicle' */
                entity_type?: components["schemas"]["EntityTypeFilter"] | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter entities seen since this time */
                since?: string | null;
                /** @description Filter entities seen until this time */
                until?: string | null;
                /** @description Data source: 'redis', 'postgres', or 'both' */
                source?: components["schemas"]["SourceFilter"];
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityListResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_get_entity_v2: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityDetail"];
                };
            };
            /** @description Entity not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_get_entity_detections: {
        parameters: {
            query?: {
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityDetectionsResponse"];
                };
            };
            /** @description Entity not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_get_entity: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityDetail"];
                };
            };
            /** @description Entity not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_get_entity_history: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityHistoryResponse"];
                };
            };
            /** @description Entity not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    entities_update_entity_trust: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                entity_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EntityTrustUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EntityTrustResponse"];
                };
            };
            /** @description Entity not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    events_list_events: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by risk level (low, medium, high, critical) */
                risk_level?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
                /** @description Filter by detected object type */
                object_type?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip (deprecated, use cursor) */
                offset?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string | null;
                /** @description Comma-separated list of fields to include in response (sparse fieldsets). Valid fields: id, camera_id, started_at, ended_at, risk_score, risk_level, summary, reasoning, reviewed, detection_count, detection_ids, thumbnail_url */
                fields?: string | null;
                /** @description Include soft-deleted events in results. Default is False to hide deleted events. */
                include_deleted?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_analyze_batch_streaming: {
        parameters: {
            query?: {
                /** @description Camera ID for the batch */
                camera_id?: string | null;
                /** @description Comma-separated detection IDs (optional) */
                detection_ids?: string | null;
            };
            header?: never;
            path: {
                batch_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_bulk_create_events: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventBulkCreateRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventBulkCreateResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    events_bulk_delete_events: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventBulkDeleteRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkOperationResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    events_bulk_update_events: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventBulkUpdateRequest"];
            };
        };
        responses: {
            /** @description Multi-status response with per-item results */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkOperationResponse"];
                };
            };
            /** @description Invalid request format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    events_get_event_clusters: {
        parameters: {
            query: {
                /** @description Start date for clustering (ISO format) */
                start_date: string;
                /** @description End date for clustering (ISO format) */
                end_date: string;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Time window in minutes for clustering events (default: 5) */
                time_window_minutes?: number;
                /** @description Minimum events required to form a cluster (default: 2) */
                min_cluster_size?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventClustersResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_list_deleted_events: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of soft-deleted events */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeletedEventsListResponse"];
                };
            };
        };
    };
    events_export_events: {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by risk level (low, medium, high, critical) */
                risk_level?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Exported events file */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example [
                     *       {
                     *         "camera_name": "Front Door",
                     *         "event_id": 1
                     *       }
                     *     ]
                     */
                    "application/json": Record<string, never>[];
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": string;
                    /** @example event_id,camera_name,started_at,... */
                    "text/csv": string;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    jobs_start_export_job: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExportJobRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobStartResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_search_events_endpoint: {
        parameters: {
            query: {
                /** @description Search query string */
                q: string;
                /** @description Filter by camera ID (comma-separated for multiple) */
                camera_id?: string | null;
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by risk levels (comma-separated: low,medium,high,critical) */
                severity?: string | null;
                /** @description Alias for severity - filter by risk levels (comma-separated: low,medium,high,critical) */
                risk_level?: string | null;
                /** @description Filter by object types (comma-separated: person,vehicle,animal) */
                object_type?: string | null;
                /** @description Filter by reviewed status */
                reviewed?: boolean | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_get_event_stats: {
        parameters: {
            query?: {
                /** @description Filter by start date (ISO format) */
                start_date?: string | null;
                /** @description Filter by end date (ISO format) */
                end_date?: string | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_get_timeline_summary: {
        parameters: {
            query?: {
                /** @description Start of timeline range (ISO format) */
                start_date?: string | null;
                /** @description End of timeline range (ISO format) */
                end_date?: string | null;
                /** @description Zoom level determining bucket size (hour, day, week) */
                bucket_size?: string;
                /** @description Filter by camera ID */
                camera_id?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TimelineSummaryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_get_event: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_delete_event: {
        parameters: {
            query?: {
                /** @description Cascade soft delete to related detections */
                cascade?: boolean;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event already deleted */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_update_event: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Conflict - event was modified by another request (optimistic locking) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "current_version": 3,
                     *       "detail": "Event was modified by another request. Please refresh and retry."
                     *     }
                     */
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_get_event_clip: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClipInfoResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_generate_event_clip: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ClipGenerateRequest"];
            };
        };
        responses: {
            /** @description Clip already exists */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClipGenerateResponse"];
                };
            };
            /** @description Clip created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClipGenerateResponse"];
                };
            };
            /** @description Cannot generate clip - event has no detections */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_get_event_detections: {
        parameters: {
            query?: {
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
                /** @description Order detections by: 'detected_at' (detection timestamp, default) or 'created_at' (when associated with event - shows detection sequence in event) */
                order_detections_by?: string;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetectionListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_get_event_enrichments: {
        parameters: {
            query?: {
                /** @description Maximum number of enrichments to return */
                limit?: number;
                /** @description Number of enrichments to skip */
                offset?: number;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventEnrichmentsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    events_restore_event: {
        parameters: {
            query?: {
                /** @description Cascade restore to related detections */
                cascade?: boolean;
            };
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event restored successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventResponse"];
                };
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event is not deleted */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    exports_list_exports: {
        parameters: {
            query?: {
                /** @description Filter by job status */
                status?: components["schemas"]["ExportJobStatusEnum"] | null;
                /** @description Maximum number of jobs to return */
                limit?: number;
                /** @description Number of jobs to skip (for pagination) */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    exports_start_export: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExportJobCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobStartResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    exports_get_export_status: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobResponse"];
                };
            };
            /** @description Export job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    exports_cancel_export: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobCancelResponse"];
                };
            };
            /** @description Export job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Job cannot be cancelled (already completed or failed) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    exports_download_export: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Export not yet complete */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Export job or file not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    exports_get_download_info: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportDownloadResponse"];
                };
            };
            /** @description Export job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_list_face_events": {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter events after this time */
                start_time?: string | null;
                /** @description Filter events before this time */
                end_time?: string | null;
                /** @description Only return unknown faces */
                unknown_only?: boolean;
                /** @description Maximum events to return */
                limit?: number;
                /** @description Number of events to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FaceDetectionEventListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_match_face": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FaceMatchRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FaceMatchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_get_unknown_strangers": {
        parameters: {
            query?: {
                /** @description Filter events after this time */
                start_time?: string | null;
                /** @description Filter events before this time */
                end_time?: string | null;
                /** @description Minimum quality score */
                min_quality?: number;
                /** @description Maximum events to return */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnknownStrangerListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    feedback_create_feedback: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventFeedbackCreate"];
            };
        };
        responses: {
            /** @description Feedback created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventFeedbackResponse"];
                };
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Feedback already exists for this event */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    feedback_get_event_feedback: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                event_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Feedback found */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventFeedbackResponse"];
                };
            };
            /** @description No feedback found for this event */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    feedback_get_feedback_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Statistics retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FeedbackStatsResponse"];
                };
            };
        };
    };
    health_get_ai_services_health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description AI services health status returned */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AIServicesHealthResponse"];
                };
            };
            /** @description Critical AI services are unhealthy */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    heatmaps_get_current_heatmap: {
        parameters: {
            query?: {
                /** @description Heatmap resolution */
                resolution?: components["schemas"]["HeatmapResolution"];
                /** @description Output image width */
                output_width?: number;
                /** @description Output image height */
                output_height?: number;
                /** @description Colormap name (e.g., jet, hot, viridis) */
                colormap?: string;
            };
            header?: never;
            path: {
                /** @description Camera ID */
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HeatmapResponse"];
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    heatmaps_reset_heatmap_accumulator: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Camera ID */
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    heatmaps_get_heatmap_history: {
        parameters: {
            query: {
                /** @description Start of the time range (ISO format) */
                start_time: string;
                /** @description End of the time range (ISO format) */
                end_time: string;
                /** @description Filter by resolution level */
                resolution?: components["schemas"]["HeatmapResolution"] | null;
                /** @description Maximum number of records to return */
                limit?: number;
                /** @description Number of records to skip */
                offset?: number;
            };
            header?: never;
            path: {
                /** @description Camera ID */
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HeatmapListResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    heatmaps_get_merged_heatmap: {
        parameters: {
            query: {
                /** @description Start of the time range (ISO format) */
                start_time: string;
                /** @description End of the time range (ISO format) */
                end_time: string;
                /** @description Filter by resolution level */
                resolution?: components["schemas"]["HeatmapResolution"] | null;
            };
            header?: never;
            path: {
                /** @description Camera ID */
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HeatmapResponse"];
                };
            };
            /** @description Bad request - Invalid date range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Camera not found or no heatmap data */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    heatmaps_save_heatmap_snapshot: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Camera ID */
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["HeatmapSnapshotRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HeatmapSnapshotResponse"];
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    heatmaps_get_heatmap_stats: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Camera ID */
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    household_list_members: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HouseholdMemberResponse"][];
                };
            };
        };
    };
    household_create_member: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["HouseholdMemberCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HouseholdMemberResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    household_get_member: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                member_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HouseholdMemberResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    household_delete_member: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                member_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    household_update_member: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                member_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["HouseholdMemberUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HouseholdMemberResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    household_add_embedding_from_event: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                member_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddEmbeddingRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PersonEmbeddingResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    household_list_vehicles: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RegisteredVehicleResponse"][];
                };
            };
        };
    };
    household_create_vehicle: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisteredVehicleCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RegisteredVehicleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    household_get_vehicle: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vehicle_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RegisteredVehicleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    household_delete_vehicle: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vehicle_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    household_update_vehicle: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vehicle_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisteredVehicleUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RegisteredVehicleResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_list_jobs: {
        parameters: {
            query?: {
                /** @description Filter by job type (e.g., 'export', 'cleanup') */
                job_type?: string | null;
                /** @description Filter by job status */
                status?: components["schemas"]["JobStatusEnum"] | null;
                /** @description Maximum number of jobs to return */
                limit?: number;
                /** @description Number of jobs to skip (for pagination) */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_bulk_cancel_jobs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BulkCancelRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkCancelResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_search_jobs: {
        parameters: {
            query?: {
                /** @description Free text search across job type, error message, and metadata */
                q?: string | null;
                /** @description Comma-separated status values to filter (e.g., 'running,pending') */
                status?: string | null;
                /** @description Comma-separated job types to filter (e.g., 'export,cleanup') */
                job_type?: string | null;
                /** @description Queue name filter (reserved for future use) */
                queue?: string | null;
                /** @description Filter jobs created after this ISO timestamp */
                created_after?: string | null;
                /** @description Filter jobs created before this ISO timestamp */
                created_before?: string | null;
                /** @description Filter jobs completed after this ISO timestamp */
                completed_after?: string | null;
                /** @description Filter jobs completed before this ISO timestamp */
                completed_before?: string | null;
                /** @description If true, only jobs with errors; if false, only jobs without errors */
                has_error?: boolean | null;
                /** @description Minimum job duration in seconds (only completed jobs) */
                min_duration?: number | null;
                /** @description Maximum job duration in seconds (only completed jobs) */
                max_duration?: number | null;
                /** @description Maximum number of jobs to return */
                limit?: number;
                /** @description Number of jobs to skip (for pagination) */
                offset?: number;
                /** @description Field to sort by (created_at, started_at, completed_at, progress, job_type, status) */
                sort?: string;
                /** @description Sort direction (asc or desc) */
                order?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobSearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_get_job_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobStatsResponse"];
                };
            };
        };
    };
    jobs_list_job_types: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobTypesResponse"];
                };
            };
        };
    };
    jobs_get_job_status: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_delete_job: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobCancelResponse"];
                };
            };
            /** @description Job cannot be cancelled or aborted */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_abort_job: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobAbortResponse"];
                };
            };
            /** @description Job is not running (use cancel for queued jobs) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_cancel_job: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobCancelResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Job cannot be cancelled (already completed or failed) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_get_job_detail: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobDetailResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_get_job_history: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobHistoryResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    jobs_get_job_logs: {
        parameters: {
            query?: {
                /** @description Minimum log level to return (DEBUG, INFO, WARNING, ERROR) */
                level?: string | null;
                /** @description Return logs from this timestamp onwards (ISO format) */
                since?: string | null;
                /** @description Maximum number of log entries to return */
                limit?: number;
            };
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobLogsResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_list_known_persons": {
        parameters: {
            query?: {
                /** @description Filter to household members only */
                household_only?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KnownPersonListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_create_known_person": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KnownPersonCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KnownPersonResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_get_known_person": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                person_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KnownPersonResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_delete_known_person": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                person_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_update_known_person": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                person_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KnownPersonUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KnownPersonResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_list_person_embeddings": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                person_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FaceEmbeddingResponse"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_add_face_embedding": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                person_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FaceEmbeddingCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FaceEmbeddingResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "face-recognition_delete_face_embedding": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                person_id: number;
                embedding_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    logs_list_logs: {
        parameters: {
            query?: {
                /** @description Filter by log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) */
                level?: string | null;
                /** @description Filter by component (partial match) */
                component?: string | null;
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter by source (backend, frontend) */
                source?: string | null;
                /** @description Full-text search on message content */
                search?: string | null;
                /** @description Filter from date (ISO format) */
                start_date?: string | null;
                /** @description Filter to date (ISO format) */
                end_date?: string | null;
                /** @description Page size */
                limit?: number;
                /** @description Number of results to skip (deprecated, use cursor) */
                offset?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string | null;
                /** @description Include total count in response. Defaults to False for performance. */
                include_total_count?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogsListResponse"];
                };
            };
            /** @description Invalid date range or cursor */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    logs_ingest_frontend_log: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FrontendLogEntry"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FrontendLogResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    logs_ingest_frontend_logs_batch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FrontendLogBatchRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FrontendLogResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    logs_get_log_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogStats"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    media_serve_camera_file: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    media_serve_clip: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Clip served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    media_serve_thumbnail: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                filename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Thumbnail served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    media_serve_media_compat: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File served successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Access denied */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description File not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MediaErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Too many requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    metrics_metrics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Prometheus metrics in exposition format */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "notification-preferences_get_notification_preferences": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationPreferencesResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "notification-preferences_update_notification_preferences": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotificationPreferencesUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationPreferencesResponse"];
                };
            };
            /** @description Bad request - Invalid sound or risk level value */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "notification-preferences_get_all_camera_settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraNotificationSettingsListResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "notification-preferences_get_camera_setting": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraNotificationSettingResponse"];
                };
            };
            /** @description Camera notification setting not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "notification-preferences_update_camera_setting": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraNotificationSettingUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraNotificationSettingResponse"];
                };
            };
            /** @description Camera not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "notification-preferences_get_quiet_hours": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QuietHoursPeriodsListResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "notification-preferences_create_quiet_hours_period": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QuietHoursPeriodCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QuietHoursPeriodResponse"];
                };
            };
            /** @description Bad request - Invalid time range */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "notification-preferences_delete_quiet_hours_period": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                period_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Quiet hours period not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    notification_get_notification_config: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationConfigResponse"];
                };
            };
        };
    };
    notification_update_notification_config: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotificationConfigUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationConfigUpdateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    notification_get_notification_history: {
        parameters: {
            query?: {
                /** @description Filter by alert ID */
                alert_id?: string | null;
                /** @description Filter by channel */
                channel?: components["schemas"]["NotificationChannel"] | null;
                /** @description Filter by success status */
                success?: boolean | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    notification_test_notification: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookTestNotificationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TestNotificationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "outbound-webhooks_list_webhooks": {
        parameters: {
            query?: {
                /** @description Filter to only return enabled webhooks */
                enabled_only?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_create_webhook": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["backend__api__schemas__outbound_webhook__WebhookResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_get_delivery": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                delivery_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookDeliveryResponse"];
                };
            };
            /** @description Delivery not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_retry_delivery": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                delivery_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookDeliveryResponse"];
                };
            };
            /** @description Delivery not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Delivery cannot be retried (not in failed state) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_get_webhook_health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookHealthSummary"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_get_webhook": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                webhook_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["backend__api__schemas__outbound_webhook__WebhookResponse"];
                };
            };
            /** @description Webhook not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_delete_webhook": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                webhook_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Webhook not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_update_webhook": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                webhook_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["backend__api__schemas__outbound_webhook__WebhookResponse"];
                };
            };
            /** @description Webhook not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_list_deliveries": {
        parameters: {
            query?: {
                /** @description Maximum number of deliveries to return */
                limit?: number;
                /** @description Number of deliveries to skip (for pagination) */
                offset?: number;
            };
            header?: never;
            path: {
                webhook_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookDeliveryListResponse"];
                };
            };
            /** @description Webhook not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_disable_webhook": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                webhook_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["backend__api__schemas__outbound_webhook__WebhookResponse"];
                };
            };
            /** @description Webhook not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_enable_webhook": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                webhook_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["backend__api__schemas__outbound_webhook__WebhookResponse"];
                };
            };
            /** @description Webhook not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "outbound-webhooks_test_webhook": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                webhook_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookTestRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookTestResponse"];
                };
            };
            /** @description Webhook not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "plate-reads_list_plate_reads": {
        parameters: {
            query?: {
                /** @description Filter by camera ID */
                camera_id?: string | null;
                /** @description Filter reads after this time (ISO format) */
                start_time?: string | null;
                /** @description Filter reads before this time (ISO format) */
                end_time?: string | null;
                /** @description Minimum OCR confidence filter */
                min_confidence?: number | null;
                /** @description Page number (1-indexed) */
                page?: number;
                /** @description Number of items per page */
                page_size?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlateReadListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "plate-reads_create_plate_read": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PlateReadCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlateReadResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "plate-reads_get_reads_by_camera": {
        parameters: {
            query?: {
                /** @description Filter reads after this time (ISO format) */
                start_time?: string | null;
                /** @description Filter reads before this time (ISO format) */
                end_time?: string | null;
                /** @description Page number (1-indexed) */
                page?: number;
                /** @description Number of items per page */
                page_size?: number;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlateReadListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "plate-reads_recognize_plate": {
        parameters: {
            query?: {
                /** @description Whether to store the result in database */
                store?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PlateRecognizeRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlateRecognizeResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "plate-reads_search_by_plate_text": {
        parameters: {
            query: {
                /** @description Plate text to search for */
                text: string;
                /** @description If true, match exactly; otherwise partial match */
                exact?: boolean;
                /** @description Page number (1-indexed) */
                page?: number;
                /** @description Number of items per page */
                page_size?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlateReadListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "plate-reads_get_statistics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlateStatisticsResponse"];
                };
            };
        };
    };
    "plate-reads_get_plate_read": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                plate_read_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PlateReadResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    prompts_get_all_prompts: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AllPromptsResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    prompts_export_prompts: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptsExportResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    prompts_get_prompt_history: {
        parameters: {
            query?: {
                /** @description Filter by specific model */
                model?: components["schemas"]["AIModelEnum"] | null;
                /** @description Maximum results to return */
                limit?: number;
                /** @description Offset for pagination */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptHistoryResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    prompts_restore_prompt_version: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                version_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptRestoreResponse"];
                };
            };
            /** @description Version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    prompts_import_prompts: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PromptsImportRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptsImportResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    prompts_preview_import_prompts: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PromptsImportPreviewRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptsImportPreviewResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    prompts_test_prompt: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PromptTestRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromptTestResult"];
                };
            };
            /** @description Validation error - Invalid configuration */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too many requests - Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    prompts_test_custom_prompt: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomTestPromptRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomTestPromptResponse"];
                };
            };
            /** @description Bad request - Invalid or too long prompt */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Event not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Request timeout */
            408: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too many requests - Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description AI service unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    prompts_get_prompt_for_model: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                model: components["schemas"]["AIModelEnum"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelPromptConfig"];
                };
            };
            /** @description Model configuration not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    prompts_update_prompt_for_model: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                model: components["schemas"]["AIModelEnum"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PromptUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelPromptConfig"];
                };
            };
            /** @description Model not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Conflict - Concurrent modification detected */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error - Invalid configuration */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    queues_get_queues_status: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Queue status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "queues": [
                     *         {
                     *           "depth": 15,
                     *           "name": "ai_analysis",
                     *           "oldest_job": {
                     *             "id": "job_12345",
                     *             "queued_at": "2025-12-23T10:30:00.000000",
                     *             "wait_seconds": 45.2
                     *           },
                     *           "running": 2,
                     *           "status": "healthy",
                     *           "throughput": {
                     *             "avg_processing_seconds": 4.8,
                     *             "jobs_per_minute": 12.5
                     *           },
                     *           "workers": 4
                     *         }
                     *       ],
                     *       "summary": {
                     *         "overall_status": "healthy",
                     *         "total_queued": 15,
                     *         "total_running": 2,
                     *         "total_workers": 4
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["QueuesStatusResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    rum_ingest_rum_metrics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RUMBatchRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RUMIngestResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "scheduled-reports_list_scheduled_reports": {
        parameters: {
            query?: {
                enabled?: boolean | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of scheduled reports */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScheduledReportListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "scheduled-reports_create_scheduled_report": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ScheduledReportCreate"];
            };
        };
        responses: {
            /** @description Scheduled report created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScheduledReportResponse"];
                };
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "scheduled-reports_get_scheduled_report": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                report_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Scheduled report details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScheduledReportResponse"];
                };
            };
            /** @description Scheduled report not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "scheduled-reports_update_scheduled_report": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                report_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ScheduledReportUpdate"];
            };
        };
        responses: {
            /** @description Scheduled report updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScheduledReportResponse"];
                };
            };
            /** @description Scheduled report not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "scheduled-reports_delete_scheduled_report": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                report_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Scheduled report deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Scheduled report not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "scheduled-reports_run_scheduled_report": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                report_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Report run initiated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScheduledReportRunResponse"];
                };
            };
            /** @description Scheduled report not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    summaries_get_daily_summary: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Latest daily summary or null if none exists */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "content": "Today has seen minimal high-priority activity...",
                     *       "event_count": 1,
                     *       "generated_at": "2026-01-18T14:55:00Z",
                     *       "id": 2,
                     *       "window_end": "2026-01-18T15:00:00Z",
                     *       "window_start": "2026-01-18T00:00:00Z"
                     *     }
                     */
                    "application/json": components["schemas"]["SummaryResponse"] | null;
                };
            };
        };
    };
    summaries_get_hourly_summary: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Latest hourly summary or null if none exists */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "content": "Over the past hour, one critical event occurred...",
                     *       "event_count": 1,
                     *       "generated_at": "2026-01-18T14:55:00Z",
                     *       "id": 1,
                     *       "window_end": "2026-01-18T15:00:00Z",
                     *       "window_start": "2026-01-18T14:00:00Z"
                     *     }
                     */
                    "application/json": components["schemas"]["SummaryResponse"] | null;
                };
            };
        };
    };
    summaries_get_latest_summaries: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Latest hourly and daily summaries */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "daily": {
                     *         "content": "Today has seen...",
                     *         "event_count": 1,
                     *         "generated_at": "2026-01-18T14:55:00Z",
                     *         "id": 2,
                     *         "window_end": "2026-01-18T15:00:00Z",
                     *         "window_start": "2026-01-18T00:00:00Z"
                     *       },
                     *       "hourly": {
                     *         "content": "Over the past hour...",
                     *         "event_count": 1,
                     *         "generated_at": "2026-01-18T14:55:00Z",
                     *         "id": 1,
                     *         "window_end": "2026-01-18T15:00:00Z",
                     *         "window_start": "2026-01-18T14:00:00Z"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["LatestSummariesResponse"];
                };
            };
        };
    };
    "gpu-config_list_ai_services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AiServicesResponse"];
                };
            };
        };
    };
    system_get_anomaly_config: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AnomalyConfig"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    system_update_anomaly_config: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AnomalyConfigUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AnomalyConfig"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    system_get_circuit_breakers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CircuitBreakersResponse"];
                };
            };
        };
    };
    system_reset_circuit_breaker: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CircuitBreakerResetResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_trigger_cleanup: {
        parameters: {
            query?: {
                dry_run?: boolean;
            };
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanupResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_run_orphaned_file_cleanup: {
        parameters: {
            query?: {
                /** @description If True, only report what would be deleted without deleting. Default is True for safety. */
                dry_run?: boolean;
            };
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrphanedFileCleanupResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_get_cleanup_status: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CleanupStatusResponse"];
                };
            };
        };
    };
    system_get_config: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConfigResponse"];
                };
            };
        };
    };
    system_patch_config: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConfigUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConfigResponse"];
                };
            };
            /** @description Unauthorized - API key required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    system_get_gpu_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GPUStatsResponse"];
                };
            };
        };
    };
    "gpu-config_get_gpu_config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GpuConfigResponse"];
                };
            };
            /** @description Failed to load configuration */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "gpu-config_update_gpu_config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GpuConfigUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GpuConfigUpdateResponse"];
                };
            };
            /** @description Invalid configuration */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Failed to save configuration */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "gpu-config_apply_gpu_config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GpuApplyResponse"];
                };
            };
            /** @description Apply operation already in progress */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to apply configuration */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "gpu-config_detect_gpus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GpuDevicesResponse"];
                };
            };
            /** @description GPU detection failed */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "gpu-config_preview_gpu_config": {
        parameters: {
            query: {
                /** @description Assignment strategy to preview */
                strategy: components["schemas"]["GpuAssignmentStrategy"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GpuConfigPreviewResponse"];
                };
            };
            /** @description Invalid strategy */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Preview generation failed */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "gpu-config_get_service_health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceHealthResponse"];
                };
            };
        };
    };
    "gpu-config_get_gpu_config_status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GpuConfigStatusResponse"];
                };
            };
        };
    };
    system_get_gpu_stats_history: {
        parameters: {
            query?: {
                since?: string | null;
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GPUStatsHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "gpu-config_list_gpus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GpuDevicesResponse"];
                };
            };
            /** @description GPU detection failed */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    system_get_health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
        };
    };
    system_get_full_health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description System is healthy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FullHealthResponse"];
                };
            };
            /** @description One or more critical services are unhealthy */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    system_get_readiness: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReadinessResponse"];
                };
            };
        };
    };
    system_get_websocket_health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebSocketHealthResponse"];
                };
            };
        };
    };
    system_get_model_zoo_latency_history: {
        parameters: {
            query: {
                /** @description Model name to get latency history for (e.g., 'yolo11-license-plate') */
                model: string;
                /** @description Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours) */
                since?: number;
                /** @description Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour) */
                bucket_seconds?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelLatencyHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_get_model_zoo_status: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelZooStatusResponse"];
                };
            };
        };
    };
    system_get_models: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelRegistryResponse"];
                };
            };
        };
    };
    system_get_model: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                model_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelStatusResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_get_monitoring_health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoringHealthResponse"];
                };
            };
        };
    };
    system_get_monitoring_targets: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoringTargetsResponse"];
                };
            };
        };
    };
    system_get_performance_metrics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PerformanceUpdate"];
                };
            };
        };
    };
    system_get_performance_history: {
        parameters: {
            query?: {
                time_range?: components["schemas"]["TimeRange"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PerformanceHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_get_pipeline_status: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineStatusResponse"];
                };
            };
        };
    };
    system_get_pipeline_latency: {
        parameters: {
            query?: {
                window_minutes?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineLatencyResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_get_pipeline_latency_history: {
        parameters: {
            query?: {
                /** @description Number of minutes of history to return (1-1440, i.e., 1 minute to 24 hours) */
                since?: number;
                /** @description Size of each time bucket in seconds (10-3600, i.e., 10 seconds to 1 hour) */
                bucket_seconds?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineLatencyHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    services_list_services: {
        parameters: {
            query?: {
                category?: components["schemas"]["ServiceCategory"] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServicesResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    services_disable_service: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceActionResponse"];
                };
            };
            /** @description Service not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    services_enable_service: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceActionResponse"];
                };
            };
            /** @description Service not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    services_restart_service: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceActionResponse"];
                };
            };
            /** @description Bad request - Service is disabled */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Service not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    services_start_service: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceActionResponse"];
                };
            };
            /** @description Bad request - Service already running or disabled */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Service not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Container orchestrator not available */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    system_get_severity_metadata: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeverityMetadataResponse"];
                };
            };
        };
    };
    system_update_severity_thresholds: {
        parameters: {
            query?: never;
            header?: {
                "x-api-key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SeverityThresholdsUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SeverityMetadataResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_get_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemStatsResponse"];
                };
            };
        };
    };
    system_get_storage_stats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StorageStatsResponse"];
                };
            };
        };
    };
    system_get_supervisor_status: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkerSupervisorStatusResponse"];
                };
            };
        };
    };
    system_reset_worker: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                worker_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string | boolean;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_get_restart_history: {
        parameters: {
            query?: {
                /** @description Filter by worker name */
                worker_name?: string | null;
                /** @description Maximum number of events to return */
                limit?: number;
                /** @description Number of events to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RestartHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_get_supervisor_full_status: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkerSupervisorStatusResponse"];
                };
            };
        };
    };
    system_restart_supervisor_worker: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                worker_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkerControlResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_start_supervisor_worker: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                worker_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkerControlResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_stop_supervisor_worker: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                worker_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkerControlResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    system_get_telemetry: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TelemetryResponse"];
                };
            };
        };
    };
    system_list_websocket_event_types: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventRegistryResponse"];
                };
            };
        };
    };
    tracks_get_tracks_by_camera: {
        parameters: {
            query?: {
                /** @description Filter tracks starting after this time (ISO format) */
                start_time?: string | null;
                /** @description Filter tracks starting before this time (ISO format) */
                end_time?: string | null;
                /** @description Filter by object class (e.g., 'person', 'car') */
                object_class?: string | null;
                /** @description Page number (1-indexed) */
                page?: number;
                /** @description Number of items per page */
                page_size?: number;
            };
            header?: never;
            path: {
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TrackListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    tracks_get_track_history: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                camera_id: string;
                track_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TrackHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    tracks_get_track_trajectory: {
        parameters: {
            query?: {
                /** @description Maximum number of trajectory points */
                limit?: number;
            };
            header?: never;
            path: {
                camera_id: string;
                track_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TrajectoryPoint"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    alertmanager_receive_alertmanager_webhook: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertmanagerWebhook"];
            };
        };
        responses: {
            /** @description Webhook received and processed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlertmanagerWebhookResponse"];
                };
            };
            /** @description Invalid payload format */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    areas_get_area: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                area_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AreaResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    areas_delete_area: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                area_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    areas_update_area: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                area_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AreaUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AreaResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    areas_list_area_cameras: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                area_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AreaCamerasResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    areas_link_camera_to_area: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                area_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CameraLinkRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraLinkResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    areas_unlink_camera_from_area: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                area_id: number;
                camera_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraLinkResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    households_list_households: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HouseholdListResponse"];
                };
            };
        };
    };
    households_create_household: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["HouseholdCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HouseholdResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    households_get_household: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                household_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HouseholdResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    households_delete_household: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                household_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    households_update_household: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                household_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["HouseholdUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HouseholdResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    households_list_household_properties: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                household_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PropertyListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    households_create_property: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                household_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PropertyCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PropertyResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    properties_get_property: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                property_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PropertyResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    properties_delete_property: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                property_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    properties_update_property: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                property_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PropertyUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PropertyResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    properties_list_property_areas: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                property_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AreaListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    properties_create_area: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                property_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AreaCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AreaResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    settings_get_user_settings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SettingsResponse"];
                };
            };
        };
    };
    settings_update_settings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SettingsUpdate"];
            };
        };
        responses: {
            /** @description Settings updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SettingsResponse"];
                };
            };
            /** @description Validation error (e.g., invalid severity ordering) */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to write settings to runtime.env */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "system-settings_list_system_settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemSettingListResponse"];
                };
            };
        };
    };
    "system-settings_get_system_setting": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemSettingResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "system-settings_delete_system_setting": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "system-settings_update_system_setting": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                key: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SystemSettingUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemSettingResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    webhooks_receive_alertmanager_webhook: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlertmanagerWebhookPayload"];
            };
        };
        responses: {
            /** @description Webhook received and processed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookResponse"];
                };
            };
            /** @description Invalid payload format */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "zone-anomalies_list_all_anomalies": {
        parameters: {
            query?: {
                /** @description Filter by severity level(s) */
                severity?: string[] | null;
                /** @description Only return unacknowledged anomalies */
                unacknowledged_only?: boolean;
                /** @description Filter anomalies from this time (ISO 8601) */
                since?: string | null;
                /** @description Filter anomalies until this time (ISO 8601) */
                until?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneAnomalyListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "zone-anomalies_acknowledge_anomaly": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                anomaly_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneAnomalyAcknowledgeResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "zone-household_get_member_zones": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                member_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    }[];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "zone-household_get_vehicle_zones": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                vehicle_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    }[];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "zone-anomalies_list_zone_anomalies": {
        parameters: {
            query?: {
                /** @description Filter by severity level(s) */
                severity?: string[] | null;
                /** @description Only return unacknowledged anomalies */
                unacknowledged_only?: boolean;
                /** @description Filter anomalies from this time (ISO 8601) */
                since?: string | null;
                /** @description Filter anomalies until this time (ISO 8601) */
                until?: string | null;
                /** @description Maximum number of results */
                limit?: number;
                /** @description Number of results to skip */
                offset?: number;
            };
            header?: never;
            path: {
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneAnomalyListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "zone-household_get_zone_household_config": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneHouseholdConfigResponse"] | null;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "zone-household_upsert_zone_household_config": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneHouseholdConfigCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneHouseholdConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "zone-household_delete_zone_household_config": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "zone-household_patch_zone_household_config": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                zone_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZoneHouseholdConfigUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZoneHouseholdConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "zone-household_check_entity_trust": {
        parameters: {
            query?: {
                /** @description Time to check access for (ISO 8601 format, defaults to current time) */
                at_time?: string | null;
            };
            header?: never;
            path: {
                zone_id: string;
                entity_type: "member" | "vehicle";
                entity_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TrustCheckResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    ready: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
